<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>学习 on 知政的个人博客</title>
    <link>https://99999.fun/categories/%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 学习 on 知政的个人博客</description>
    <image>
      <title>知政的个人博客</title>
      <url>https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 01 Mar 2024 10:49:25 +0800</lastBuildDate>
    <atom:link href="https://99999.fun/categories/%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>密码学的学习笔记</title>
      <link>https://99999.fun/posts/165/</link>
      <pubDate>Fri, 01 Mar 2024 10:49:25 +0800</pubDate>
      <guid>https://99999.fun/posts/165/</guid>
      <description>密码技术手段：数据指纹，身份证明，消息的可信度和不可抵赖性，数据加密
信息安全（机密性，完整性，可用性，不可抵赖性）
Hash函数
hash可以用于校验文件是否完整，数字签名的摘要信息等等
hash函数是将任意大小的输入映射成固定大小的哈希值的函数
hash函数具备抗原像性（无法通过哈希值求到输入的值，是具备单相性的），抗次原像性（很难得到两个不同输入内容确得到相同的hash值），雪崩效应（原文的改变会导致hash值发生变化），抗碰撞性（很难得到可以生成相同hash值的输入内容）
常见的哈希函数：md4，md5，sha1，sha224，SM3（国密发布），sha256，sha384，sha512等等
md5发布于于1992年，摘要长度为128个比特，hash值为16位字节（128/8=16），块大小512个比特（每一次计算都以512个比特来分组处理），轮计算4（16 step）（一共进行4轮的计算，每一轮计算16步，一共计算64步）
简单的来说就是hash值长度是16位字节，计算过程中每个512比特的数据块都会进行64步的计算
sha1发布于1995年，摘要长度为160个比特，块大小512个比特，轮计算4（20 step）
md5和sha1的计算过程：
先将原消息作为一个头部，然后填充一个64位的尾部（这个尾部是说明了原消息有多长），然后中间填充一个经过计算得到的多少个位的数据（确保头部和尾部大小，以及中间的大小的和是512的倍数，这个中间会在开头填1，然后填0，直到头部和中间，以及尾部的bit是512的倍数为止），这个目的是将任意大小的原信息计算切成多个512的块，计算完成后是没有余的
也就是输入信息长度除于512不等于512-64时，进行填充，填充1和n个0，让其总长度等于（512-64）+512的倍数，这个填充是必须进行的，即便输入信息长度等于512-64，也要进行填充一个512bit的数据，确保填充位数是1到512之间
确保这个消息的长度=输入消息+64+填充 = 512的整倍数
md5会初始化4个32bit的值，sha1会初始化5个32bit的值
md5将512的块数据进行分组，分成16个32bit的子分组，然后对4个初始值进行循环计算
每个512块数据都需要进行4轮处理，每一轮64步的计算，然后得到128的结果，这个128位的结果将作为下一组的初始值，一直计算到最后的一组，得到就是128位md5哈希值
计算过程：在1到16步计算时，顺序获得16个子分组进行计算（即第几步就获取第几个分组的数据，例如第3步计算，使用第3组子分组进行计算），在17步到32步计算时，将跳跃获取16个子分组进行计算（跳跃的长度取决于当前的步数+5，即第18步时，获取2+5，第7组的数据），在33步到48步计算时获取当前步数+3，在49步到64步计算时获取当前步数+7，计算完成时，得到的数就是md5哈希值
如果有多个区块的数据，计算的步数就是n*64了，只是初始值变成了上一个区块计算完成的结果
mod 模计算
sha1原理和md5差不多，只是变成了80个步。并且将在20，40，60，80步用不同的计算方式
注意：md5和sha1都不安全了
md5
cryptographically broken and unsuitable for further use
users should avoid using the MD5 algorithm in any capacity. As previous research has demonstrated, it should be considered cryptographically broken and unsuitable for further use
sha1
谷歌SHA1碰撞实验
结论：应该放弃md5，sha1，改用sha2，sha3，BLAKE2等更安全的哈希函数
对称加密
AES，发布于1997年，其是迭代类型的加密，分组长度128bit，密钥长度有128，192，256，轮数分别10，12，14
计算过程：
AES加密计算会进行4种操作，轮密钥加（AddRoundKey），字节替代（SubBytes），行移位（ShiftRows），列混淆（MixColumns）
128位的明文和128位的密钥被分组成16个子节，变成4*4的正方形矩阵
加解密的每一轮的密钥都是通过密钥扩展算法得到的，因此轮密钥也是4*4的正方形矩阵</description>
    </item>
    <item>
      <title>云计算学习笔记</title>
      <link>https://99999.fun/posts/164/</link>
      <pubDate>Tue, 27 Feb 2024 10:49:25 +0800</pubDate>
      <guid>https://99999.fun/posts/164/</guid>
      <description>云服务平台：微软的Azure，开源云服务平台Open Stack，谷歌家的Google Cloud，亚马逊的AWS，国内的阿里云，京东云，华为云，腾讯云等等公有云，私有云
云计算就是通过互联网按需访问计算资源，例如物理服务器和虚拟服务器资源，数据存储器等等，这些资源都由云服务提供商管理，云服务提供商通过这些资源，并且根据使用情况按量收费
云计算的特点：按需使用，按量收费，弹性资源，自助服务（即开即用，无需审核），无人值守（高可用，无需监守）
亚马逊在2006年推出S3和EC2，2008年谷歌发布Google App Engine，2009年heroku发布Paas，2010年微软推出Azure服务平台，2011年Open Stack发布开源Iaas，2014年亚马逊推出lambda（无服务器计算服务）
云计算类似于水电服务，电力部门已经为你架构好了基础设施，无需再投资建设基础设施
云计算按需支付按需使用，无需再使用服务器来浪费用不到的资源，多用资源，使用时间长更省钱
云计算保证业务高可用，运维自动化，资源自动扩缩，无需人为管理
云主机，云服务器，云端服务器
创建云主机，指定规格
核心数量，内存，磁盘，网络（私有地址，公有地址），操作系统，操作系统账户（密码，ssh密钥），地理位置，防火墙（安全组）
openstack 构建私有云或者公有云
安装openstack
OpenStack 是一个基于Python的开源项目，安装太复杂了，将通过kolla-ansible快速部署OpenStack环境
kolla-ansible使用ansible自动化运维工具进行OpenStack服务编排部署，kolla-ansible采用可全容器部署，全部跑在docker容器中
OpenStack官方要求8g内存，40g磁盘
Kolla Ansible支持Ubuntu20.04，Ubuntu22.04，Debian 11系统，支持Ubuntu，centos，Debian容器
Kolla Ansible官方文档地址：https://docs.openstack.org/kolla-ansible/yoga/user/quickstart.html
这里将使用Ubuntu22.04
安装必要依赖
sudo apt install git python3-dev libffi-dev gcc libssl-dev
sudo apt install python3-pip
pypi换源（适合国内朋友）
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
安装 ansible（官方要求ansible版本大于4，小于6）
sudo apt install ansible
或者
sudo pip install -U &amp;lsquo;ansible&amp;gt;=4,&amp;lt;6&amp;rsquo;
安装Kolla-ansible
sudo pip install git+https://opendev.org/openstack/kolla-ansible@master
创建目录
sudo mkdir -p /etc/kolla
复制kolla-ansible配置文件（例如globals.yml和passwords.yml，清单文件）</description>
    </item>
    <item>
      <title>C&#43;&#43;学习笔记</title>
      <link>https://99999.fun/posts/163/</link>
      <pubDate>Sat, 17 Feb 2024 14:50:12 +0800</pubDate>
      <guid>https://99999.fun/posts/163/</guid>
      <description>C++的历史最早追溯到1979年，Bjarne Stroustrup创建了带类的C（即C的超集），这就是C++的雏形，直到1983年，才正式成为C++
C++标准委员会在1998年发布了第一个国际标准C++ ISO/IEC 1488，又叫C++ 98
2011年，C++ 11标准发布，boost库诞生，11标准之后，c++每3年发布一个版本，每一个版本保持向后兼任性的同时，还提供新功能以及改进
C++的特点：封装能力强，高性能，低功耗（可在微型设备上运行，例如嵌入式设备）
C++主要用于开发桌面应用程序，后台系统引擎，游戏以及游戏引擎，图像视觉和AI引擎，数据库（例如MongoDB）,嵌入式开发
C++是编译型语言，C++程序会经过编译器生成中间的目标程序，再通过链接器，将目标程序和程序库链接到一起，最后生成可执行程序
.cpp程序经过编译器生成汇编程序.asm，再通过汇编器生成目标程序.obj，链接器会将目标程序和其他目标程序以及一些库程序链接到一起，生成可执行文件
Windows下直接安装Visual Studio，选择使用C++的桌面开发和通用Windows平台开发，Visual Studio扩展插件选上
如果需要开发移动设备的开发，也可以选择使用C++的移动开发选项，还有使用C++的Linux开发，根据自己需求选择
第一个C++程序
#include＜iostream＞int main(){std::cout &amp;lt;&amp;lt; &amp;quot;hallo word!\n&amp;quot;;}运行以及调试程序：生成，生成解决方案，清理解决方案，编译
C++的每一个变量是具备其数据类型的，该数据类型决定了该变量在内存的空间大小以及该内存空间的值范围，该变量能参与哪些运算，例如：
int sum; // 定义整形int a = 1;int b = 1;sum = a + b; // 求和一些常见的类型的定义：
#include &amp;quot;stdafx.h&amp;quot;void main(void){char a[6]=&amp;quot;qq&amp;quot;;short int a = 88;long int a = 99;int a = 99;float a = 3.</description>
    </item>
    <item>
      <title>汇编基础学习笔记</title>
      <link>https://99999.fun/posts/162/</link>
      <pubDate>Sun, 20 Nov 2022 11:49:00 +0000</pubDate>
      <guid>https://99999.fun/posts/162/</guid>
      <description>x86架构通用寄存器（32位的x86架构和64位的x86_64架构）
x86_64架构由amd公司推出，因此又叫amd64架构，64位架构是基于32位架构扩展的
32位架构的x86处理器具备8个32位的通用寄存器，可通过名称来引用这8个寄存器，分别为EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI
EAX的低16位可以被单独使用，引用名称叫AX（高位是左边位，低位是右边位），AX又可以被分为高8位的AH和低8位的AL
实质上EAX，ECX，EDX，EBX都可以被拆开使用，ECX的低16位叫CX，CX又可以被分为高8位的CH和低8位的CL
EDC的低16位叫DX，DX又可以被分为高8位的DH和低8位的DL，EBX的低16为叫BX，BX又可以被分为高8位的BH和低8位的BL
ESP，EBP，ESI，EDI的低16位也可以被单独使用，但是没有8位的，这低16位名称分别是SP，BP，SI，DI
EAX寄存器被乘法和除法指令自动调用，因此又叫累加寄存器
ECX被LOOP（循环）指令调用为循环计数器
ESP被用于寻址栈上的数据，ESP始终指向栈顶，因此又叫栈指针寄存器
ESI和EDI又叫变址寄存器，变址寄存器引用的是内存地址，ESI指向内存源地址，EDI指向目的地址
EBP叫帧指针寄存器，被用来引用栈上的函数参数和局部变量
除了通用寄存器还有EFLAGS标志寄存器，EIP指针寄存器（这个非常重要，因为其引用的是下一条要被指向的指令的地址，注意：并不能直接通过名称来说调用，只能通过CALL之类的间接修改）等等
64位架构（通用寄存器为16个，并且是64位的，而且每个都可以低8位，16位，32位单独使用）
EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI的64位是R开头的，其他和32位架构是一样的，64位架构的内存地址也是64位的
x86汇编指令（通常是由一个操作码（opcode）和0到多个的操作数（operand）组成）
整数加减指令（ADD指令（有2个操作数，分别是目的操作数和源操作数，ADD指向将这2个操作数的值相加，将结果存放在源操作数中，源操作数可以是寄存器，内存，目的操作数要满足可写条件，因此也可以是寄存器，内存，但是不能同为内存））和SUB指令（和ADD指令一样，但是是将结果存放在目的操作数中））
ADD指令：ADD EAX,32 （将EAX寄存器的值加上32，并且将结果存放回EAX寄存器中）
SUB指令：SUB ESP,32 （将ESP寄存器的值减去32，并且将值存放回EAX寄存器中）
数据传输指令（x86架构有多个数据传输指令，这里是MOV指令）
MOV指令用于寄存器之间和寄存器和内存之间传输数据使用，MOV指令将源操作数复制到目的操作数中，例如MOV EDX, 666 （将数值666存储在EDX寄存器中）
x86架构内存寻址：displacement（位移，可以在指令中直接得到内存的偏移量，也就是位移，这个位移表示距离操作数的直接偏移量），base（基址，内存地址存储在通用寄存器中），index（索引，注意ESP寄存器不能用于索引），scale（比例因子，用于索引相乘，是固定值，可取值1，2，4，8）
内存最复杂的地址计算公式：base+（index*scale）+displacement
base和index，displacement都可以随意组合，也可以不存在，如果不使用index，就不需要使用scale了，scale只为index服务，index和scale被用于寻找数组地址和多维数组
入栈和出栈指令（PUSH和POP指令）
PUSH指令只有一个操作数，就是需要入栈的源操作数，这个指令可以将ESP寄存器向下移动一个位，并且将源操作数复制到ESP寄存器指向的内存处，例如：PUSH EAX
POP指令也是只有一个操作数，就是用来接收数据的目的操作数，POP指向会将ESP寄存器指向的内存处的值复制到目的操作数中，并且将ESP寄存器向上移动一个位置，例如：POP EAX
分支跳转指令（JMP指令）
JMP指令只有一个操作数，这个操作数可以是内存，寄存器或者立即数，通过这个操作数来给出需要跳转的目的地址，例如 JMP EAX
过程调用指令（CALL指令）
高级语言的函数在汇编叫过程，CALL指令只有一个操作数，是过程的起始地址，例如 CALL EAX
分支跳转指令和过程调用指令的区别是，分支跳转指令不会记录返回地址，这个返回地址是CALL指令之后的下一条指令的地址，CALL指令会将返回地址入栈，然后跳转到目的地址执行
子过程执行完成通过RET指令返回，RET指令会在栈上弹出返回地址，并且跳转到该返回地址上继续执行
内存分页机制
线性地址
在内存分页模式中，应用使用的地址就叫线性地址，由MMU(menorymanagement unit)基于页表来映射转换为物理地址
在内存分页模式未出现之前，应用是直接访问物理内存的，应用具备读写全部物理内存的权限，因此可能会覆盖其他应用的数据，而80386架构出现，出现了保护模式，使用内存分页来通过特权级和进程地址空间来进行隔离
进程地址空间隔离是通过进程独立性页表来完成的，每个进程实现的地址空间是不同的，避免影响到其他进程
80386两级页表
80386架构的线性地址为32位，因此可寻4GB大小的内存空间（4096），地址总线也是32位，因此也是只能寻找4gb大小的物理内存，而且分页机制也将每个物理内存的页面的大小设为4096字节
一个页面大小为4096字节，地址总线为32位，因此一个页面可存储1024个物理页面地址，80386页表的第一页面是目录页面，物理内存地址存储在CR3寄存器中，可通过该目录页面来查找第二页面的1024个物理页面地址
MMU将32位的线性地址，低12位是页内偏移，然后的低10位是页表的索引，最后的高10位是页面目录索引，页内偏移的取值范围为0到4095，页表索引和页面目录索引的取值范围为0到1023
80386线性地址转换到物理地址的过程：先从CR3寄存器中获取页目录的物理地址，然后选择一个页表，在到页表索引中，找到页面的物理地址，最后通过页内偏移量来得到实质上的物理地址
PAE三级页表
80386架构的每个进程可使用4gb的线性地址空间，但是操作系统会将4gb的地址空间划分成用户空间和内核空间，为了解决内存空间不够使用，英特尔公司推出了物理地址扩展技术（PAE，PhysicalAddressExtension）
PAE将地址总线扩展到36位，因此可寻找64gb的物理内存，但是线性地址依然是32位的，为了解决32位线性地址支持36位的物理地址映射，MMU页表映射机制进行了调整，一个页面只能存储512个地址
PAE的32位线性地址是，高2位是页目录指针索引，后面9位是页目录索引，再后9位是页表索引，最后12位是页内偏移
x64四级页表
因为PAE技术并没有扩展线性空间，32位的地址宽度不够使用了，AMD公司基于x86架构扩展而出的x64架构，x64架构的寄存器宽度是64位的，但是线性地址只使用了48位，但是也足够了，因为可以寻高达256TB的内存空间地址，具体可寻多少物理内存空间，取决于地址总线的宽度
x64架构，在PAE的基础上扩展了页表为4级，而且每个页面的大小是4096字节，高9位是页目录指针表，后9位是页目录指针，再后9位是页目录，然后9位是页表。最后12位是页内偏移量
虚拟内存
进程是以内存页面为单位向操作系统申请内存的，现代操作系统中会对申请的内存空间进行记录，并不会马上分配，而是等到该进程真正访问该内存空间是才会分配物理页面并且进行映射，然后恢复中断程序，如果进程访问了没有映射的内存空间，会被操作系统进行page fault处理，操作系统通过page failt handle进行检查内存空间分配记录
物理空间不够分配时，操作系统可以将少使用的物理页面写入到磁盘交换分区（Swap分区）中，将空出来的页面给需要的进程使用，注意：当在磁盘交换分区中内存页面被访问了，也会触发page fault处理，操作系统通过page failt handle来将磁盘交换分区的内存页面加载回内存中</description>
    </item>
    <item>
      <title>Deno js运行时环境学习笔记</title>
      <link>https://99999.fun/posts/161/</link>
      <pubDate>Fri, 11 Nov 2022 07:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/161/</guid>
      <description>Deno是基于V8引擎，使用Rust构建的JavaScript &amp;amp; TypeScript 运行时环境，天生支持TypeScript，并且有安全模式（默认情况下无法获取网络，文件系统，环境变量等权限，当然也可以开放），Deno的作者是Nodejs之父Ryan Dahl，构建的原因是解决Nodejs的缺陷，例如模块的安全性（Node运行时的权限很高，缺乏模块的安全运行），Deno的模块化选择了ESMoule标准，而且具备浏览器的api，例如window全局变量，支持onload，onunload等事件函数，支持fetch，Web Workers等标准，异步操作返回采用Promise，支持await
Deno不使用node_modules与package.json的包管理机制，而是采用下载编译的机制，并且存在缓存，模块更新通过更新缓存来完成
Deno有个特殊的功能，就是可以从网络上导入模块
安装
Linux
curl -fsSL https://deno.land/install.sh | sh
或者
windows
iwr https://deno.land/install.ps1 -useb | iex
也可以通过scoop安装
scoop install deno
作为Rust构建的，当然也支持Cargo包管理器安装
cargo install deno &amp;ndash;locked
或者通过单一的可执行文件来安装（我采用这个方式，再配置一下Path环境变量就是可以了，windows选择deno-x86_64-pc-windows-msvc）
https://github.com/denoland/deno/releases
检查是否安装完成
deno &amp;ndash;version
第一个例子
import DFetch from &amp;quot;https://deno.land/x/dfetch/mod.ts&amp;quot;DFetch.get(&amp;quot;https://xiaochenabc123.test.com&amp;quot;).then((response) =&amp;gt; {console.log(response)})运行
deno run .\index.ts
它会向你询问进行网络请求，是否允许，可通过&amp;ndash;allow-net默认运行，例如：deno run &amp;ndash;allow-net .\index.ts
第三方库通过https://deno.land/x查找
权限
&amp;ndash;allow-env，允许访问环境变量，可指定环境变量列表，通过逗号分隔
&amp;ndash;allow-hrtime，允许高分辨率时间测量
&amp;ndash;allow-net，允许网络访问，可指定网络地址列表，通过逗号分隔
&amp;ndash;allow-ffi，允许加载动态库，动态库不是安全运行的
&amp;ndash;allow-read，允许读取，可指定读取文件列表或者目录，使用逗号分隔
&amp;ndash;allow-run，允许运行子进程，这个子进程不是安全运行的，可指定子进程列表，通过逗号分隔
&amp;ndash;allow-write，允许写入，可指定写入文件列表或者目录，使用逗号分隔
-A 或者 &amp;ndash;allow-all 允许全部权限
VsCode插件deno
deno内置工具
安装模块</description>
    </item>
    <item>
      <title>计算机图形学学习笔记</title>
      <link>https://99999.fun/posts/159/</link>
      <pubDate>Tue, 08 Nov 2022 12:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/159/</guid>
      <description>计算机图形学(Computer Graphics，CG)是研究图形表达，生成，处理与显示的学科
通过数学算法将二维，三维图形转换成计算机显示器的栅格，例如向量，行列式，矩阵算法等等
图形学历史
1950年，MIT诞生第一个图形显示器（用于Whirlwind（旋风）电子管计算机显示图形），CRT显示器
Whirlwind电子管计算机设计之初是美国空军训练飞行员，半自动地面防空系统（SAGE）
应用CRT和光笔
1958年，双人网球
1960年，William Fetter（威廉﹒费特），创造‘计算机图形学’名词，计算机图形学先驱
1961年，史帝夫﹒罗素（Steve Russell），spacewar游戏
1962年，皮埃尔·贝塞尔（Pierre Bézier），贝塞尔曲线（Bézier curve），绘制曲线
1962年，伊凡·苏泽兰（Ivan Sutherland），Sketchpad绘图应用，计算机图形学之父
1963年，Force, Mass and Motion，https://techchannel.att.com/play-video.cfm/2012/8/20/AT&amp;amp;T-Archives-Force-Mass-Motion
1968年，Ivan Sutherland创造“达摩克里斯之剑”头盔显示器
1968年，Arthur Appel 提出光线投射算法
1973年，Bui Tuong Phong，发明phong shading（Phong着色法）
1974年，Speed Race游戏，第一款赛车游戏
1977年，3D core Graphics System，图形学标准
1980年，NEC µPD7220 GPU，支持1024*1024的显示，普及民用
1996年，Krishnamurthy与Levoy提出法线贴图（Normal Mapping）
1995年，Directx 1.0
1997年，OpenGL 1.1
1999年，Nvidia，Gefprce 256 GPU</description>
    </item>
    <item>
      <title>WebSocket学习笔记</title>
      <link>https://99999.fun/posts/158/</link>
      <pubDate>Sat, 05 Nov 2022 14:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/158/</guid>
      <description>HTTP1.1协议实质上就是半双工信道，无法同时发送数据和接收数据，而且HTTP连接必须是客户端发起，由服务器来进行处理响应，只有HTTP2.0才是全双工信道（不需要等待响应，就可以发送第二个报文）
WebSocket是全双工信道，而且还支持服务端主动发送数据给客户端，是服务器推送技术（还是需要客户端发起连接）
WebSocket协议是应用层协议，而且是建立在TCP协议上，端口也是使用443和80，握手使用HTTP协议，浏览器不会限制WebSocket的同源
WebSocket客户端配置
WebSocket构造函数，用来创建WebSocket实例
const ws = new WebSocket(&amp;lsquo;ws://127.0.0.1&amp;rsquo;)
WebSocket.readyState实例具备4种状态，该属性是只读的，用来表示连接WebSocket服务端的状态，分别是：0（正在连接），1（连接完成并且可以通信），2（连接正在关闭），3（连接已经关闭或者连接失败）
WebSocket.onopen是指定连接成功后执行的回调函数
WebSocket.onerror是指定连接失败后执行的回调函数
WebSocket.onclose是指定连接关闭后执行的回调函数
WebSocket.onmessage是指定从服务器获取信息时执行的回调函数
可以指定WebSocket.binaryType来指定传输的数据类型，数据类型有2种，分别是blob和arraybuffer
客户端配置例如：
const ws = new WebSocket(&#39;ws://localhost:8080&#39;)ws.onopen = () =&amp;gt;{console.log(&amp;quot;连接中&amp;quot;)ws.send(&#39;hallo word&#39;) // 向服务端发送数据}ws.onerror = () =&amp;gt;{console.log(&#39;连接失败&#39;)}ws.onmessage = (evt) =&amp;gt;{console.log(&#39;连接成功，正在获取数据&#39;)if(typeof evt.data === String){console.log(&#39;hallo&#39;+evt.data)}else if(evt.data instanceof ArrayBuffer){let data = evt.dataconsole.log(&#39;数据：&#39;+data)}ws.close() // 手动关闭连接}ws.onclose = () =&amp;gt;{console.log(&#39;连接已关闭&#39;)}还有WebSocket.bufferedAmount属性，也是只读，用于返回WebSocket..send没有发送到服务端的数据的字节数，为0表示全部数据已传输完毕
WebSocket.url属性可以返回WebSocket实例的URL绝对路径，只读</description>
    </item>
    <item>
      <title>简单使用Element Plus组件库</title>
      <link>https://99999.fun/posts/157/</link>
      <pubDate>Thu, 03 Nov 2022 17:40:00 +0000</pubDate>
      <guid>https://99999.fun/posts/157/</guid>
      <description>Element Plus是基于vue3开发的组件库，而Element使用vue2开发的组件库
安装Element Plus
npm install element-plus &amp;ndash;save
或者
yarn add element-plus
导入Element Plus
import ElementPlus from &#39;element-plus&#39;import &#39;element-plus/dist/index.css&#39;按需导入
安装插件
npm install -D unplugin-vue-components unplugin-auto-import
如果是使用Vite则配置vite.config.ts文件
导入并且启用插件
import AutoImport from &#39;unplugin-auto-import/vite&#39;import Components from &#39;unplugin-vue-components/vite&#39;...plugins: [AutoImport({resolvers: [ElementPlusResolver()],}),Components({resolvers: [ElementPlusResolver()],}),],这个组件库还支持module导入的方式手动按需使用，例如：
&amp;lt;template&amp;gt;&amp;lt;el-button&amp;gt;I am ElButton&amp;lt;/el-button&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;import { ElButton } from &#39;element-plus&#39;export default {components: { ElButton },}&amp;lt;/script&amp;gt;</description>
    </item>
    <item>
      <title>计算机网络学习笔记</title>
      <link>https://99999.fun/posts/156/</link>
      <pubDate>Tue, 01 Nov 2022 12:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/156/</guid>
      <description>计算机网络是通用，可编程的硬件组成的，并且这些设备可互连，并且可以传输不同类型的数据
计算机网络不是只有软件概念，还有硬件设备，例如：网卡，网线，路由器等等
网络作用范围：广域网（WAN），城域网（MAN），局域网（LAN）
计算机网络发展历史
ARPANET（1969年，美国国防部创建的单个网络）
三层结构互联网（现代互联网雏形，当时主要用于连接美国学校，实验室的计算机，主干网，地区网，校园网）
多层次ISP互联网（ISP指网络服务提供商（Internet Service Provider），常见网络服务提供商有中国移动，中国电信，中国联通等等）
多层次ISP互联网，分主干ISP（主要跨国通信），地区ISP（主要局部地区通信，例如广东移动，北京电信等等）
中国创建了多个公共互联网，例如：中国电信互联网（CHINANET），中国移动互联网（CMNET），中国联通互联网（UNINET），中国教育与科研计算机网（CERNET），中国科学技术网（CSTNET）等等
计算机网络层次结构（确保数据通信顺通，识别目标计算机的状态，数据是否存在错误）
层次结构大概分3个，网络应用，数据通信，物理网络
层次细分的话，有七层，也就是OSI七层模型（OSI国际标准定义的），而且每个层都是独立的（不干预其他层），只完成不同的工作
OSI七层模型：应用层（为计算机提供服务），表示层（数据处理），会话层（管理通信会话），传输层（管理通信连接），网络层（数据路由），数据链路层（管理节点之间的数据通信，例如传输数据到另一个局域网），物理层（计算机物理设备）
OSI七层模型并没有成为广泛使用的标准，而是采用TCP/IP四层模型
TCP/IP四层模型：应用层（对于OSI七层模型的应用，表示，会话，HTTP协议），传输层（OSI七层模型的传输层，TCP/UDP协议），（OSI七层模型的网络层，IP/ICMP协议）网络层，（数据链路层和物理层，ARP/RARP协议）网络接口层
计算机网络性能指标
bps=bit/s，1秒多少比特位，比特率
时延：发送时延（数据bit除以bps），排队时延（数据等待被网络设备处理的时间），处理时延（数据到达目标机器后处理需要的时间），传输时延（传输路径除以bps）
总时延 = 发送时延+排队时延+传输时延+处理时延
往返时间RTT（Route-Trip Time）：数据报文在通信中来回一次的时间（可通过ping命令来查看RTT）
物理层（连接不同的物理设备，传输比特流）
物理层传输介质：双绞线（又分屏蔽和无屏蔽，区别就是增加了一层屏蔽层），同轴电缆，光纤（通过光传输，光纤内部是具有高折射率的纤芯，能折射光）
电缆使用铜作为传输介质，光纤通过光来作为传输介质
铜线中的电信号传播速度大约为2.3*10^8m/s
光纤中光信号的传播速度是2.0*10^8m/s
因此实质上电缆的传播速度比光纤快，因为光纤是利用光的反射来传输到远方的，实质光走的距离更长
但是电缆的铜在远距离的情况下，会导致衰减（主要有2个原因导致，介质损耗（通过电磁波传导，会在介质中产生电场的电荷规则排序，这会消耗能量）和导线损耗），需要通过中继器来延续信号
因此在跨市，跨城，跨省，跨国使用都是光纤（光纤的带宽比电缆好，也是一个原因），但是短距离，得益于电缆的传播速度，会更好，因此局域网内部大多使用电缆来传输（因为解析光信号，还需要个光信号调制调解器，计算机无法直接使用光纤传输的数据）
比特流：通过高低电平来表示比特流，来传输数据
信道（往一个方向传输信息的媒体，一个通信电路最少要有一个发送信道和接收信道）
信道的分类：单工通信信道（只能往一个方向通信的信道，没有反馈的信道，例如电视机的电视闭路线），半双工通信信道（可以发送和接收信息，但是不能同时发送，同时接收），全双工通信信道（可以同时发送，同时接收）
物理层会实现信道分用复用技术（提升信道的利用率）
频分复用，时分复用，波分复用，码分复用
数据链路层（封装成帧，透明传输，差错监测）
数据帧：数据链路层中数据的基本单位，数据发送方会在网络层的一段数据的前后添加特定标记，而这一段数据就是数据帧，数据接收方根据特定标记来识别数据帧，是数据链路层内部数据处理成帧
数据帧也分MAC帧（没有帧尾，因为MAC帧之间是96比特时间，帧头也是没有的，而是让物理层给MAC帧添加8bts的前导码），PPP帧（有帧头和帧尾，帧头到帧尾就是这个帧的长度）
封装成帧：数据链路层会将网络层交付的数据报文添加帧头和帧尾，让其成为帧
帧头和帧尾都是特定的控制字符（比特流），帧头（SOH）：00000001，帧尾（EOT）:00000100
透明传输：数据链路层对网络层提供的数据没有限制（控制字符在帧数据中，但是不会去当成数据去处理，就好像帧头和帧尾不存在一样）
字节填充（对数据内部的数据填充ESC转义字符），比特填充（零比特填充法：在每5个连续的1后面插入比特0）
数据链路层规定了帧的数据的长度限制，就是最大传输单元MTU（Maximun Transfer Unit）
以太网的MTU（MAC帧）是1500字节
路径MTU：由链路中MTU的最小值决定
差错监测：因为物理层只负责传输比特流，没有控制出错的功能，因此数据链路层提供了差错监测的功能
奇偶校验码：在发送的每个字节后加上一位，让字节中为1的数可以是奇数或者偶数，通过奇偶校验来确定数据是否出错，具体可以看https://xiaochenabc123.test.com/archives/77.html这篇文章，讲TCP的可靠性那里
奇偶校验码的缺点就是如果发生2位的出错，就无法校验出来错误
循环冗余校验码CRC（根据传输或者保存的数据来产生固定位数的校验码，校验码再附加到数据的后面）
模二除法：通过异或来表示0或者1，例如00就是0，01就是1，异为1，或为0
选择用于校验的多项式，并且在数据后面添加多个0，添加多个0的数据，通过模二除法来除以校验的多项式的位串，得到的余数将填充到原来数据的添加多个0的位置，来得到可校验的位串
假设校验的多项式为X3+X2+1，那么就是原数据后面添加3个0（添加多少个0取决多项式的最高阶，二进制位的最高位也取决于最高阶（最高幂次）二进制位数等于最高阶+1，这里就是表示的二进制位为4位的二进制数），二进制位串位计算就是1x3+1x2+0x1+1x0，就是1101
例如原数据为1010110，CRC校验码计算就是1010110000除以1101，得到的余数0001就是CRC校验码，在将原来填充0的位置填充CRC，就是10101100001，这个比特流就是要传输的数据
接收数据进行校验通过，传输的数据除以位串，来得到余数，根据余数来进行判断校验（余数为0则表示数据正确）
数据链路层只检测数据的错误，不会进行数据的纠错，数据错了，数据链路层将会丢弃错误的数据或者重新传输数据
MAC地址（物理地址，硬件地址，每个设备都有唯一的MAC地址，用48个比特位来表示，使用16进制）
MAC地址表：映射MAC地址到硬件接口上
以太网协议是数据链路层的协议，以太网协议是局域网技术，以太网协议用于完成相邻设备的数据帧传输
网络层（数据路由，数据在网络传输的路径，跨局域网，跨节点）
路由器的顶层是网络层，没有使用到传输层和应用层
网络层的ip协议，子网划分
虚拟互连网络（物理网络复杂，使用IP协议时，将无需关心物理网络的差异）
网络层利用IP协议来将使用IP协议的计算机连接起来，就好像这些计算机只需要连接一个虚拟互连网络一样，无需关心底层经过了哪些网关，路由器，ISP等等，将专注于数据的转发工作
IP协议
IP地址（v4只有32位，v6有128位），ipv4使用点分十进制表示，使用4组从0到255的数字表示ip地址，ipv6使用冒分十六进制，用8组4位的16进制表示ipv6地址</description>
    </item>
    <item>
      <title>计算机组成原理学习笔记</title>
      <link>https://99999.fun/posts/155/</link>
      <pubDate>Tue, 01 Nov 2022 02:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/155/</guid>
      <description>计算机发展历史
1946-1957，电子管计算机，1957-1964，晶体管计算机，1964-1980，集成电路计算机，1980-至今，超大规模集成电路计算机
电子管计算机：二战时期，英国为了破译德国的无线电密文，而发明了电子管计算机，最出名的电子管计算机莫过于埃尼阿克（ENIAC），埃尼阿克是美国军方为了计算弹道而诞生的，埃尼阿克长30多米，高2.4米，宽6米，拥有18000多个电子管，70000个电阻，10000个电容，1500个续电，6000多个开关，运行耗电150千瓦，重30吨，占地1500平方英寸（140平方米），造价48万美元，运算速度每秒5000次
电子管计算机特点：集成度低，占空间大，功耗高，操作复杂（更换程序需要接线）
晶体管计算机：诞生原因是因为贝尔实验室发明晶体管，1956年诺贝尔物理奖授予贝尔实验室发明晶体管的科学家，第一台晶体管计算机TX-0诞生于MIT的林肯实验室，当时的最强晶体管计算机PDP-1具备4k内存，每秒可执行20万条指令，具备512x512显示器（也是世界第一个显示器，也因为这个计算机携带了显示器的原因，而诞生了世界第一款电子游戏，太空战争）
晶体管计算机特点：对于电子管计算机来说，集成度高，空间占据小，功耗比电子管低，运行速度快
集成电路计算机：诞生原因是因为德州仪器的工程师发明了集成电路（IC），操作系统也因为集成电路计算机的出现而诞生，当时为了解决IBM的2款集成电路计算机（7094和1401）所编写的程序无法相互兼容，IBM而推出了System/360（操作系统雏形）
超大规模集成电路计算机：芯片集成超大规模的集成电路
微型计算机发展历史：因为集成电路计算机的诞生，计算机逐渐从庞然大物变成小型，乃至微型，1971到1973年，500khz频率的微型计算机（8位），1973到1978年，高于1mhz的微型计算机（8位），1978到1985年，500mhz的微型计算机（16位），1985到2000年，高于1ghz的微型计算机（32位），2000年到至今，高于2ghz的微型计算机（64位）
摩尔定律：当价格不变的情况下，集成电路的性能，会每18至24个月提升一倍
后来因为集成电路太密集，热损耗也越来越高，无法解决，摩尔定律也因此失效
因为摩尔定律的失效，单核已到瓶颈，转而搞多核CPU，2005年，英特尔发布了奔腾系列的双核CPU，AMD也发布了速龙系列的双核CPU，2006年，英特尔发布酷睿四核CPU，至今AMD的服务器级霄龙处理器CPU可以高达64核，而且基准频率（单核频率）可以达到2Ghz以上
计算机的分类
超级计算机：功能最强，运算最快，存储容量最大的计算机，用于天气预报，海洋监测，生物制药，科学计算，航天等等需要超大运算的领域，衡量超级计算机的单位是TFlop/s（每秒一万亿次浮点计算）
著名的超级计算机有Summit，神威太湖之光，天河一号，天河二号，Sierra
天河二号位于广州大学城的中山大学校区的国家超级计算机广州中心
大型计算机：又被称为大型机，大型机面向大型商业公司，维护成本高，硬件不易扩展，IBM占据大型机的大片市场，IBM为IOE中的I（计算机提供商）
迷你计算机（服务器）：目前已替代大型机，为企业主要计算顶梁柱
工作站：高端微型计算机，面向需要强性能的专业工作者（例如图形，视频）
微型计算机（个人计算机）：又分为台式计算机，笔记本计算机，一体化计算机
计算机体系和结构
冯诺依曼体系：将指令和数据一起存储的计算机设计概念结构，使用通用电路设计，而不是使用专用电路，将指令存储，再将指令编译成通用电路可理解的程序
冯诺依曼体系要求具备存储器，控制器，运算器，输入/输出设备
冯诺依曼体系要求能将程序和数据发送给计算机（输入），能长期存储程序，数据，计算过程，计算结果的功能（存储器），具备算术，逻辑处理和数据传送等数据处理功能（运算器和控制器），并且能将处理结果反馈给用户（输出）
冯诺依曼瓶颈：CPU和存储器速率之间无法调和，导致CPU空转等待数据传输
现代计算机都是基于冯诺依曼体系的（解决冯诺依曼瓶颈），存储器和运算器，以及控制器整合在一起（就是CPU），CPU内部的存储器更高速（寄存器）
计算机层次和编程语言
程序编译和程序解析（计算机无法理解人类语言），需要进行语言（高级语言对低级语言）的转换
高级语言生成低级语言的过程叫程序编译，而生成的工具叫编译器
常见的编译型语言有C，C++，Golang
高级语言作为输入，低级语言接收输入，从而达到高转低的目的，这个过程叫程序解析，而这个低级语言接收的工具叫解析器，解析器必须是用低级语言编写的
常见的解析型语言有Python，PHP
java是编译+解析语言，因为它会将源程序编译成JVM字节码，JVM虚拟机再将JVM字节码再解析成机器码，java的跨平台就是因为JVM虚拟机解析器
计算机的层次：硬件逻辑层，微程序机器层，传统机器层，操作系统层，汇编语言层，高级语言层，应用层
硬件逻辑层：由门电路和触发器等逻辑电路组成
微程序机器层：由微指令组成的微程序直接交给硬件执行
传统机器层：CPU指令集，不同架构CPU使用不同的CPU指令集
这3层都为机器硬件层，一个指令就是一个微程序，也是一组微指令
操作系统层：向上提供操作界面，向下对应指令系统，管理硬件（例如分配内存空间）
汇编语言层：汇编语言可以直接编译成机器语言，完成翻译的工具叫汇编器
高级语言层：高级语言
应用层：应用软件
计算机的计算单位
容量单位
在物理层次，用高低电平来记录信息（低电平为0，高电平为1，一个0/1的位被叫为bit（比特位））
1字节（Byte）等于8bit
1Kb（千字位）等于1024字节（Byte）
1mb（兆字节）等于1025kb（千字节）
1Gb（吉字节）等于1024mb（兆字节）
1tb（太字节）等于1024gb（吉字节）
1pb（拍字节）等于1024tb（太字节）
1eb（艾字节）等于1024pb（拍字节）
1024是2的10次方
对于硬盘制造商来说，使用10进制，也就是硬盘制造商认为1000G才是1tb
因此实质硬盘容量为购买标注的容量（例如240G）乘以1000的3次方，再除于1024的3次方，得到的数就是实质硬盘的容量
原因是硬盘制造商为了记录硬盘的扇区，使用人类可理解的10进制，而不是2进制
速度单位
网络速度
网络传输数据的单位为Mbps
因此100M宽带就是指100Mbit/s，每秒传输100Mbps
100Mbit换算字节就是100/8，也就是12.5MB，因此100m宽带峰值每秒可以传输12.5mb
CPU速度（CPU的时钟频率，Hz）
Hz是每秒中的周期性变动重复次数的计量
例如 3.30 GHz的CPU，就是3.3*1000^3Hz，也就是每秒可以达到33亿次的高低电平变化
计算机的字符和编码集
字符编码集的历史
ASCII码：ASCII码包含95个可打印字符和33个不可打印的字符（例如控制字符），用7个bits表示一个ASCII码（95+33就是128，也就是2的7次方）
因为ASCII码无法满足需求（例如π），而推出了Extended ASCII码，由原来的7个bits变成8个bits，也就是支持256个字符</description>
    </item>
    <item>
      <title>Nuxt.js学习笔记</title>
      <link>https://99999.fun/posts/152/</link>
      <pubDate>Sun, 05 Jun 2022 21:36:00 +0000</pubDate>
      <guid>https://99999.fun/posts/152/</guid>
      <description>nuxt是一个基于vue的应用框架，用于创建服务端渲染应用，使用vite作为打包器，使用webpack作为构建工具
创建项目
yarn create nuxt-app test
需要做一些选择，例如：选择TypeScript，选择Yarn，选择UI框架等等
安装依赖
yarn
启动项目
yarn dev
构建打包
yarn build
yarn start
启动测试环境 yarn test</description>
    </item>
    <item>
      <title>编译原理学习笔记</title>
      <link>https://99999.fun/posts/148/</link>
      <pubDate>Sun, 08 May 2022 03:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/148/</guid>
      <description>编译就是翻译，将机器语言翻译成另一个机器语言（例如高级语言翻译成低级语言（例如汇编），低级语言翻译成机器语言（二进制））
编译让计算机理解高级语言并且执行，编译让计算机更理解人，编译提供了人类新的思考方式
编译的翻译只能作用于形式语言
编译器和解释器
编译器将源程序编译成目标的程序
解释器接收源程序与输入，执行并且返回输出
混合编译器通常需要2次编译，第一次编译将源程序翻译成目标程序，第二次编译时，将目标程序与输入一起放到虚拟机来处理执行（虚拟机用于跨平台，来处理复杂的执行环境）
即时编译器，将源程序编译成机器码后再执行
交叉编译：在一个平台上编译产生多个平台的可执行程序
编译的过程
关注度分离
词法分析（分词，分析词法）
语法分析（将词分析的结果分析成抽象语法树的过程，也就是AST（Abstract Syntax Tree）），语法分析器被叫为parser
语义分析：分析抽象语法的语法是否合法
根据抽象语法树生成的三地址码进行存储，传输，优化
根据三地址码生成机器码（有一些还需要把机器码编译成可执行应用）
词法分析：将程序的字符流转换为符号流，分析符号，并且给予描述
例如：let a = 1
词法分析后得到
let: Keyword a: Variable =: Operator 1: Integer
词法分析器会将关键字抽离，并且对每个字符作描述
词法分析器得到返回值是符号元组，符号又叫词法单元（Token）
词法：构造语句的方法（哪些是具备词性（根据词的特点来区分的语法分类，例如动词，名词等等），哪些是具备词语（具有意义的词，关键字）），通常使用正则表达式来描述词法，使用状态机来实现正则表达式
字母表（alphabet）：某个编程语言中允许的全部字符
串（string）是某个编程语言中的字母序列
词法分析器将源程序的字符流进行分析，通正则文法过来找到这些词汇，并且给予词性，如果存在不支持的词汇，则报错（也就是分词）
词法分析器使用了一种叫有限自动机（有限状态机，deterministic finite automaton, DFA）的算法，在分析字符串时，当遇到了关键字时，会改变状态
有限自动机和图灵机很相似，不过有限自动机只能读取，无法进行计算
例如：a == 1
当识别扫描到a时，会处于标识符状态，直到遇到了==，就会切换到比较运算符状态，然后再识别1，知道该值是数值字面量
语法分析
语法分析的过程就是在词法分析的基础上分析程序的语法结构，这个语法结构是树状的，这个树叫抽象语法树（Abstract Syntax Tree，AST），树节点是语法单元，可通过递归下降算法或者自底向上算法来构造该树状
语法制导翻译</description>
    </item>
    <item>
      <title>vuejs底层原理学习笔记</title>
      <link>https://99999.fun/posts/147/</link>
      <pubDate>Tue, 26 Apr 2022 20:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/147/</guid>
      <description>组件的渲染，更新
组件的渲染：通过组件的模板创建vnode，渲染vnode，生成DOM
vue应用的初始化
import { createApp } from &#39;vue&#39;import App from &#39;./app&#39;const app = createApp(App)app.mount(&#39;#app&#39;)通过上面例子看到vue将app应用挂载到根组件上（一般是id为app的dom节点），通过createApp()函数，对外暴露vue，createApp()方法主要作用是创建app应用，以及重写mount方法，最后返回app应用
通过createApp()源码，可以看到createApp()接收一个参数，这个参数也就是app应用（根组件），createApp()创建app应用是通过ensureRenderer()的createApp()创建的
ensureRenderer()用于创建一个惰性渲染器对象（延时创建，这样的好处是当只使用响应式包时，不需要打包渲染器等渲染逻辑相关的代码）</description>
    </item>
    <item>
      <title>web安全学习笔记</title>
      <link>https://99999.fun/posts/145/</link>
      <pubDate>Wed, 13 Apr 2022 13:50:00 +0000</pubDate>
      <guid>https://99999.fun/posts/145/</guid>
      <description>常见web工具：
burpsuite：通过代理渗透，可重放HTTP请求，来分析HTTP响应
curl：通过url方式传输数据，可用于抓取页面（执行请求），监控网络等等
postmain
hackbar quantum
wappalyzer
文件上传漏洞：没有足够的安全约束的情况下，允许上传恶意文件，例如恶意脚本，webshell等等
文件上传漏洞关键点在于绕过
由于法律限制的原因，禁止对其他网站非法攻击，因此需要在本地或者在自己的服务器上建立靶场渗透环境，这边使用的是bwapp（全称为buggy web Application）
这边使用的是docker运行bwapp，也可以下载bwapp，来自己搭建（https://sourceforge.net/projects/bwapp/files/）
docker pull raesene/bwapp
docker run -d -p 0.0.0.0:80:80 raesene/bwapp
访问127.0.0.1/install.php
点击here来初始化，或者直接访问127.0.0.1/install.php?install=yes
创建账号信息，点击new user，或者直接访问127.0.0.1/user_new.php
点击login，或者直接访问127.0.0.1/login.php，根据刚才的账号信息进行登录
简单接触文件上传漏洞
chose your bug选择unrestricted File Upload（未经严格审记的文件上传），安全级别选择low（set your security level）
上传一句话木马，创建shell.php文件，添加
通过curl触发，执行curl -d &amp;rsquo;test=echo getcwd();&amp;rsquo; http://127.0.0.1/images/shell.php
可以看到成功触发shell.php，并且服务器返回了当前执行的目录
后缀名绕过
安全级别选择medium（set your security level）
常见后缀名验证方式有，黑名单（禁止哪些后缀上传），白名单（只允许哪些后缀上传）
这里的靶场环境的web server为Apache，因此需要了解Apache解析器模块
.htaccess绕过，当黑名单没有限制上传.htaccess文件时，并且web sever也支持.htaccess时
上传.htaccess文件，内容为：AddType application/x-httpd-php jpg
上传木马，shell.jpg
AddType application/x-httpd-php jpg的意思是，jpg文件按照php文件的方式解析
大小写绕过
大小写用于Windows平台环境下，在Windows中，大小写是不敏感的，而在Linux环境下，大小写是敏感的
Windows文件流绕过
利用windows平台的NTFS文件系统的文件流特性，设置文件时，默认使用未命名的文件流，但是也可以创建其他命名的文件流
例如：
echo hallo,word &amp;gt; hallo.txt:a.txtecho hallo &amp;gt; hallo.</description>
    </item>
    <item>
      <title>Rust学习笔记</title>
      <link>https://99999.fun/posts/142/</link>
      <pubDate>Mon, 28 Mar 2022 13:22:00 +0000</pubDate>
      <guid>https://99999.fun/posts/142/</guid>
      <description>Rust由非盈利组织Mozilla基金会开发，像著名的Mozilla Firefox浏览器和MDN Web Docs都出自该基金会
安装
官方推荐使用Rustup来安装（Rustup是rust的安装器和版本管理工具）
通过rustup-init来安装Rust
https://www.rust-lang.org/zh-CN/tools/install
windows直接安装pustup-init.exe来安装（需联网）,默认通过vc安装，建议选择2自定义安装
Linux或者macOS则直接执行以下命令
curl &amp;ndash;proto &amp;lsquo;=https&amp;rsquo; &amp;ndash;tlsv1.2 -sSf https://sh.rustup.rs | sh
注意：Rust的一些包，可能还依赖C编译器，因此最好安装一下GCC
检查是否安装完成
rustc &amp;ndash;version
如果喜欢用Visual Studio Code开发，可搭配rust-analyzer插件来使用
更新rust
rustup update
卸载rust和rustup
rustup self uninstall
在安装rustup的同时也会安装Cargo
Cargo是rust的项目构建工具和包管理器
检查是否安装成功
cargo &amp;ndash;version
创建第一个rust项目
cargo new halloword
其中Cargo.toml文件是项目的依赖库文件
通过编辑Cargo.toml文件来添加依赖
rust依赖可通过https://crates.io/查找
[package]name = &amp;quot;hallo_word&amp;quot;version = &amp;quot;0.0.1&amp;quot;edition = &amp;quot;2021&amp;quot;[dependencies]hyper = &amp;quot;0.14.20&amp;quot; # 来自https://crates.io/# hyper = { git = &amp;quot;https://github.com/hyperium/hyper&amp;quot; } # 来自第三方社区# hyper = { path = &amp;quot;.</description>
    </item>
    <item>
      <title>Flutter框架学习笔记</title>
      <link>https://99999.fun/posts/141/</link>
      <pubDate>Tue, 22 Mar 2022 12:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/141/</guid>
      <description>Flutter是谷歌开源的跨平台UI框架，可以快速在iOS和Android上构建高质量的原生用户界面，可在Windows，Linux，Android，Web，iOS，Mac等6大平台上开发应用
闲鱼和Now直播，美团，快手都使用了Flutter
获取Flutter
https://storage.flutter-io.cn/flutter_infra_release/releases/stable/windows/flutter_windows_2.10.3-stable.zip
添加path环境变量
由于Flutter库是在google那，因此需要设置第三方可信镜像库
设置PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL环境变量
PUB_HOSTED_URL设置为https://pub.flutter-io.cn
FLUTTER_STORAGE_BASE_URL设置为https://storage.flutter-io.cn
（flutter-io.cn所提供的镜像由中国的Flutter开发者社区提供和维护）
其他可信第三方镜像库：
腾讯云镜像
PUB_HOSTED_URL（https://mirrors.cloud.tencent.com/dart-pub） FLUTTER_STORAGE_BASE_URL（https://mirrors.cloud.tencent.com/flutter）
清华大学镜像
PUB_HOSTED_URL（https://mirrors.tuna.tsinghua.edu.cn/dart-pub） FLUTTER_STORAGE_BASE_URL（https://mirrors.tuna.tsinghua.edu.cn/flutter）
添加Flutter环境变量path，解压路径\flutter\bin
执行where.exe flutter dart，如果有反应，说明path环境配置完成
（如果要开发安卓的话，需要安装jdk，Android Studio，Android Jdk，可执行flutter doctor检查依赖（如果是X表示没依赖，需要安装））
这里用Visual Studio Code的Flutter插件
创建第一个demo（项目名必须全小写，可用_下划线）
flutter create flutterdemo
启动项目（编译执行）
flutter run
Dart是静态类型语言，它会在定义时绑定数据类型（var）
Dart允许一个类中有多个构造函数，在new初始化时，可选择类的某个构造函数
Dart库管理（pub.dev）,在pubspec.yaml添加库
实质上Dart和JavaScript很相似，只是它有抽象和泛型（ts也有泛型，抽象类就是类似于golang的接口，只定义不实现）
Dart也是单线程执行，主线程外也有宏任务队列和事件队列（可以理解为JavaScript中的宏任务）
Dart执行过程：执行main()函数，判断是微任务还是事件队列，是微任务则插入微任务队列，是宏任务则插入宏任务队列，执行完成后（主线程），会执行微任务队列和事件队列，以及判断微任务队列和事件队列是否为空，当为空时程序执行结束
flutter项目下的lib/main.dart，class MyApp类下
修改为 home: const MyHomePage(title: &amp;lsquo;Hallo word&amp;rsquo;), // 当前title信息
在return Scaffold下的body: Center下的，修改为children: [const Text(&amp;lsquo;Hallo word&amp;rsquo;,),
运行后可以看到一个title以及内容都为Hallo word的app
flutter自带了可视化工具，Dart DevTools
自己写一个main.dart
void main() =&amp;gt; runApp(MyApp());class MyApp extends StatelessWidget{@overrideWidget build(BuildContext context){return MaterialApp(title: &amp;quot;hallo word&amp;quot;, // app的titletheme: ThemeData(primarySwatch: Colors.</description>
    </item>
    <item>
      <title>Nestjs学习笔记</title>
      <link>https://99999.fun/posts/139/</link>
      <pubDate>Sat, 05 Mar 2022 14:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/139/</guid>
      <description>NestJS是一个nodejs服务端应用开发框架，基于typescript开发，http服务框架默认为Express，也支持Fastify，支持面向对象，函数式以及函数响应式编程
安装
npm install -g @nestjs/cli
创建demo项目
nest new demo
选择使用包管理器（支持npm，yarn，pnpm）
创建完成后可以看到src目录，是典型的MVC架构
app.controller.ts（应用路由控制器，例如Get()方法，该路由控制器将从应用服务文件中获取数据，并且将数据返回到页面上） app.controller.spec.ts（应用控制器单元测试） app.module.ts（应用模块文件，nest模块化，一个nest项目最少有一个模块，通过controllers()方法接收一个模块组(数组形式)，） app.service.ts（应用服务文件，数据来源于该文件） main.ts（应用程序入口文件，实质上是async/await异步函数（bootstrap()）
从main.ts入口文件可以看出，nest应用实例是基于NestFactory类（该类来源于@nestjs/core，nest核心程序）对外暴露的方法创建的
启动项目
npm run start
访问http://localhost:3000/，如果看到Hello World!表示启动成功
nestjs cli支持对mvc模块的生成
新建nest项目 nest new demo
打包nest项目 nets build
运行nest项目 nest start
查看nest当前项目的一些信息 nest info
创建控制器 nest g controller 名称 或者 nest g co 名称
创建服务 nest g service 名称 或者 nest g s 名称
创建模块 nest g module 名称 或者 nest g mo 名称
创建异常过滤器 nest g filter 名称</description>
    </item>
    <item>
      <title>Gin框架学习笔记</title>
      <link>https://99999.fun/posts/135/</link>
      <pubDate>Tue, 15 Feb 2022 17:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/135/</guid>
      <description>Gin是一个基于go语言编写的web框架，因为Gin的路由库基于httprouter开发的，性能非常好，支持Restful api规范
安装
go get -u github.com/gin-gonic/gin
第一个demo
package mainimport &amp;quot;github.com/gin-gonic/gin&amp;quot;import &amp;quot;net/http&amp;quot;func main() {g := gin.Default()g.GET(&amp;quot;/&amp;quot;, func(c *gin.Context) {c.String(http.StatusOK, &amp;quot;hallo word&amp;quot;)})g.Run()}go run main.go
g.Run()是将应用部署到本地服务器上，默认端口为8080，可设置端口，g.Run(&amp;quot;:2333&amp;quot;)
路由
r.GET(&amp;quot;/test/:name&amp;quot;, func(c *gin.Context) {name := c.Param(&amp;quot;name&amp;quot;)c.String(http.StatusOK, name)})g.Run(&amp;quot;:6666&amp;quot;)127.0.0.1:6666/test/xiaochen
可以看到Context的Param方法可以获取路由的参数
通过url传递参数
r.GET(&amp;quot;/test&amp;quot;, func(c *gin.Context) {name := c.DefaultQuery(&amp;quot;name&amp;quot;, &amp;quot;test&amp;quot;)c.String(http.StatusOK, fmt.Sprintf(&amp;quot;hallo %s&amp;quot;, name))})r.Run()127.0.0.1:6666/test
如果没有传递参数将会输出DefaultQuery的默认参数test
传递参数后 127.0.0.1:6666/test?name=word
POST请求
index.html main.go</description>
    </item>
    <item>
      <title>PostCSS学习笔记</title>
      <link>https://99999.fun/posts/129/</link>
      <pubDate>Sun, 23 Jan 2022 13:55:00 +0000</pubDate>
      <guid>https://99999.fun/posts/129/</guid>
      <description>PostCSS是一个用JS插件转换为css的插件工具（注意：PostCSS不是css预处理器，PostCSS本身是个平台，可以通过一些插件达到css预处理器的效果）
PostCSS is a tool for transforming CSS with JS plugins. These plugins can support variables and mixins, transpile future CSS syntax, inline images, and more.
插件查询：https://www.postcss.parts/
常用插件：https://github.com/postcss/postcss/blob/main/docs/plugins.md
安装
npm install postcss postcss-loader
或者安装到项目中
npm install postcss postcss-loader &amp;ndash;save-dev
PostCSS不单独使用，可搭配Gulp或者webpack使用（这里使用的是webpack）
webpack.config.js
module.exports = {module: {rules: [{test: /\.css$/,use: [&amp;quot;style-loader&amp;quot;, &amp;quot;css-loader&amp;quot;, &amp;quot;postcss-loader&amp;quot;]}]}};postcss.config.js
module.exports = {plugins: [插件1,插件2]};Autopreﬁxer（自动添加浏览器前缀）
npm install autoprefixer &amp;ndash;save-dev</description>
    </item>
    <item>
      <title>Golang进阶扩展笔记</title>
      <link>https://99999.fun/posts/128/</link>
      <pubDate>Sun, 16 Jan 2022 09:08:00 +0000</pubDate>
      <guid>https://99999.fun/posts/128/</guid>
      <description>这篇笔记是进阶学习，如果基础没有看的的话，请去看https://xiaochenabc123.test.com/archives/96.html
并发
go的并发靠goroutine，goroutine由go运行时调度，线程由操作系统调度，go还提供channel来给多个goroutine之间通行，goroutine和channel是go并发模式CSP（Communicating Sequential Process，通讯顺序进程）的实现基础，goroutine的调度在用户态下完成，不涉及内核态（比如内存的分配和释放，都是用户态维护的内存池，成本远比调度OS线程要低的多，可轻松做到成千上万个goroutine）
内核态：程序执行操作系统层级的程序时
用户态：程序执行用户自己写的程序时
常见的并发模型有七种，分别是通讯顺序进程（CSP），数据级并行，函数式编程，线程与锁，Clojure，actor，Lambda架构
CSP（Communicating Sequential Process，通讯顺序进程）：思想就是将两个并发执行的实体使用channel管道来连接起来，全部信息通过channel管道来传输，而且数据的传输是根据顺序来发送和接收的，CSP理论由托尼·霍尔提出
小知识：托尼·霍尔（C.A.R.Hoare），图灵奖获得者，快速排序算法（Quick Sort）也出自这位之手
go的并发编程不需要像java那样维护线程池，go在语言层面内置了调度和上下文切换机制，只需要定义任务，让go运行时来智能合理的调度goroutine的任务给每个CPU，也不需要额外写什么进程，线程，协程，只需要写一个函数，开启一个goroutine就是可以实现并发了
Go运行时会给main()函数建立一个默认的goroutine，当main()结束时，其他在main()执行的goroutine都会被结束（不管有没有执行完成）
goroutine的栈开始时为2kb（OS线程一般为2mb），而且栈不是固定的，可以增大和缩小，大小限制可以达到1GB
GPM调度器是Go对CSP并发模型的实现，是Go自己开发的一套调度系统（GPM分别表示为Goroutine，Processor，Machine）
Goroutine：go关键字创建的执行体，对应则结构体g，这个结构体存储着goroutine的堆栈信息
Processor：负责管理goroutine队列，存储则当前goroutine运行的上下文，会给自己管理的goroutine队列进行调度，例如：暂停goroutine，执行goroutine，当自己的队列处理完毕，将去全局队列中获取，全局队列处理完毕，还可以去其他P的队列去获取，用来处理G和M的通信
Machine：G运行时对操作系统内核线程的虚拟化，映射内核线程（groutine就是被放到这个内核线程的映射虚拟化M中执行）
简单来说就是P管理一组G在M上执行，当一个G阻塞在一个M时，Go运行时创建一个新的M，负责管理阻塞的那个G的P将其他G挂载在新的M上，G阻塞完成时或者G死掉了，回收旧的M
P的个数通过runtime.GOMAXPROCS设置（最大256）（1.5版本后默认为计算机物理线程数）
GPM调度器使用被称为m:n调度的技术（复用或者调度m个goroutine到n个OS线程）（可用runtime.GOMAXPROCS来控制OS线程的数量）
因为底层OS线程的切换机制是根据时间轮询来切换的，因此goroutine的切换机制也是根据时间轮询来切换
runtime.Gosched()：让当前任务让出线程占用，给其他任务执行
runtime.Goexit()：终止当前任务
通道是可被垃圾回收机制回收的，所以只有在告诉接收数据方，所有数据都已发送完毕了才需要关闭通道
对已经关闭的管道发送数据，导致触发panic，同样关闭已经关闭的管道也会导致
对已经关闭并且没有值的管道接收数据，将得到对应类型的零值，接收一个已经被关闭的管道，会一直接收数据，直到管道空了
无缓冲区管道（阻塞管道）：要求管道的发送方和接收方交互是同步的，管道容量等于0的就是无缓冲管道，如果不能满足同步，将导致阻塞，要接收者准备完毕，发送者才能进行工作
有缓冲区管道（非阻塞管道）：可以异步发送数据接收数据，只要缓冲区存在没有使用的空间，通信就是无阻塞的，可先发送数据再接收（因为有缓冲区），而且缓冲区管道可以保存数据（不需要取完数据）
任务池：goroutine池，当goroutine任务完成，不kill该goroutine，而是获取下一个任务，并且继续执行该任务
注意：go内置的map并不是并发安全的，只有使用channel或者sync.Map才是并发安全的
锁可以避免并发冲突，但是锁对系统性能影响很大，原子操作可以减少这种消耗
原子操作：指的是某个操作在执行中，其他协程不会看到没有执行完毕的结果，对于其他协程来说，只有原子操作完成了或者没开始，就好像原子一样，不被分割
在多核中，某个核心读取某个数据是，会因为CPU缓存的原因，可能读取到的值不是最新的，在Go中，原子操作主要依赖于sync/atomic包
sync/atomic包将原子操作封装成了Go的函数，sync/atomic包提供了底层的原子级内存操作
因为Go不支持泛型，所以封装的函数很多（每个类型都有自己的原子操作函数，这里只写int64一个类型）
增或减（被操作值增大或减少，只适合int和uint类型增减）：func AddInt64(addr *int64, delta int64) (new int64)
载入（读取，避免读取过程，其他协程进行修改操作）：func LoadInt64(addr *int64) (val int64)
存储（写入，避免写入过程，其他协程进行读取操作）：func StoreInt64(addr *int64, val int64)
交换（和CAS不同，交换只赋值old值，不管原来的值）：func SwapInt64(addr *int64, new int64) (old int64)
比较并且交换（Compare And Swap 简称CAS，类似于乐观锁，只有原来的值和传入的old值一样才修改）：func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</description>
    </item>
    <item>
      <title>Kubernetes学习笔记</title>
      <link>https://99999.fun/posts/127/</link>
      <pubDate>Mon, 10 Jan 2022 12:31:00 +0000</pubDate>
      <guid>https://99999.fun/posts/127/</guid>
      <description>Kubernetes（k8s，8是指k到s之间有8个字母），是谷歌在2014年发布并且开源的容器化集群管理系统（已在谷歌生产环境中工作15年），支持自动化部署，应用容器化管理，大规模升级或回滚，应用扩展等等
k8s的特性：
自动部署与滚动更新：自动化部署应用容器，k8s采取滚动式更新，可以根据应用的情况进行一次或者批量更新（判断该应用添加是否正常使用），也可以进行历史版本回滚
自我修复：当某个容器发生故障，会自动重新启动失败的容器，当某个节点（Pod）出现故障进行容器的替换或者重新部署，并且关闭没有通过检查的容器（不进行处理请求，保证服务不中断），直到容器恢复正常
弹性伸缩：通过命令，UI界面，CPU等资源使用情况，自动对应用容器进行扩容或者缩容，保证在高峰期的高可用性，降低运行成本
服务发现和负载均衡：k8s为容器对外提供了统一访问入口（api server），并且关联全部容器（负载均衡）
密钥与配置管理：允许在不重新构建容器（不需要重新集群，热更新）的情况下更新应用程序配置，可以存储和管理密钥，令牌等敏感信息，不需要暴露这些敏感信息（部署和更新密钥）
存储编排：支持挂载外部存储（网络存储服务，云存储服务）（本地当然是支持），自动完成存储系统的挂载以及应用，保证数据持久化
批处理：支持一次性任务，定时任务
k8s的集群架构分为2个组件，分别为master（主控节点）和node（工作节点）
master组件：api server（集群统一人口，restful），scheduler（节点调度，调度node节点应用部署），controller-manager（处理集群中后台任务，一个资源对应一个控制器，资源控制），etcd（存储系统，用来存储集群的相关数据）
node组件：kubelet（node节点代理，管理k8s容器），kube-proxy（负责网络代理，负载均衡等操作）
Pod：k8s管理系统中最小部署单位，一个或者多个容器的集合（共享同一个网络），容器重启将结束该pod的生命（生命周期短）
Service
Volume
Namespace
Controller：控制器（确保预期pod的数量），状态应用部署（无状态（没有任何限制约定），有状态（有限制条件，依赖需要））负责一次性任务，定时任务，守护进程等等，确保所有node运行同一个pod
Service Ingress：对外接口（定义pod的访问规则）
RBAC：安全机制，权限管理
Helm：包管理器，快速下载，安装软件
k8s集群搭建
单master集群：单个master节点，管理多个node节点
多master集群（高可用集群）：多个master节点，管理多个node节点，中间存在着负载均衡的过程
kubeadm
kubeadm是k8s部署工具，用于快速部署k8s集群
官方文档：https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
kubeadm安装
安装必备软件
apt install -y apt-transport-https ca-certificates curl
添加k8s国内源
sudo tee /etc/apt/sources.list.d/kubernetes.list &amp;laquo;-&amp;lsquo;EOF&amp;rsquo; deb https://mirrors.tencent.com/kubernetes/apt/ kubernetes-xenial main EOF
添加签名
gpg &amp;ndash;keyserver keyserver.ubuntu.com &amp;ndash;recv-keys 836F4BEB gpg &amp;ndash;export &amp;ndash;armor 836F4BEB | sudo apt-key add - apt update
836F4BEB这个为NO_PUBKEY的后8位
安装三件套
apt install -y kubelet kubeadm kubectl</description>
    </item>
    <item>
      <title>python爬虫学习笔记</title>
      <link>https://99999.fun/posts/125/</link>
      <pubDate>Fri, 31 Dec 2021 01:05:00 +0000</pubDate>
      <guid>https://99999.fun/posts/125/</guid>
      <description>urllib，xpath，jsonpath，beautiful，requests，selenium，Scrapy
python库内置的HTTP请求库 urllib.request 请求模块 urllib.error 异常处理模块 urllib.parse url解析模块 urllib.robotparsef robots.txt解析模块
urllib.request提供了最基本的http请求方法，主要带有处理授权验证，重定向，浏览器Cookies功能
模拟浏览器发送get请求，就需要使用request对象，在该对象添加http头 import urllib.requst response = urllib.request.urlopen(&amp;lsquo;https://xiaochenabc123.test.com/&#39;) print(response.read().decode(&amp;lsquo;utf-8&amp;rsquo;))
使用type()方法 import urllib.requst response = urllib.request.urlopen(&amp;lsquo;https://xiaochenabc123.test.com/&#39;) print(type(response))
HTTPResposne类型对象
通过status属性获取返回的状态码 import urllib.requst response = urllib.request.urlopen(&amp;lsquo;https://xiaochenabc123.test.com/&#39;) print(response.status) print(response.getheaders())
post发送一个请求，只需要把参数data以bytes类型传入 import urllib.parse import urllib.request data = bytes(urllib.parse.urlencode({&amp;lsquo;hallo&amp;rsquo;:&amp;lsquo;python&amp;rsquo;}),encoding=&amp;lsquo;utf-8&amp;rsquo;) response = urllib.request.urlopen(&amp;lsquo;http://httpbin.org/post&#39;.data = data) print(response.read())
timeout参数用于设置超时时间，单位为秒 import urllib.request response = urllib.request.urlopen(&amp;lsquo;https://xiaochenabc123.test.com/&#39;,timeout=1)
这里设置超时时间为1秒，如果超了1秒，服务器依然没有响应就抛出URLError异常，可以结合try和except
import urllib.parseimport urllib.requesturl = &amp;quot;https://xiaochenabc123.test.com/&amp;quot;headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.</description>
    </item>
    <item>
      <title>操作系统学习笔记</title>
      <link>https://99999.fun/posts/115/</link>
      <pubDate>Thu, 07 Oct 2021 09:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/115/</guid>
      <description>操作系统是管理计算机硬件和软件资源，并且提供用户交互的软件系统
常见操作系统有Windows，Linux，Android
操作系统具备管理计算机资源的功能，具备抽象计算机资源的能力，能和用户进行交互
操作系统实质上是一个很复杂的控制软件，可以管理应用，资源管理，管理外设等等
操作系统的架构的层次是在硬件之上，应用之下
OS Kernel：可并发（同时存在多个运行的应用）。可共享，可虚拟，可异步
微内核：尽可能将内核功能移植到用户空间，缺点就是性能低
外核和内核：一个负责硬件，一个负责软件
DISK（硬盘存储）：存储OS
BIOS：基本I/O处理系统（加载外设以及加载软件来运行OS） （basic I/O system)
BootLoader：加载OS
POST（加电自检，查找显卡和执行BIOS）
系统调度：来源于“合法”的应用向系统发出服务请求的（同步或者异布）
异常：来源于“不良”的应用非法指令（或者应用意想不到的请求，应用无法获得资源需求）（同步）
中断：来源于外设对于硬件设备和网络中断（异步）
逻辑化地址空间，独立地址空间，可访问相同内存，更多内存空间（虚拟化）
物理地址空间：硬件支持的地址空间
逻辑地址空间：应用程序拥有的内存范围
操作系统为了运行多个程序，进行了内存地址的隔离（分配独立的虚拟内存地址），虚拟内存地址和物理内存地址是映射关系
应用逻辑地址映射到物理地址
CPU需要逻辑地址上的内存内容（ALU），内存管理单元（MMU）寻找逻辑地址和物理地址之间的映射，控制器将从总线发送物理地址的内存内容的请求
内存发送物理地址内存内容给CPU（告诉CPU，物理地址找到了），建立逻辑地址和物理地址之间的映射（确保应用互不干扰）
虚拟地址和物理地址的映射关系管理
内存分段（内存被看成一组不同长度的段）
内存分段下的虚拟地址分为段选择⼦和段内偏移量
段选择⼦保存在段寄存器中，段选择⼦其中的段号被用于段表的索引，段表中保存的是这个段的基地址和段界限等等
而段内偏移量是位于0和段界限之间的，如果段内偏移量合法，那么段内偏移量加段的基地址得到物理内存地址
分段的内存碎片问题，如果某个程序占用了128mb内存，然后该程序被关闭了，释放128mb内存，如果这个128mb内存不是连续的，而是被分段了，这将导致没有内存空间打开另一个内存占用128mb的程序
内存分页（将物理内存和虚拟内存切成一段段固定大小的内存空间）
内存分页解决了内存分段的内存碎片问题，其释放内存是以页为单位释放的，当内存空间不够，会释放其他正在运行的进程的没使用的内存页面
内存分页下的虚拟地址被分为页号和页内偏移，页好为页表的索引，页表保存着物理页的所在物理内存的基地址，基地址和页内偏移组成物理内存地址
内存分页的缺点就是在运行多线程时，页表会非常大，所以出现了多级⻚表（将页表分成一级一级的）
段⻚式内存管理（内存分段和内存分页的结合体）
先将内存分为多个段，再将每个端分为多个页，地址通过段号，段内⻚号和⻚内位移组成
连续性内存管理（内存碎片和分区的动态分配）
外部碎片：在分配单元间的未使用内存
内部碎片：在分配单元中的未使用内存
当一个应用被批准运行在内存中时，分配一个连续的区间，来给运行的应用访问数据
动态分配的策略：当想分配某字节，先从低地址找，找到第一个被某字节大的空闲块，就使用它
动态分配的缺点就是外部碎片严重
非连续内存分配
分段Segmentation：
逻辑地址空间连续，物理地址离散
一个段表示一个内存块，一个逻辑地址空间，应用访问内存地址的时候，需要个二维的二元组
虚拟内存：
早期内存不够应用消耗，应用的规模比存储器的容器大
当应用太大，超出内存，可采用手动的覆盖(overlay) 技术，只把需要的指令和数据保存在内存中
当应用太多，超出内存，可采用自动的交换(swapping) 技术，把暂时不能执行的程序送到外存（磁盘）中
进程和线程：
进程状态(state)，线程(thread)，进程间通信(inter-process communication)，进程互斥与同步，死锁(deadlock)
进程包含正在运行的应用的全部状态信息
进程可动态化创建，结束进程，可以被独立调度并占用处理，不同的进程互不影响，可访问共享数据或者资源
进程控制块(process control block, PCB)：进程的数据结构，操作系统管理控制进程运行所用的信息集合，操作系统为每一个进程都维护了一个PCB，用来存储保存和该进程有关的状态信息
进程是操作系统最小可调度的资源单位
多个程序运行在单核心CPU服务器上，实质就是在共享时间片（时间片，操作系统将某个程序分配到某段CPU时间上，单核是无法同时运行多个程序的，只能共享时间片，而进程就是因此而生）
进程状态有3种，分别是运行，阻塞以及就绪
运行和就绪可互相转换，运行状态就是CPU指令在读取运行进程中的程序段，而就绪就是该进程在等待调用
运行可切换到阻塞状态
阻塞就是进程在等待信号（依赖的资源没有就位），阻塞状态结束后会切换到就绪状态
进程状态的切换可理解为接力赛跑，运行状态就是正在跑的运动员，而就绪状态就是在等待接力棒的运动员，而阻塞状态就是运动员需要补充休息，暂时不跑了</description>
    </item>
    <item>
      <title>Redis学习笔记</title>
      <link>https://99999.fun/posts/97/</link>
      <pubDate>Fri, 10 Sep 2021 21:10:00 +0000</pubDate>
      <guid>https://99999.fun/posts/97/</guid>
      <description>Redis是NoSQL数据库（Not Only SQL）家族的代表之一，其特点就是基于内存运行，支持分布式，key-value存储
Redis具备速度快，支持多种数据结构，可持久化，支持主从复制，具备高可用，分布式等特点
可以将内存中的数据存储到磁盘中，重启的时候再加载使用，保证数据的持久性，支持备份恢复，常用于缓存数据库（辅助持久化数据库）
因为其是以内存作为存储介质，因此读写数据的效率极高，读取速度可高达110000次/s（也就说可达到10W QPS，QPS（Queries Per Second）:每秒查询率），写速度高达81000次/s
Redis将数据存储于内存中，Redis会将数据的更新异步存储到磁盘中来持久化，Redis数据持久化有2种方式，分别是RDB（Redis DataBase）和AOF（append only file）
Redis支持多种数据结构，例如：string（字符串），hash（哈希），list（列表），set（集合），zset(Sorted Set: 有序集合)，BitMaps（位图），HyperLogLog（超小内存唯一值计数），GEO（地理信息定位）
Redis支持分布订阅，Lua脚本，事务，pipeline等功能，支持主从复制，确保高可用
Redis可以用来当做缓存系统，用户访问app应用服务时，一般来说会优先从缓存中读取，如果缓存没有再到存储介质中读取，并且将该数据会在存储在缓存中，这个缓存就是Redis
Redis安装
编译安装（linux）
下载redis-x.x.x.tar.gz
解压
tar xzf redis-x.x.x.tar.gz
进入解压出来的文件夹中，执行make&amp;amp;&amp;amp;make install命令
因为用的是默认配置
进入src，./redis-server ../redis.conf
测试客户端
./redis-cli
src目录下可看到6个可执行文件，作用如下：
redis-server可执行文件用于启动redis服务器
redis-cli可执行文件用于redis命令行客户端，用于连接redis服务器
redis-benchmark可执行文件用于redis性能测试，基准测试
redis-check-aof可执行文件用于修复AOF可持久化文件
redis-check-dump可执行文件用于RDB可持久化文件的检查工作
redis-sentinel可执行文件用于启动高可用的sentinel模式（该模式又叫哨兵）
使用redis并不推荐使用windows，虽然微软官方提供了redis补丁，但是redis版本太低了，建议使用Linux虚拟机或者docker容器来跑
redis有3种启动服务器方式
默认配置启动
redis-server
动态参数启动
redis-server &amp;ndash;port 6380
配置文件启动（推荐，通过redis.conf文件来进行配置）
redis-server configPath
客户端连接服务（6379是redis默认端口）
redis-cli -h 127.0.0.1 -p 6379 -a &amp;ldquo;root&amp;rdquo;
redis.conf配置
默认端口为6379
port 6379
要远程访问则设置为0.0.0.0
bind 127.0.0.1
logfile，redis日志名
dir，redis工作目录（日志文件和持久化文件存储在哪个文件）
以守护进程运行（yes为守护进程），注意如果是以守护进程运行，那么会默认将pid写入到/var/run/redis.pid
daemonize yes</description>
    </item>
    <item>
      <title>Golang学习笔记</title>
      <link>https://99999.fun/posts/96/</link>
      <pubDate>Thu, 09 Sep 2021 01:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/96/</guid>
      <description>Golang又叫go语言，golang是它的全称，是由Google开发的一种静态强类型，编译型，并发型，并具有垃圾回收功能的编程语言
go语言确保达到静态编译语言的安全和性能的同时，又达到动态语言的开发维护效率
Go语言天生支持并发，提供自动垃圾回收机制
go的源文件是xxx.go
值得一提的是哔哩哔哩网站后端就是用golang开发，这个足以说明golang的并发功能有多强大了
检查是否安装成功go
go version
环境配置
GOROOT对应着go的安装目录
GOPATH对应着go的源代码目录（可以放多个目录）
GOBIN对应着 go install安装和编译的二进制程序的安装目录
检查go环境
go env
源程序默认为UTF-8编码，;可省略
第一个go程序
package mainimport &amp;quot;fmt&amp;quot;func main(){fmt.Println(&amp;quot;hallo golang&amp;quot;)}go run hallo.go
当然作为一个编译型语言，编译成二进制文件是支持的
go build hallo.go
作为一个静态强类型语言，如果学过java的话，理解还是很轻松的
定义包 package : 必须在源程序上声明该文件是属性那个包的
引入包 import : 导入包，引用外部包开扩展功能
注释
// 单行
/* 多 行 */
标识符命名规范：第一个字母必须是字母或者下划线，而且不能是关键字，特殊符号只支持下划线
常用的数据类型有：
整型：int（有符号），uint（无符号），rune，int/unint(8,16,32,64)
浮点型：float(32,64)，comple
布尔型：bool（true，false）（bool默认值为false）
字符串型：string
数组：array
结构体：struct
变量
var abc string = &amp;ldquo;hallo&amp;rdquo;
注意：如果声明变量了，但是没有初始化，那个该变量的值为系统默认设置的值（零值）
定义多个变量
var abc xyz string = &amp;ldquo;hallo&amp;rdquo;,&amp;ldquo;word&amp;rdquo;</description>
    </item>
    <item>
      <title>React进阶学习笔记</title>
      <link>https://99999.fun/posts/94/</link>
      <pubDate>Fri, 03 Sep 2021 12:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/94/</guid>
      <description>react16是Facebook在2017年发布的react版本，几乎对react底层进行重写，但是对外API不变，因此可以无缝转移到react16
render返回类型
除了只能返回单个元素外，react16支持返回字符串和数组（由react元素组成）
例如：
render(){return[&amp;lt;div&amp;gt;hallo&amp;lt;/div&amp;gt;,&amp;lt;div&amp;gt;word&amp;lt;/div&amp;gt;]}或者
render(){return &amp;quot;hallo word&amp;quot;}错误处理
react16引入了新的错误处理机制，当组件发生错误，将会将其从组件树中卸载，避免引起整个应用的崩溃
当然也提供了更友好的处理方式，叫错误边界，这个会捕获子组件的错误，并且输出错误日志和出错提示，例如：
componentDidCatch(error, info){console.log(error,info)}Portals
React16的Portals特性可以将组件渲染到当前组件树以外的DOM树上，例如弹框
ReactDOM.createPortal(child, container)
第一个参数是可以被渲染的react节点，第二个参数是dom元素，react节点将会被挂载到该DOM元素上
自定义DOM属性
在react16之前，会忽略不识别的属性，而在react16之后，会将不识别的属性传递给dom元素
React AJAX（搭配jQuery）
通过componentDidMount()调用，通过componentWillUnmount()取消未完成的请求
Virtual-DOM实质上就是模拟DOM树结构，通过JavaScript对象来描述DOM对象，通过映射成真实的DOM节点来实现
对于DOM节点数据更新，则通过生成一个新的Virtual-DOM，两个Virtual-DOM通过Diff算法进行差异更新，将更新处理为真实的DOM
Virtual-DOM的优势：减少操作DOM，处理视图和状态的关系
没有任何框架能比原生DOM处理快，但是操作原生DOM可能导致浏览器的回流（回流是性能第一杀手），因此在复杂视图下，原生DOM操作就可能没有Virtual-DOM性能好了
react-markdown是react官方提供的库，专门用来解析md文件或者符合md语法的变量
安装react-markdown
yarn add react-markdown
导入
import ReactMarkdown from &amp;lsquo;react-markdown&amp;rsquo;
测试
let markdown =&amp;quot;**这是加粗的文字**\n\n&amp;quot; +&amp;quot;*这是倾斜的文字*`\n\n&amp;quot; +&amp;quot;***这是斜体加粗的文字***\n\n&amp;quot; +&amp;quot;~~这是加删除线的文字~~ \n\n&amp;quot; +&amp;quot;`console.log(111)` \n\n&amp;quot; +&amp;quot;``` var a=11; ```&amp;quot;;&amp;lt;ReactMarkdown source={markdown} escapeHtml={false} children={markdown}/&amp;gt;</description>
    </item>
    <item>
      <title>Taro框架学习笔记</title>
      <link>https://99999.fun/posts/92/</link>
      <pubDate>Tue, 31 Aug 2021 12:15:00 +0000</pubDate>
      <guid>https://99999.fun/posts/92/</guid>
      <description>Taro是京东凹凸实验室推出的一个框架，设计目的是多端统一开发解决方案，一次开发，多端运行
Taro可以使用React/Vue等前端框架开发的，当然typescript肯定是支持
Taro官方文档：https://taro-docs.jd.com/taro/docs/README
Taro官方组件库：https://taro-ui.jd.com/
Taro支持微信小程序，百度小程序，支付宝小程序，字节小程序，QQ轻应用，ReactNatvie等等
Taro 1.2支持将已有的微信小程序进行转换，只需要在项目根目录运行taro convert命令就可以在将现有的小程序项目转换到taroConvert目录下，转换成jsx代码，并且可以直接使用这个代码来进行taro build来编译成taro支持的平台应用
安装Taro框架
npm install -g @tarojs/cli
或者
yarn global add @tarojs/cli
升级框架
taro update self
创建项目
taro init hallo
创建h5项目
yarn dev:h5
创建微信小程序项目
yarn dev:weapp
创建完毕会在dist目录下生成小程序程序
支付宝小程序 yarn dev:alipay
百度小程序 yarn dev:swan
ReactNative yarn dev:rn
编译完成的端源码在dist目录下
作为一个可以使用react规范开发的框架，React Hooks和jsx也是支持的
Taro组件化（Taro可以使用react开发，因此也具备react的组件化功能）
import Taro, { useState } from &#39;@tarojs/taro&#39;import { View, Text } from &#39;@tarojs/components&#39;import &#39;./index.less&#39;function Main(){const [count ,setUserName] = useState(&amp;quot;hallo word&amp;quot;)return ( &amp;lt;View&amp;gt;&amp;lt;Text&amp;gt;{count}&amp;lt;/Text&amp;gt;&amp;lt;/View&amp;gt;)}export default Main子组件</description>
    </item>
    <item>
      <title>算法学习笔记</title>
      <link>https://99999.fun/posts/79/</link>
      <pubDate>Mon, 09 Aug 2021 20:36:00 +0000</pubDate>
      <guid>https://99999.fun/posts/79/</guid>
      <description>虽然学过java和Python，但是还是JavaScript比较熟练，因此算法学习全部用JavaScript来写
算法不会被程序语言所限制，也不会一个实现只有一个算法
常见数据结构（数组，列表，映射，堆栈，队列，哈希表，树，图）
算法(排序,双指针,查找,分治,动态规划,递归,回溯,贪心,位运算,DFS,BFS)
大O表示法是专门用来表示算法速度有多快的，不同算法所耗时间的时间增速度不同
一个算法执行的时间和解决问题的规模大小相关
假设一个列表有n个元素，遍历全部元素，要执行n次，大O表示法为O(n)
大O表示法不是表示消耗的时间，而是通过操作元素的次数决定的，一个优秀的算法操作元素次数肯定很少
时间复杂度：
O(1): Constant Complexity: Constant 常数复杂度 O(log n): Logarithmic Complexity: 对数复杂度 O(n): Linear Complexity: 线性时间复杂度 O(n^2): N square Complexity 平⽅方 O(n^3): N square Complexity ⽴立⽅方 O(2^n): Exponential Growth 指数 O(n!): Factorial 阶乘
算法的特点：有穷性（必须要在一定的时间内完成，不能无限循环），确定性（每一条指令都有明确的目的，不产生二义性），可行性（可以通过基础运算来实现），输入输出（要有0个或者多个输入，要有1个或者多个输出）
删除有序数组中的重复项
保证有序数组中的元素是不重复的，也就是说不存在重复的元素
有序数组中重复的肯定是挨着的，只需要遍历数组全部的元素，前面和后面进行比较，如果相同则删除后面的
例如：
let arr = function(nums) {if(nums == null || nums.length == 0){return 0}let b = 0for(let a=0;a&amp;lt;nums.length;a++){if(nums[b]!=nums[a]){nums[++b] = nums[a]}}return ++b}b作为覆盖，a作为查询，当b的值不等于a查询到的值时，b++的值等于a的值，等于的时候b不改变，当不相等再等于到b上</description>
    </item>
    <item>
      <title>MongoDB学习笔记</title>
      <link>https://99999.fun/posts/76/</link>
      <pubDate>Sun, 08 Aug 2021 14:20:00 +0000</pubDate>
      <guid>https://99999.fun/posts/76/</guid>
      <description>MongoDB是一个以键值对存储数据的数据库（基于json描述数据，实质上是一个叫BSON的数据格式，BSON是基于二进制字节流，json基于文本）
MongoDB是No SQL家族的成员之一，No SQL一般指的是非关系型数据库（Not only SQL）
关系型数据库和Excel表格类似，表与表之间存在着复杂的关联关系，例如MySQL，sql server
而非关系型数据库不使用SQL作为查询，不需要遵循ACID（Atomicity Consistency Insolation Durability）
基于json有个好处就是不需要额外对数据进行转换（例如sql，在调用其数据时需要进行数据的转换）
MongoDB使用了WiredTiger存储引擎（3.2+版本开始为默认引擎），利用可用内存来缓存数据，来提供优秀的读取性能，该引擎使用WiredTiger内部缓存和文件系统缓存这俩种缓存
WiredTiger提供了内存快照，而且每隔60秒（创建检查点）就将内存快照写入磁盘（数据持久化，而且持久化的数据还可以作为校验，确保数据在最后一个检查点是一致的，而且旧检查点可以作为有效检查点恢复因为写入新检查点时的错误而且重启导致丢失的数据）
对于60秒内的数据丢失，WiredTiger采用了Journal机制（WAL预写日志）来提供断电保护，Journal每隔100ms刷新日志，数据被存储在Journal文件（发生断电情况，可通过Journal文件根据记录追加数据），Journal机制会保留检查点之间保留所有数据修改
而且不用担心100ms以内的数据丢失，因为MongoDB提供了其特有的写入安全机制（Write Concern），默认使用Acknowledged安全策略，该策略在每次写入操作时确认状态，这个状态取决于内存的写入（不保证数据不丢失）
Journaled策略要求每一次写入操作必须在journal落盘后（确保数据不丢失，吞吐和响应会有影响），该策略会确认落盘后等待30ms，将30ms内的全部写入操作统一按照顺序写入盘中
majority副本集策略要求只有当数据被复制到绝大多数节点（包括主节点）后才应答（适合集群）
Write Concern用法
例如：
db.test.insert({&amp;ldquo;name&amp;rdquo;:&amp;ldquo;hallo&amp;rdquo;},{writeConcern:{w:1}})
w有这几个常用值，分别为0（非应答式写入），1（应答式写入），&amp;gt;1（设置副本写入节点数量），majority(表示majority副本集策略)
而且还提供了wtimeout参数来限制节点写入时间（超过该时间，报错，只适用集群环境，单位ms）
j参数是用来开启写入操作必须在写入journal日志后响应（Journaled策略，参数值为布尔值）
MongoDB有三种集群部署架构，主从，副本集，分片
一个副本集架构由一个主节点和多个副本节点组成，个主节点和多个副本节点的数据同步基于oplog，当主节点发生故障，副本节点会自动选择一个新的主节点来继续工作
在分片架构上，数据均衡分布在每一个节点上（负载均衡），可通过增加或者减少分片来实现按需扩展，
简单使用MongoDB数据库
mongod.conf文件是MongoDB数据库配置文件
启动数据库（没有该数据库则创建数据库）
mongod &amp;ndash;dbpath D:\mongodb
默认端口为27017
启动服务
net start mongodb
连接数据库
mongo &amp;ndash;port 27017
切换数据库（没有该数据库就会创建）
use demo
查看全部数据库
show dbs
注意：默认数据库为test，没有创建新数据库，那么就存储在test数据库中
删除数据库（当前数据库）
db.dropDatabase()
创建集合（类似于MySQL中的表）
db.createCollection(&amp;ldquo;hallo&amp;rdquo;)
插入数据（插入到test集合中，当该集合不存在时，将自动创建该集合）
db.test.insert({&amp;ldquo;name&amp;rdquo;:&amp;ldquo;hallo&amp;rdquo;})
查看当前已有集合
show collections
或者
show tables
db.createCollection(&amp;ldquo;test&amp;rdquo;, { capped : true, autoIndexId : true, size : 102400, max : 10000 } )</description>
    </item>
    <item>
      <title>NextJS学习笔记</title>
      <link>https://99999.fun/posts/74/</link>
      <pubDate>Sat, 07 Aug 2021 23:26:00 +0000</pubDate>
      <guid>https://99999.fun/posts/74/</guid>
      <description>NextJS是一个用于生产环境的react框架，可以提供服务器端渲染等等功能
服务端渲染（ssr）：后端调用数据库获取数据后，将数据和页面元素进行组合成完整的DOM结构，再返回给浏览器，提供给用户浏览
SPA：
全称single page web application
单一页面，加载慢，百度目前不支持spa的SEO
NextJS：
服务端渲染，服务端和客户端数据同步，插件丰富，搭建轻量，灵活配置
手动配置：
yarn add react react-dom next
yarn init
修改package.json文件
在scripts下加添加
&amp;ldquo;dev&amp;rdquo; : &amp;ldquo;next&amp;rdquo;, &amp;ldquo;build&amp;rdquo;: &amp;ldquo;next build&amp;rdquo;, &amp;ldquo;start&amp;rdquo;: &amp;ldquo;next start&amp;rdquo;
创建个js文件
function Hallo(){return(&amp;lt;div&amp;gt;hallo next.js&amp;lt;/div&amp;gt;)}export default Halloyarn dev调试
如果浏览器输出正确则配置成功
通过create-next-app脚手架创建项目
npm install create-next-app -g
或者
yarn add create-next-app -g
创建create-next-app项目
npx create-next-app demo
或者
yarn create-next-app demo
跑create-next-app项目
yarn dev
访问http://localhost:3000/，正常显示网页则配置正常
编程式跳转
import Link from &amp;quot;next/link&amp;quot;&amp;lt;Link href=&amp;quot;/&amp;quot;&amp;gt;&amp;lt;a&amp;gt;返回&amp;lt;/a&amp;gt;&amp;lt;/Link&amp;gt;Link不支持直接加兄弟标签，起码要有一个父级标签</description>
    </item>
    <item>
      <title>深入学习vuejs</title>
      <link>https://99999.fun/posts/75/</link>
      <pubDate>Sat, 07 Aug 2021 23:25:00 +0000</pubDate>
      <guid>https://99999.fun/posts/75/</guid>
      <description>Vue CLI是vue官方脚手架，可以快速创建vue项目
安装vue-cli3
npm install -g @vue/cli
或者
yarn global add @vue/cli
升级
npm update -g @vue/cli
或者
yarn global upgrade &amp;ndash;latest @vue/cli
创建vue项目
vue create vue-demo
如果提示vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称，可以使用npx vue create vue-demo
default (babel, eslint) // 默认选项，包含babel和eslint
Manually select features // 自定义创建配置工程
一般比较常用的有Babel，TypeScript，Router，CSS Pre-processors，Linter / Formatter
空格为选择，enter为下一步
跑vue项目
npm run serve
或者
yarn start/yarn run dev
如果运行报错error Component name &amp;ldquo;Home&amp;rdquo; should always be multi-word vue/multi-word-component-names
只需要在vue.config.js添加lintOnSave: false配置，例如：
module.exports = defineConfig({transpileDependencies: true,lintOnSave: false})这个问题的原因在于vue-cli默认开启了ESLint检测，关闭就好了</description>
    </item>
    <item>
      <title>gulp学习笔记</title>
      <link>https://99999.fun/posts/73/</link>
      <pubDate>Fri, 06 Aug 2021 20:52:00 +0000</pubDate>
      <guid>https://99999.fun/posts/73/</guid>
      <description>gulp.js是一个基于流(stream)的自动化构建工具，是开源的JavaScript自动化工具，基于node.js和npm的构建工具，可以处理压缩代码，合并代码，压缩图片，编译less等等任务
全局安装gulp
npm install &amp;ndash;global gulp-cli
或者
yarn add gulp-cli -g
初始化
npm init
作为开发依赖进行安装gulp
npm install &amp;ndash;save-dev gulp
或者
yarn add gulp-cli -d
安装依赖
yarn add &amp;ndash;save-dev gulp-sass gulp-autoprefixer browser-sync gulp-notify
创建gulpfile.js
执行gulp
gulp
修改gulpfile.js
导入gulp（这里用个变量接收）
let gulp = require(&amp;ldquo;gulp&amp;rdquo;);
常用方法
gulp.task() // 定义任务
gulp.src() // 指向需要执行任务的文件
gulp.dest() // 执行完任务的文件最后在哪里
gulp.watch() // 监测文件是否发生变化
gulp.task()其中有两个参数，分别是任务名称和一个回调函数
例如：
let gulp = require(&amp;quot;gulp&amp;quot;);gulp.task(&amp;quot;test&amp;quot;, function() {return console.log(&amp;quot;hallo gulp&amp;quot;);});执行test任务（在终端，应用根目录下）
gulp test</description>
    </item>
    <item>
      <title>深入学习React</title>
      <link>https://99999.fun/posts/63/</link>
      <pubDate>Sun, 25 Jul 2021 12:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/63/</guid>
      <description>setState()
注意：如果调用多次setState()，但是还是只触发一次重新渲染（性能优化，如果每更新一次状态就渲染一次的话，很影响性能）
setState()是异步更新数据的，因此setState()不要依赖于前面的setState()，因为其不会立刻更新数据
如果当前setState()依赖于前面的setState()，解决方法：
this.setState((state, props) =&amp;gt;{return{count: state.count + 1}})console.log(this.state.count)this.setState((state, props) =&amp;gt;{return{count: state.count + 1}})console.log(this.state.count)state和props参数分别获取到最新的state和最新的props，通过回调函数返回值，保证每次都获取到最新的state和props
如果想在状态更新后（页面完成重新渲染）立刻执行某个操作，那么可以使用setState()的第二个参数，这个参数是一个回调函数
例如：
this.setState((state, props) =&amp;gt;{return{count: state.count + 1}},() =&amp;gt; {console.log(this.state.count)})可以看出 console.log(this.state.count)会在状态更新后被执行，因此可以获取到更新后的count值
因此setState()一定会改变状态，但是不会立刻更新，而是当页面渲染完毕了（状态更新完毕之后）才会更新
jsx语法的转化
jsx实质上还是createElement()方法的语法糖（简化），因为jsx语法最后还是会编译（@babel/preset-react插件）成createElement()方法
而createElement()方法也会被转换为js对象（ReactElement），用来描述页面上显示的内容，因此不管是jsx还是createElement()最后都会转换为js对象（ReactElement），ReactElement然后通过虚拟DOM实现DOM创建和更新
例如：
const Abc = (&amp;lt;div&amp;gt;hallo&amp;lt;/div&amp;gt;)console.log(Abc)可以看到输出返回的是一个js对象
React.createElement()接收3个参数，type（表示标签或者组件），config（对象，表示组件的所有属性），children（对象，表示组件之间的嵌套关系）
组件更新机制
setState()的作用：修改state，更新组件
父组件重新更新state，子组件也会更新，不过只会影响到当前组件和其他子组件（后代组件）（组件树），对于该组件的兄弟组件和根组件（父组件）是不会影响
初次渲染，当页面刷新时就会初次渲染，先渲染根组件，再按顺序渲染更新父组件和后代组件
更新根组件，那么其下全部的组件树都会更新
组件性能优化
state只存储和组件渲染相关的数据，例如列表数据，而不用来渲染的数据不放在state中
如果需要在多个方法中使用（共享）的数据，应该放在this中
因为组件更新机制的原因，子组件没有变化也会重新渲染
解决方法：
使用钩子函数 shouldComponentUpdate(nextProps, nextState)，该钩子函数是更新阶段的，组件重新渲染前执行</description>
    </item>
    <item>
      <title>TypeScript学习笔记</title>
      <link>https://99999.fun/posts/58/</link>
      <pubDate>Sun, 18 Jul 2021 15:50:00 +0000</pubDate>
      <guid>https://99999.fun/posts/58/</guid>
      <description>TypeScript设计目标是开发大型项目，编译成纯JavaScript，让其可以运行在任何浏览器上
TypeScript可以增强IDE的交互和反馈，主流IDE都支持TypeScript
TypeScript实质上就是JavaScript的扩展，JavaScript超集
TypeScript具备类型检查，静态类型，JSnext属性和方法，以及还在提案阶段的语法（例如装饰器）
TypeScript本身并不能在浏览器运行，需要进行编译成JavaScript（tsc编译）
全局安装typescript
yarn global add typescript
或者
npm install -g typescript
安装ts-node（node不能直接运行ts文件，需要安装ts-node包）
npm install -g ts-node
ts-node运行（不需要编译成js文件，直接运行ts）
ts-node hallo.ts
检查是否安装成功
tsc -v
使用TypeScript编写的文件统一以.ts为后缀，用ts写React，统一以.tsx为后缀
创建tsconfig.json
npx tsc &amp;ndash;init
执行（不加任何参数，这样才能使用tsconfig.json配置文件，tsc默认对当前根目录的ts文件进行编译）
tsc
或者指定编译的文件
tsc ./src/index.ts
tsc ./src/index.ts -t es6 -m cjs
注意：cjs标准只能存在一个顶级导出（mudule.exports）,如果存在其他exports的话会被忽略，因此要么不用mudule.exports，要么只使用一个mudule.exports
编译指定ts文件（在compilerOptions同级）
&amp;ldquo;include&amp;rdquo;:[&amp;quot;./test1.ts&amp;quot;] // 指定编译哪个ts文件 &amp;ldquo;excclude&amp;rdquo;:[&amp;quot;./test.ts&amp;quot;] // 指定不编译哪个ts文件
编译TypeScript文件
tsc hallo.ts
变量声明
推荐使用const和let声明变量，而不要使用var声明（因为var具有变量提升和重定义）
基础类型
TypeScript具有强类型的特点
boolean，string，number，array，null，undefined，object，tuple，enum，void，never，any
boolean布尔值，例如：
let hallo: boolean = true
number数值，例如：
let hallo: number = 123;</description>
    </item>
    <item>
      <title>ES6学习笔记</title>
      <link>https://99999.fun/posts/57/</link>
      <pubDate>Fri, 09 Jul 2021 22:51:00 +0000</pubDate>
      <guid>https://99999.fun/posts/57/</guid>
      <description>ECMAScript
JavaScript的创造者Netscape将其提交给标准化组织ECMA，因此JavaScript的标准是ECMAScript
ECMAScript是规范，JavaScript是实现
ES6又叫ECMAScript2015，因为标准委员会决定每年的6月份正式发布标准，作为当年的正式标准，使用年份来标记，不需要之前的版本号了
变量
let关键字声明变量，使用let声明的变量具有块级作用域有效的特性
例如：
if(true){let a = 666;}console.log(a); // Uncaught ReferenceError: a is not defined注意：
使用var声明的变量不具备块级作用域有效的特性
使用let声明的变量不存在变量提升，只能先声明后使用，具有暂时性死区特性，绑定在块级作用域，不会受外部污染或者影响，let不允许在同一个作用域中，重复声明同一个变量
const声明一个只读的常量，一声明，常量的值将不能改变
const abc =123;
const一旦声明将立刻初始化，只声明不赋值是会报错的，同样不存在变量提升，存在暂时性死区
ES6的作用域：
全局作用域 函数作用域 块级作用域
因为部分低版本浏览器还不支持ES6，因此有一些工具可以ES6语法转ES5的语法，例如：babel
安装babel
npm install -g babel-cli
安装转换包
npm install &amp;ndash;save-dev babel-preset-es2015 babel-cli
新建.babelrc文件，写入：
{&amp;quot;presets&amp;quot;:[&amp;quot;es2015&amp;quot;],&amp;quot;plugins&amp;quot;:[]}babel main.js -o src/main.js
然后就成功将ES6语法转为ES5的语法，提高浏览器兼容性
变量声明方式
let，声明一个变量
const，声明一个常量
在ES6中，var是声明全局变量的，而let声明的变量是具有块级作用域的，只能在当前语句块中访问调用
let实质上就是为了避免污染全局的设计的，希望在某个语句结束后销毁该变量，而不会影响语句外部的变量
const实质就是为了保证该变量始终不变而设计的，使用const声明的变量，不能进行修改，否则会抛出错误
变量解构
ES6允许从数组或者对象中获取值，来对变量进行赋值，这个又被称为解构，例如：
let [a,b,c] = [1,2,3]
会根据位置的关系来进行变量的赋值，格式一定要相同，否则可能获取undefined</description>
    </item>
    <item>
      <title>React学习笔记</title>
      <link>https://99999.fun/posts/55/</link>
      <pubDate>Fri, 09 Jul 2021 22:23:00 +0000</pubDate>
      <guid>https://99999.fun/posts/55/</guid>
      <description>React是构造用户界面的JavaScript库，就是负责视图层的，只负责视图的渲染，其特点是声明式，组件化
安装react
npm i react react-dom
必需：react和react-dom
react包是提供创建元素，组件等功能，是核心（废话）
react-dom包提供DOM相关的功能
通常还需要导入babel来解析jsx（注意：在浏览器使用babel编译jsx效率很低，babel内嵌了对于jsx的支持），babel可以将es6语法转化为es5，方便运行在不支持es6的浏览器上
也可以通过引入src文件的方式引入cdn文件或者本地文件
第一个例子
&amp;lt;script type=&amp;quot;text/babel&amp;quot;&amp;gt;ReactDOM.render(&amp;lt;h1&amp;gt;hallo,react!!!&amp;lt;/h1&amp;gt;,document.getElementById(&amp;quot;app&amp;quot;));&amp;lt;/script&amp;gt;使用babel解析jsx，react官方推荐使用jsx，因为使用jsx渲染dom简单明了
jsx是一种JavaScript语法扩展，例如：
const hallo = &amp;lt;h1&amp;gt;hallo&amp;lt;/h1&amp;gt;;像上面这种就是jsx，jsx本身是一个表达式，经过编译（例如babel）后jsx表达式会转换成JavaScript对象（注意：jsx不是标准的ECMAScript语法，是语法的扩展，不进行编译处理，直接使用是会报错的）
在jsx中插入JavaScript表达式，用大括号包含起来，例如：
function hallo(yes){return yes.name;}const yes = {name: &amp;quot;react&amp;quot;};const hallo = &amp;lt;h1&amp;gt;hallo,{hallo(yes)}&amp;lt;/h1&amp;gt;;ReactDOM.render(hallo,document.getElementById(&amp;quot;app&amp;quot;));当然react并没有强制要求必须使用jsx，例如：
const hallo = React.createElement(&amp;quot;h1&amp;quot;,{class: &amp;quot;main&amp;quot;},React.createElement(&amp;quot;p&amp;quot;,null,&amp;quot;hallo word!!!&amp;quot;))/* 上面提供了三个参数，分别是元素名称，元素属性，元素的子节点 */ReactDOM.render(hallo,document.getElementById(&amp;quot;app&amp;quot;))/* 上面提供了个两个参数，分别是要渲染的react元素，挂载点*/react脚手架
初始化项目
npx create-react-app app
启动项目（在项目根目录执行）
npm start或者yarn start
模块化导入react</description>
    </item>
    <item>
      <title>Ajax学习笔记</title>
      <link>https://99999.fun/posts/54/</link>
      <pubDate>Sat, 03 Jul 2021 15:30:00 +0000</pubDate>
      <guid>https://99999.fun/posts/54/</guid>
      <description>ajax是浏览器提供的一套方法，可以实现页面无刷新更新数据
关于XMLHttpRequest对象（构造函数）的用法：https://xiaochenabc123.test.com/archives/14.html
ajax需要网站环境下生效，需要web服务器，nodemon
app.js
// 导入expressconst express = require(&amp;quot;express&amp;quot;);// 导入pathconst patg = require(&amp;quot;path&amp;quot;);// 创建web服务器const app = express();// 静态资源访问服务app.use(express.static(path.join(__dirname,&amp;quot;public&amp;quot;)));app.get(&amp;quot;/hallo&amp;quot;,(req, res) = &amp;gt;{res.send(&amp;quot;hallo&amp;quot;);});// 监听端口app.listen(3000);console.log(&amp;quot;服务器启动成功&amp;quot;)nodemon app.js
ajax运行原理
ajax代理浏览器发送请求和接收响应，达到局部更新页面数据的效果
创建ajax对象
var hallo = new XMLHttpRequest();
请求方式和请求地址
hallo.open(&amp;ldquo;GET&amp;rdquo;,&amp;ldquo;https://httpbin.org/get&amp;quot;)
发送请求
hallo.send();
获取服务端给予客户端的响应数据，因为请求和获取数据的速度取决于网络速度，应该设置onload事件，当加载完毕了再获取数据
hallo.onload = function(){console.log(hallo.responseText)}服务端大部分情况下用json对象作为响应数据的格式，通过拼接json数据和html，将拼接的结果显示在页面中
在http请求与响应的过程中，请求参数或者响应内容，如果是对象类型，最后都会转换为对象字符串进行传输，例如：
app.get(&amp;quot;/hallo&amp;quot;,(req, res) = &amp;gt;{res.send({&amp;quot;name&amp;quot; : &amp;quot;root&amp;quot;});});json字符串转换为json对象
var responseText = JSON.parse(hallo.responseText);console.</description>
    </item>
    <item>
      <title>深入学习vue组件</title>
      <link>https://99999.fun/posts/53/</link>
      <pubDate>Sat, 03 Jul 2021 11:16:00 +0000</pubDate>
      <guid>https://99999.fun/posts/53/</guid>
      <description>组件注册
.component()接收2个参数，其中第一个参数是组件名（数据类型是字符串）
组件名命名：
全部小写，多个单词用连字符连接（-减号）
因为html中是大小写不敏感的，浏览器会将大写解析为小写，因此不要使用驼峰命名法来命名自定义标签，而是使用连字符分隔
组件被引用时，也必须是相同的名，例如：组件名是img-data，那么被引用时标签为，闭不闭合看组件的定义，如果组件的定义是img之类的，就不需要闭合
直接暴露在vue实例的组件都是全局组件，可以直接在组件实例中调用
局部组件是使用一个JavaScript对象进行定义封装，例如：
&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;datas-a&amp;gt;&amp;lt;/datas-a&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt;const datas ={template: `&amp;lt;div&amp;gt;hallo&amp;lt;/div&amp;gt;`}const hallo = Vue.createApp({components: {&amp;quot;datas-a&amp;quot; : datas}}).mount(&#39;#app&#39;)&amp;lt;/script&amp;gt;components对象，键为自定义元素的名称，值为组件的实质对象
局部组件的属性是不能直接被调用的，但是可以在另一个组件中指向其为自己的子组件，例如：
const datab ={components: {&amp;quot;datas-a&amp;quot; : dataa}}模块系统
通过导入模块的方式导入组件，例如：
import datas from &amp;lsquo;./datas&amp;rsquo;
那么datas组件就是可以在当前使用了
Props
prop类型
用对象的方式列出prop，并且定义其类型，当传入的prop类型不对就会报错（开发版本），例如：
const hallo = Vue.createApp({component: {props:{abc: String,xyz: Boolean,},template: `&amp;lt;h1&amp;gt;{{abc.</description>
    </item>
    <item>
      <title>正则表达式学习笔记</title>
      <link>https://99999.fun/posts/52/</link>
      <pubDate>Fri, 02 Jul 2021 18:12:00 +0000</pubDate>
      <guid>https://99999.fun/posts/52/</guid>
      <description>正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式，在JavaScript中，正则表达式也是对象
JavaScript创建正则表达式
使用RegExp对象创建
var hallo = new RegExp(/123/);
或者
var hallo = /123/;
检查是否符合该正则表达式
使用test方法判断字符串是否符合该规则的要求，返回的值是布尔值
console.log(hallo.test(123));
/123/只要包含123就返回true
正则表达式元字符
边界符（^和$）
^表示匹配行首的文本（以谁开始）
$表示行尾的文本（以谁结束）
var hallo = ^abc;
必须要abc开头，如果是aabc的话，返回false
var hallo = abc$;
必须要abc结尾，例如aabc，返回true
var hallo = ^abc$;
^和$一起使用就是精确匹配，必须是abc，如果是abcabc的话，返回false
字符类[]
var hallo = /[abc]/;
只要包含a，b，c其中一个字符都匹配，返回true，例如axx
var hallo = /^[abc]$/;
三选一，只有包含a，b，c其中单独的一个才匹配返回true，例如abc，就返回false
范围符-
var hallo = /^[a-z]$/;
多选一，a到z，包含26个字母任何一个字母都返回true，大小写敏感，A和a不一样
var hallo = /^[a-zA-Z0-9_-]$/;
多选一，包含26个字母（包含大小写）任何一个字母和数字（0到9）和下划线其中一个都返回true
取反
var hallo = /^[^a-z]$/;
在方括号内部加^，就是代表取反，不能包含a到z其中的一个字母
量词符（*，+，?）
var hallo = /a*/;</description>
    </item>
    <item>
      <title>微信小程序学习笔记</title>
      <link>https://99999.fun/posts/48/</link>
      <pubDate>Sun, 27 Jun 2021 12:34:00 +0000</pubDate>
      <guid>https://99999.fun/posts/48/</guid>
      <description>小程序实质上就是一个基于web基础的应用程序（网页）（但是不支持浏览器的api，小程序的api全部由微信提供，高度依赖微信，因此只能在微信中运行）
微信之父张小龙是这样描述小程序的：
小程序是一种不需要下载安装就可以使用的应用，它实现了应用触手可及的梦想。
用户扫一扫或者搜一下即可打开应用，也体现了用完即走的理念。
用户不用关心是否安装太多应用的问题，应用将无处不在，随时可用，但又无需安装卸载
微信小程序的接口服务器要求进行ICP备案，并且经过审核，才能发布小程序
微信小程序开发文档
https://developers.weixin.qq.com/miniprogram/dev/framework/
开发工具：微信开发者工具
小程序的宿主环境
在iOS中，使用JavaScriptCore，在Android中使用X5内核，在ide中使用nwjs
小程序的运行机制（冷启动，热启动）
小程序在后台中停留一段时间后，被微信销毁，再打开时需要重新加载该小程序的资源，也就是冷启动，而在没被销毁的时间段内，再打开该小程序，是不需要重新加载资源，是热启动
小程序发布更新时，会异步加载新资源，也会导致冷启动
小程序产品需求
发现真实需要
用户深度访谈，分析竞品，付费意愿
需求分期：最小化可行产品（MVP）
不是每个功能都要开发（优先开发最重要和最紧急的功能）
优化开发顺序，先开发基础可用，然后迭代更新功能，满足用户需求，功能文档
根据用户体验来优化服务
原型制作工具：墨刀，Axure
微信小程序结构
index.wxml页面结构
index.wxss页面样式
index.js页面逻辑
如果设置了单独的页面样式，那么会覆盖掉app.wxss的样式
app.json定义了页面和基本配置，采用json格式，必须包含pages属性，说明小程序有哪些页面
app.json文件结构
pages是用来定义页面的，是一个数组，每一个项都是代表一个页面，例如：
&amp;quot;pages&amp;quot;:[&amp;quot;pages/index/index&amp;quot;,&amp;quot;pages/demo/demo&amp;quot;],window属性是设置小程序的窗口样式，例如：
&amp;quot;window&amp;quot;:{&amp;quot;backgroundTextStyle&amp;quot;:&amp;quot;light&amp;quot;,&amp;quot;navigationBarBackgroundColor&amp;quot;: &amp;quot;#fff&amp;quot;, // 导航栏背景颜色&amp;quot;navigationBarTitleText&amp;quot;: &amp;quot;Weixin&amp;quot;, // 导航栏文本&amp;quot;navigationBarTextStyle&amp;quot;:&amp;quot;black&amp;quot; // 导航栏文本颜色},从上面可以看出是一个三层结构，页面是放在pages目录下的，而demo和index都是代表这个页面叫什么
demo.js，Page()是小程序提供的一个函数，用来初始化页面，参数是一个对象，用来配置当前页面的属性
demo.wxml，该文件是用来描述页面的，和html类似
pages文件夹：存放小程序页面，每个页面代表为一个文件夹，文件夹名称为页面名称，在这个页面文件夹下的全部文件都是描述这个页面的
utils文件夹：用于存放公共的js程序，便于不同的页面进行调用
imgages文件夹：为方便管理小程序的用到的全部静态图片
app.js：当前项目的js（全局数据和反应）
json：全局配置
wxss：全局样式
project.config.json：项目配置文件，配置微信开发者工具，例如工具的页面颜色，编译配置等等个性化配置
page.json: 单独定义每个页面的一些属性，例如：顶部颜色，是否可以下拉刷新等等
app.json：这是一种数据格式，小程序的静态配置（全局配置），页面的路径，界面的表现，顶部样式，网络超时等等
pages字段：描述当前小程序所有页面的路径，让微信清楚小程序页面定义在哪个目录
window字段：定义小程序所有页面的顶部背景颜色，文字颜色等等
json是包裹在一个括号中，以键值对的方式表达数据，值必须包含在双引号中，在json中无法使用注释
wxml
WXML：从html中衍生而来一种专门在小程序页面中使用的语言，组合了基础组件，事件系统，构造出页面的结构
view元素是表示块级，和div类似
scroll-view元素是表示可滚动页面区域
text元素是表示行内文本，和span类似</description>
    </item>
    <item>
      <title>webpack学习笔记</title>
      <link>https://99999.fun/posts/47/</link>
      <pubDate>Thu, 24 Jun 2021 10:11:00 +0000</pubDate>
      <guid>https://99999.fun/posts/47/</guid>
      <description>webpack作为模块加载和打包神器
安装node就有npm了，用npm安装webpack
npm i webpack webpack-cli -g 安装全局的webpack
到项目目录下，npm init -y 初始化模块
npm i webpack webpack-cli -D 安装项目局部的webpack，-D是&amp;ndash;save-dev的意思，推荐使用
webpack 入口文件名 最后输出到哪个文件的文件名，例如：
npx webpack A.js B.js
那么就会编译A.js，输出到B.js
webpack只能处理JavaScript，处理其他类型的文件，需要安装几个包
npm install css-loader style-loader
假设有个一个abc.css文件，里面定好了样式
那么修改A.js
require(&amp;quot;!style-loader!css-loader!./abc.css&amp;quot;); document.write(require(&amp;quot;./C.js&amp;quot;));
再打包一次
npx webpack A.js B.js
会出现一个C.js
配置webpack.config.js
module.exports = {entry: &#39;入口文件的路径&#39;,output: {path:__dirname,filename: &#39;最后输出到哪个文件的文件名&#39;},module: {rules: [{test: &#39;处理什么格式的文件&#39;,use:[{loader: &#39;依赖包&#39;}]}]}};模块化</description>
    </item>
    <item>
      <title>Git版本管理系统学习笔记</title>
      <link>https://99999.fun/posts/30/</link>
      <pubDate>Wed, 16 Jun 2021 14:51:00 +0000</pubDate>
      <guid>https://99999.fun/posts/30/</guid>
      <description>git安装
Windows和mac
到git官网下载对应的安装文件，进行安装，下一步
Linux
sudo apt install git-all 或者 sudo dnf install git-all
也可以用源代码编译（Git是开源的，是Linux之父的作品） https://github.com/git/git/releases
方便git管理，记录每一个修改了Git仓库的人，设置用户名和邮箱
git config &amp;ndash;global user.name &amp;ldquo;chenjunlin&amp;rdquo; git config &amp;ndash;global user.email &amp;ldquo;a@xiaochenabc123.test.com&amp;rdquo;
ssh-keygen -t rsa -C &amp;ldquo;a@xiaochenabc123.test.com&amp;rdquo; # 生成ssh密钥
mkdir learngit #创建一个空目录
cd learngit # cd到目录
pwd #显示当前目录路径
git init #将当前的目录变成git管理仓库
ls -ah #将所有目录（包括隐藏目录）显示出来
git add 文件名 #将文件添加到仓库中
git commit -m 说明 #告诉git这次添加到仓库的说明，可以是任意内容
git status #返回仓库的当前状态
git diff 文件名 #查看当前文件的内容
git log #查看历史记录，加上&amp;ndash;pretty=oneline 查看commit id（版本号）
git reset &amp;ndash;hard HEAD^ #回退上一个版本，上上一个版本就是HEAD^^，以此类推，或者使用HEAD~ 就是要回退多少个版本</description>
    </item>
    <item>
      <title>python基础语法笔记</title>
      <link>https://99999.fun/posts/28/</link>
      <pubDate>Wed, 16 Jun 2021 14:40:00 +0000</pubDate>
      <guid>https://99999.fun/posts/28/</guid>
      <description>安装python
推荐安装anaconda3（linux）
wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.05-Linux-x86_64.sh
dash Anaconda3-2019.10-Linux-x86_64.sh
根据提示安装，如果还是系统自带的python
sudo gedit ~/.bashrc
export PATH=&amp;quot;/home/pc/anaconda3/bin:$PATH&amp;quot;
pc为系统的用户名，请修改成自己的系统用户名，请勿在root用户下安装anaconda3
注意：如果使用anaconda3，请设置Path环境变量，/Anaconda3，/Anaconda3/Scripts，/Anaconda3brary/bin，这3个路径都需要设置
Windows和mac 到官网下载安装包，直接下一步安装
mac安装了Homebrew，可以使用brew install python3
Windows设置环境变量，PATH 安装路径
现在liunx一般都会自带有python3,如果没有可以安装一下
apt install python3
yun install python3
注意一下python2.x和python3.x这两个版本是不兼容的，要区分开
检查是否安装成功，在命令行或者终端输入python3 回车 没有反应或者报错就说明没有安装成功或者可能出问题了 Windows的一定要注意PATH系统变量
因为Python语言从规范到解释器都是开源的，所以存在多个解释器
例如CPython，安装python3.x时就可以直接获取到一个官方版本的解释器：CPython，因为是使用C语言开发的，所以叫CPython
在命令行或者终端，输入输入python3 回车，如果出现了&amp;raquo;&amp;gt; 那么当前状态是python的交互模式
在交互模式下输入exit()，退出python的交互模式
在交互模式下执行第一个程序 print(&amp;ldquo;hello,world&amp;rdquo;)
回车输出hello，world，这是简单的打印字符串
除了使用交互模式执行程序，又可以使用.py，在命令行或者终端下 python hello.py，如果报错，请检查程序是否出错或者该文件是否在当前目录下
交互模式可以直接输出结果，但是使用.py文件却不会，想要输出结果，必须使用print()打印出来
一个好的开发工具往往可以达到事半功倍的效果，例如pycharm和Visual Studio Code，我使用的是Visual Studio Code
print()接受多个输出，使用“,”分隔开，也可以输出整数
当你想让用户输入一点东西的时候，python提供了一个input()，用法如下 name = input() 将输入的值存放到一个变量里
input()还提供了提示功能，显示一个字符串，例如：input(&amp;ldquo;xxxxx&amp;rdquo;)
我想知道这个变量的内容咋办，可以在交互模式下直接输入变量名，回车，就可以查看该变量的内容 又可以使用print()打印下来
那么什么是变量呢？
在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串
输入是Input，输出是Output，输入输出统称为Input/Output，或者简写为IO
以#开头的语句是注释，注释是给人看的，解释器会忽略掉注释，注释可以是任何内容
其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块
注意：python区分大小写，搞错了大小写，程序可能会报错。缩进建议使用4个空格
python能直接处理的有：整型，浮点型，字符串，布尔值，空值，变量，常量
python可以处理整型任意大小的整数，也可以使用二进制代表整数、
浮点型就是小数，使用科学记数法表示时，一个浮点数的小数点位置是可变的，所以小数又叫浮点型，表示很大或很小的浮点数，必须用科学计数法表示
字符串是使用&amp;quot;&amp;ldquo;和&amp;rsquo;&amp;lsquo;括起来的任意文本，&amp;lsquo;&amp;lsquo;或&amp;quot;&amp;ldquo;本身只是一种表示方式，不是字符串的一部分</description>
    </item>
    <item>
      <title>vuejs基础学习笔记</title>
      <link>https://99999.fun/posts/23/</link>
      <pubDate>Wed, 16 Jun 2021 10:13:00 +0000</pubDate>
      <guid>https://99999.fun/posts/23/</guid>
      <description>vuejs的核心层就是只关心视图层的，本笔记使用的是最新版本的vue3
vue全家桶：Vue+VueRouter+Vuex
vue名字来源于法语（中文翻译为视图），可以看出其对视图层的重视
导入一般都是使用cdn导入或者直接下载vuejs进行托管，也可以使用npm安装或者使用官方的CLI来构建一个应用
https://unpkg.com/vue@next
cjs版本：完整版，包含编译器
prod.js都是开发版，代码进行了压缩
global版本：可以直接通过scripts标签导入，会建立一个全局Vue对象
browser版本：包含esm,浏览器模块
bundler版本：该版本不是完整版，min
vuejs模板支持所有JavaScript表达式
vuejs本身是用声明式渲染把数据渲染到html dom中，渲染格式为{{&amp;hellip;}}，例如：
&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;p&amp;gt;{{ hallovuejs }}&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt;const hallo ={data() {return {hallovuejs: &amp;quot;hallo vuejs!&amp;quot;}}}Vue.createApp(hallo).mount(&amp;quot;#app&amp;quot;)&amp;lt;/script&amp;gt;vue本身携带了一些指令，主要特征就是带有v-前缀，用来渲染html dom上的一些行为，例如：
&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;a v-bind:href=&amp;quot;url&amp;quot;&amp;gt;{{ main }}&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt;const hallo ={data() {return {url:&amp;quot;https://xiaochenabc123.test.com&amp;quot;,main: &amp;quot;小陈的辣鸡屋&amp;quot;}}}Vue.createApp(hallo).mount(&amp;quot;#app&amp;quot;)&amp;lt;/script&amp;gt;这个v-bind:href，就是将a标签的href属性绑定，v-bind可以绑定任何属性，例如class属性等等，因此可以在视图层留下一些接口指令，让vuejs来响应式渲染出视图
而vue还提供了可以绑定事件的v-on属性，例如：
&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;button v-on:click=&amp;quot;go&amp;quot;&amp;gt;{{ main }}&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt;const hallo ={data() {return {main: &amp;quot;hallo&amp;quot;}},methods: {go: function(){console.</description>
    </item>
    <item>
      <title>HTML全局属性笔记</title>
      <link>https://99999.fun/posts/22/</link>
      <pubDate>Wed, 16 Jun 2021 09:38:00 +0000</pubDate>
      <guid>https://99999.fun/posts/22/</guid>
      <description>属性
accesskey
定义快捷键获取焦点，例如
&amp;lt;a href=&amp;quot;https://xiaochenabc123.test.com&amp;quot; accesskey=&amp;quot;q&amp;quot;&amp;gt;GO\&amp;lt;/a&amp;gt;按ait+q，就会跳到指定的网页上
class
定义元素的类，开头必须是字母，多个类使用空格隔开，例如
&amp;lt;div class = &amp;quot;a1 a2 a3&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;id
定义一个id，id为唯一性，不能重复，例如
&amp;lt;div id = &amp;quot;a1&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;lang
定义网页或者元素的语言，例如
&amp;lt;div lang = &amp;quot;fr&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;style
定义元素的行内样式，例如
&amp;lt;div style=&amp;quot;color : #fff&amp;quot;&amp;gt;hi&amp;lt;/div&amp;gt;tabindex
指定tab键的焦点控制，例如
&amp;lt;a href=&amp;quot;https://xiaochenabc123.test.com&amp;quot; tabindex=&amp;quot;1&amp;quot;&amp;gt;GO&amp;lt;/a&amp;gt;使用键盘的tab键盘，触发（不会跳转到网页，只是焦点）
contenteditable
指定元素是否为可以编辑的，例如
&amp;lt;div contenteditable=&amp;quot;true&amp;quot;&amp;gt;hi&amp;lt;/div&amp;gt;dir
指定元素内文本的方向，例如
&amp;lt;div dir = &amp;quot;rtl&amp;quot;&amp;gt;hi&amp;lt;/div&amp;gt;ltr默认值，从左到右
rtl，从右到左
title
指定元素的信息，一般为鼠标移动到元素是停留一段时间，显示信息，例如
&amp;lt;div title = &amp;quot;hi&amp;quot;&amp;gt;hi&amp;lt;/div&amp;gt;data-xxx
用于存储一些自定义属性，data-后面必须有一个字符，不包括大写
JavaScript可以通过getAttribute获取到
draggable
指定元素是否可以拖动，默认情况下，只有图片和链接可以拖动
有3个可选值，true/false/auto，在JavaScript中可以配合拖动事件，例如
&amp;lt;div draggable = &amp;quot;true&amp;quot;&amp;gt;hi&amp;lt;/div&amp;gt;hidden
指定元素是否隐藏，有两个可选值，hidden/true，例如
&amp;lt;div hidden = &amp;quot;hidden&amp;quot;&amp;gt;hi&amp;lt;/div&amp;gt;contextmenu</description>
    </item>
    <item>
      <title>jQuery基础学习笔记</title>
      <link>https://99999.fun/posts/21/</link>
      <pubDate>Wed, 16 Jun 2021 09:38:00 +0000</pubDate>
      <guid>https://99999.fun/posts/21/</guid>
      <description>##第一个jQuery程序
$(&amp;lsquo;div&amp;rsquo;).html(&amp;ldquo;hello.world&amp;rdquo;);
##DOM对象和jQuery对象互转化
jQuery对象和DOM对象是不一样的，但是都能操作DOM
get()方法（jquery对象转化为DOM对象）
var $main =$(&amp;rsquo;.main&amp;rsquo;); // jquer对象
var main = $main.get(0); // 通过get方法，转化成DOM对象
main.style.color = &amp;lsquo;#c7edcc&amp;rsquo;; // 操作DOM对象属性
DOM对象转化为jQuery对象
var main = document.getElementsByClassName(&amp;lsquo;main&amp;rsquo;); // DOM对象
var $main = $(main); // jQuery对象
$main.css(&amp;lsquo;color&amp;rsquo;,&amp;rsquo;#c7edcc&amp;rsquo;); // 操作jQuery对象属性
##jQuery选择器
元素选择器
$(&amp;lsquo;div&amp;rsquo;)
ID选择器
$(&amp;quot;#main&amp;quot;)
id是唯一性，只能在页面中使用一次
类选择器
$(&amp;rsquo;.main&amp;rsquo;)
全选择器
$(&amp;rsquo;*&amp;rsquo;)
层次选择器
$(&amp;lsquo;div .main&amp;rsquo;)
属性选择器
$(&amp;ldquo;a[href=&amp;ldquo;https://xiaochenabc123.test.com&amp;rdquo;]&amp;rdquo;) // 选择带href属性的a元素
可以使用前缀或者后缀来选择 $(&amp;ldquo;div[name^=&amp;ldquo;yes&amp;rdquo;]&amp;rdquo;) // 选择div标签的neme属性值为yes开头的 $(&amp;ldquo;div[name$=&amp;ldquo;yes&amp;rdquo;]&amp;rdquo;) // 选择div标签的neme属性值为yes结尾的
组合选择器
$(&amp;ldquo;div[class=divs]&amp;rdquo;)
组合选择器其实就是用多个选择器组合起来
多项选择器
$(&amp;ldquo;div[class=divs],a[href=&amp;ldquo;https://xiaochenabc123.test.com&amp;rdquo;)
多项选择器就是将多个选择器用逗号组合起来
层级选择器 $(&amp;ldquo;ul.nev li.active&amp;rdquo;)</description>
    </item>
    <item>
      <title>JAVA基础学习笔记</title>
      <link>https://99999.fun/posts/19/</link>
      <pubDate>Wed, 16 Jun 2021 09:35:00 +0000</pubDate>
      <guid>https://99999.fun/posts/19/</guid>
      <description>java基于java虚拟机（Java Virtual Machine，JVM）和java应用编程接口（Application Programming Interface，API）构成
java的跨平台得益于java虚拟机，只需要编译一次java程序，就可以在不同系统的java虚拟机上运行
java编译成字节流，java虚拟机通过解析这些字节流来做的跨平台，编译完成得到的字节流可以在不同平台的java虚拟机上跑
java分为Java SE、Java EE 和 Java ME。
类的命名：必须是英文开头，后可字母，数字和下划线
一般为大写字母开头
例如：
public class Abc
public是访问修饰符，表示该class为公开，如果没有写pulic，也可以正常编译，但是这个class将不能在命令行中执行
在class内部可以定义方法，例如:
public static void main(String[] args){}
这个例子的方法名为main，返回值为void，表示没有返回值，空
static是一个关键字，同样也是修饰符，表示静态方法
java入口程序必须是静态方法，方法名也必须为main，参数必须为String数组
在方法内部，语句才能执行，每一行程序都必须要以分号结束;
// 单行注释
/*
多行注释
*/
/** *
一样是多行注释 * */ java的变量的类型和JavaScript一样，变量分两种，基本类型变量和引用类型变量 java有8种基础类型，分别是整型（4种），字符型（1种），浮点型（2种），布尔型（1种）
变量必须先定义，后赋值使用，例如：
int a = 1;
定义为int整数类型，名称为a，初始值为1
变量的特点就是可以重新赋值
int i = 1; // 定义int类型，名称为i，赋值为1
i = 100; // 重新赋值为100
int x = i; // 变量x的值为i，因为i的值为100，所以x的值为i
整型
整型类型：int，byte，short，long
整型类型的数就是整数，整数默认为int，在数值后加上L就代表为long，例如：long abc = 123L;</description>
    </item>
    <item>
      <title>XML学习笔记</title>
      <link>https://99999.fun/posts/17/</link>
      <pubDate>Wed, 16 Jun 2021 09:32:00 +0000</pubDate>
      <guid>https://99999.fun/posts/17/</guid>
      <description>xml中文全称为可扩展标记语言（Extensible Markup Language）
xml和html类似，但是xml是用来传输和存储数据的，xml大小写敏感，xml的标记是自定义的
xml声明，该声明位在xml文档的第一行，结尾
version属性表示xml的版本，encoding属性表示该xml文档的编码方式，standalone属性表示该文档是否为独立，no表示依赖于外部文档
xml的标记也可以像html一样，认为是元素，一般由开始标签，属性，内容，结束标签组成，例如xml
和就是xml文档中的标签（元素），和html一样，可以嵌套n个子元素，如果一个元素没有被嵌套到其他元素上，那么这个元素就是根元素
一般来说一个格式良好的xml文档只有一个根元素，而且根元素是xml文档的第一个元素，如果一个元素没有嵌套子元素也没有内容，那么这个元素为空元素，空元素不需要结束标签，例如
属性是元素的描述和说明，可以使用多个属性，每个属性都有自己名称和值，值用&amp;quot;&amp;ldquo;或者&amp;rsquo;&amp;lsquo;包起来
xml的注释方式和html一样，
DTD约束
XML是自定义标签，浏览器不知道这个标签是用来干什么的，因此制定的一套约束，遵循一定的语法
DTD约束写在一个DTD文件里，dtd导入，例如：
如果导入了本地的DTD文档，那么standalone属性的值不能为yes
DTD除了导入外，还可以内嵌，例如
元素内容包括元素的声明，包括数据类型和符号
PCDATA 中文意思就是被解析的字符数据，会被解析器解析
子元素 例如
空元素 一般用来定义空元素
ANY 表示这个元素没有包含任何字符数据和子元素，例如，在实际开发中，尽量不要使用ANY，除了根元素外，其他使用ANY的元素会失去DTD对XML的约束
符号
问号?:表示该对象可以出现0次或者1次 星号*:表示该对象可以出现0次或者多次 加号+:表示该对象可以出现1次或者多次 竖线|:表示在列出的对象中选择一个 逗号,:表现对象必须按照指定的顺序出现 括号():用于给元素进行分组
DTD除了给定义元素外，也可以为元素定义属性
属性类型指定该属性是属性哪个类型的，属性说明一般用来说明该属性是否必须出现
属性类型
CDTATA // 表示属性类型为字符数据，如果想在属性设置值中出现特殊符号（例如&amp;lt;），那么需要使用其转义字符序列来表示，例如 &amp;ldquo;&amp;lt;&amp;ldquo;来表示&amp;rdquo;&amp;lt;&amp;rdquo;
Enumerated(枚举类型) // 在声明一个属性时，可以限制该属性的取值只能从一个列表中选择，但是在DTD文档中不会出现Enumerated关键字，用法例如：
ID // 表示该属性类型为唯一标识，一个元素只能有一个id类型的属性，而且属性说明必须为REQUIRED或者IMPLIED
IDREF和IDREFS // 一般用来关联元素与元素之间的关系，而且IDREF类型的属性的值必须为一个已经存在的ID类型的属性值，例如：
1 2
说明ID为01和02的元素之间，存在关联
IDREFS就是引用多个ID类型的属性值，例如：
1
属性说明
REQUIRED // 表示这个元素的这个属性是必须的
IMPLIED // 表示这个元素可以包含这个属性，也可以不包含
FIXED // 表示这个固定的属性默认值，不能将该属性的值设置为其他值，使用该说明时还需要提供一个默认值，如果XML没有定义该属性，那么其值就被自动设置为DTD定义的默认值
默认值 // 和FIXED一样，不同的是，这个属性的值可以改变，如果在xml文档中设置了新的值，那么新的值会覆盖DTD定义的默认值</description>
    </item>
    <item>
      <title>JavaScript-IntersectionObserver构造函数笔记</title>
      <link>https://99999.fun/posts/16/</link>
      <pubDate>Wed, 16 Jun 2021 09:29:00 +0000</pubDate>
      <guid>https://99999.fun/posts/16/</guid>
      <description>IntersectionObserver是浏览器本身提供的构造函数，因此可能有一些老版本浏览器没有效果
该构造函数提供了一种异步的监测目标对象和祖先对象或者视口相交的方法
var observe = new IntersectionObserver(callback, options)
例如上面，该函数可以传入两个参数，callback是当可视性发生改变时执行回调函数，options是配置对象
使用该构造函数生成的实例中有3个观察器实例，分别是observe（开始监测），unobserve（停止监测），disconnect（关闭监测），其中observe的参数是dom对象
当监测目标对象的可视性发生改变时调用callback参数中的回调函数
options参数：主要是设置观测的对象和观测值，该参数中有三个键值对
root指的是观测对象的根元素，默认是浏览器视口，值要么是根元素，要么就是观测对象的父元素
rootMargin指的是用于扩大或者缩小视口的大小
threshold指的是交叉的比例，主要决定什么时候触发回调函数，是数组，默认值为0
callback参数中的回调函数一般会被调用两次，一次是当监测对象可视性满足了threshold指定的值，还有一次就是监测对象不满足threshold指定的值
IntersectionObserverEntry对象
该对象提供了监测对象的信息，有七个属性
boundingClientRect：返回目标的矩形信息
intersectionRatio：返回相交时和目标的比例值，不可视时小于等于0
intersectionRect：返回目标和视口相交的矩形信息
isIntersecting：返回目标当前是否可视，可视为true（返回值为布尔值）
rootBounds：返回根元素的矩形信息，没有指定根元素则返回当前视口的矩形信息
target：返回观测的目标对象，是dom对象
time：返回一个记录了从观测开始到交叉被触发时间的的时间戳，单位为毫秒
如果是搞懒加载，那么intersectionRatio和isIntersecting是关键点
例如：
const lazyload = new IntersectionObserver((target)=&amp;gt;{// 实例化target.forEach((item) =&amp;gt;{if (item.intersectionRatio){// 当目标可视item.target.src = item.target.alt; // 进行属性值覆盖lazyload.unobserve(item.target) // 停止观测}})},{rootMargin: &amp;quot;100px&amp;quot; // 提前100px}); const imgs = document.querySelectorAll(&amp;quot;img[alt]&amp;quot;); // 选择带有alt属性的img元素imgs.forEach((item) =&amp;gt; {lazyload.observe(item)// 开始观测}); </description>
    </item>
    <item>
      <title>html5学习笔记</title>
      <link>https://99999.fun/posts/12/</link>
      <pubDate>Wed, 16 Jun 2021 09:22:00 +0000</pubDate>
      <guid>https://99999.fun/posts/12/</guid>
      <description>HTML5是HTML标准的第5代标准，主要目的是语义化并且提供多媒体的嵌入
HTML是什么？HTML全称为HyperTextMarkupLanguage，中文叫超文本标记语言，简称HTML
而HTML5是一个标准，指的是第五代HTML标准
HTML5主要的新特性：
语义特性，本地存储特性，设备兼容特性，连接特性，网页多媒体特性，性能与集成特性，CSS3特性
HTML的块级与行级
块级元素的特征：
独占一行，不和其他元素待在同一行上，能设置宽和高
默认宽度是该元素的容器的100%，不过可以设置宽度
常用的块级元素有div，ul，li，dl，dt，h1-h6
行级元素的特征：
可以和其他元素待在同一行上，不能设置宽和高
它的宽度就是它的文字或者图片的宽度
常用的行级元素有a，span
行内块级元素的特征：
可以设置宽和高，可以一行多个
常见的行内块级元素有input，img
转换元素为块级或者行内
display：block //定义元素为块级元素
display: inline //定义元素为行内元素
display：inline-block //定义元素为行内块级元素。
这三个的区别只有三个，排列分式，设置宽高，默认宽度
html语义
语义化：使得页面可以很好的向浏览器和开发者描述其意义
语义化的好处：
方便开发团队的前期开发和后期维护，不只是作用于自己的开发团队，也方便其他国家的开发者能理解网页的结构；
在css文件丢失的情况下，也能表示出好的内容结构和代码结构，方便用户阅读；
方便辅助技术能更好的阅读或者转译网页，方便有障碍人士阅读；
良好的结构和语义，可以提高搜索引擎爬虫的有效爬取；
重点：用正确的标签做正确的事！！！
要注意可以改变样式的标签不一定是有居于语义的
在没有出现语义元素前，几乎都是使用div或者span，加类加id
没有语义的元素最适合当容器使用了
常用的非语义元素有&amp;lt;div&amp;gt;和&amp;lt;span&amp;gt;常用的语义元素有&amp;lt;header&amp;gt;和&amp;lt;footer&amp;gt;&amp;lt;header&amp;gt;：页眉，一般包括网站logo，主导航，搜索框等；&amp;lt;nav&amp;gt;：导航，链接；&amp;lt;main&amp;gt;：定义文章的主要内容，一个页面只能使用一次；&amp;lt;article&amp;gt;：定义一份独立的内容，脱离其他内容或者其他部分，独立于文档的其余部分；&amp;lt;section&amp;gt;：定义内容的节（段）；&amp;lt;footer&amp;gt;：页脚，一般包含版权信息或者链接等；&amp;lt;aside&amp;gt;：侧边栏，一般作为附属信息，例如导航索引，广告等；meta viewport
viewport 是指 web 页面上的可见区域
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;device-width指设备的理想宽度,不同的设备 device-width 是不一样的
nitial-scale=1.0 是指默认缩放大小是1，也就是默认不缩放
maximum-scale=1.0 是指最大缩放大小是1
标签使用&amp;lt;和&amp;gt;括起来，例如&amp;lt;div&amp;gt;
html标签大多都是成对出现的，分开始标签和结束标签，结束标签比开始标签多了个/
例如： html不区分大小写。所以&amp;lt;DIV&amp;gt;和&amp;lt;div&amp;gt;作用一样。建议使用小写
&amp;lt;!DOCTYPE html&amp;gt;声明这是一个html5文件，声明位于&amp;lt;html&amp;gt;前面&amp;lt;html&amp;gt; 标识HTML文档的开始&amp;lt;head&amp;gt;表明一些和html文档有关的信息，例如title&amp;lt;body&amp;gt;html文档的主体&amp;lt;!</description>
    </item>
    <item>
      <title>css3学习笔记</title>
      <link>https://99999.fun/posts/11/</link>
      <pubDate>Wed, 16 Jun 2021 09:21:00 +0000</pubDate>
      <guid>https://99999.fun/posts/11/</guid>
      <description>盒子模型
盒模型在css中是用来封装html元素的，因为本质上来看像个盒子一样，所以叫盒模型或者盒子模型，术语叫box model
外边距（margin）：一般用于控制同辈元素之间的间距
边框（border）：在内边距和内容之外的边框
内边距（padding）：内边框是用于控制内容的距离
内容（content）：内容，一般为文本和图像
例子：建立一个宽度为100px，10px的内边距，10px的外边距，10px的红色边框的盒子
div{width: 100px;borde: 10px solid red;padding: 10px;margin: 10px;}top，bottom，left，right分别代表了上，下，左，右
或者padding: 上，右，下，左，只有一个数字就表示上，下，左，右都是这个数值
有两个数值就是分别代表上下和左右，有三个数值表示上和左右和下
这个盒子大小应该是内容的宽度+内边距+边框+外边距
100+20+20+20=160
两种盒模型
IE 盒子模型（box-sizing content-box）（怪异盒模型）
IE盒模型的width与height是content、padding和border的总和
调用IE盒模型 box-sizing: border-box;
W3C标准盒模型（box-sizing content-box）
标准盒模型的width与height只含content，不包括padding和border
调用W3C标准盒模型 box-sizing: content-box;
在IE6，7，8浏览器中不声明DOCTYPE类型，那么在IE6，7，8浏览器中会将盒子模型解释为IE盒子模型
如果在页面中声明了DOCTYPE类型，那么所有的浏览器都会把盒模型解释为W3C盒模型
JavaScript获取盒模型的宽和高（这里的DOM不是指整个dom，而是某个元素）
DOM.style.width和DOM.style.height（只能获取内联样式）
DOM.currentStyle.width和DOM.currentStyle.height（只支持IE）
window.getComputedStyle(DOM).width和window.getComputedStyle(DOM).height（兼容性好）
获取元素相对于视窗的位置(top,right,bottom,left都可以获取)
let data = DOM.getBoundingClientRect() data.top
有BFC特性的元素是一个被“隔离”的容器，该容器里面的元素不会在布局上影响到外面的元素
满足下面其中一个条件就触发BFC特性
body 根元素
浮动元素 float除none外的值
绝对定位元素 position (absolute、fixed)
display 为 inline-block、table-cells、flex
overflow 除了 visible 以外的值 (hidden、auto、scroll)
BFC的特性：</description>
    </item>
    <item>
      <title>MySQL学习笔记</title>
      <link>https://99999.fun/posts/20/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://99999.fun/posts/20/</guid>
      <description>推荐使用mariaDB
操作数据库
创建数据库
CREATE DATABASE xxx;
删除数据库
DROP DATABASE xxx;
查看所有数据库
SHOW DATABASES;
查看指定数据库
SHOW xxx;
打开指定数据库
USE xxx;
查看指定数据库的详细信息
SHOW CREATE DATABASE xxx;
修改指定数据库的字符集
ALTER DATABASE xxx CHARACTER SET gbk COLLATE gbk_bin;
数据表的校对规则，与于指定数据集如何排序
COLLATE=utf8_bin
指定字符集
CHARSET=utf8
查看当前mysql所支持的字符集
SHOW CHARACTER SET;
新建数据表
CREATE TABLE xxx(id int(4),email char(20),status int(2),code varchar(10)​ );
添加数据
INSERT INTO xxx VALUES(1,&amp;quot;hallo&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;xxx&amp;quot;);修改数据(根据条件)
UPDATE xxx SET status=1 WHERE id = 4;</description>
    </item>
  </channel>
</rss>
