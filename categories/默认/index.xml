<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>默认 on 小陈的个人博客</title>
    <link>http://chenjunlinabc.github.io/categories/%E9%BB%98%E8%AE%A4/</link>
    <description>Recent content in 默认 on 小陈的个人博客</description>
    <image>
      <url>http://chenjunlinabc.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>http://chenjunlinabc.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 26 Dec 2021 20:22:00 +0000</lastBuildDate><atom:link href="http://chenjunlinabc.github.io/categories/%E9%BB%98%E8%AE%A4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pinia---vuejs的轻量级状态管理库</title>
      <link>http://chenjunlinabc.github.io/posts/124/</link>
      <pubDate>Sun, 26 Dec 2021 20:22:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/124/</guid>
      <description>Pinia是vuejs的轻量级状态管理库，Pinia支持Vue devtools浏览器扩展工具，可扩展，模块化设计，热模块更新，轻量级，支持TypeScript，支持SSR服务器端渲染，支持vue2，vue3
Pinia作者也是vuex核心之一
安装pinia
npm install pinia@next
或者
yarn add pinia@next
导入pinia并且挂载为vue插件(在Vite脚手架下)
src/main.js
import { createApp } from &#39;vue&#39;import App from &#39;./App.vue&#39;const app = createApp(App)import { createPinia } from &#39;pinia&#39;app.use(createPinia())app.mount(&#39;#app&#39;)src/stores/main.js（pinia通过defineStore函数来创建state，并且接收一个id来标识state）
import { defineStore } from &#39;pinia&#39;export const useDataStore = defineStore(&#39;data&#39;, {state: () =&amp;gt; {return { count: 666 }},//state: () =&amp;gt; {//name: chen//},getters:{ // getters计算属性doubleCount(state){return state.</description>
    </item>
    
    <item>
      <title>简单了解RSS</title>
      <link>http://chenjunlinabc.github.io/posts/122/</link>
      <pubDate>Mon, 06 Dec 2021 02:32:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/122/</guid>
      <description>RSS指 Really Simple Syndication（简易信息聚合），RSS定义了方法来获取网站的标题以及内容，而且RSS可以被自动更新，RSS使用了XML进行编写（xml笔记：https://cjlio.com/archives/17.html）
一个RSS例子：
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;&amp;lt;rss version=&amp;quot;2.0&amp;quot;&amp;gt;&amp;lt;channel&amp;gt;&amp;lt;title&amp;gt;小陈的辣鸡屋&amp;lt;/title&amp;gt;&amp;lt;link&amp;gt;https://cjlio.com/&amp;lt;/link&amp;gt;&amp;lt;description&amp;gt;cjlio.com&amp;lt;/description&amp;gt;&amp;lt;item&amp;gt;&amp;lt;title&amp;gt;简单了解设计模式&amp;lt;/title&amp;gt;&amp;lt;link&amp;gt;https://cjlio.com/archives/121.html&amp;lt;/link&amp;gt;&amp;lt;description&amp;gt;&amp;lt;![CDATA[设计模式实质就是一套可以通用，复用的设计方案，设计模式是针对面向对象的，在面向对象出来之前，程序是面向过程的，设计模式就是软件设计的工具面向过程：逻辑化过程，以逻辑实现面向对象：思考有哪些对象，...]]&amp;gt;&amp;lt;/description&amp;gt;&amp;lt;content:encoded xml:lang=&amp;quot;zh-CN&amp;quot;&amp;gt;xxxxxxx&amp;lt;/content:encoded&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;/channel&amp;gt;&amp;lt;/rss&amp;gt;可以看到是RSS频道的标题，是该频道的超链接，是该频道的描述，是定义该频道的某篇文章的，其中又有，分别表示文章标题，文章的超链接，文章的描述，其中还有表示文章的内容
RSS注释和HTML的注释一样，
注意：RSS是基于XML编写，所以全部元素都要有闭合标签，大小写敏感，属性值要带引号
channel元素除了上面那几个外，还有，， ，等等
元素还有，，，等等
RSS阅读器可以更好读取RSSfeed</description>
    </item>
    
    <item>
      <title>简单了解设计模式</title>
      <link>http://chenjunlinabc.github.io/posts/121/</link>
      <pubDate>Tue, 30 Nov 2021 15:08:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/121/</guid>
      <description>设计模式实质就是一套可以通用，复用的设计方案，设计模式是针对面向对象的，在面向对象出来之前，程序是面向过程的，设计模式就是软件设计的工具
面向过程：逻辑化过程，以逻辑实现
面向对象：思考有哪些对象，对象都有什么行为，行为的逻辑化
设计模式的好处就是通用可复用，跨语言
设计模式的6大原则：
单一职责原则：指的是一个类只负责一个职责，职责越单一，越容易复用
里氏替换原则：子类可以替换自己的父类，通过开闭原则，通过增加子类来实现父类的“修改”，子类可以添加自己的方法和属性，但是不能重写父类的方法
依赖倒置原则：依赖于接口，而不是实现，面向接口编程，类于类之间不要存在直接依赖，而依赖于接口
接口隔离原则：不同的功能应该用多种接口实现行为，而不能将接口功能直接概括全部行为，单独实现需要的接口
迪米特法则：迪米特法则又叫最少知识原则，一个对象对其他对象应该保持最少的了解，降低类与类之间的耦合，避免一个类依赖于另一个类，而导致另一个类的影响
开闭原则：指的是对扩展进行开放，对修改进行关闭，需要添加新功能，应该添加类，而不是修改原来有的类，保证程序的稳定性
常见的设计模式有工厂模式，策略模式，单例模式，代理模式，适配器模式，装饰者模式，模版方法模式，观察者模式，抽象工厂模式，门面模式
创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程 单例模式 工厂模式 抽象工厂 建造者模式 原型模式
创建型模式就是指创建对象，在创建对象时通过共同的接口来指向这个新创建的对象
结构型模式：把类或对象结合在一起形成一个更大的结构 适配器模式 组合模式 装饰器模式 代理模式 享元模式 外观模式 桥接模式
行为型模式：类和对象如何交互，及划分责任和算法 迭代器模式 模板方法模式 策略模式 命令模式 状态模式 责任链模式 备忘录模式 观察者模式 访问者模式 中介者模式 解释器模式</description>
    </item>
    
    <item>
      <title>shell脚本学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/120/</link>
      <pubDate>Tue, 23 Nov 2021 00:01:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/120/</guid>
      <description>shell中文意思为壳，shell可以接受使用者的指令，来调用服务，shell的种类很多，而比较常见是Bash，头部声明#!/bin/bash，表示bash是解释脚本的程序
例如：
#!/bin/bashecho &amp;quot;hallo word&amp;quot;执行该脚本（注意：需要有可执行权限，sudo chmod +x hallo.sh）
bash hallo.sh
也可以直接执行
./hallo.sh
变量（首字符必须是字母，而且不能有bash的关键字，大小写敏感）
data = &amp;ldquo;hallo&amp;rdquo; echo $data data = &amp;ldquo;word&amp;rdquo; echo ${data}
注意：如果使用单引号，单引号里面有变量的话，是无法生效的，而且还不能出现单引号，而且双引号可以使用变量和转义字符，美元符号（$）只有在使用变量才需要，在定义，更新，删除变量都不需要
例如：
name=&amp;ldquo;chenjunlin&amp;rdquo; data=&amp;ldquo;hallo, ${name} !&amp;rdquo; echo $data
获取字符串的长度
data=&amp;ldquo;hallo word&amp;rdquo; echo ${#data}
获取指定位置的字符 data=&amp;ldquo;hallo word&amp;rdquo; echo ${#data:5:8}
删除变量（不能删除只读变量）
unset data echo ${data}
在shell脚本定义的变量只能在当前脚本交互中使用，可以通过export传递变量到子shell中，可以通过env或者export指令来获取当前shell的环境变量
参数
echo &amp;ldquo;hallo word&amp;rdquo;; echo &amp;ldquo;要执行的shell脚本：$0&amp;rdquo;; echo &amp;ldquo;参数为：$1&amp;rdquo;;
./hallo.sh abc
获取参数的个数：$#
以单一字符串的方式输出全部参数（要被双引号包裹）：$*
以独立字符串的方式输出全部参数（要被双引号包裹）：$@
获取上个命令的状态（是否执行成功，0为成功，非0为失败）：$?
获取当前脚本shell进程的ID：$$
获取后台运行的最后一个进程的ID：$!
配合函数使用（参数也可以通过函数来传递）
function abc(){echo &amp;quot;参数1: $1&amp;quot;echo &amp;quot;被执行的脚本为: $0&amp;quot;}abc hallo.</description>
    </item>
    
    <item>
      <title>简单使用Rollup模块打包工具</title>
      <link>http://chenjunlinabc.github.io/posts/119/</link>
      <pubDate>Wed, 10 Nov 2021 16:22:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/119/</guid>
      <description>根据Rollup官方文档的介绍：Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。
Rollup和webpack那种偏向于应用打包不同，Rollup更专注于类库打包，像vue，react都是通过rollup打包的
注意：webpack支持HMR（热模块更新），而Rollup并不支持，因此在应用打包的时候还是选择webpack比较好，但是如果只是打包类库之类的，并且还是基于ES6模块开发的，那么就可以考虑选择rollup了，因为rollup在Tree-shaking和ES6模块有着算法优势。因为Rollup对模块化是使用新标准，例如 CommonJS，而不是老旧解决方案
提示：webpack已经支持Tree-shaking，并且在babel-loader的情况下也支持es6 module的打包
安装rollup
npm install rollup -g
打包
rollup src/demo.js -f cjs -o dist/bundle.js
注意：-f是&amp;ndash;format的缩写，表示生成代码的格式，例如amd，cjs，esm，umd
如果想监听文件是否改动，可以使用-w参数，当文件发送改动的时候，重新打包
配置文件（rollup.config.js）
export default {input: [&amp;quot;./src/demo.js&amp;quot;],output: {file: &amp;quot;./dist/bundle.js&amp;quot;,format: &amp;quot;cjs&amp;quot;,name: &amp;quot;experience&amp;quot;,},}执行命令
rollup -c
Rollup常用插件
@rollup/plugin-babel
@rollup/plugin-json
@rollup/plugin-alias
@rollup/plugin-commonjs
@rollup/plugin-node-resolve
@rollup/plugin-typescript
@rollup/plugin-image
rollup-plugin-terser
rollup-plugin-postcss
rollup-plugin-serve
rollup-plugin-livereload
rollup-plugin-copy
rollup-plugin-visualizer</description>
    </item>
    
    <item>
      <title>Django学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/118/</link>
      <pubDate>Fri, 22 Oct 2021 18:50:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/118/</guid>
      <description>django是一个基于Python编写的Web框架
Django采用了MVT的设计模式（模型，视图，模板）（mvt设计模式是基于mvc设计模式的）
安装django
pip install django
检查是否安装成功
django-admin
django常用命令
startproject #创建django项目
startapp #创建django应用
check #检查校验项目完整性
runserver #本地运行django项目
shell # 进入django项目的shell环境（Python）
test # 执行django实例测试
makemigrations # 创建模型变更的迁移文件
migrate # 执行迁移文件
dumpdata # 数据库数据导出
loaddata # 文件数据导入数据库
创建第一个项目
django-admin startproject django_demo
settings.py是django项目的配置文件，urls.py是django项目的路由文件，wsgi.py是django作为wsgi应用的配置文件（wsgi，全成web server gateway interface，这个文件用来部署应用服务器），manage.py是django项目的管理文件，init.py是Django项目的包初始化文件
wsgi：Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。（来自百度百科）
运行django项目
python .\manage.py runserver 0.0.0.0:8000
访问127.0.0.1:8000
django应用
django应用和django项目的区别：django项目是基于django的web应用，可以独自运行，django应用是一个可复用（重用）的Python软件包
django项目下可以包含一组配置和n个django应用
创建django应用
python .\manage.py startapp django_app
admin.py #定义admin模块管理的配置文件
apps.py # 声明应用的配置文件
tests.py # 应用测试的配置文化</description>
    </item>
    
    <item>
      <title>Web.py学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/117/</link>
      <pubDate>Mon, 18 Oct 2021 12:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/117/</guid>
      <description>web.py是一个轻量级Python web框架，是由已故著名计算机黑客Aaron Swartz设计开发（如果你看过互联网之子这个电影，你应该对这位大佬很熟悉）
安装web.py
pip install web.py
导入模块
import web
第一个例子
import weburls = (&amp;quot;/(.*)&amp;quot;,&amp;quot;hallo&amp;quot;)app = web.application(urls,globals())class hallo:def GET(self,name):return &amp;quot;&amp;lt;h1&amp;gt;hallo web.py&amp;lt;/h1&amp;gt;&amp;quot;if __name__==&amp;quot;__main__&amp;quot;:app.run()可以看到页面内容是return返回的，也可以open读取html文件，来返回回去，都是可以的</description>
    </item>
    
    <item>
      <title>weex跨平台框架学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/116/</link>
      <pubDate>Sun, 10 Oct 2021 14:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/116/</guid>
      <description>weex是阿里巴巴在Qcon大会上宣布开源的一套跨平台移动开发工具
支持ES6，跨平台，体积小，性能优异，编写规范
官网：http://emas.weex.io/zh/
weex调试工具：weexplayground（可以用来测试，要同局域网下）
安装
npm install -g weex-toolkit
检查weex
weex -v
初始化项目
weex init demo
npm install
或者
weex create demo
运行
npm run dev
npm run server
编译js bundle
weex compile 目录或者文件 打包文件存放的目录或者文件
压缩编译
weex compile 目录或者文件 打包文件存放的目录或者文件 -m
注意：Weex目前只支持像素值，不支持相对单位(em、rem)，也不支持百分比，默认设计标准为750px，当真实像素不是750px的时候，会自动将设计标准映射到真实的尺寸中，这个映射比率叫scale，计算公式为：当前屏幕尺寸/750
不支持层 z-index，具体层级叠加根据编写顺序显示，不支持使用border创建三角形
运行流程：weex生成js bundle，然后通过网络等等方式将js bundle传递到客户端，在客户端中，weexSDK会在用户打开一个weex页面的时候执行对应的js bundle，然后命令发送到native端进行处理</description>
    </item>
    
    <item>
      <title>简单使用mocha测试框架</title>
      <link>http://chenjunlinabc.github.io/posts/114/</link>
      <pubDate>Sun, 03 Oct 2021 12:55:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/114/</guid>
      <description>mocha是JavaScript测试框架
安装
npm install &amp;ndash;global mocha
测试，例如：
demo.js
function abc(a,b,c){return a+b+c}module.exports = abcdemo.test.js
const demo = require(&#39;./demo.js&#39;)const expect = require(&#39;chai&#39;).expectdescribe(&#39;test&#39;, function() {it(&#39;错误&#39;, function() {expect(demo(1,3,7)).to.be.equal(11)})})测试（允许测试多个，默认执行test子目录的测试文件，如果test子目录存在该文件，可以不用加参数）
mocha demo.test.js
其中expect(demo(1,3,7)).to.be.equal(11)是断言，当1+3+7的结果不是11的时候，抛出错误
因为mocha本身没有断言库，需要导入 const expect = require(&amp;lsquo;chai&amp;rsquo;).expect
查看内置的全部报告格式（默认是spec）
mocha &amp;ndash;reporters
使用Dot格式显示
mocha &amp;ndash;reporter dot
使用HTML报告
npm install &amp;ndash;save-dev mochawesome
mocha其他参数
&amp;ndash;watch：监听指定测试脚本，只要测试脚本发生改变就自动执行mocha
搜索测试实例（通过名称）
mocha &amp;ndash;grep &amp;ldquo;test&amp;rdquo;
&amp;ndash;invert ：只执行不符合条件的测试脚本，要搭配&amp;ndash;grep使用
如果要测试ES6，需要转码
npm install babel-core babel-preset-es2015 &amp;ndash;save-dev
.babelrc</description>
    </item>
    
    <item>
      <title>简单使用istanbul代码覆盖率工具</title>
      <link>http://chenjunlinabc.github.io/posts/113/</link>
      <pubDate>Thu, 30 Sep 2021 12:22:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/113/</guid>
      <description>代码覆盖率：是否所有代码都被执行或者调用
每一行，每个函数，每个语句块，每个if分支是否都被执行或者被调用
istanbul是JavaScript的覆盖率工具（类似工具还有NYC）（可搭配mocha使用）
安装
npm install -g istanbul
测试覆盖率
istanbul cover demo.js
检查程序覆盖率是否达到某个值
istanbul check-coverage &amp;ndash;statement 60 &amp;ndash;branch -5 &amp;ndash;function 100
在执行检查测试后，会在目标文件的当前目录下生成个coverage文件夹
在coverage/lcov-report/index.html，可以查看网页版结果</description>
    </item>
    
    <item>
      <title>简单使用Lerna多包管理工具</title>
      <link>http://chenjunlinabc.github.io/posts/112/</link>
      <pubDate>Sun, 26 Sep 2021 12:50:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/112/</guid>
      <description>Lerna是一个基于git和npm来管理多个包工作流的工具（monorepo），解决多个包之间的依赖问题，像React，Vue，Babel都在使用lerna管理多包
安装Lerna
npm install &amp;ndash;global lerna
新建git仓库（初始化）
git init lerna-demo
初始化Lerna仓库
lerna init
创建新包
lerna create demoPackage
显示全部已经安装的包
lerna list
依赖处理（通过软链接方式将多个package关联起来）
lerna bootstrap
添加包到外层的node_modules
lerna add axios
移除所有packages下的node_modules（不会移除根目录的）
lerna clean
发布package（不会发布标记为private的包）
lerna publish
查看上一次有修改的包的差异
lerna diff
注意：全部子包会放在packages/目录下，lerna.json就是lerna的配置文件
lerna有两个管理模式，分别是固定模式（默认模式）和独立模式
固定模式将全部包版本绑定在一起，如果只更新一个包，将会更新对应包的版本到新的版本号
独立模式：init的时候使用&amp;ndash;independent参数，独立模式允许对每个库单独改变版本号，每次发布的时候只需要为每个改动的库指定版本号</description>
    </item>
    
    <item>
      <title>简单使用ESlint代码风格校验工具</title>
      <link>http://chenjunlinabc.github.io/posts/111/</link>
      <pubDate>Thu, 23 Sep 2021 10:06:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/111/</guid>
      <description>ESlint是用来校验JavaScript代码风格格式的工具，目的是确保每个人的代码风格统一，按照统一的规范编写（规范化、标准化是前端工程化的特点）
安装ESlint
npm install eslint &amp;ndash;save-dev
或者全局安装
npm install eslint &amp;ndash;global
修改scripts属性（package.json）&amp;ndash;fix参数是ESlint提供的自动修复基础错误功能（不能修复逻辑性错误），如果不要也可以
&amp;ldquo;lint&amp;rdquo;: &amp;ldquo;eslint src &amp;ndash;fix&amp;rdquo;, &amp;ldquo;lint:create&amp;rdquo;: &amp;ldquo;eslint &amp;ndash;init&amp;rdquo;
创建.eslintrc
npm run lint:create
会显示显示要求，例如是否校验ES6语法，首行空白是Tab键还是Space等等
校验程序（根据上面的修改，会检查src目录下的所有.js文件）
npm run lint
.eslintrc文件是ESlint校验配置文件，这个配置文件可以自己设置（或者手写手动修改），也可以复制别人的
&amp;ldquo;off&amp;rdquo; or 0 ：关闭规则
&amp;ldquo;warn&amp;rdquo; or 1 ：将规则视为一个警告
&amp;ldquo;error&amp;rdquo; or 2 ：将规则视为一个错误
可以设置规范，只能使用单引号，tab缩进等等编写规范</description>
    </item>
    
    <item>
      <title>Umi框架学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/110/</link>
      <pubDate>Mon, 20 Sep 2021 21:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/110/</guid>
      <description>Umi是一款前端应用框架
官方文档：https://umijs.org/zh-CN/docs
根据官方文档要求，node版本&amp;gt;=10.13
yarn create @umijs/umi-app
安装依赖
yarn
启动项目
yarn start
构建项目（默认生成到./dist）
yarn build
路由（src\.umi\core\routes.ts）
&amp;quot;routes&amp;quot;: [{&amp;quot;path&amp;quot;: &amp;quot;/&amp;quot;,&amp;quot;component&amp;quot;: require(&#39;@/pages/index&#39;).default,&amp;quot;exact&amp;quot;: true},{&amp;quot;path&amp;quot;: &amp;quot;/admin&amp;quot;,&amp;quot;component&amp;quot;: require(&#39;@/pages/admin&#39;).default,&amp;quot;exact&amp;quot;: true}]组件文件放在src\pages下
path是路径，component是组件路径，绝对和相对都可以用，也可以有require(&amp;rsquo;@/pages/xxx&amp;rsquo;)的方式
exact表示是否严格匹配，就是path和组件路径是否要完全对应，默认为开启，如果设置为false，表示模糊匹配
子组件
&amp;quot;routes&amp;quot;: [{&amp;quot;path&amp;quot;: &amp;quot;/&amp;quot;,&amp;quot;redirect&amp;quot;: &#39;/admin&#39;,},{&amp;quot;path&amp;quot;: &amp;quot;/admin&amp;quot;,&amp;quot;component&amp;quot;: require(&#39;@/pages/admin&#39;).default,routes: [{ path: &#39;/admin/archives&#39;, redirect: &#39;/&#39; },{ path: &#39;/admin/category&#39;, component: &#39;category&#39; },]}]redirect是跳转路由，当访问/的时候，跳转到/admin
文件路由（根据目录和文件名来分析路由）
如果没有routes路由配置，那么就会触发该文件路由，通过分析src/pages目录
注意：用.或者_开头的文件，用d.ts结尾的文件，不是 .</description>
    </item>
    
    <item>
      <title>简单了解并且使用npm script</title>
      <link>http://chenjunlinabc.github.io/posts/109/</link>
      <pubDate>Mon, 20 Sep 2021 14:30:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/109/</guid>
      <description>npm script是package.json中可以定义的脚本命令，可以用来实现自动化构建，例如：
&amp;quot;scripts&amp;quot;: {&amp;quot;dev&amp;quot;: &amp;quot;node hallo.js&amp;quot;}npm run dev // 等于执行node hallo.js
查看当前项目的全部npm脚本
npm run
注意：当前项目的node_modules/bin下的全部依赖都可以直接访问
如果要执行多个脚本可以用&amp;amp;&amp;amp;（依次运行），&amp;amp;（并行运行）
npm script有pre和post两个钩子，这两个钩子可以分别来做准备工作和清理工作等等，例如：
&amp;quot;scripts&amp;quot;: {&amp;quot;predev&amp;quot;: &amp;quot;echo hallo&amp;quot;,&amp;quot;dev&amp;quot;: &amp;quot;node hallo.js&amp;quot;,&amp;quot;postdev&amp;quot;: &amp;quot;echo yes&amp;quot;}相对于npm run predev &amp;amp;&amp;amp; npm run dev &amp;amp;&amp;amp; npm run postdev
像install，uninstall，publish，test，start等等都有pre和post这两个钩子
查看正在运行的脚本
const NpmScript = process.env.npm_lifecycle_event console.log(NpmScript)
可以缩写不用run，例如：npm dev
npm script可以使用npm内部变量，例如：
{&amp;quot;name&amp;quot;: &amp;quot;root&amp;quot;, &amp;quot;scripts&amp;quot;: {&amp;quot;dev&amp;quot;: &amp;quot;node hallo.js $npm_package_name&amp;quot;}}获取npm内部变量name
console.log(process.env.npm_package_name)
脚本错误抛出
&amp;quot;scripts&amp;quot;: {&amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;}传递参数</description>
    </item>
    
    <item>
      <title>Node.js学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/108/</link>
      <pubDate>Mon, 20 Sep 2021 10:50:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/108/</guid>
      <description>nodejs是基于Google的V8引擎，使JavaScript不再只能运行与浏览器中了
npm是跟随nodejs的包管理工具，可以用来更新包，安装包，编写包等等功能
nodejs也提供了完整的http服务功能（http模块是用c++写的，性能可靠）
const http = require(&amp;quot;http&amp;quot;)http.createServer(function (_request, response) {response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;})response.end(&amp;quot;hallo nodejs&amp;quot;)}).listen(8888)console.log(&#39;Server running at http://127.0.0.1:8888/&#39;)如果在http://127.0.0.1:8888/看到了hallo nodejs，那么就说明运行成功了
nodejs的模块分为全局模块，系统模块，自定义模块
全局模块（不需要引入，可以直接使用）
例如process.env和process.argv
获取系统环境变量
console.log(process.env)node自定义参数（process.argv）
let num1 = parseInt(process.argv[2])let num2 = parseInt(process.argv[3])console.log(num1+num2)node hallo.js 6 3
可以看到输出了9，说明参数被传递进去了
系统模块（需要引用，不需要安装，nodejs已经封装好的预制的系统模块）
获取目录
const path = require(&amp;quot;path&amp;quot;)console.log(path.dirname(&amp;quot;/hallo/index/main.js&amp;quot;))获取文件名
console.log(path.basename(&amp;quot;/hallo/index/main.js&amp;quot;))获取文件扩展名
console.log(path.extname(&amp;quot;/hallo/index/main.js&amp;quot;))功能扩展
console.log(path.resolve(&amp;quot;/hallo/index/main.js&amp;quot;,&amp;quot;../&amp;quot;,&amp;quot;index.js&amp;quot;))获取文件的绝对路径
console.log(path.resolve(__dirname,&amp;quot;index.js&amp;quot;))文件读写模块（fs）
读
const fs = require(&amp;quot;fs&amp;quot;)fs.readFile(&amp;quot;data.txt&amp;quot;,(err,data)=&amp;gt;{if(err){console.log(err)}else{console.log(data.toString())}})写</description>
    </item>
    
    <item>
      <title>数据结构学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/106/</link>
      <pubDate>Fri, 17 Sep 2021 01:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/106/</guid>
      <description>数据结构其实就是带结构的数据元素的集合，结构是数据元素之间的关系
数据结构（数组，字符串，队列，栈，链表，集合，哈希表（散列表），树（二叉树），图）
集合：结构中的元素除了同属于一个集合外，没有别的关系
线性结构：结构中的元素之间存在一对一的关系，一个对应一个
数性结构：结构中的元素之间存在一对多的关系
图形结果或者网状结构：结构中的任意元素都可以有关系
顺序结构：数据元素按照一个排序（规律）顺序存放，例如1，2，3
链式结构：每一个数据元素都是随机存放
栈：线性结构的一种特殊的存储方式
数据存储是按照先进后出的原理，先进入的数据，放在最下面，最后进入的放在最前面
数据的获取也是才上面往下面获取的
顺序栈：会在顺序栈中设置一个永远指向顶部元素的变量，当这个变量为-1的时候，说明这个栈没有元素，而存储一个元素就加一，获取就减一</description>
    </item>
    
    <item>
      <title>NodeJS常用工具的简单使用</title>
      <link>http://chenjunlinabc.github.io/posts/105/</link>
      <pubDate>Thu, 16 Sep 2021 21:55:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/105/</guid>
      <description>npm在这里https://cjlio.com/archives/31.html
Yarn在这里https://cjlio.com/archives/38.html
nvm全名node.js version management
用来nodejs多版本管理，可以切换和安装不同版本的nodejs
安装nvm之前记得把安装过的nodejs都卸载了
安装完成后，安装目录下会生成一个settings.txt文件
配置一下（如果要使用淘宝npm源的话）
root: D:\Software\nvm path: D:\Software\nodejs arch: 64 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/
环境变量
NVM_HOME设置为nvm安装目录
NVM_SYMLINK设置为nodejs安装目录
Path：添加%NVM_HOME%和%NVM_SYMLINK%
注意：安装路径不能出现中文或者空格，否则报错，请使用管理员权限运行use命令，否则可能导致exit status 1:xxx
安装指定版本nodejs
nvm install 14.17.3
查看可以安装的nodejs版本
nvm ls available
查看当前全部已经安装的nodejs版本
nvm ls
切换nodejs版本
nvm use 14.17.3
卸载nodejs
nvm uninstall 14.17.3
查看系统位数和node位数
nvm arch
另一个nodejs多版本管理工具n
安装n
npm install -g n
安装最新nodejs版本
n latest
安装稳定版本nodejs
n stable
安装lts版本
n lts
安装指定版本的nodejs（如果已安装了这个版本，那么就会选择这个版本，这个命令可以用来安装和选择）
n 14.17.3
卸载指定版本
n rm 14.17.3</description>
    </item>
    
    <item>
      <title>Angular学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/101/</link>
      <pubDate>Mon, 13 Sep 2021 12:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/101/</guid>
      <description>Angular是三大前端框架之一（Angular在国内的热度低，但是在国外热度还是很高的，主要是因为Angular到Angular2的断崖式升级）
Angular和Vue的区别就是，Angular具备完整的MVVM框架功能（功能高度集成），提供一套完整的解决方案，而Vue是轻量级MVVM框架（渐进式，还需要vue-router之类的扩展功能），Angular和Vue并没有谁好谁坏之分，各有风格
注意：Angular是AngularJS的重写，AngularJS使用JavaScript编写完成，而Angular采用TypeScript编写完成
安装
npm install -g angular-cli
第一个Angular应用
&amp;lt;div ng-app ng-init=&amp;quot;name=&#39;default&#39;&amp;quot;&amp;gt;&amp;lt;p&amp;gt;name: &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;h1&amp;gt;hallo，{{name}}&amp;lt;/h1&amp;gt;&amp;lt;p ng-bind=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;ng-app属性将其声明为是一个Angular应用，ng-model将数据绑定到name中，ng-bind将其输出绑定，ng-init是初始化值</description>
    </item>
    
    <item>
      <title>Koa框架学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/100/</link>
      <pubDate>Sun, 12 Sep 2021 18:30:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/100/</guid>
      <description>koa是web应用框架，是Express原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架
个人推荐：个人开发推荐用koa，团队开发推荐用egg
egg是在koa的基础上进行封装，并且提供了一些，并且添加了约束，更利于工程化的开发
安装koa
npm install koa
新建一个app.js
const Koa = require(&amp;quot;koa&amp;quot;)const app = new Koa()app.use(async (ctx, next) =&amp;gt; {await next()ctx.response.type = &#39;text/html&#39;ctx.response.body = &#39;&amp;lt;h1&amp;gt;hallo, koa!&amp;lt;/h1&amp;gt;&#39;})app.listen(3000)node app.js
get请求参数的接收
const Koa = require(&#39;koa&#39;)const app = new Koa()app.use(async(ctx)=&amp;gt;{const url =ctx.urlconst request =ctx.requestconst reqQuery = request.queryconst reqQuerystring = request.querystringctx.body={url,reqQuery,reqQuerystring}})app.listen(3000,()=&amp;gt;{console.log(&#39;port 3000&#39;)})http://127.</description>
    </item>
    
    <item>
      <title>简单使用Jest-JavaScript测试工具</title>
      <link>http://chenjunlinabc.github.io/posts/95/</link>
      <pubDate>Mon, 06 Sep 2021 23:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/95/</guid>
      <description>Jest是Facebook开源的一套JavaScript测试框架
安装
在项目中安装
yarn add &amp;ndash;dev jest或者npm install &amp;ndash;save-dev jest
全局安装
yarn global add jest
hello.js
module.exports = function(){return &amp;quot;hello world&amp;quot;}hello.test.js
const hello = require(&#39;../hello&#39;)it(&#39;should &#39;, () =&amp;gt; {expect(hello()).toBe(&#39;hello world&#39;)})package.json
{&amp;quot;scripts&amp;quot;: {&amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;}}执行测试
yarn test或者npm run test
exspect() //运行结果
toBe() //期待的结果
not.toBe() //判断不等
toBeNull() //判断是否为NULL
toBeUndefined() //判断是否为undefined
toBeDefined() //判断是否为undefined取反
toBeTruthy() //判断结果为true
toBeFalsy() //判断结果为false
toBeGreaterThan(5) //判断结果是否大于5
toBeLessThan(5) //判断结果是否小于5
toBeGreaterThanOrEqual(6) //判断结果是否大于等于6</description>
    </item>
    
    <item>
      <title>Taro脚手架学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/92/</link>
      <pubDate>Tue, 31 Aug 2021 12:15:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/92/</guid>
      <description>Taro是京东凹凸实验室推出的一个脚手架，设计目的是多端统一开发解决方案，一次开发，多端运行
Taro可以使用React/Vue等前端框架开发的，当然typescript肯定是支持
Taro官方文档：https://taro-docs.jd.com/taro/docs/README
Taro支持微信小程序，百度小程序，支付宝小程序，字节小程序，QQ轻应用，ReactNatvie等等
安装Taro脚手架
npm install -g @tarojs/cli
或者
yarn global add @tarojs/cli
升级脚手架工具
taro update self
创建项目
taro init hallo
创建h5项目
yarn dev:h5
创建微信小程序项目
yarn dev:weapp
创建完毕会在dist目录下生成小程序程序
作为一个可以使用react开发的脚手架，React Hooks和jsx也是支持的
Taro组件化（Taro可以使用react开发，因此也具备react的组件化功能）
import Taro, { useState } from &#39;@tarojs/taro&#39;import { View, Text } from &#39;@tarojs/components&#39;import &#39;./index.less&#39;function Main(){const [count ,setUserName] = useState(&amp;quot;hallo word&amp;quot;)return ( &amp;lt;View&amp;gt;&amp;lt;Text&amp;gt;{count}&amp;lt;/Text&amp;gt;&amp;lt;/View&amp;gt;)}export default Main子组件
import { View, Text } from &#39;@tarojs/components&#39;function Data(){return ( &amp;lt;View&amp;gt;&amp;lt;Text&amp;gt;hallo word&amp;lt;/Text&amp;gt;&amp;lt;/View&amp;gt;)}export default Data导入</description>
    </item>
    
    <item>
      <title>简单利用Electron框架开发桌面端应用</title>
      <link>http://chenjunlinabc.github.io/posts/91/</link>
      <pubDate>Wed, 25 Aug 2021 12:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/91/</guid>
      <description>Electron是由github开发的开源框架，允许开发者使用web技术构建跨平台的桌面应用
GUI由Chromium提供，底层通过Nodejs提供，Native API提供桌面端和跨平台的原生功能
Visual Studio Code和Atom都是使用Electron开发的，可以说技术很成熟
但是毕竟是基于Chromium的，打包出来的应用非常大，就算是个halloword，也要几百m
安装Electron
npm install electron &amp;ndash;save-dev
全局安装
npm install -g electron
新建项目，并且在该目录下建立index.html文件和main.js
mian.js是Electron应用的配置文件
导入electron模块
var electron = require(&amp;rsquo;electron&#39;)
创建Electron引用
var app = electron.app
创建窗口引用
var BrowserWindow = electron.BrowserWindow
声明主窗口
var mainWindow = null
设置参数
app.on(&#39;ready&#39;,()=&amp;gt;{mainWindow = new BrowserWindow({// 设置窗口大小width:500,height:500,webPreferences:{nodeIntegration: true// 是否集成node}}) mainWindow.loadFile(&#39;index.html&#39;) // 指定窗口加载那个页面mainWindow.on(&#39;closed&#39;,()=&amp;gt;{mainWindow = null// 监听销毁事件，事件触发关闭主窗口，设置为null})})初始化
npm init &amp;ndash;yes</description>
    </item>
    
    <item>
      <title>React Hooks学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/90/</link>
      <pubDate>Fri, 20 Aug 2021 23:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/90/</guid>
      <description>React Hooks提供了新特性来给纯函数组件可以管理状态
学过react都知道纯函数组件没有生命周期钩子，而且还不能更新状态，只有class组件有生命周期钩子和状态
而一个好的组件要有高独立性，高可复用性，而class组件本身就是有状态，因此要复用起来比较麻烦，而且还有个this缺陷
React Hooks的出现，是因为类组件会继承React.Component父类，而React.Component父类拥有大量的方法和属性，在开发一些小型组件时，完全没有必要用到这么多的方法和属性，就好吧杀鸡用屠龙刀一样，可以但是没有必要，而纯函数组件就不存在这些方法和属性，可谓是轻量级
例如：
class组件：
class Hi extends React.Component{constructor(props) {super(props)this.state = { count:0 }}render(){console.log(this.state.count)return(&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;数据：{this.state.count}&amp;lt;/p&amp;gt;&amp;lt;button onClick={this.addGo.bind(this)}&amp;gt;GO&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;)}addGo(){this.setState({count:this.state.count+1})}}那么函数组件+React Hooks怎么实现状态更新呢？
而function组件想更新状态可以通过React Hooks来实现，例如：
例如：
import React, { useState } from &#39;react&#39;function Hi(){const [ count , setCount ] = useState(0)return (&amp;lt;div&amp;gt;&amp;lt;p&amp;gt; 数据：{count} &amp;lt;/p&amp;gt;&amp;lt;button onClick={()=&amp;gt;{setCount(count+1)}}&amp;gt;GO&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;)}没错就是这么简单，看起来函数组件+React Hooks更简洁，更容易理解</description>
    </item>
    
    <item>
      <title>Markdown基础语法笔记</title>
      <link>http://chenjunlinabc.github.io/posts/88/</link>
      <pubDate>Wed, 18 Aug 2021 16:50:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/88/</guid>
      <description>Markdown是一个标记语言，常用于编写文档
标题
一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 分别对别h1到h6
段落
斜体文本
斜体文本
粗体文本
粗体文本
粗斜体文本
粗斜体文本
分割线
删除线
hallo
脚注
列表
列表 列表 列表 1.列表
区块
xxx 代码
xxx
xxx
链接
chenjunlin
图片
表格
xxx xxx yyy yyy yyy yyy :-表示左对齐，-:表示右对齐，:-:表示居中对齐
转义
*</description>
    </item>
    
    <item>
      <title>简单使用Vite-前端构建工具</title>
      <link>http://chenjunlinabc.github.io/posts/87/</link>
      <pubDate>Wed, 18 Aug 2021 14:20:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/87/</guid>
      <description>Vite是由 Vue.js 的作者尤雨溪开发完成的一款前端项目构建工具，使用原生ESM文件，支持热重载
Vite在法语中的意思为快速的（尤大是真喜欢法语啊）
基于原生 import 的，使用浏览器来解析import，服务端按需编译返回，支持热更新模块
依赖于Rollup打包，虽然vite设计初衷是为了vue3.x的，但是也是支持其他框架（例如react）
对于TypeScrip的支持程度相当好，只需要在script元素加lang=&amp;ldquo;ts&amp;quot;就可以使用ts了
至于less，sass/scss之类的css预处理器以及css原生支持也是很好，Vite支持css样式直接引入（import &amp;lsquo;./app.css&amp;rsquo;）
sass/scss使用（前提已经安装了sass）
在style元素中加lang=&amp;ldquo;scss&amp;quot;就可以使用sass了
json也是可以直接引入，例如：import data from &amp;lsquo;./data.json&amp;rsquo;
另外对于JSX也是支持的，用.jsx表示jsx，例如：import App from &amp;lsquo;./App.jsx&amp;rsquo;
vite有一套开发服务功能，基于原生es模块，ESM+HMR，而且还有一套项目构建指令，用rollup打包
打包：指的是使用工具来抓取和处理源码模块，并且合成可以在浏览器上运行的文件（浏览器本身并不提供模块管理的机制，多模块需要很多的script标签，很繁琐臃肿，而打包就很好的解决了这个问题）
常见的打包工具例如：webpack，rollup，parcel，gulp
注意：当冷启动服务的时候，必须要先抓取并且构建应用（当应用越来越大，模块越来越多的时候，会导致服务启动缓慢），才能提供服务，而且进行模块更新的话，也会导致重建应用缓慢
传统打包，是将多个模块打包成单一的文件，而esm打包，是根据http请求，来获取相应的route，再根据route来获取module（避免一开始就获取全部module）
vite将模块分为依赖和源码，依赖指的是开发时不会发生改变的，vite将使用esbuild预构建依赖，而且将以原生ESM方式让浏览器接管打包源码
构建Vite项目
npm init vite-app demo
或者
yarn create vite-app demo
然后初始化一下
npm install
或者
yarn
启动服务器
vite
或者
npm run dev，yarn dev
本地预览
vite preview
打包
vite build
react
npm init vite-app &amp;ndash;template react
npm install
Vite是一个构建工具的高阶封装（生产环境打包用Rollup来构建），开发环境无需要打包编译（利用现代浏览器的原生ESM来进行导入模块，模块加载的工作由浏览器完成，实现冷启动），支持动态模块热重载（HMR），开发环境的编译通过Esbuild来完成
Vite生产环境构建（也就是Rollup）是根据browserslist来做浏览器兼容性的，需要通过修改vite.config.ts下的build.target来指定构建目标，Vite最低支持es2015，也就是es6，需要es5以及更多浏览器可能无法正常运行或者通过@vitejs/plugin-legacy插件来获取支持（注意：使用该插件也不能让vue3支持ie11，只有vue2支持ie11）
安装@vitejs/plugin-legacy
yarn add @vitejs/plugin-legacy -d配置vite.</description>
    </item>
    
    <item>
      <title>SVN版本控制系统学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/84/</link>
      <pubDate>Wed, 11 Aug 2021 15:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/84/</guid>
      <description>SVN全名Subversion，即版本控制系统
和Git不同，Git是分布式，而SVN是集中式
在commit没有冲突的时候，会合并
而存在冲突那么就需要先手动处理冲突再commit
源代码库：源代码统一存放的地方
获取：到源代码库获取一份源代码
提交：已经修改了源代码，想提交到源代码库
更新：更新同步和源代码库一样的源代码
安装SVN
dnf install subversion
创建版本库
cd /svn/demo
svnadmin create /svn/demo
其中conf/svnserve.conf文件是svn服务配置文件
anon-access = read auth-access = write password-db = passwd authz-db = authz realm = /svn/demo
passwd文件为账号密码文件
格式为：账号=密码，例如：abc = root
authz为权限控制文件
格式为：账号=rw（r读，w写），例如：abc=rw
启动版本库
svnserve -d -r /svn/demo &amp;ndash;listen-port 3690
&amp;ndash;listen-port是指定svn监听端口，默认是3690，-r是指定版本库
停止svn服务
killall svnserve
检出：从版本库中创建副本，在其修改，再提交到版本库中
例如：
svn checkout svn:xxx/demo &amp;ndash;username=root
因为root有读写权限，因此将会在本地获取到demo的副本
更新：更新副本，将其同步到版本库最新版本，如果不是当前最新版本，当前本地的副本将无效
svn update
默认是更新到最新版本，也可以指定更新到哪个版本
svn update -r 2 demo
提交
svn commit -m &amp;ldquo;hello svn&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Axios网络请求库学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/83/</link>
      <pubDate>Wed, 11 Aug 2021 12:15:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/83/</guid>
      <description>Axios是一个基于promise的http网络请求库，可以用于浏览器和nodejs，在nodejs中使用http模块，而在浏览器使用XMLHttpRequests
支持promise api，支持拦截请求和响应，转换请求数据和响应数据，取消请求，自动转换json数据，支持防御XSRF攻击
安装
yarn add axios
实例demo
import axios from &amp;quot;axios&amp;quot;;axios.get(&amp;quot;https://httpbin.org/get&amp;quot;, {params: {name: &amp;quot;root&amp;quot;}}).then(function (response) {console.log(response);}).catch(function (error) {console.log(error);});axios.post(&amp;quot;https://httpbin.org/post&amp;quot;, {name: &amp;quot;root&amp;quot;,pass: &amp;quot;root&amp;quot;}).then(function (response) {console.log(response);}).catch(function (error) {console.log(error);});可以看到页面已经发送了get和post请求，.then和.catch分别表示请求成功和请求失败时调用的函数，也可以用箭头函数，其中response参数为请求的数据，error为错误信息
还可以写成这样
axios({method: &#39;post&#39;,url: &#39;https://httpbin.org/post&#39;,data: {name: &amp;quot;root&amp;quot;,pass: &amp;quot;root&amp;quot;}});FormData方式
let data = {home: &amp;quot;hallo&amp;quot;,main: &amp;quot;abc&amp;quot;}let formData = new FormData()for(let key in data){formData.</description>
    </item>
    
    <item>
      <title>简单使用Ant Design组件库</title>
      <link>http://chenjunlinabc.github.io/posts/82/</link>
      <pubDate>Tue, 10 Aug 2021 23:03:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/82/</guid>
      <description>Ant Design是蚂蚁金服技术沉淀出一套基于React的组件库和前端框架
官网：https://ant.design/index-cn
使用create-react-app初始项目
yarn create react-app antd-demo
运行
yarn start
安装antd组件库
yarn add antd
通过import { 组件名 } from &amp;ldquo;antd&amp;quot;方式导入antd组件
导入antd css样式
@import &amp;lsquo;~antd/dist/antd.css&amp;rsquo;;
在typescript上使用
yarn create react-app antd-demo-ts &amp;ndash;template typescript
Antd的样式使用了less作为开发语言
第一个实例demo
import &#39;antd/dist/antd.css&#39;;import { DatePicker, Space } from &#39;antd&#39;;ReactDOM.render(&amp;lt;Space direction=&amp;quot;vertical&amp;quot;&amp;gt;&amp;lt;DatePicker/&amp;gt;&amp;lt;/Space&amp;gt;,document.getElementById(&#39;root&#39;),); </description>
    </item>
    
    <item>
      <title>Svelte学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/80/</link>
      <pubDate>Mon, 09 Aug 2021 22:50:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/80/</guid>
      <description>Svelte的核心思想在于通过静态编译减少框架运行时的代码量
Svelte风格和vue相似，模板用{}来表示
Svelte的特点就是没有虚拟DOM（像Vue和React都是用虚拟DOM的）
初始化
npx degit sveltejs/template demo
yarn
yarn dev
修改src\App.svelte和src\main.js
&amp;lt;script&amp;gt;let name = &#39;world&#39;&amp;lt;/script&amp;gt;&amp;lt;h1&amp;gt;Hello {name}!&amp;lt;/h1&amp;gt;导入组件
import Hallo from &#39;./hallo.svelte&#39;...&amp;lt;Hallo/&amp;gt;如果想将HTML渲染到组件中可以使用 let string = &amp;lt;div&amp;gt;hallo word&amp;lt;/div&amp;gt; {@html string}
事件响应
function aClick() {count += 1}...&amp;lt;button on:click={aClick}&amp;gt;{count}&amp;lt;/button&amp;gt; </description>
    </item>
    
    <item>
      <title>Mobx学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/78/</link>
      <pubDate>Sun, 08 Aug 2021 21:35:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/78/</guid>
      <description>Mobx是一个状态管理库（状态管理实质上就是在管理数据变化）
Mobx通过透明的函数响应式编程使得状态管理变得简单和可扩展
Mobx状态管理是基于观察者模式的（Mobx6.0移除了修饰器）
安装Mobx
npm install mobx mobx-react --save或者
yarn add mobx mobx-react --save导入
import {observable, autorun, computed, action, makeObservable,reaction,when} from &amp;quot;mobx&amp;quot;import {observer} from &amp;quot;mobx-react&amp;quot;注意：在严格模式中，是不允许在action之外改变状态的
启动严格模式
import {configure} from &#39;mobx&#39;configure({enforceActions: true})observable定义可观察的状态 action修改状态（动作） computed计算值
数据变化可被观察，例如：
let appdata = observable([1,2,3,4,5])console.log(appdata[1])appdata = observable({a:1,b:2,c:3})console.log(appdata.a)appdata.a += 1console.log(appdata.a)appdata = observable.box(100)console.log(appdata)响应式对象
makeObservable（手动配置observable，action，computed）
const store = makeObservable({ count: 666, get double(){return this.count * 2},increment(){this.</description>
    </item>
    
    <item>
      <title>CSS预处理器-Sass学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/51/</link>
      <pubDate>Fri, 02 Jul 2021 08:44:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/51/</guid>
      <description>sass是一门css扩展语言，css预处理器
sass是基于ruby语言开发，在前端中可以使用npm安装
npm install node-sass或者npm install node-sass &amp;ndash;save-dev
当然也可以安装ruby，通过gem托管服务进行安装sass
gem install sass
文件
hallo.scss
解析为css文件
sass hallo.scss hallo.css
sass提供了4种编译风格
nested：嵌套缩进的css代码，默认值
expanded：没有缩进，扩展的css代码
compact：简洁格式的css代码
compressed：压缩后的css代码，生产环境一般选择这个
编译风格使用语法
sass &amp;ndash;style nested hallo.scss hallo.css
也可以让sass自动编译
监听文件
sass &amp;ndash;watch hallo.scss:hallo.css
监听目录
sass &amp;ndash;watch sass/style.scss:css/style.css
注意：目录不要有中文
注释
/* 注释 */
// 注释
/*! 注释 */
第一种注释，会保留到编译后的css文件中
第二种注释，不会编译到编译后的css文件中
第三种注释，是表示重要注释，就算就是压缩编译，也会保留这个注释，一般用来声明版权
变量
$color: #ccc;#app{color: $color;}变量也可以嵌套到属性中
$right: right;#app{margin-#{$right}: 50px;}运算
允许使用加减乘除运算
#app{width: 100px + 20px;height: (300px / 3) * 2;}嵌套，嵌套一般用在有同一个父元素（祖先元素）下，例如：</description>
    </item>
    
    <item>
      <title>CSS预处理器-Less学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/50/</link>
      <pubDate>Thu, 01 Jul 2021 15:31:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/50/</guid>
      <description>less是一门css扩展语言，是css预处理器，扩展了css的动态特性，在css语法基础上引入了变量，混合，运算和函数等功能
常见的css预处理器有sass，less，stylus
less开发手册：https://less.bootcss.com/
安装less
npm install -g less
检查是否安装成功
lessc -v
或者使用CDN和src导入的方法也都是可以的
例如：
https://cdn.jsdelivr.net/npm/less@4.1.1/dist/less.min.js
less文件
hallo.less
注释
/*块注释*/
// 行注释
变量
变量名命名规范
必须是以@开头
不能包含特殊字符
不能以数字开头
大小写敏感
例如：
@color: #ccc;#app{background-color: @color;}less编译
less提供了一个解析器，通过解析器，编译成css文件
例如：
npm
lessc style.less style.css
将style.less编译成style.css文件
或者
vsc插件：Easy LESS（修改保存就自动编译成css文件）
less嵌套
子元素嵌套到父元素上（后代选择器）
#app{width: 100px;div{width: 60px;}}伪类或者伪元素选择之类的，需要加&amp;amp;连接起来，不加则认为是后代
#app{width: 100px;a{color: #000;&amp;amp;:hover{color: @color;}&amp;amp;::before{width: 30px;}} }less运算</description>
    </item>
    
    <item>
      <title>数据结构与算法学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/49/</link>
      <pubDate>Tue, 29 Jun 2021 15:52:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/49/</guid>
      <description>根据于小甲鱼大佬的数据结构与算法教程而 ~~ 写 ~~ 抄的笔记
什么是数据结构？
数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。
程序设计 = 数据结构 + 算法
数据元素相互之间存在的一种或多种特定关系的集合
数据结构分为逻辑结构和物理结构
逻辑结构：指的是数据对象中数据元素之间的相互关系
物理结构：指的是数据的逻辑结构在计算机中的存储形式
四大逻辑结构：
集合结构： 集合结构中的数据元素是同属性一个集合的
线性结构：线性结构中的数据元素之间是一对一的关系
树型结构：树性结构中数据元素之间存在一种一对多的层次关系
图形结构：图形结构的数据元素是多对多的关系
物理结构：实质是研究如何将数据元素存储到计算机的存储器中
存储器主要是针对于内存，外部存储器（例如：硬盘）的数据组织一般用文件结构来表示
数据元素的存储结构形式有两种，顺序存储和链式存储
顺序存储结构：指的是数据元素存放在地址连续的存储单元里，其数据之间的逻辑关系和物理关系是一样的，例如编程语言中的数组
链式存储结构：经常变化的结构，指的是将数据元素存放在任意的存储单元里，而这组存储单元是可以连续的，也可以是不连续的，数据元素存储关系不能反应其逻辑关系，通过分配一个指针指向一个内存，而这个内存用来存放数据元素的地址，通过内存来寻找相对应的数据元素地址
算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令一个或多个的操作，就是一个解决问题的技巧或者方式
一个问题可以用多个算法解决，但是一个算法不能解决所有问题的能力
算法五个基本特征：输入，输出，有穷性，确定性和可行性
输入：算法具有零个或者多个输入
输出：算法至少有一个或者多个输出
有穷性：指的是算法在执行有限的步骤之后，自动结束，而不是无限循环，要求每一个步骤在一段时间内完成，而不是永远不会停止的
确定性：算法的每一个步骤都具有确定的含义，不会出现二义性（二义性指的是一个东西在一个环境下出来两种或者两种以上的含义）
可行性：算法的每一个步骤必须是可行的，，每一个步骤都可以通过执行有限次数完成
算法设计的要求：
正确性：算法必须要具备输入，输出，无歧义，能正确反应问题的要求，能够得到问题的正确答案
算法没有语法错误，能对合法的输入返回满足要求的输出，对于非法输入能返回满足要求的说明，对于输入的内容要满足其满足要求的输出结果
可读性：算法的另一目的是方便阅读，理解或者交流其算法的实现原理
健壮性：当输入数据不合法时，算法也能做出对应的处理，而不是产生异常，崩溃之类的
时间效率高和存储量低
算法效率的度量方法
算法的效率一般指的是算法的执行时间
事后统计方法：这种方法主要是通过设计好的程序和数据，利用计算机计时器对不同算法的运行时间进行比较，从而达到确定算法效率的高低
缺点：需要根据算法事先编写好测试程序，需要耗费大量时间和精力，不同的测试环境下的效率差异大
事前分析估算方法：在编写程序之前，依据统计方法对算法进行估算
影响算法效率的原因：
算法采用的策略或者方案
代码质量
问题的输入规模
机器执行指令的速度
一个算法程序的运行时间依赖于算法的好坏和问题的输入规模（输入量）
算法的复杂性实际上就是算法因为输入规模扩大而增长量的一个抽象，只关心其实现的算法
函数的渐近增长
最高次项相乘的常数并不重要，可以忽略
所以一个算法存在一个常数，那么这个常数基本上可以忽略
最高次项的指数大的，函数会随着n的增长，结果也会变得增长特别快。指数！！！ 判断一个算法的效率时间，应该忽略函数中的常数和其他次要项，而关注最高项（主项）的阶数
算法的时间复杂度
算法时间复杂度的定义：
在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，T(n) = O(f(n))，表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称为时间复杂度，f(n)是问题规模n的某个函数。
像上面的，用大写O（）来体现算法时间复杂度的记法，我们称之为大O记法。
随着输入规模n的增大，T(n)增长最慢的算法为最优算法
简称为执行次数等于时间
分析一个算法的时间复杂度（推导大O阶方法）：
用常数1取代运行时间中的所有加法常数
在修改后的运行次数函数中，只保留最高阶项
如果最高阶项存在且不是1，则去除于这个项相乘的常数</description>
    </item>
    
    <item>
      <title>JavaScript基础学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/46/</link>
      <pubDate>Thu, 24 Jun 2021 07:57:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/46/</guid>
      <description>插入js
在html页面使用js
引用js文件</description>
    </item>
    
    <item>
      <title>Grid布局学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/45/</link>
      <pubDate>Wed, 23 Jun 2021 10:29:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/45/</guid>
      <description>grid 布局
grid布局和flex布局类似，不过grid是最强大的css布局方式
grid布局是网格布局
display: grid; // 定义grid布局，默认为块级元素
display: inline-grid // 设置为行内元素
设置为grid布局后，容器的子元素的float（浮动），display: inlne-block（行内块级元素），display: table-cell（表格单元格），vertical-align（垂直对齐方式）之类的全部都会失效
列宽和行高的设置
grid-template-columns: 100px; // 列宽
grid-template-rows: 100px; // 行高
数值也支持百分比
grid-template-columns: repeat(3, 100px); // 列宽，重复次数为3，重复的值为100px，和下面效果是一样的
grid-template-columns: 100px 100px 100px;
grid-template-rows: repeat(auto-fill, 100px); // 行高，自动填充容器，行高为100px
grid-template-rows: 1fr 2fr; // 行高，第二个的行高是第一的2倍
grid-template-rows: minmax(100px, 300px); // 生成一个长度范围，长度在这个范围内，两个参数分别代表最小值和最大值，这里表示的是行高不小于100px，不大于300px
grid-template-rows: auto; // 由浏览器决定行高
grid-template-columns: [a1] 100px [a2] 100px [a3] auto; // 方括号[]内的的值是用于指定网格的名称
grid-template-columns: 20% 60% 20%; // 左栏20%，中间60%，右栏20%，如果是重复的值搭配repeat使用更佳
grid-row-gap: 10px; // 行间距（行与行的距离）</description>
    </item>
    
    <item>
      <title>一些常用的进制转换方法</title>
      <link>http://chenjunlinabc.github.io/posts/43/</link>
      <pubDate>Sun, 20 Jun 2021 20:07:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/43/</guid>
      <description>除2取余，逆序排列
十进制（整数）转二进制一般使用&amp;quot;除2取余，逆序排列&amp;quot;法：
1.先使用2整除2进制，得到商和余数
2.然后再使用2整除商，得到新的商和余数
3.如此反复进行，直到商为0时为止
4.把先得到的余数作为二进制的低位，后得到的余数作为二进制的高位，依次排列
注意：最左边是高位，最右边是低位
例子： 100/2 = 50余 0 50/2= 25余 0 25/2=12余 1 12/2=6余 0 6/2 = 3余 0 3/2 =1 余 1 1/2=0余 1
所以100的二进制为1100100
小数转二进制
乘2取整，顺序排列</description>
    </item>
    
    <item>
      <title>记录一次MIME类型错误</title>
      <link>http://chenjunlinabc.github.io/posts/39/</link>
      <pubDate>Thu, 17 Jun 2021 08:25:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/39/</guid>
      <description>打开网页，发现css没有加载出来，f12一看，content-type: text/plain;，把这个css当文本输出了，浏览器请求到这种类型的文件都不会对其进行处理，而且应该是text/css才对
先了解一下浏览器是如何处理这些数据的，是怎么区分的
数据通过http传输协议获取到，然后由web服务器的content-type向浏览器进行指示数据的类型，而mime.types就是用来定义数据文件的类型，用什么格式来进行网页编码（charset=utf-8）
当web服务器接收到请求时，会依据请求文件的后缀名在服务器的MIME配置文件中找到对应的mime.types，然后根据mime.types来确定content-type，浏览器根据content-type来处理数据
解决方法：当然是指定mime.types文件，而宝塔的nginx一般是在/www/server/nginx目录下，而mime.types文件一般在nginx目录下的conf目录下，会看到一个叫mime.types的文件和一个叫mime.types.default的文件
往nginx配置文件上输入 include /www/server/nginx/conf/mime.types; default_type application/octet-stream;
第一个行指定mime.types，第二行就是默认类型
然后重启一下nginx服务器，刷新一下网页，看到恢复成content-type: text/css了</description>
    </item>
    
    <item>
      <title>Nginx服务器的一些简单配置</title>
      <link>http://chenjunlinabc.github.io/posts/34/</link>
      <pubDate>Wed, 16 Jun 2021 15:52:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/34/</guid>
      <description>配置ssl证书
前提是已经申请到ssl证书,并且开放443端口
编辑nginx.conf
将443那几行的注释去掉（#）,并且修改
ssl_certificate &amp;ldquo;crt证书的绝对路径&amp;rdquo;; ssl_certificate_key&amp;quot;key证书的绝对路径&amp;quot;;
如果想访问网站就301重定向到https，那么添加这几行
server{listen 80;server_name cjlio.com;rewrite ^(.*) https://$host$1 permanent;}# 当使用80端口访问网站时，将301永久重定向到https://cjlio.com，达到全站https的效果
然后刷新一下配置nginx -s
nginx反向代理配置
将客户端请求转发给内部网络的其他目标服务端，并且将从其他服务端的结果返回到客户端，代理服务端和目标服务端，在外部看起来像是一个整体，只是将请求转发给其他服务端处理，从而达到减轻目标服务端的压力的效果
配置nginx.conf
location / {proxy_pass https://test.cjlio.com; # 反向代理服务器地址proxy_connect_timeout 200; # 设置连接超时proxy_read_timeout 200; # 设置读响应超时}重启Nginx服务：service nginx restart
请求当前服务器时，当前服务器将请求转发给地址为 https://test.cjlio.com 的服务器处理
gzip压缩
gzip on;gzip_comp_level 1; gzip_min_length 10;gzip_http_version 1.1;gzip_types text/html text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;解释：
gzip on // gzip开启，关闭是off</description>
    </item>
    
    <item>
      <title>Linux环境下简单搭建Minecraft服务器（java版）</title>
      <link>http://chenjunlinabc.github.io/posts/33/</link>
      <pubDate>Wed, 16 Jun 2021 15:46:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/33/</guid>
      <description>服务器可以使用国内的，保证延迟低，服务器配置一定要高一点，不然很容易Killed
安装java
dnf install java-openjdk
检测java是否安装成功
java -version
新建一个目录
mkdir hallomc
cd hallomc
下载第三方mc服务器
wget -c https://papermc.io/api/v2/projects/paper/versions/1.16.5/builds/553/downloads/paper-1.16.5-553.jar
这是1.16.5的版本，服务器版本和客户端版本要一致
历史版本https://papermc.io/legacy
运行mc服务器
java -Xmx1024M -Xms512M -jar paper-1.16.5-553.jar
Xmx 代表服务器启动所占的最大运行内存，Xms代表服务器正常运行的最大内存
一般来说第一次运行都是运行不了，因为没有同意协议
进入mc目录下，nano eula.txt，把eula=false改成eula=true，然后再运行mc服务器
24小时运行mc服务端
一般来说退出ssh登录，就会终止运行mc服务端，可以通过简单建立个“虚拟终端”，来24小时运行
dnf install screen # 安装screen
screen -S mcserver # 创建一个新“终端”，名称自定义
screen -R mcserver # 进入这个新“终端”
如果想退出，可以使用ctrl+a+d
可以使用screen -ls 命令来查看所有“终端”
关闭正版验证
在服务端目录，找到server.properties文件
修改这个文件，把onlinemode 改为 false
MCSManager面板
wget -qO- https://gitee.com/mcsmanager/script/raw/master/setup.sh | bash</description>
    </item>
    
    <item>
      <title>JavaScript的一些基础知识扩展</title>
      <link>http://chenjunlinabc.github.io/posts/32/</link>
      <pubDate>Wed, 16 Jun 2021 15:12:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/32/</guid>
      <description>JavaScript的变量具有动态性的特性，就决定了变量只是用于保存该特定的值的名字
JavaScript中有两种，基本类型值和引用类型值
基本数据类型有数字(Number)，字符串(String)，布尔值(Boolean)，null，undefined，（es6中加入了个symbol）,BigInt(ES2020)
基本类型是按值访问，可以直接操作保存在变量中的值
基本类型值是简单的数据段，而引用类型是指由多个值组成的对象
因为基本类型是按值访问的，所以可以操控保存在变量的值
引用类型的值是保存在内存中的对象，JavaScript不允许直接访问内存中的位置
操控对象，其实就是在操控对象的引用，而不是对象本身
JavaScript的逻辑运算
JavaScript的任何数据类型都能转换为布尔类型
&amp;lt; 小于 &amp;gt; 大于 &amp;lt;= 小于或者等于 &amp;gt;= 大于或者等于 == 没错，这个才是等于，=这个是用来赋值的 != 不等于 === 绝对等于（值和数据类型相等） !== 不绝对等于（值和数据类型其中有一个或者都不相等）
&amp;amp;&amp;amp; 必须都要符合要求
|| 只有一个符合要求
! 真为假，假为真（当判断为true时返回false，判断为false时返回true）
逻辑运算的结果为布尔值
类型判断
数据类型有undefined，null，boolean，number，string，object，symbol，BigInt（ES2020）
undefined，该变量没有被赋值
null，该变量的值为空的对象指针
boolean，该变量的值为布尔值
string，该变量的值为字符串
number，该变量的值为数值
object，该变量为对象或者null
Symbol，生成一个全局独一无二的值
tyoeof操作符会返回该变量的值或者该值是什么数据类型
注意：null值表示一个空对象指针，所以使用typeof操作符检测null时会返回object，typeof个函数，会返回function
typeof判断null之类的不合适，在这种情况可以使用instanceof
instanceof会检查构造函数的prototype属性是否在某个实例的原型链上
例如：
var abc = new testa() if(Object.getPrototypeOf(abc) === testa.prototype){}
instanceof判断null
null instanceof Object // false
返回布尔值,例如
var arr = [1,1,2,3,4,5]; console.log(arr instanceof Array); // 返回true</description>
    </item>
    
    <item>
      <title>node.js包管理工具npm的简单使用</title>
      <link>http://chenjunlinabc.github.io/posts/31/</link>
      <pubDate>Wed, 16 Jun 2021 15:05:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/31/</guid>
      <description>npm是Node.js的默认包管理工具
安装npm：安装node.js(一般来说安装nodejs都会安装npm的)
npm -v 查看npm版本号 node -v 查看node版本号 npm install nmp@latest -g 更新最新nmp，-g全局，没有加-g就是本地安装，或者在@后面加版本号来更新到指定版本的npm npm init -y 初始化 npm i 要安装的依赖 先检查有没有这个东西，有的话就下载下来 npm uninstall 要删除的依赖的名称 npm i 要安装的依赖@版本号 安装指定版本的依赖 npm update 依赖名称 安装最新的依赖或者更新npm npm init -y 使用默认的参数，去掉-y就是手动配置 npm run 对象名 执行脚本,引用package.json中的scripts对象，在对象中添加脚本 npm adduser 注册npm账号 npm publish 发布npm包 npm install 一键安装package.json文件里的所有依赖 npm install &amp;ndash;dependencies 只安装package.json里的dependencies的文件 npm install &amp;ndash;devDependencies 只安装package.json里的devDependencies文件 会自动将package.json中的模块安装到node-modules文件夹
升级插件 npm-check-updates使用 npm install -g npm-check-updates 安装npm-check-updates插件 ncu 查看package.json中依赖的最新版本 ncu -u 更新依赖到最新版本 ncu -a 更新全部依赖到最新版本 npm update</description>
    </item>
    
    <item>
      <title>配置树莓派笔记</title>
      <link>http://chenjunlinabc.github.io/posts/29/</link>
      <pubDate>Wed, 16 Jun 2021 14:48:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/29/</guid>
      <description>（树莓派系统）Raspbian是基于Debian GNU/Linux的免费操作系统，所以可以使用debian的操作方法来配置系统和使用系统
现改名为Raspberry Pi OS
工具：读卡器，16g内存卡，micro usb充电器，树莓派，一台pc
修改为国内镜像源
# 编辑 /etc/apt/sources.list 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspberry-pi-os/raspbian/ buster main non-free contrib rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspberry-pi-os/raspbian/ buster main non-free contrib rpi
# 编辑 /etc/apt/sources.list.d/raspi.list 文件，删除原文件所有内容，用以下内容取代： deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui
使用刻录工具刻录树莓派系统（Win32DiskImager）
使用读卡器读取系统信息，在boot目录新建一个名为ssh的空白文件，用来打开ssh服务，ssh文件不需要存在内容 没有用那么需要手动启动ssh服务：service sshd restart
在boot目录新建一个wpa_supplicant.conf文件
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1
network={ssid=&amp;quot;wifi的名字&amp;quot;psk=&amp;quot;wifi的密码&amp;quot;key_mgmt=WPA-PSKpriority=1}update_config=1，这个用来控制wifi的优先级，只有一个wifi的时候可有可无，没有影响
插入内存卡，连接电源，开启树莓派
Windows10开热点会显示连接设备的ip，wifi路由器的就去路由器后台找
使用ssh工具，连接树莓派，默认用户名：pi，密码：raspberry 修改用户密码：sudo passwd pi pi是要修改密码的用户
修改用户名： vi /etc/shadow 把用户名修改为新用户名，其他不要动 vi /etc/group 把用户名修改为新用户名，其他不要动！！！ 修改完，保存，重启
vnc服务
sudo raspi-config
依次操作：Interfacing Options -&amp;gt; VNC -&amp;gt; Yes</description>
    </item>
    
    <item>
      <title>简单搭建一个hexo博客</title>
      <link>http://chenjunlinabc.github.io/posts/26/</link>
      <pubDate>Wed, 16 Jun 2021 14:36:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/26/</guid>
      <description>hexo+github可以实现免费搭建一个博客网站，就是维护起来有点麻烦
apt install npm
npm install hexo-cli -g
hexo init blog
cd blog
npm install
hexo server
使用NexT
apt install git
git clone https://github.com/theme-next/hexo-theme-next.git
把hexo-theme-next文件夹放到hexo根目录的themes文件夹下
启动主题
打开hexo目录下的_config.yml文件，这个文件为站点配置文件
找到theme，修改值为hexo-theme-next
调试模式
hexo s &amp;ndash;debug 查看是否输出有错误，方便修改错误信息
选择主题
打开主题的根目录的_config.yml文件，这个文件是主题配置文件
找到scheme，需要启动的在前面去掉#注释即可，不需要就加注释#
设置 语言
打开站点配置文件，修改language为需要的语言zh-CN
修改菜单
打开主题配置文件，找到menu，需要用到的菜单就去掉#，不需要就加#
home 主页 archives 归档页 categories 分类页 tags 标签页 about 关于页面 commonweal公益 404
修改对应的语言翻译
主题目录下languages/zh-CN.yml
设定菜单项的图标，可以使用的是Font Awesome 图标
设置 侧栏
打开主题配置文件
修改sidebar.position的值
left - 靠左放置 right - 靠右放置
设置 头像</description>
    </item>
    
    <item>
      <title>css常见布局</title>
      <link>http://chenjunlinabc.github.io/posts/24/</link>
      <pubDate>Wed, 16 Jun 2021 13:23:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/24/</guid>
      <description>居中布局
分水平居中和垂直居中，水平+垂直居中
水平居中：当前元素在父级元素容器中，水平方向是居中显示的
inline-block+text-algin
#app{text-align: center;// 父元素，文本内容居中对齐}.child{display: inline-block;// 子元素，行内块级元素}优点：浏览器兼容性好（css2）
缺点：text-align具有继承性，会导致子元素的文本也是居中的
table+margin
.child{display: table; // 也可以为blockmargin: 0 auto;// 子元素，margin外边距，上下为0，左右为auto（浏览器自动分配）}优点：只需要对子元素设置，就可以实现效果
缺点：如果子元素脱离正常流，将会导致margin属性的值无效化
absolute+transform
#app{position: relative; // 父元素相对定位}.child{position: absolute; // 子元素绝对定位，如果父元素没有定位，那么该元素是相对于页面定位，父元素定位了，那么该元素是相对于父元素的left: 50%; // 相对于父元素左边50% transform: translateX(-50%); // 子元素水平平移-50%（左负数，右正数）}优点：父元素是否脱离正常流，也是不影响子元素的水平居中效果
缺点：transform属性是css3的新属性，浏览器兼容性比较差
垂直居中：当前元素在父级元素容器中，垂直方向是居中显示的
table-cell+vertical-algin
#app{// 父元素display: table-cell;vertical-align: middle; // 设置文本的垂直方向对齐方式}优点：浏览器兼容性好
缺点：vertical-align属性具有继承性
absolute+transform</description>
    </item>
    
    <item>
      <title>jQuery基础学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/21/</link>
      <pubDate>Wed, 16 Jun 2021 09:38:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/21/</guid>
      <description>##第一个jQuery程序
$(&amp;lsquo;div&amp;rsquo;).html(&amp;ldquo;hello.world&amp;rdquo;);
##DOM对象和jQuery对象互转化
jQuery对象和DOM对象是不一样的，但是都能操作DOM
get()方法（jquery对象转化为DOM对象）
var $main =$(&amp;rsquo;.main&amp;rsquo;); // jquer对象
var main = $main.get(0); // 通过get方法，转化成DOM对象
main.style.color = &amp;lsquo;#c7edcc&amp;rsquo;; // 操作DOM对象属性
DOM对象转化为jQuery对象
var main = document.getElementsByClassName(&amp;lsquo;main&amp;rsquo;); // DOM对象
var $main = $(main); // jQuery对象
$main.css(&amp;lsquo;color&amp;rsquo;,&amp;rsquo;#c7edcc&amp;rsquo;); // 操作jQuery对象属性
##jQuery选择器
元素选择器
$(&amp;lsquo;div&amp;rsquo;)
ID选择器
$(&amp;quot;#main&amp;quot;)
id是唯一性，只能在页面中使用一次
类选择器
$(&amp;rsquo;.main&amp;rsquo;)
全选择器
$(&amp;rsquo;*&amp;rsquo;)
层次选择器
$(&amp;lsquo;div .main&amp;rsquo;)
属性选择器
$(&amp;ldquo;a[href=&amp;ldquo;https://cjlio.com&amp;rdquo;]&amp;rdquo;) // 选择带href属性的a元素
可以使用前缀或者后缀来选择 $(&amp;ldquo;div[name^=&amp;ldquo;yes&amp;rdquo;]&amp;rdquo;) // 选择div标签的neme属性值为yes开头的 $(&amp;ldquo;div[name$=&amp;ldquo;yes&amp;rdquo;]&amp;rdquo;) // 选择div标签的neme属性值为yes结尾的
组合选择器
$(&amp;ldquo;div[class=divs]&amp;rdquo;)
组合选择器其实就是用多个选择器组合起来
多项选择器
$(&amp;ldquo;div[class=divs],a[href=&amp;ldquo;https://cjlio.com&amp;rdquo;)
多项选择器就是将多个选择器用逗号组合起来
层级选择器 $(&amp;ldquo;ul.nev li.active&amp;rdquo;)</description>
    </item>
    
    <item>
      <title>MySQL学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/20/</link>
      <pubDate>Wed, 16 Jun 2021 09:37:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/20/</guid>
      <description>推荐使用mariaDB
操作数据库
创建数据库
CREATE DATABASE xxx;
删除数据库
DROP DATABASE xxx;
查看所有数据库
SHOW DATABASES;
查看指定数据库
SHOW xxx;
打开指定数据库
USE xxx;
查看指定数据库的详细信息
SHOW CREATE DATABASE xxx;
修改指定数据库的字符集
ALTER DATABASE xxx CHARACTER SET gbk COLLATE gbk_bin;
数据表的校对规则，与于指定数据集如何排序
COLLATE=utf8_bin
指定字符集
CHARSET=utf8
查看当前mysql所支持的字符集
SHOW CHARACTER SET;
新建数据表
CREATE TABLE xxx(id int(4),email char(20),status int(2),code varchar(10)​ );
添加数据
INSERT INTO xxx VALUES(1,&amp;quot;hallo&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;xxx&amp;quot;);修改数据(根据条件)
UPDATE xxx SET status=1 WHERE id = 4;</description>
    </item>
    
    <item>
      <title>XML学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/17/</link>
      <pubDate>Wed, 16 Jun 2021 09:32:49 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/17/</guid>
      <description>xml中文全称为可扩展标记语言（Extensible Markup Language）
xml和html类似，但是xml是用来传输和存储数据的，xml大小写敏感，xml的标记是自定义的
xml声明，该声明位在xml文档的第一行，结尾
version属性表示xml的版本，encoding属性表示该xml文档的编码方式，standalone属性表示该文档是否为独立，no表示依赖于外部文档
xml的标记也可以像html一样，认为是元素，一般由开始标签，属性，内容，结束标签组成，例如xml
和就是xml文档中的标签（元素），和html一样，可以嵌套n个子元素，如果一个元素没有被嵌套到其他元素上，那么这个元素就是根元素
一般来说一个格式良好的xml文档只有一个根元素，而且根元素是xml文档的第一个元素，如果一个元素没有嵌套子元素也没有内容，那么这个元素为空元素，空元素不需要结束标签，例如
属性是元素的描述和说明，可以使用多个属性，每个属性都有自己名称和值，值用&amp;quot;&amp;ldquo;或者&amp;rsquo;&amp;lsquo;包起来
xml的注释方式和html一样，
DTD约束
XML是自定义标签，浏览器不知道这个标签是用来干什么的，因此制定的一套约束，遵循一定的语法
DTD约束写在一个DTD文件里，dtd导入，例如：
如果导入了本地的DTD文档，那么standalone属性的值不能为yes
DTD除了导入外，还可以内嵌，例如
元素内容包括元素的声明，包括数据类型和符号
PCDATA 中文意思就是被解析的字符数据，会被解析器解析
子元素 例如
空元素 一般用来定义空元素
ANY 表示这个元素没有包含任何字符数据和子元素，例如，在实际开发中，尽量不要使用ANY，除了根元素外，其他使用ANY的元素会失去DTD对XML的约束
符号
问号?:表示该对象可以出现0次或者1次 星号*:表示该对象可以出现0次或者多次 加号+:表示该对象可以出现1次或者多次 竖线|:表示在列出的对象中选择一个 逗号,:表现对象必须按照指定的顺序出现 括号():用于给元素进行分组
DTD除了给定义元素外，也可以为元素定义属性
属性类型指定该属性是属性哪个类型的，属性说明一般用来说明该属性是否必须出现
属性类型
CDTATA // 表示属性类型为字符数据，如果想在属性设置值中出现特殊符号（例如&amp;lt;），那么需要使用其转义字符序列来表示，例如 &amp;ldquo;&amp;lt;&amp;ldquo;来表示&amp;rdquo;&amp;lt;&amp;rdquo;
Enumerated(枚举类型) // 在声明一个属性时，可以限制该属性的取值只能从一个列表中选择，但是在DTD文档中不会出现Enumerated关键字，用法例如：
ID // 表示该属性类型为唯一标识，一个元素只能有一个id类型的属性，而且属性说明必须为REQUIRED或者IMPLIED
IDREF和IDREFS // 一般用来关联元素与元素之间的关系，而且IDREF类型的属性的值必须为一个已经存在的ID类型的属性值，例如：
1 2
说明ID为01和02的元素之间，存在关联
IDREFS就是引用多个ID类型的属性值，例如：
1
属性说明
REQUIRED // 表示这个元素的这个属性是必须的
IMPLIED // 表示这个元素可以包含这个属性，也可以不包含
FIXED // 表示这个固定的属性默认值，不能将该属性的值设置为其他值，使用该说明时还需要提供一个默认值，如果XML没有定义该属性，那么其值就被自动设置为DTD定义的默认值
默认值 // 和FIXED一样，不同的是，这个属性的值可以改变，如果在xml文档中设置了新的值，那么新的值会覆盖DTD定义的默认值</description>
    </item>
    
    <item>
      <title>JavaScript-IntersectionObserver构造函数笔记</title>
      <link>http://chenjunlinabc.github.io/posts/16/</link>
      <pubDate>Wed, 16 Jun 2021 09:29:56 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/16/</guid>
      <description>IntersectionObserver是浏览器本身提供的构造函数，因此可能有一些老版本浏览器没有效果
该构造函数提供了一种异步的监测目标对象和祖先对象或者视口相交的方法
var observe = new IntersectionObserver(callback, options)
例如上面，该函数可以传入两个参数，callback是当可视性发生改变时执行回调函数，options是配置对象
使用该构造函数生成的实例中有3个观察器实例，分别是observe（开始监测），unobserve（停止监测），disconnect（关闭监测），其中observe的参数是dom对象
当监测目标对象的可视性发生改变时调用callback参数中的回调函数
options参数：主要是设置观测的对象和观测值，该参数中有三个键值对
root指的是观测对象的根元素，默认是浏览器视口，值要么是根元素，要么就是观测对象的父元素
rootMargin指的是用于扩大或者缩小视口的大小
threshold指的是交叉的比例，主要决定什么时候触发回调函数，是数组，默认值为0
callback参数中的回调函数一般会被调用两次，一次是当监测对象可视性满足了threshold指定的值，还有一次就是监测对象不满足threshold指定的值
IntersectionObserverEntry对象
该对象提供了监测对象的信息，有七个属性
boundingClientRect：返回目标的矩形信息
intersectionRatio：返回相交时和目标的比例值，不可视时小于等于0
intersectionRect：返回目标和视口相交的矩形信息
isIntersecting：返回目标当前是否可视，可视为true（返回值为布尔值）
rootBounds：返回根元素的矩形信息，没有指定根元素则返回当前视口的矩形信息
target：返回观测的目标对象，是dom对象
time：返回一个记录了从观测开始到交叉被触发时间的的时间戳，单位为毫秒
如果是搞懒加载，那么intersectionRatio和isIntersecting是关键点
例如：
const lazyload = new IntersectionObserver((target)=&amp;gt;{// 实例化target.forEach((item) =&amp;gt;{if (item.intersectionRatio){// 当目标可视item.target.src = item.target.alt; // 进行属性值覆盖lazyload.unobserve(item.target) // 停止观测}})},{rootMargin: &amp;quot;100px&amp;quot; // 提前100px}); const imgs = document.querySelectorAll(&amp;quot;img[alt]&amp;quot;); // 选择带有alt属性的img元素imgs.forEach((item) =&amp;gt; {lazyload.observe(item)// 开始观测}); </description>
    </item>
    
    <item>
      <title>简单理解区块链的基本原理</title>
      <link>http://chenjunlinabc.github.io/posts/15/</link>
      <pubDate>Wed, 16 Jun 2021 09:27:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/15/</guid>
      <description>注意：不推荐去玩比特币以及类似的加密货币，那个玩意说涨就涨，说跌就跌，比特币实质上就是一串数字，没有实物，没有信用背书，当这个巨大泡沫破裂之时，大部分人绝对不可能及时套现跑路，了解比特币下的技术可以，但是绝对不能接触或者玩比特币以及类似的加密货币
1个比特币相当于100000000聪,聪(Satoshi)是比特币目前最小的单位，是为了纪念比特币的创建者中本聪(Satoshi Nakamoto)
在中国唯一值得信赖的加密货币是数字人民币，有国家在做信用背书，是有法偿能力的法定货币，和现金等值
区块链技术诞生于比特币，而比特币的诞生又来源于一位叫中本聪的一篇文章（比特币：一种点对点的电子现金系统）
区块链的一个特点就是去中心化，中心化指的是数据中心化，例如支付宝和微信，那些支付的数据全部集中在数据库中，确保交易用户的余额一增一减
而区块链技术就是把数据全部公开，区块链中的每一个节点都可以获得一份完整的区块链，而且全部都是相同的数据，如果篡改了其中一份数据，那么这份数据会和其他节点的数据对比，如果不相同，那么这份数据是不被其他节点承认的
而需要伪造一个区块链需要拥有超过全网51%的（节点）算力
区块链是一个个区块组成的有序链表，区块中记录着一系列信息，每个区块都指向前一个区块，每个区块都有一个哈希标识（又被称为区块哈希），区块链的不可篡改的特性就是由哈希算法提供的（哈希是单向的，哈希算法可以将一段数据计算出一个哈希值，而哈希值不能反推出加密前的数据，只能暴力穷举）
如果两份数据的哈希值相同，那么这两个哈希值的数据就是相同的，只要改动了原始数据任意的数据，那怕只修改一个字节，都会改变哈希值
常见的哈希算法
MD5：128位，16字节
SHA-1：160位，20字节
SHA-256：256位，32子节
SHA-512：512位，64子节
RipeMD160：160位，20子节
哈希函数：Hash(原始数据) = 摘要数据（哈希值）
比特币使用的哈希算法有两种，一种是双重SHA-256（将数据进行两次SHA-256计算），另一种就是先将数据进行SHA-256计算，再将处理过的数据再进行一次RipeMD160计算
区块的头部有一个Merkle Hash字段，记录了该区块的全部交易的哈希树（全部交易的数据通过哈希算法处理为一个汇总的哈希值）
例如：当一个区块中有好几个交易，然后将一对一对的交易数据做差异哈希算法（dhash），得到两个哈希值，将这两个哈希值拼起来，计算出下一层的哈希值，一层一层计算，最后的得到的哈希值就是Merkle Hash
那么如果每一层是单数，那么将每一层的最后的一个数据复制一份，最后计算出最终值
区块本身使用Merkle Hash来表示，而区块本身的哈希值是没有记录在区块头部的，需要通过计算区块头部的数据得到
区块头部的Prev Hash记录了上一个区块的哈希值（不是Merkle Hash，而是区块本身的哈希值），可以通过Prev Hash来追踪到上一个区块，每个区块的Prev Hash都会指向自己的上一个区块，一直反复下去，一直到区块链的第一个区块（创世区块，该区块没有上一个区块）
从对Merkle Hash的计算方法和对区块头部来追踪到上一个区块的方法得出，只要篡改其中任意一个交易的数据（哪怕是一字节的改动）都会让Merkle Hash验证失败，那么这个区块就是无效的，只能重新计算Merkle Hash，然后这个区块本身的哈希值就改变，因此下一个区块指向该区块的链接也断了
篡改一个区块，需要重新计算这个区块的本身的哈希值，然后将下一个的所有区块全部计算并且伪造，才能篡改整个区块链，难度极高，因为区块链是不断增长的，修改的难度也会越来越难，而挖矿实质上就是重新计算区块头部的哈希值，直到于哈希值匹配，挖矿本身的要求就已经很高了，更不用说篡改整个区块链了
比特币交易中使用了一种名叫点对点交易，就是用户对用户，这个交易的特点就是去中心化，整个交易全部依赖于数学加密
用到一个叫公钥和私钥，地址的概念，公钥是可以根据私钥计算出来的，而私钥就不能通过公钥计算出来，因此私钥很重要，不能泄露
地址的计算方法
Hash(Hash(fun(私钥))) = 地址
而需要不通过泄露私钥的情况下，表明拥有某个私钥，需要用到签名，先将交易信息进行哈希计算，然后签名计算，sign(&amp;lsquo;交易信息的哈希值&amp;rsquo;,&amp;lsquo;私钥&amp;rsquo;)，最后得到一个签名值
而进行付款时，会向区块链的节点进行广播，广播信息包括，交易信息和签名值，而验证签名信息的确是某个私钥的，验证过程例如：
verify(&amp;lsquo;签名值&amp;rsquo;,&amp;lsquo;付款方地址&amp;rsquo;)，获得的值为交易的哈希值
if(verify(&amp;lsquo;签名值&amp;rsquo;,&amp;lsquo;付款方地址&amp;rsquo;) == hash(&amp;rsquo;{交易信息}&amp;rsquo;))
如果当某一个节点验证通过，那么该节点也会进行再一次的广播
交易信息中没有包含任何个人的信息，因此区块链具有匿名性
而比特币的交易是根据私钥来验证的，只要不泄露私钥，那么比特币的账户是安全的，私钥破解，私钥的个数有2的256次方，相当于人类可观测宇宙的原子数，根据当前计算机的计算速度，根本不可能碰撞出来，除非倒霉到碰撞第一次就匹配到了
挖矿：将交易记录，交易的时间，以及序号等等数据进行哈希打包的节点就是矿工节点，而完成哈希打包任务，并且认为其有效的，就会获得比特币奖励
一段时间内只能一个矿工节点成功记账，并且被证明为有效的，这个时间一般为10分钟，奖励比特币的机制为每4年减半
而且需要进行POW工作量证明竞争来获得记账权（也就是传说中的挖矿，因为要进行大量的计算，因此挖矿需要大量的算力，竞争该记账权是具有一定随机性的）
其他节点复制记账结果（也会获得比特币奖励）
POW工作量证明
Hash(上一个Hash值,交易记录集,随机数)= 哈希值
而比特币中有个机制，哈希值要小于某个目标值，因此需要不断修改随机数的值，比特币因为矿工节点越来越多，挖取比特币的难度也会越来越难，难度越难，那么目标值就越小
交易记录集：收集广播中还没有被记录账本的交易，交易的有效性验证，添加给自己转账的交易（挖矿奖励）
目前比特币的共识机制：优先选择工作量最大的区块链，最长的区块链，因此矿工会延长计算，已确保自己是工作量是最大最长的
如果两条链被广播到其他节点，因为网络具有不确定性，有可能某个节点会先收到某个链，在这个链上挖矿，从而导致链出现分叉，如果两个链都同时收到，那么会优先选择工作量最大的区块链，另一个链为备用链保存
解决分叉：如果当前链的上一级链更长的话，优先选择，而短一点的链会被抛弃
分叉分为硬分叉和软分叉
硬分叉：区块链发生永久性改变，在新共识发布后，那些没有更新的节点无法验证已经升级的节点的所产生的区块，改变挖矿难度
软分叉：区块链发生改变，但是不会像硬分叉那样影响没有更新的节点，旧节点会兼容新节点，但是新节点不兼容旧节点而已
解决分叉的方法就是所有矿工都遵从同样的机制（升级机制，保证机制为最新），而且那些没有遵从的就会发生分叉
最经典的例子就是拜占庭将军问题
主要讲的是：拜占庭帝国去攻击一个敌人，派了10支军队，要将这个敌人打败需要至少6支军队，而且必须在分散包围状态下同时攻击，需要依靠通信兵来进行传递信息，但是不清楚这些通信兵或者将军中是否有叛徒，而这些叛徒可能会传递假消息来导致进攻失败，而拜占庭将军们需要在这种分布式下进行传递消息</description>
    </item>
    
    <item>
      <title>JavaScript-XMLHttpRequest对象笔记</title>
      <link>http://chenjunlinabc.github.io/posts/14/</link>
      <pubDate>Wed, 16 Jun 2021 09:25:49 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/14/</guid>
      <description>ajax请求是异步的，因此可以通过回调函数来处理响应
实现ajax请求大多是使用XMLHttpRequest对象，该对象用于与服务器交互，可以在不刷新页面的情况下请求url，获取数据，从而达到更新页面内容的目的
初始化XMLHttpRequest()构造函数，可以获得一个XMLHttpReques实例，例如：
var xmlhttp = new XMLHttpRequest()xmlhttp.onreadystatechange = function(){if(xmlhttp.readyState == 4 &amp;amp;&amp;amp; xmlhttp.status == 200){document.getElementById(&amp;quot;app&amp;quot;).innerHTML = xmlhttp.responseText}}console.log(xmlhttp.readyState) // 0xmlhttp.open(&amp;quot;GET&amp;quot;,&amp;quot;https://httpbin.org/get&amp;quot;,true)console.log(xmlhttp.readyState) // 1xmlhttp.onprogress =function(){console.log(xmlhttp.readyState) // 3}xmlhttp.onload = function(){console.log(xmlhttp.readyState) // 4}xmlhttp.send();XMLHttpReques实例的属性
XMLHttpRequest.readyState：该属性会返回一个XMLHttpRequest的状态，状态有5种，例如：
状态0：已被实例化，但是未调用open()方法 状态1：open()方法已被调用（连接） 状态2：send()方法已被调用（请求） 状态3：请求处理中 状态4：请求完毕，且响应已就绪
XMLHttpReques.onreadystatechange：该属性对应了一个回调函数，当XMLHttpRequest.readyState属性发生改变时，该回调函数就会被调用，例子如上面所示
XMLHttpRequest.response：该属性会返回一个类型，该类型取决于XMLHttpRequest.responseType的值，类型例如：
DOMString：当XMLHttpRequest.responseType的值为空字符串，那么就是DOMString类型（是一个utf-16字符串，默认）
arraybuffer：XMLHttpRequest.responseType的值为存储二进制数据的ArrayBuffer对象（该对象是用于存储二进制数据，不能直接进行操作，只能通过视图来进行操作）
Blob：XMLHttpRequest.responseType的值为包含二进制数据的Blob对象（该对象是用于表示一个类似文件的对象，可以通过二进制的方式进行读取）
Document：值是一个Document
json：值是一个JavaScript对象
text：值是一个DOMString对象表示的文本（utf-16字符串）
XMLHttpRequest.responseText：该属性的值是请求被发送到服务端后，从服务端返回的文本，如果值为null，那么就是请求失败，如果为空字符串，那么就是没有send()
XMLHttpRequest.responseType：该属性会返回一个值，该值和response属性的值一样
XMLHttpRequest.responseURL：该属性会返回一个序列化url，如果url为空那么就返回空字符串
XMLHttpRequest.responseXML：该属性返回Document(html/xml)，如果请求没有成功或者获取的数据，无法解析为html或者xml，那么为null
XMLHttpRequest.status：该属性会返回响应中的http状态码，如果请求没有完成，那么值为0，如果出错也是为0
XMLHttpRequest.timeout：该属性会返回一个值，该值为请求被自动终止前所消耗的毫秒数（默认为0，则表示没有超时）
XMLHttpRequest.upload：该属性是用于表示上传的进度，可搭配事件监听器来追踪进度，例如：
onloadstart：开始获取数据 onprogress：数据正在传输中 onabort：数据获取终止 onerror：数据获取失败 onload：数据获取成功 ontimeout：数据获取操作在规定的时间内未完成 onloadend：数据获取完成（不管是否成功）</description>
    </item>
    
    <item>
      <title>jQuery-ajax()方法笔记</title>
      <link>http://chenjunlinabc.github.io/posts/13/</link>
      <pubDate>Wed, 16 Jun 2021 09:24:37 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/13/</guid>
      <description>ajax()是jQuery中定义的一个方法，该方法用于执行ajax请求，例如：
$(document).ready(function(){$(&amp;quot;button&amp;quot;).click(function(){$.ajax({type: &amp;quot;GET&amp;quot;,url: &amp;quot;https://httpbin.org/get&amp;quot;,success: function(getdata){console.log(getdata)}})})});参数
url：指定发送请求的URL，默认是当前页面
type：指定请求方式（GET或者POST）
success：当请求成功时执行的函数
data：指定要发送到服务端的数据
dataType：预期服务端响应过来的数据类型
async：指定请求是否异步（布尔值）
beforeSend：在发送请求之前执行的函数
cache：指定客户端是否缓存被请求页面，默认是true（布尔值）
complete：在请求完成时执行的函数（不管是否发送成功）
contentType：指定要发送到服务端时使用的内容类型
context：指定所有ajax相关的回调函数规定this值
dataFilter：指定用于处理ajax返回的原始响应数据的函数
error：指定请求失败时执行的函数
global：指定请求是否触发全局ajax事件，默认为true
ifModified：指定是否在最后一次请求
jsonp：指定一个jsonp请求中重写回调函数的字符串
jsonpCallback：指定一个jsonp回调函数的名称
processData：指定是否将请求发送的数据转换为查询字符串，默认为true
scriptCharset：指定请求的字符集
timeout：指定请求超时时间（单位：毫秒）
traditional：指定是否使用传统的方式来序列化数据
username：指定响应http访问认证请求的用户名
password：指定响应http访问认证请求的密码
xhr：用于重写或者增强XMLHttpRequest对象的函数</description>
    </item>
    
    <item>
      <title>原生js实现瀑布流布局</title>
      <link>http://chenjunlinabc.github.io/posts/10/</link>
      <pubDate>Wed, 16 Jun 2021 09:14:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/10/</guid>
      <description>瀑布流的特点就是容器等宽不等高，计算其高度，选择最矮的一个容器的下面将插入第二行的第一个容器，以此类推，因此容器需要设置为绝对定位
首先需要确定一行有多少列，列数 = 页面的宽度 / 容器的宽度
获取页面的宽度：window.innerWidth或者document.documentElement.clientWidth或者document.body.clientWidth
获取页面的高度：window.innerHeight或者document.documentElement.clientHeight或者document.body.clientHeight
页面宽度：.width，容器宽度：.offsetWidth
得到了列数后，还需要得到全部容器的高度，因此还需要用到数组，用来存储容器的高度
遍历全部容器，还需要判断是否到了第二行，i&amp;lt;列数
而第一行的全部容器，设置头部和左边定位，左边定位设置为容器的宽度*i，保证不会被覆盖或者溢出，同时将arr[i].offsetWidth传入新的数组中
然后找到上一行最矮的容器，只需要将全部得到的容器的宽度判断一下就可以，首先假释一下第一个容器就是最矮的，当遍历的容器小于该容器时，那么将该容器设置为当前遍历的容器，而当前遍历的i就是最矮的容器索引值
然后就设置下一行的容器的位置就可以了，头部：最矮的容器的高度，左边：最矮的容器距离页面最左边的宽度
因为已经设置了下一行的容器，因此还需要重新获取一下当前容器的高度，当前容器高度 = 当前容器高度+间隙 +拼接过来的容器的高度
为了体验更好，可以将上面操作封装到一个函数中，当网页加载完毕加执行（window.onload），当页面宽度高度发送变化时也执行(window.onresize)
例如：
var data = document.getElementsByClassName(&#39;imgs&#39;);function datamain(){var datawidtha = window.innerWidth;var datawidthb = Math.floor(data[0].offsetWidth);var dataab = Math.floor(datawidtha/datawidthb);var ints = Math.floor((datawidtha - dataab*datawidthb)/(dataab+1))var arr = [];for(var i=0;i&amp;lt;data.length;i++){if(i&amp;lt;dataab){data[i].style.top = 0;data[i].style.left = (datawidthb+ints) * i + &amp;quot;px&amp;quot;;arr.push(data[i].offsetHeight);}else{var datamin = arr[0];var index = 0;for(var a = 0; a&amp;lt;arr.</description>
    </item>
    
    <item>
      <title>简单解决文本溢出问题</title>
      <link>http://chenjunlinabc.github.io/posts/6/</link>
      <pubDate>Wed, 16 Jun 2021 08:40:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/6/</guid>
      <description>当文本宽度超过容器的宽度那么将导致溢出
使用text-overflow属性会修剪文本导致文本显示不全
这里使用的方法是word-break: break-all+white-space: pre-wrap
word-break: break-all
允许在单词内换行（还有个keep-all属性，用来只能在半角空格和连字符处换行，默认值为normal）
white-space: pre-wrap
normal：默认，空白被忽略
nowrap：文本不换行，文本在同一行继续
pre：保留空格，换行保留，不自动换行
pre-wrap：保留完整空格，保留换行符，自动换行
pre-line：保留空格（可能不完整），保留换行
一个提供换行规则，另一个保证换行的样式还存在（例如换行符，空格等等），而且还提供自动换行功能</description>
    </item>
    
    <item>
      <title>IndexedDB浏览器数据库学习笔记</title>
      <link>http://chenjunlinabc.github.io/posts/5/</link>
      <pubDate>Tue, 15 Jun 2021 19:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/5/</guid>
      <description>IndexedDB是浏览器提供的本地数据库，允许存储数据，采用键值对存储，允许异步请求，允许索引请求，IndexedDB理论上存储空间没有限制
打开（新建）indexedDB：
indexedDB.open()，该方法有俩个值，第一个是数据库名（没有该数据库那么就新建），第二个值为数据库的版本，一般来说默认为1（必须是大于0的自然数），例如：
var datadb = window.indexedDB.open(&amp;quot;data&amp;quot;,1);datadb.onerror = function(){console.log(&amp;quot;数据库打开失败&amp;quot;)}datadb.onsuccess = function(){console.log(&amp;quot;数据库打开成功&amp;quot;);}datadb.onupgradeneeded = function(event){ console.log(&amp;quot;数据库版本升级&amp;quot;);}onerror事件表示打开数据库失败
onsuccess事件表示打开数据库成功
onupgradeneeded事件表示数据库升级（当数据库版本低于指定的数据库版本）（另外，新建数据库，操作新的数据库也可以在该事件中处理）
新建数据对象（数据表）
datadb.onupgradeneeded = function(event) {console.log(&amp;quot;数据库升级&amp;quot;);var objdb = event.target.result.createObjectStore(&amp;quot;abc&amp;quot;,{keyPath: &amp;quot;id&amp;quot;});}表名为abc，主键为id，主键默认为索引
判断是否存在该表
if(!event.target.result.objectStoreNames.contains(&#39;abc&#39;)){var objdb = event.target.result.createObjectStore(&amp;quot;abc&amp;quot;,{keyPath: &amp;quot;id&amp;quot;});}递增属性(可以用于作为主键)
var maindb = event.target.result.createObjectStore(&amp;quot;abc&amp;quot;,{autoIncrement: true});唯一属性
objdb.createIndex(&amp;quot;id&amp;quot;,&amp;quot;id&amp;quot;,{unique: false})createIndex()，三个参数分别是索引名称，索引的属性，配置对象，用来新建索引
添加数据
var datadb = window.indexedDB.open(&amp;quot;data&amp;quot;,1);var db;var objdb;datadb.onupgradeneeded = function(event) {console.log(&amp;quot;数据库升级&amp;quot;);db = event.</description>
    </item>
    
    <item>
      <title>简单了解SEO</title>
      <link>http://chenjunlinabc.github.io/posts/2/</link>
      <pubDate>Sat, 20 Mar 2021 11:50:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/2/</guid>
      <description>SEO：搜索引擎优化（Search Engine Optimization），是利用搜索引擎的规则来提升网站在该搜索引擎的排名（免费，高回报）
robots.txt就是robots协议，用来告诉网络蜘蛛，这个网站什么内容是不应该获取的，那些内容可以获取，例如：淘宝就屏蔽了百度的爬虫
robots.txt文件应该放在网站根目录下
允许指定蜘蛛获取，*为通配符
User-agent: *
允许指定目录可以被获取
Allow: /
指定Sitemap文件在哪
Sitemap: sitemap.xml
不允许指定目录被获取（注意该方法会模糊匹配，例如/adminxxx，也是会被屏蔽）
Disallow: /admin
description（描述）
keywords（关键词）
Sitemap（通知搜索引擎，该网站有哪些可以供爬取的，常见的有xml，html）
HTML标签优化
语义化标签，例如header，nav，footer
内部连接优化
尽量不要使用JavaScript来设置链接，应该使用简单的a href
友情链接
友情链接就是在自己网站上放其他网站的链接，友情链接实质上并不能带来多少访问量，而且是用来增强搜索引擎的收录量爬取量
注意：请不要在友情链接上加rel=&amp;ldquo;nofollow&amp;rdquo;，该属性会告诉搜索引擎爬虫不用抓取目标页，那么这个友情链接就是废了
而且不要乱加友情链接，应该选择高质量，而且内容相似，更新频率高，而且还要有一定的访问量
注意：如果没有必要就不要单向链接，爬虫跑过去，就不会回来了，一直到找到你的链接，通过该链接回来，所以没有必要不要单向链接
尽量避免使用iframe标签，搜索引擎不会抓取iframe标签的内容
重要信息请勿使用js输出，爬虫不会抓取js的内容
给图片加alt信息，重要信息请放头部，有部分搜索引擎爬虫会限制抓取的长度</description>
    </item>
    
    <item>
      <title>欢迎使用 Typecho</title>
      <link>http://chenjunlinabc.github.io/posts/1/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://chenjunlinabc.github.io/posts/1/</guid>
      <description>如果您看到这篇文章,表示您的 blog 已经安装成功.</description>
    </item>
    
  </channel>
</rss>
