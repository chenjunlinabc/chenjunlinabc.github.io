<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.123.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>知政的个人博客</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="知政的个人博客"><meta name=author content="Me"><link rel=canonical href=https://99999.fun/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css rel="preload stylesheet" as=style><link rel=icon href=https://99999.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://99999.fun/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://99999.fun/favicon.ico><link rel=apple-touch-icon href=https://99999.fun/favicon.ico><link rel=mask-icon href=https://99999.fun/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://99999.fun/index.xml><link rel=alternate type=application/json href=https://99999.fun/index.json><link rel=alternate hreflang=en href=https://99999.fun/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="知政的个人博客"><meta property="og:description" content="知政的个人博客"><meta property="og:type" content="website"><meta property="og:url" content="https://99999.fun/"><meta property="og:image" content="https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="知政的个人博客"><meta name=twitter:description content="知政的个人博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"知政的个人博客","url":"https://99999.fun/","description":"知政的个人博客","thumbnailUrl":"https://99999.fun/favicon.ico","sameAs":["https://github.com/chenjunlinabc","mailto:chenjunlinabc123@qq.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://99999.fun/ accesskey=h title="知政的个人博客 (Alt + H)"><img src=https://99999.fun/favicon.ico alt aria-label=logo height=35>知政的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://99999.fun/ title=首页><span class=active>首页</span></a></li><li><a href=https://99999.fun/categories/ title=分类><span>分类</span></a></li><li><a href=https://99999.fun/archives/ title=归档><span>归档</span></a></li><li><a href=https://99999.fun/tags/ title=标签><span>标签</span></a></li><li><a href=https://99999.fun/links/ title=链接><span>链接</span></a></li><li><a href=https://99999.fun/about/ title=关于><span>关于</span></a></li><li><a href=https://99999.fun/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>简单使用Mock.js模拟数据生成器</h2></header><div class=entry-content><p>Mock.js是模拟数据生成器，不需要后端来提供接口数据来进行开发，Mock可以根据数据模板生成随机数据，并且拦截Ajax请求返回模拟数据
安装
npm install mockjs
导入
import Mock from 'mockjs'
通过传入数据模板对象生成数据
const data = Mock.mock({
'list|10': [{
"id|+1": 1,
"name": "@cname",
"age|18-25": 25
}]
})
console.log(data)
配置响应数据（当匹配url的ajax请求时，会根据数据模板生成模拟数据，并且作为响应返回，这里通过axios发送get请求）
const Data = Mock.mock('/api/name','get',{
code: 200,
data: {
'list|10': [{
"id|+1": 1,
"name": "@cname",
"age|18-25": 25
}]
}
})
axios.get('/api/name').then(
res => {
console.log(res.data)
}
)
也可以传入第二个参数，表示匹配的请求是哪个请求方法的
记录数据模板
const Data = Mock.mock('/api/name',(options) => {
return {
code: 200,
options
}
})
axios({method: 'get', url: '/api/name' , data: {'name':'chenjunlin'}})....</p></div><footer class=entry-footer><span title='2022-11-09 12:00:00 +0000 UTC'>2022-11-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 简单使用Mock.js模拟数据生成器" href=https://99999.fun/posts/160/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>计算机图形学学习笔记</h2></header><div class=entry-content><p>计算机图形学(Computer Graphics，CG)是研究图形表达，生成，处理与显示的学科
通过数学算法将二维，三维图形转换成计算机显示器的栅格，例如向量，行列式，矩阵算法等等
图形学历史
1950年，MIT诞生第一个图形显示器（用于Whirlwind（旋风）电子管计算机显示图形），CRT显示器
Whirlwind电子管计算机设计之初是美国空军训练飞行员，半自动地面防空系统（SAGE）
应用CRT和光笔
1958年，双人网球
1960年，William Fetter（威廉﹒费特），创造‘计算机图形学’名词，计算机图形学先驱
1961年，史帝夫﹒罗素（Steve Russell），spacewar游戏
1962年，皮埃尔·贝塞尔（Pierre Bézier），贝塞尔曲线（Bézier curve），绘制曲线
1962年，伊凡·苏泽兰（Ivan Sutherland），Sketchpad绘图应用，计算机图形学之父
1963年，Force, Mass and Motion，https://techchannel.att.com/play-video.cfm/2012/8/20/AT&amp;T-Archives-Force-Mass-Motion
1968年，Ivan Sutherland创造“达摩克里斯之剑”头盔显示器
1968年，Arthur Appel 提出光线投射算法
1973年，Bui Tuong Phong，发明phong shading（Phong着色法）
1974年，Speed Race游戏，第一款赛车游戏
1977年，3D core Graphics System，图形学标准
1980年，NEC µPD7220 GPU，支持1024*1024的显示，普及民用
1996年，Krishnamurthy与Levoy提出法线贴图（Normal Mapping）
1995年，Directx 1.0
1997年，OpenGL 1.1
1999年，Nvidia，Gefprce 256 GPU</p></div><footer class=entry-footer><span title='2022-11-08 12:00:00 +0000 UTC'>2022-11-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 计算机图形学学习笔记" href=https://99999.fun/posts/159/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>WebSocket学习笔记</h2></header><div class=entry-content><p>HTTP1.1协议实质上就是半双工信道，无法同时发送数据和接收数据，而且HTTP连接必须是客户端发起，由服务器来进行处理响应，只有HTTP2.0才是全双工信道（不需要等待响应，就可以发送第二个报文）
WebSocket是全双工信道，而且还支持服务端主动发送数据给客户端，是服务器推送技术（还是需要客户端发起连接）
WebSocket协议是应用层协议，而且是建立在TCP协议上，端口也是使用443和80，握手使用HTTP协议，浏览器不会限制WebSocket的同源
WebSocket客户端配置
WebSocket构造函数，用来创建WebSocket实例
const ws = new WebSocket(‘ws://127.0.0.1’)
WebSocket.readyState实例具备4种状态，该属性是只读的，用来表示连接WebSocket服务端的状态，分别是：0（正在连接），1（连接完成并且可以通信），2（连接正在关闭），3（连接已经关闭或者连接失败）
WebSocket.onopen是指定连接成功后执行的回调函数
WebSocket.onerror是指定连接失败后执行的回调函数
WebSocket.onclose是指定连接关闭后执行的回调函数
WebSocket.onmessage是指定从服务器获取信息时执行的回调函数
可以指定WebSocket.binaryType来指定传输的数据类型，数据类型有2种，分别是blob和arraybuffer
客户端配置例如：
const ws = new WebSocket('ws://localhost:8080')
ws.onopen = () =>{
console.log("连接中")
ws.send('hallo word') // 向服务端发送数据
}
ws.onerror = () =>{
console.log('连接失败')
}
ws.onmessage = (evt) =>{
console.log('连接成功，正在获取数据')
if(typeof evt.data === String){
console.log('hallo'+evt.data)
}else if(evt.data instanceof ArrayBuffer){
let data = evt.data
console.log('数据：'+data)
}
ws.close() // 手动关闭连接
}
ws.onclose = () =>{
console.log('连接已关闭')
}
还有WebSocket.bufferedAmount属性，也是只读，用于返回WebSocket..send没有发送到服务端的数据的字节数，为0表示全部数据已传输完毕
WebSocket.url属性可以返回WebSocket实例的URL绝对路径，只读...</p></div><footer class=entry-footer><span title='2022-11-05 14:00:00 +0000 UTC'>2022-11-05</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WebSocket学习笔记" href=https://99999.fun/posts/158/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>简单使用Element Plus组件库</h2></header><div class=entry-content><p>Element Plus是基于vue3开发的组件库，而Element使用vue2开发的组件库
安装Element Plus
npm install element-plus –save
或者
yarn add element-plus
导入Element Plus
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
按需导入
安装插件
npm install -D unplugin-vue-components unplugin-auto-import
如果是使用Vite则配置vite.config.ts文件
导入并且启用插件
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
...
plugins: [
AutoImport({
resolvers: [ElementPlusResolver()],
}),
Components({
resolvers: [ElementPlusResolver()],
}),
],
这个组件库还支持module导入的方式手动按需使用，例如：
&lt;template>
&lt;el-button>I am ElButton&lt;/el-button>
&lt;/template>
&lt;script>
import { ElButton } from 'element-plus'
export default {
components: { ElButton },
}
&lt;/script></p></div><footer class=entry-footer><span title='2022-11-03 17:40:00 +0000 UTC'>2022-11-03</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 简单使用Element Plus组件库" href=https://99999.fun/posts/157/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>计算机网络学习笔记</h2></header><div class=entry-content><p>计算机网络是通用，可编程的硬件组成的，并且这些设备可互连，并且可以传输不同类型的数据
计算机网络不是只有软件概念，还有硬件设备，例如：网卡，网线，路由器等等
网络作用范围：广域网（WAN），城域网（MAN），局域网（LAN）
计算机网络发展历史
ARPANET（1969年，美国国防部创建的单个网络）
三层结构互联网（现代互联网雏形，当时主要用于连接美国学校，实验室的计算机，主干网，地区网，校园网）
多层次ISP互联网（ISP指网络服务提供商（Internet Service Provider），常见网络服务提供商有中国移动，中国电信，中国联通等等）
多层次ISP互联网，分主干ISP（主要跨国通信），地区ISP（主要局部地区通信，例如广东移动，北京电信等等）
中国创建了多个公共互联网，例如：中国电信互联网（CHINANET），中国移动互联网（CMNET），中国联通互联网（UNINET），中国教育与科研计算机网（CERNET），中国科学技术网（CSTNET）等等
计算机网络层次结构（确保数据通信顺通，识别目标计算机的状态，数据是否存在错误）
层次结构大概分3个，网络应用，数据通信，物理网络
层次细分的话，有七层，也就是OSI七层模型（OSI国际标准定义的），而且每个层都是独立的（不干预其他层），只完成不同的工作
OSI七层模型：应用层（为计算机提供服务），表示层（数据处理），会话层（管理通信会话），传输层（管理通信连接），网络层（数据路由），数据链路层（管理节点之间的数据通信，例如传输数据到另一个局域网），物理层（计算机物理设备）
OSI七层模型并没有成为广泛使用的标准，而是采用TCP/IP四层模型
TCP/IP四层模型：应用层（对于OSI七层模型的应用，表示，会话，HTTP协议），传输层（OSI七层模型的传输层，TCP/UDP协议），（OSI七层模型的网络层，IP/ICMP协议）网络层，（数据链路层和物理层，ARP/RARP协议）网络接口层
计算机网络性能指标
bps=bit/s，1秒多少比特位，比特率
时延：发送时延（数据bit除以bps），排队时延（数据等待被网络设备处理的时间），处理时延（数据到达目标机器后处理需要的时间），传输时延（传输路径除以bps）
总时延 = 发送时延+排队时延+传输时延+处理时延
往返时间RTT（Route-Trip Time）：数据报文在通信中来回一次的时间（可通过ping命令来查看RTT）
物理层（连接不同的物理设备，传输比特流）
物理层传输介质：双绞线（又分屏蔽和无屏蔽，区别就是增加了一层屏蔽层），同轴电缆，光纤（通过光传输，光纤内部是具有高折射率的纤芯，能折射光）
电缆使用铜作为传输介质，光纤通过光来作为传输介质
铜线中的电信号传播速度大约为2.3*10^8m/s
光纤中光信号的传播速度是2.0*10^8m/s
因此实质上电缆的传播速度比光纤快，因为光纤是利用光的反射来传输到远方的，实质光走的距离更长
但是电缆的铜在远距离的情况下，会导致衰减（主要有2个原因导致，介质损耗（通过电磁波传导，会在介质中产生电场的电荷规则排序，这会消耗能量）和导线损耗），需要通过中继器来延续信号
因此在跨市，跨城，跨省，跨国使用都是光纤（光纤的带宽比电缆好，也是一个原因），但是短距离，得益于电缆的传播速度，会更好，因此局域网内部大多使用电缆来传输（因为解析光信号，还需要个光信号调制调解器，计算机无法直接使用光纤传输的数据）
比特流：通过高低电平来表示比特流，来传输数据
信道（往一个方向传输信息的媒体，一个通信电路最少要有一个发送信道和接收信道）
信道的分类：单工通信信道（只能往一个方向通信的信道，没有反馈的信道，例如电视机的电视闭路线），半双工通信信道（可以发送和接收信息，但是不能同时发送，同时接收），全双工通信信道（可以同时发送，同时接收）
物理层会实现信道分用复用技术（提升信道的利用率）
频分复用，时分复用，波分复用，码分复用
数据链路层（封装成帧，透明传输，差错监测）
数据帧：数据链路层中数据的基本单位，数据发送方会在网络层的一段数据的前后添加特定标记，而这一段数据就是数据帧，数据接收方根据特定标记来识别数据帧，是数据链路层内部数据处理成帧
数据帧也分MAC帧（没有帧尾，因为MAC帧之间是96比特时间，帧头也是没有的，而是让物理层给MAC帧添加8bts的前导码），PPP帧（有帧头和帧尾，帧头到帧尾就是这个帧的长度）
封装成帧：数据链路层会将网络层交付的数据报文添加帧头和帧尾，让其成为帧
帧头和帧尾都是特定的控制字符（比特流），帧头（SOH）：00000001，帧尾（EOT）:00000100
透明传输：数据链路层对网络层提供的数据没有限制（控制字符在帧数据中，但是不会去当成数据去处理，就好像帧头和帧尾不存在一样）
字节填充（对数据内部的数据填充ESC转义字符），比特填充（零比特填充法：在每5个连续的1后面插入比特0）
数据链路层规定了帧的数据的长度限制，就是最大传输单元MTU（Maximun Transfer Unit）
以太网的MTU（MAC帧）是1500字节
路径MTU：由链路中MTU的最小值决定
差错监测：因为物理层只负责传输比特流，没有控制出错的功能，因此数据链路层提供了差错监测的功能
奇偶校验码：在发送的每个字节后加上一位，让字节中为1的数可以是奇数或者偶数，通过奇偶校验来确定数据是否出错，具体可以看https://xiaochenabc123.test.com/archives/77.html这篇文章，讲TCP的可靠性那里
奇偶校验码的缺点就是如果发生2位的出错，就无法校验出来错误
循环冗余校验码CRC（根据传输或者保存的数据来产生固定位数的校验码，校验码再附加到数据的后面）
模二除法：通过异或来表示0或者1，例如00就是0，01就是1，异为1，或为0
选择用于校验的多项式，并且在数据后面添加多个0，添加多个0的数据，通过模二除法来除以校验的多项式的位串，得到的余数将填充到原来数据的添加多个0的位置，来得到可校验的位串
假设校验的多项式为X3+X2+1，那么就是原数据后面添加3个0（添加多少个0取决多项式的最高阶，二进制位的最高位也取决于最高阶（最高幂次）二进制位数等于最高阶+1，这里就是表示的二进制位为4位的二进制数），二进制位串位计算就是1x3+1x2+0x1+1x0，就是1101
例如原数据为1010110，CRC校验码计算就是1010110000除以1101，得到的余数0001就是CRC校验码，在将原来填充0的位置填充CRC，就是10101100001，这个比特流就是要传输的数据
接收数据进行校验通过，传输的数据除以位串，来得到余数，根据余数来进行判断校验（余数为0则表示数据正确）
数据链路层只检测数据的错误，不会进行数据的纠错，数据错了，数据链路层将会丢弃错误的数据或者重新传输数据
MAC地址（物理地址，硬件地址，每个设备都有唯一的MAC地址，用48个比特位来表示，使用16进制）
MAC地址表：映射MAC地址到硬件接口上
以太网协议是数据链路层的协议，以太网协议是局域网技术，以太网协议用于完成相邻设备的数据帧传输
网络层（数据路由，数据在网络传输的路径，跨局域网，跨节点）
路由器的顶层是网络层，没有使用到传输层和应用层
网络层的ip协议，子网划分
虚拟互连网络（物理网络复杂，使用IP协议时，将无需关心物理网络的差异）
网络层利用IP协议来将使用IP协议的计算机连接起来，就好像这些计算机只需要连接一个虚拟互连网络一样，无需关心底层经过了哪些网关，路由器，ISP等等，将专注于数据的转发工作
IP协议
IP地址（v4只有32位，v6有128位），ipv4使用点分十进制表示，使用4组从0到255的数字表示ip地址，ipv6使用冒分十六进制，用8组4位的16进制表示ipv6地址...</p></div><footer class=entry-footer><span title='2022-11-01 12:00:00 +0000 UTC'>2022-11-01</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 计算机网络学习笔记" href=https://99999.fun/posts/156/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://99999.fun/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://99999.fun/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://99999.fun/>知政的个人博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>