<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 小陈的个人博客</title><meta name=keywords content><meta name=description content="Posts - 小陈的个人博客"><meta name=author content="Me"><link rel=canonical href=https://blog.cjlio.com/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.0b739a2e2c5e5656e4bcd5f0b2268d063addaf81d89ec3987d6af8f04decdc97.css rel="preload stylesheet" as=style><link rel=icon href=https://blog.cjlio.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.cjlio.com/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://blog.cjlio.com/favicon.ico><link rel=apple-touch-icon href=https://blog.cjlio.com/favicon.ico><link rel=mask-icon href=https://blog.cjlio.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.cjlio.com/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Posts"><meta property="og:description" content="小陈的个人博客"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.cjlio.com/posts/"><meta property="og:image" content="https://blog.cjlio.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.cjlio.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="小陈的个人博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.cjlio.com/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.cjlio.com accesskey=h title="小陈的个人博客 (Alt + H)"><img src=https://blog.cjlio.com/favicon.ico alt=logo aria-label=logo height=35>小陈的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.cjlio.com/ title=首页><span>首页</span></a></li><li><a href=https://blog.cjlio.com/categories/ title=分类><span>分类</span></a></li><li><a href=https://blog.cjlio.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.cjlio.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.cjlio.com/links/ title=链接><span>链接</span></a></li><li><a href=https://blog.cjlio.com/about/ title=关于><span>关于</span></a></li><li><a href=https://blog.cjlio.com/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://blog.cjlio.com>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>简单利用Electron框架开发桌面端应用</h2></header><div class=entry-content><p>Electron是由github开发的开源框架，允许开发者使用web技术构建跨平台的桌面应用
GUI由Chromium提供，底层通过Nodejs提供，Native API提供桌面端和跨平台的原生功能
Visual Studio Code和Atom都是使用Electron开发的，可以说技术很成熟
但是毕竟是基于Chromium的，打包出来的应用非常大，就算是个halloword，也要几百m
安装Electron
npm install electron –save-dev
全局安装
npm install -g electron
新建项目，并且在该目录下建立index.html文件和main.js
mian.js是Electron应用的配置文件
导入electron模块
var electron = require(’electron')
创建Electron引用
var app = electron.app
创建窗口引用
var BrowserWindow = electron.BrowserWindow
声明主窗口
var mainWindow = null
设置参数
app.on('ready',()=>{ mainWindow = new BrowserWindow({ // 设置窗口大小 width:500, height:500, webPreferences:{ nodeIntegration: true // 是否集成node } }) mainWindow.loadFile('index.html') // 指定窗口加载那个页面 mainWindow.on('closed',()=>{ mainWindow = null // 监听销毁事件，事件触发关闭主窗口，设置为null }) }) 初始化
npm init –yes...</p></div><footer class=entry-footer><span title='2021-08-25 12:00:00 +0000 UTC'>2021-08-25</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 简单利用Electron框架开发桌面端应用" href=https://blog.cjlio.com/posts/91/></a></article><article class=post-entry><header class=entry-header><h2>React Hooks学习笔记</h2></header><div class=entry-content><p>React Hooks提供了新特性来给纯函数组件可以管理状态
学过react都知道纯函数组件没有生命周期钩子，而且还不能更新状态，只有class组件有生命周期钩子和状态
而一个好的组件要有高独立性，高可复用性，而class组件本身就是有状态，因此要复用起来比较麻烦，而且还有个this缺陷
React Hooks的出现，是因为类组件会继承React.Component父类，而React.Component父类拥有大量的方法和属性，在开发一些小型组件时，完全没有必要用到这么多的方法和属性，就好吧杀鸡用屠龙刀一样，可以但是没有必要，而纯函数组件就不存在这些方法和属性，可谓是轻量级
例如：
class组件：
class Hi extends React.Component{ constructor(props) { super(props) this.state = { count:0 } } render(){ console.log(this.state.count) return( &lt;div> &lt;p>数据：{this.state.count}&lt;/p> &lt;button onClick={this.addGo.bind(this)}>GO&lt;/button> &lt;/div> ) } addGo(){ this.setState({count:this.state.count+1}) } } 那么函数组件+React Hooks怎么实现状态更新呢？
而function组件想更新状态可以通过React Hooks来实现，例如：
例如：
import React, { useState } from 'react' function Hi(){ const [ count , setCount ] = useState(0) return ( &lt;div> &lt;p> 数据：{count} &lt;/p> &lt;button onClick={()=>{setCount(count+1)}}>GO&lt;/button> &lt;/div> ) } 没错就是这么简单，看起来函数组件+React Hooks更简洁，更容易理解...</p></div><footer class=entry-footer><span title='2021-08-20 23:00:00 +0000 UTC'>2021-08-20</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to React Hooks学习笔记" href=https://blog.cjlio.com/posts/90/></a></article><article class=post-entry><header class=entry-header><h2>Markdown基础语法笔记</h2></header><div class=entry-content><p>Markdown是一个标记语言，常用于编写文档
标题
一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 分别对别h1到h6
段落
斜体文本
斜体文本
粗体文本
粗体文本
粗斜体文本
粗斜体文本
分割线
删除线
hallo
脚注
列表
列表 列表 列表 1.列表
区块
xxx 代码
xxx
xxx
链接
chenjunlin
图片
表格
xxx xxx yyy yyy yyy yyy :-表示左对齐，-:表示右对齐，:-:表示居中对齐
转义
*</p></div><footer class=entry-footer><span title='2021-08-18 16:50:00 +0000 UTC'>2021-08-18</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Markdown基础语法笔记" href=https://blog.cjlio.com/posts/88/></a></article><article class=post-entry><header class=entry-header><h2>简单使用Vite-前端构建工具</h2></header><div class=entry-content><p>Vite是由 Vue.js 的作者尤雨溪开发完成的一款前端项目构建工具，使用原生ESM文件，支持热重载
Vite在法语中的意思为快速的（尤大是真喜欢法语啊）
基于原生 import 的，使用浏览器来解析import，服务端按需编译返回，支持热更新模块
依赖于Rollup打包，虽然vite设计初衷是为了vue3.x的，但是也是支持其他框架（例如react）
对于TypeScrip的支持程度相当好，只需要在script元素加lang=“ts"就可以使用ts了
至于less，sass/scss之类的css预处理器以及css原生支持也是很好，Vite支持css样式直接引入（import ‘./app.css’）
sass/scss使用（前提已经安装了sass）
在style元素中加lang=“scss"就可以使用sass了
json也是可以直接引入，例如：import data from ‘./data.json’
另外对于JSX也是支持的，用.jsx表示jsx，例如：import App from ‘./App.jsx’
vite有一套开发服务功能，基于原生es模块，ESM+HMR，而且还有一套项目构建指令，用rollup打包
打包：指的是使用工具来抓取和处理源码模块，并且合成可以在浏览器上运行的文件（浏览器本身并不提供模块管理的机制，多模块需要很多的script标签，很繁琐臃肿，而打包就很好的解决了这个问题）
常见的打包工具例如：webpack，rollup，parcel，gulp
注意：当冷启动服务的时候，必须要先抓取并且构建应用（当应用越来越大，模块越来越多的时候，会导致服务启动缓慢），才能提供服务，而且进行模块更新的话，也会导致重建应用缓慢
传统打包，是将多个模块打包成单一的文件，而esm打包，是根据http请求，来获取相应的route，再根据route来获取module（避免一开始就获取全部module）
vite将模块分为依赖和源码，依赖指的是开发时不会发生改变的，vite将使用esbuild预构建依赖，而且将以原生ESM方式让浏览器接管打包源码
构建Vite项目
npm init vite-app demo
或者
yarn create vite-app demo
然后初始化一下
npm install
或者
yarn
启动服务器
vite
或者
npm run dev，yarn dev
本地预览
vite preview
打包
vite build
react
npm init vite-app –template react
npm install</p></div><footer class=entry-footer><span title='2021-08-18 14:20:00 +0000 UTC'>2021-08-18</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 简单使用Vite-前端构建工具" href=https://blog.cjlio.com/posts/87/></a></article><article class=post-entry><header class=entry-header><h2>简单使用Nginx</h2></header><div class=entry-content><p>Nginx是目前web服务器占比第一（在https://w3techs.com 中可以看到Nginx占比33.1%）
安装
编译安装
apt install -y gcc gcc-c++ pcre pcre-devel openssl openssl-devel zlib zlib-devel
wget http://nginx.org/download/nginx-1.18.0.tar.gz
tar -zxvf nginx-1.18.0.tar.gz
cd nginx-1.18.0
make &&make install
一键安装（不推荐）
apt install nginx
检查是否安装完毕
nginx -v
nginx配置文件nginx.conf解读，一般在/etc/nginx下
user root; // nginx运行用户 worker_processes auto; // nginx进程数，一般会设置和CPU核数一致 error_log /www/wwwlogs/nginx_error.log crit; // 错误日志存储位置 pid /www/server/nginx/logs/nginx.pid; // 进程PID存储位置 events{ worker_connections 51200; // 单个后台进程的最大并发数 multi_accept on; // 一个进程可以同时接受所有的新连接，关闭（off）的话一个进程只能接收一个连接，默认值为off关闭 } http{ include mime.types; // 文件扩展和类型的映射表 default_type application/octet-stream; // 默认文件的类型 server_names_hash_bucket_size 512; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 50m; gzip on; // 开启gzip压缩 gzip_min_length 1k; // 设置允许压缩的最小的字节数，这里设置1k，就是只有超过1k的文件才会被压缩 gzip_buffers 4 16k; // 以16k为单位，以16k的4倍申请存储gzip压缩的数据流内存 gzip_http_version 1....</p></div><footer class=entry-footer><span title='2021-08-18 12:50:00 +0000 UTC'>2021-08-18</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 简单使用Nginx" href=https://blog.cjlio.com/posts/85/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.cjlio.com/posts/page/9/>« Prev</a>
<a class=next href=https://blog.cjlio.com/posts/page/11/>Next »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://blog.cjlio.com>小陈的个人博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>