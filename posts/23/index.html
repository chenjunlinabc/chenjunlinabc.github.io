<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>vuejs基础学习笔记 | 小陈的个人博客</title><meta name=keywords content="vuejs"><meta name=description content="vuejs的核心层就是只关心视图层的，本笔记使用的是最新版本的vue3
vue全家桶：Vue+VueRouter+Vuex
vue名字来源于法语（中文翻译为视图），可以看出其对视图层的重视
导入一般都是使用cdn导入或者直接下载vuejs进行托管，也可以使用npm安装或者使用官方的CLI来构建一个应用
https://unpkg.com/vue@next
cjs版本：完整版，包含编译器
prod.js都是开发版，代码进行了压缩
global版本：可以直接通过scripts标签导入，会建立一个全局Vue对象
browser版本：包含esm,浏览器模块
bundler版本：该版本不是完整版，min
vuejs模板支持所有JavaScript表达式
vuejs本身是用声明式渲染把数据渲染到html dom中，渲染格式为{{&mldr;}}，例如：
<div id=&#34;app&#34;><p>{{ hallovuejs }}</p></div><script>const hallo ={data() {return {hallovuejs: &#34;hallo vuejs!&#34;}}}Vue.createApp(hallo).mount(&#34;#app&#34;)</script>vue本身携带了一些指令，主要特征就是带有v-前缀，用来渲染html dom上的一些行为，例如：
<div id=&#34;app&#34;><a v-bind:href=&#34;url&#34;>{{ main }}</a></div><script>const hallo ={data() {return {url:&#34;https://xiaochenabc123.test.com&#34;,main: &#34;小陈的辣鸡屋&#34;}}}Vue.createApp(hallo).mount(&#34;#app&#34;)</script>这个v-bind:href，就是将a标签的href属性绑定，v-bind可以绑定任何属性，例如class属性等等，因此可以在视图层留下一些接口指令，让vuejs来响应式渲染出视图
而vue还提供了可以绑定事件的v-on属性，例如：
<div id=&#34;app&#34;><button v-on:click=&#34;go&#34;>{{ main }}</button></div><script>const hallo ={data() {return {main: &#34;hallo&#34;}},methods: {go: function(){console."><meta name=author content="Me"><link rel=canonical href=https://xiaochenabc123.github.io/posts/23/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaochenabc123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xiaochenabc123.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://xiaochenabc123.github.io/favicon.ico><link rel=apple-touch-icon href=https://xiaochenabc123.github.io/favicon.ico><link rel=mask-icon href=https://xiaochenabc123.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="vuejs基础学习笔记"><meta property="og:description" content="vuejs的核心层就是只关心视图层的，本笔记使用的是最新版本的vue3
vue全家桶：Vue+VueRouter+Vuex
vue名字来源于法语（中文翻译为视图），可以看出其对视图层的重视
导入一般都是使用cdn导入或者直接下载vuejs进行托管，也可以使用npm安装或者使用官方的CLI来构建一个应用
https://unpkg.com/vue@next
cjs版本：完整版，包含编译器
prod.js都是开发版，代码进行了压缩
global版本：可以直接通过scripts标签导入，会建立一个全局Vue对象
browser版本：包含esm,浏览器模块
bundler版本：该版本不是完整版，min
vuejs模板支持所有JavaScript表达式
vuejs本身是用声明式渲染把数据渲染到html dom中，渲染格式为{{&mldr;}}，例如：
<div id=&#34;app&#34;><p>{{ hallovuejs }}</p></div><script>const hallo ={data() {return {hallovuejs: &#34;hallo vuejs!&#34;}}}Vue.createApp(hallo).mount(&#34;#app&#34;)</script>vue本身携带了一些指令，主要特征就是带有v-前缀，用来渲染html dom上的一些行为，例如：
<div id=&#34;app&#34;><a v-bind:href=&#34;url&#34;>{{ main }}</a></div><script>const hallo ={data() {return {url:&#34;https://xiaochenabc123.test.com&#34;,main: &#34;小陈的辣鸡屋&#34;}}}Vue.createApp(hallo).mount(&#34;#app&#34;)</script>这个v-bind:href，就是将a标签的href属性绑定，v-bind可以绑定任何属性，例如class属性等等，因此可以在视图层留下一些接口指令，让vuejs来响应式渲染出视图
而vue还提供了可以绑定事件的v-on属性，例如：
<div id=&#34;app&#34;><button v-on:click=&#34;go&#34;>{{ main }}</button></div><script>const hallo ={data() {return {main: &#34;hallo&#34;}},methods: {go: function(){console."><meta property="og:type" content="article"><meta property="og:url" content="https://xiaochenabc123.github.io/posts/23/"><meta property="og:image" content="https://xiaochenabc123.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-16T10:13:00+00:00"><meta property="article:modified_time" content="2021-06-16T10:13:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://xiaochenabc123.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="vuejs基础学习笔记"><meta name=twitter:description content="vuejs的核心层就是只关心视图层的，本笔记使用的是最新版本的vue3
vue全家桶：Vue+VueRouter+Vuex
vue名字来源于法语（中文翻译为视图），可以看出其对视图层的重视
导入一般都是使用cdn导入或者直接下载vuejs进行托管，也可以使用npm安装或者使用官方的CLI来构建一个应用
https://unpkg.com/vue@next
cjs版本：完整版，包含编译器
prod.js都是开发版，代码进行了压缩
global版本：可以直接通过scripts标签导入，会建立一个全局Vue对象
browser版本：包含esm,浏览器模块
bundler版本：该版本不是完整版，min
vuejs模板支持所有JavaScript表达式
vuejs本身是用声明式渲染把数据渲染到html dom中，渲染格式为{{&mldr;}}，例如：
<div id=&#34;app&#34;><p>{{ hallovuejs }}</p></div><script>const hallo ={data() {return {hallovuejs: &#34;hallo vuejs!&#34;}}}Vue.createApp(hallo).mount(&#34;#app&#34;)</script>vue本身携带了一些指令，主要特征就是带有v-前缀，用来渲染html dom上的一些行为，例如：
<div id=&#34;app&#34;><a v-bind:href=&#34;url&#34;>{{ main }}</a></div><script>const hallo ={data() {return {url:&#34;https://xiaochenabc123.test.com&#34;,main: &#34;小陈的辣鸡屋&#34;}}}Vue.createApp(hallo).mount(&#34;#app&#34;)</script>这个v-bind:href，就是将a标签的href属性绑定，v-bind可以绑定任何属性，例如class属性等等，因此可以在视图层留下一些接口指令，让vuejs来响应式渲染出视图
而vue还提供了可以绑定事件的v-on属性，例如：
<div id=&#34;app&#34;><button v-on:click=&#34;go&#34;>{{ main }}</button></div><script>const hallo ={data() {return {main: &#34;hallo&#34;}},methods: {go: function(){console."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xiaochenabc123.github.io/posts/"},{"@type":"ListItem","position":2,"name":"vuejs基础学习笔记","item":"https://xiaochenabc123.github.io/posts/23/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"vuejs基础学习笔记","name":"vuejs基础学习笔记","description":"vuejs的核心层就是只关心视图层的，本笔记使用的是最新版本的vue3\nvue全家桶：Vue+VueRouter+Vuex\nvue名字来源于法语（中文翻译为视图），可以看出其对视图层的重视\n导入一般都是使用cdn导入或者直接下载vuejs进行托管，也可以使用npm安装或者使用官方的CLI来构建一个应用\nhttps://unpkg.com/vue@next\ncjs版本：完整版，包含编译器\nprod.js都是开发版，代码进行了压缩\nglobal版本：可以直接通过scripts标签导入，会建立一个全局Vue对象\nbrowser版本：包含esm,浏览器模块\nbundler版本：该版本不是完整版，min\nvuejs模板支持所有JavaScript表达式\nvuejs本身是用声明式渲染把数据渲染到html dom中，渲染格式为{{\u0026hellip;}}，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;p\u0026gt;{{ hallovuejs }}\u0026lt;/p\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rhallovuejs: \u0026quot;hallo vuejs!\u0026quot;\r}\r}\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\rvue本身携带了一些指令，主要特征就是带有v-前缀，用来渲染html dom上的一些行为，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;a v-bind:href=\u0026quot;url\u0026quot;\u0026gt;{{ main }}\u0026lt;/a\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rurl:\u0026quot;https://xiaochenabc123.test.com\u0026quot;,\rmain: \u0026quot;小陈的辣鸡屋\u0026quot;\r}\r}\r}\rVue.createApp(hallo).mount(\u0026quot;#app\u0026quot;)\r\u0026lt;/script\u0026gt;\r这个v-bind:href，就是将a标签的href属性绑定，v-bind可以绑定任何属性，例如class属性等等，因此可以在视图层留下一些接口指令，让vuejs来响应式渲染出视图\n而vue还提供了可以绑定事件的v-on属性，例如：\n\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;button v-on:click=\u0026quot;go\u0026quot;\u0026gt;{{ main }}\u0026lt;/button\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;script\u0026gt;\rconst hallo ={\rdata() {\rreturn {\rmain: \u0026quot;hallo\u0026quot;\r}\r},\rmethods: {\rgo: function(){\rconsole.","keywords":["vuejs"],"articleBody":"vuejs的核心层就是只关心视图层的，本笔记使用的是最新版本的vue3\nvue全家桶：Vue+VueRouter+Vuex\nvue名字来源于法语（中文翻译为视图），可以看出其对视图层的重视\n导入一般都是使用cdn导入或者直接下载vuejs进行托管，也可以使用npm安装或者使用官方的CLI来构建一个应用\nhttps://unpkg.com/vue@next\ncjs版本：完整版，包含编译器\nprod.js都是开发版，代码进行了压缩\nglobal版本：可以直接通过scripts标签导入，会建立一个全局Vue对象\nbrowser版本：包含esm,浏览器模块\nbundler版本：该版本不是完整版，min\nvuejs模板支持所有JavaScript表达式\nvuejs本身是用声明式渲染把数据渲染到html dom中，渲染格式为{{…}}，例如：\n{{ hallovuejs }}\nvue本身携带了一些指令，主要特征就是带有v-前缀，用来渲染html dom上的一些行为，例如：\n{{ main }}\r这个v-bind:href，就是将a标签的href属性绑定，v-bind可以绑定任何属性，例如class属性等等，因此可以在视图层留下一些接口指令，让vuejs来响应式渲染出视图\n而vue还提供了可以绑定事件的v-on属性，例如：\n{{ main }}\rv-on可以绑定多个事件，例如：\n{{ main }}\rv-model可以进行数据的双向绑定，不但可以赋予元素中的数据，也可以获取元素中的数据，例如：\n{{ main }}\rv-show可以根据表达式的值来判断是否显示，方法和v-if一样，但是隐藏的方法是加上了display: none;，v-show不支持template和v-else，如果没有频繁切换的需求可选择v-if，频繁切换会重新渲染情况严重，而且v-show只是修改css属性而已\nv-if可以进行条件判断，会根据表达式的值来判断，例如\n{{ main }}\r当值为false时，该元素就会被隐藏\nv-else 该指令必须跟着v-if或者v-else-if指令的元素的后面，否则不会被识别，例如：\n{{ main }}\r这是v-if判断为假时渲染，v-if判断为真时不渲染\rv-else-if，必须前面的元素中有v-if或者v-else-if指令，例如：\nyes_no == yes\ryes_no == no\ryes_no != no||yes\rv-for可以多次渲染元素，例如：\n{{a}}\r注意：当v-for和v-if出现在同级时，v-for优先级比v-if高，因此不要在v-for下，使用v-if过滤，应该在v-if下使用v-for，v-if应该使用（不会创建dom元素）\nv-html可以插入html\nv-once表示该元素或者组件只渲染一次，后面不会因为数据的改变而重新渲染\n动态参数的实现\nconst hallo = {\rdata() {\rreturn {\rmain: \"hallo\",\rabc: \"classa\"\r}\r},\rtemplate: `hallo word`\r}\rVue.createApp(hallo).mount(\"#app\")\rvuejs提供了一个叫组件的概念，将重复的程序进行封装，用这些被封装的组件来构建大型应用，可以理解为积木\n根组件：挂载应用时，该组件被认为是渲染的起点\n如果想挂载一个应用到id为app的dom元素中，那么就需要挂载#app，通过一个vue实例，调用其component()方法，创建一个组件\n上面简单说明了一下组件的概念,下面详细说明一下组件和组件实例\n页面是这些组件的容器，因此，组件在页面中表达出来的是原生html\n模板（template）：模板定义了数据和html dom的绑定关系\n初始数据（data）：组件的初始数据，组件具有作用域，因此是处于封装私有状态的\n接收的外部参数（props）：组件之间通过该参数进行数据的传递和分享(单向，只能从父组件中获取，不能进行修改,父传子)\n方法（methods）：对数据的改动一般都在组件的方法内进行操作，通过v-on指令把输入事件和组件方法进行绑定\n生命周期钩子（lifecycle hooks）：每个实例都会触发多个生命周期钩子，从创建到废弃的过程就是生命周期，可以在不同时候进行逻辑处理，另外还有组件生命周期\n组件：一种对数据和方法的封装\nmount()返回的是组件实例\n组件实例：组件继承于组件，通过createApp()建立组件实例\n当需要进行数据计算处理时，例如将两个数据合并，如果通过正常的表达式来表示，那么一旦数据处理复杂了，程序会显得很繁杂，vuejs中提供了一个叫计算属性的东西，例如：\n{{hallo}}\r样式绑定\n组件是可重复使用的实例，例如：\nconst app = Vue.createApp({})\rapp.component(\"test\",{\rdata() {\rreturn {\rabc: \"hallo\"\r}\r},\rtemplate: `\r{{abc}} word\r`\r})\rapp.mount(\"#app\")\r全局组件\n一般来说组件的数据是独享的，只有全局组件才能进行数据访问，例如：\nconst app = Vue.createApp({\rtemplate: `\r`\r// 父组件\r})\rapp.component(\"test\",{\rtemplate: ``\r// 全局组件\r})\rapp.component(\"abc\",{\rdata() {\rreturn {\rtext: \"hallo word\"\r}\r},\rtemplate: ` {{text}} ` // 全局组件\r})\rapp.mount('#app')\rabc组件分享了数据给test组件\n局部组件\nconst Test_date ={\rtemplate: \"hallo word\n\"\r// 局部组件\r}\rconst Test_datea ={\rtemplate: \"hallo hhh\n\"\r// 局部组件\r}\rconst app = Vue.createApp({\rcomponents: {\r\"test\" :Test_date\rTest_datea\r}\r}).mount('#app')\r其中test为组件名，指向了Test_date局部组件，\n父子组件之间传递数据\n静态传值只能传字符串类型，如果要传其他数据类型或者想动态传递数据，可以使用v-bind\n通过循环来输出一组数据\n传值校验\nprops中的值进行验证，例如：\nvuejs事件修饰符\n.stop：阻止冒泡事件的发生，只触发自身的事件，一个子元素定义了事件，但是它的父元素也定义了一个事件，而且这两个事件的触发机制还是一样的，那么就会导致这两个事件都触发，而想避免发生就需要在目标元素上的事件加上.stop，例如：\n.prevent：拦截默认事件的发生，有一些标记拥有自身的默认事件，例如a标记，例如：\n{{data}}\r这里阻止了a标记的默认事件\n.capture：捕获事件，当发生冒泡事件时，先触发带有该修饰符的，如果有多个，则从父元素到子元素触发\n触发机制：优先触发带有.capture的，然后再按照从内往外的冒泡\n.self：只有当事件在该元素上时才触发，冒泡和捕获都无法让其触发事件，只要当事件发生在该元素本身才会触发\n.once：指定该绑定的事件只会触发一次\n.stop和.self的区别：.stop会阻止全部冒泡事件，而.self只阻止自身的冒泡\n.passive：每一次发生事件，浏览器都去查询有没有preventDefault来阻止该事件的默认行为，.passive就是来声明，没有使用preventDefault来阻止该事件的默认行为，因为其是告诉没有使用阻止事件的默认行为，所有passive是和prevent冲突，不能一起使用，否则.prevent会被忽略\n因为在移动端，一般都是监听滚动事件比较多，而每移动一次都会触发一次事件，会进行查询有没有使用prevent，可能会导致滑动卡顿，使用passive能有效提升移动端的性能和流畅度\n生命周期钩子函数会在某一些特定的时刻自动触发，方便在该时刻完成一些工作\nvue实例生命周期\nvue实例的创建，运行，到销毁期间，会触发一些叫生命周期钩子的函数，可以通过该来监听数据变化\n按照生命周期排序：\nbeforeCreate：实例刚刚初始化之后，数据观察和事件机制（data 和 methods）都还未初始化，不能获取dom节点\ncreated：数据观察和事件机制（data 和 methods）都已经初始化，dom节点处理完成，组件未加载\nbeforeMount：实例已经加载完毕，但是还没有执行挂载操作，得不到具体的DOM元素\nmounted：实例已经加载完毕，也执行了挂载操作，DOM已被渲染出来\nbeforeUpdate：处于数据更新之前，data中的值是最新的，但是页面上还是旧的数据，还没有重新处理dom节点\nupdated：处于数据更新之后，data中的值和页面上的数据都已经更新，dom节点也被重新处理\nbeforeUnmount：实例销毁之前，实例还是在可用状态，可使用this获取实例\nunmounted：实例销毁后，数据绑定和事件监听器全部清除，子实例销毁\n例如：\nconst app = Vue.createApp({\rdata(){\rreturn{\rmessage: 'hallo word'\r}\r},\rbeforeCreate() {\rconsole.log(\"beforeCreate\")\r},\rcreated() {\rconsole.log(\"created\")\r},\rbeforeMount(){\rconsole.log(\"beforeMount\")\r},\rmounted() {\rconsole.log(\"mounted\")\r},\rbeforeUpdate() {\rconsole.log(\"beforeUpdate\")\r},\rupdated() {\rconsole.log(\"updated\")\r},\rbeforeUnmount() {\rconsole.log(\"beforeUnmount\")\r},\runmounted() {\rconsole.log(\"unmounted\")\r},\rtemplate: \"{{message}}\"\r})\rlet main = app.mount(\"#app\")\rsetTimeout(()=\u003e{\rmain.$data.message = 'abc' // 挂载3秒后触发更新事件\r},3000)\rsetTimeout(() =\u003e {\rapp.unmount() // 6秒后触发销毁事件\r}, 6000)\r访问组件的生命周期\nvue组件周期\n实例生命周期加on就是组件周期\nbeforeCreate和created统一为setup()\nbeforeMount为onBeforeMout，mounted为onMounted，beforeUpdate为onBeforeUpdate，updated为onUpdated，beforeUnmount为onBeforeUnmount，unmounted为onUnmounted\nsetup：data 和 method 都已经初始化\nonBeforeMount：组件被挂载到dom节点之前\nonMounted：组件被挂载到dom节点完毕\nonBeforeUpdate：组件更新之前\nonUpdated：组件更新之后\nonBeforeUnmount：组件销毁之前\nonUnmounted：组件销毁完毕之后\nonErrorCaptured：当捕获到来自子孙组件的异常时\nonRenderTracked：当虚拟DOM重新渲染时调用\nonRenderTriggered：当虚拟DOM重新渲染被触发时调用\nonActivated：当被包含在中的组件时\nonDeactivated: 当被包含在中的组件发生改变时（例如切换组件，原来的组件销毁时）\n注意：使用的组件会把数据保留在内存中，避免需要重新加载多次数据\n实例的data()是一个函数，并非方法，vue在创建vue的组件实例过程中会调用该函数，以$data的形式进行存储在vue实例中，data中的所有值都可以通过实例来暴露（访问或者修改），例如：\nconst hallo = Vue.createApp({\rdata() {\rreturn {\rhallovuejs: \"hallo vuejs!\"\r}\r}\r}).mount(\"#app\")\rconsole.log(hallo.$data.hallovuejs)\rconsole.log(hallo.hallovuejs)\r方法\nvue允许使用methods向组件实例添加方法\nvue会自动为methods绑定this，使其始终指向组件实例\nmethods一样可以在组件模板中暴露，也可以在模板中用做事件监听\n计算属性\n计算属性和方法的区别就是：计算属性只在其依赖发生变化才重新计算，只要依赖未发生改变，那么就会直接从缓存中获取，不会再执行其函数\n如果使用一个方法来计算时，那么data()返回的值，发生一次改变，事件方法就会重新计算一次，因此涉及计算类的使用计算属性，而不是方法\n例如：\nconst app = Vue.createApp({\rdata() {\rreturn {\rhallovuejs: \"hallo vuejs!\"\r}\r},\rcomputed: {\rhallo(){\rreturn this.hallovuejs == \"hallo vuejs!\" ? \"Yes\" : \"No\"\r}\r}\r}).mount(\"#app\")\rwatch监听器\nwatch接收2个参数，被监听的data()属性值，回调函数，当监听的变量发生改变时，自动执行回调函数，例如\nconst app = Vue.createApp({\rdata() {\rreturn {\rnum: 100\r}\r},\rwatch: {\rnum(current, prev) {\rconsole.log('num发生改变')\rconsole.log(\"改变之后的值:\", current)\rconsole.log(\"改变之前的值:\", prev)\r}\r}\r})\rlet vm = app.mount(\"#app\")\rvm.num = 300\rvm.$data.num = 600\r另外一种使用方法\nconst count = ref(100) watch(count,(current, prev) =\u003e {\rconsole.log('num发生改变')\rconsole.log(\"改变之后的值:\",current)\rconsole.log(\"改变之前的值:\",prev)\r})\rwatch和计算属性的区别：虽然都可以监听data()属性值的改变，但是计算属性会在页面渲染时触发一次，而watch只在被监听的发生改变时触发，而且watch可以得到改变之后的值和改变之前的值\nwatch可以监听多个值\nclass绑定\nvue允许使用:class对象来动态切换class，例如：\n而class的存在取决于键值对的值，允许传入多个值，也可以直接调用对象，例如：\nvue也允许通过数组来传入class，例如：\n同样也允许使用三元表达式，例如：\n始终添加classa，classnav取决已经no的值\nvue也是允许在数组中使用对象来处理\n如果在组件中已经绑定了class，而在调用其又加上其他class，那么就会合并，vue允许在组件中进行:class，如果有多个元素，在调用时绑定class，但是又想指定其class给予某个，可以使用$attrs组件属性，例如：\n上面只有vuejs接收到class\n内联样式绑定（:style）\n例子：\n多重值\n一般来说只会选择最后一个（前提是浏览器支持）\n列表渲染\nv-for可以将一个数组迭代成一组元素\n使用的形式是 item in items，items为数组，item为迭代的元素，例如：\n{{ item.message }}\rin可以用of替代\nv-for也可以使用对象(从某个角度来看，数组也是对象的一种)，例如：\n{{ key }}:{{ item }}\r自定义指令（directive）\nvue允许指定义指令，例如：\n这里的abc指定的是当前元素\n局部指令：组件中接受directives选项\n指令的钩子函数\ncreated：当绑定元素的属性和事件监听器被应用之前调用\nbeforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用\nmounted：绑定元素的父组件被挂载后调用\nbeforeUpdate：更新包含组件的VNode之前调用\nupdated：包含组件的VNode及其子组件的VNode更新后调用\nbeforeUnmount：在卸载绑定元素的父组件之前调用\nunmounted：当指令与元素解除绑定，并且父组件也被卸载时调用一次\n表单输入绑定\nv-model可以用于数据的双向绑定，但是v-model会忽略表单元素的初始值，而使用实例中的数据作为数据源（需要在data中声明初始值）\n复选框的数据绑定返回的是布尔值，也是可以将数据绑定到一个数组中，例如：\nhallo\rabc\rxyz\rdata: {{datas}}\r单选框（radio），数据存放在字符串中，输出的也是字符串（选择框和输入框也是字符串）\n如果想输入或者选择返回的不是字符串，而是其他类型，可以使用v-model.number，当然也是可以进行手动转类型，但是v-model.number可以自动判断输入是否是数字还是字符串\ntrue-value和false-value可以在被选中或者取消选中时触发，例如：\ndata: {{datas}}\rv-model.lazy是v-model数据双向绑定的懒加载，在每次input事件（失去焦点）触发后将输入框的值与数据进行同步\nv-model.trim可以自动过滤掉输入数据的首尾空格\n组件\n全局注册\napp.component\n局部注册\nconst componentA = {}\rcomponents: {\r'component-a': componentA,\r}\r局部注册的组件，在其子组件是不可用的\n通过Props传递数据给子组件\n通过Props共享一些数据，例如：\napp.component('titles', {\rprops: ['title'],\rtemplate: `{{ title }}`\r})\r在上面的例子里，title=“hallo\"被传递数据给模板，任何值的可以传递给props，如果一个值被传递给props属性，那么这个值就成了这个组件实例的共享数据，这个值可以在模板中访问\n监听子组件事件\n使用自定义事件监听子组件，通过子组件事件来告诉父组件应该做什么，例如：\ntemplate: `\rapp\r`\r也可以在组件的emits中列出事件\napp.component({\remits: [\"hallomain\"]\r})\r事件也可以用来返回一个值 app 这个值可以使用$event访问到，事件也可以是指向方法的，用事件来触发方法的使用，例如：@hallomain= “hallo”\n给这个方法定义一下，在methods选项\n组件也可以使用v-model（model-value）\n如果是表单元素，例如input也想用自定义事件，需要将value绑定到props上，当input事件被触发时，就会将value通过自定义事件抛出，例如：\napp.component({\rprops: [\"valueData\"],\remits: [\"hallomain\"],\rtemplate: `\r","wordCount":"1628","inLanguage":"en","datePublished":"2021-06-16T10:13:00Z","dateModified":"2021-06-16T10:13:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaochenabc123.github.io/posts/23/"},"publisher":{"@type":"Organization","name":"小陈的个人博客","logo":{"@type":"ImageObject","url":"https://xiaochenabc123.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaochenabc123.github.io/ accesskey=h title="小陈的个人博客 (Alt + H)"><img src=https://xiaochenabc123.github.io/favicon.ico alt aria-label=logo height=35>小陈的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xiaochenabc123.github.io/ title=首页><span>首页</span></a></li><li><a href=https://xiaochenabc123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://xiaochenabc123.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://xiaochenabc123.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://xiaochenabc123.github.io/links/ title=链接><span>链接</span></a></li><li><a href=https://xiaochenabc123.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://xiaochenabc123.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xiaochenabc123.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://xiaochenabc123.github.io/posts/>Posts</a></div><h1 class=post-title>vuejs基础学习笔记</h1><div class=post-meta><span title='2021-06-16 10:13:00 +0000 UTC'>2021-06-16</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://xiaochenabc123.github.io//posts/vuejs%e5%9f%ba%e7%a1%80%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>vuejs的核心层就是只关心视图层的，本笔记使用的是最新版本的vue3</p><p>vue全家桶：Vue+VueRouter+Vuex</p><p>vue名字来源于法语（中文翻译为视图），可以看出其对视图层的重视</p><p>导入一般都是使用cdn导入或者直接下载vuejs进行托管，也可以使用npm安装或者使用官方的CLI来构建一个应用</p><p><a href=https://unpkg.com/vue@next>https://unpkg.com/vue@next</a></p><p>cjs版本：完整版，包含编译器</p><p>prod.js都是开发版，代码进行了压缩</p><p>global版本：可以直接通过scripts标签导入，会建立一个全局Vue对象</p><p>browser版本：包含esm,浏览器模块</p><p>bundler版本：该版本不是完整版，min</p><p>vuejs模板支持所有JavaScript表达式</p><p>vuejs本身是用声明式渲染把数据渲染到html dom中，渲染格式为{{&mldr;}}，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{ hallovuejs }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data() {
            return {
                hallovuejs: &quot;hallo vuejs!&quot;
            }
        }
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>vue本身携带了一些指令，主要特征就是带有v-前缀，用来渲染html dom上的一些行为，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;a v-bind:href=&quot;url&quot;&gt;{{ main }}&lt;/a&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data() {
            return {
                url:&quot;https://xiaochenabc123.test.com&quot;,
                main: &quot;小陈的辣鸡屋&quot;
            }
        }
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>这个v-bind:href，就是将a标签的href属性绑定，v-bind可以绑定任何属性，例如class属性等等，因此可以在视图层留下一些接口指令，让vuejs来响应式渲染出视图</p><p>而vue还提供了可以绑定事件的v-on属性，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;button v-on:click=&quot;go&quot;&gt;{{ main }}&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data() {
            return {
                main: &quot;hallo&quot;
            }
        },
        methods: {
            go: function(){
                console.log(&quot;hallo vuejs&quot;);
            }
        },
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>v-on可以绑定多个事件，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;goclick&quot;@dblclick=&quot;yesclick&quot;&gt;{{ main }}&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data() {
            return {
                main: &quot;hallo&quot;
            }
        },
        methods: {
            goclick:function(event){
                console.log(&quot;hallo vuejs&quot;)
                console.log(event.target) // event.target可以获取到触发该事件的dom元素
            },
            yesclick:function(){
                console.log(&quot;hallo word&quot;)
            }
        },
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>v-model可以进行数据的双向绑定，不但可以赋予元素中的数据，也可以获取元素中的数据，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input v-model=&quot;main&quot;&gt;{{ main }}&lt;/input&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data() {
            return {
                main: &quot;hallo&quot;
            }
        },
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>v-show可以根据表达式的值来判断是否显示，方法和v-if一样，但是隐藏的方法是加上了display: none;，v-show不支持template和v-else，如果没有频繁切换的需求可选择v-if，频繁切换会重新渲染情况严重，而且v-show只是修改css属性而已</p><p>v-if可以进行条件判断，会根据表达式的值来判断，例如</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;span v-if=&quot;yes_no&quot;&gt;{{ main }}&lt;/span&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data() {
            return {
                yes_no: true,
                main: &quot;hallo&quot;
            }
        },
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>当值为false时，该元素就会被隐藏</p><p>v-else 该指令必须跟着v-if或者v-else-if指令的元素的后面，否则不会被识别，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;span v-if=&quot;yes_no&quot;&gt;{{ main }}&lt;/span&gt;
    &lt;span v-else&gt;这是v-if判断为假时渲染，v-if判断为真时不渲染&lt;/span&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data() {
            return {
                yes_no: false,
                main: &quot;hallo&quot;
            }
        },
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>v-else-if，必须前面的元素中有v-if或者v-else-if指令，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;span v-if=&quot;yes_no == 'yes'&quot;&gt;yes_no == yes&lt;/span&gt;
    &lt;span v-else-if=&quot;yes_no == 'no'&quot;&gt;yes_no == no&lt;/span&gt;
    &lt;span v-else&gt;yes_no != no||yes&lt;/span&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data() {
            return {
                yes_no: &quot;yes&quot;,
                yes: &quot;yes&quot;,
                no: &quot;no&quot;,
                main: &quot;hallo&quot;
            }
        },
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>v-for可以多次渲染元素，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;a in arr&quot;&gt;
            {{a}}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data() {
            return {
                arr:[
                    &quot;hallo&quot;,
                    &quot;abc&quot;,
                    &quot;xyz&quot;,
                    &quot;yes&quot;,
                    &quot;no&quot;
                ]
            }
        }
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>注意：当v-for和v-if出现在同级时，v-for优先级比v-if高，因此不要在v-for下，使用v-if过滤，应该在v-if下使用v-for，v-if应该使用&lt;template>（&lt;template>不会创建dom元素）</p><p>v-html可以插入html</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;span v-html=&quot;main&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data() {
            return {
                main: &quot;&lt;p&gt;hallo word&lt;/p&gt;&quot;
            }
        },
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>v-once表示该元素或者组件只渲染一次，后面不会因为数据的改变而重新渲染</p><p>动态参数的实现</p><pre><code>&lt;div id=&quot;app&quot;&gt;
&lt;/div&gt;

const hallo = {
    data() {
        return {
            main: &quot;hallo&quot;,
            abc: &quot;classa&quot;
        }
    },
    template: `&lt;h1 :[abc] = &quot;main&quot;&gt;hallo word&lt;/h1&gt;`
}
Vue.createApp(hallo).mount(&quot;#app&quot;)
</code></pre><p>vuejs提供了一个叫组件的概念，将重复的程序进行封装，用这些被封装的组件来构建大型应用，可以理解为积木</p><p>根组件：挂载应用时，该组件被认为是渲染的起点</p><p>如果想挂载一个应用到id为app的dom元素中，那么就需要挂载#app，通过一个vue实例，调用其component()方法，创建一个组件</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;hallo v-for=&quot;item in groceryList&quot; v-bind:todo=&quot;item&quot; v-bind:key=&quot;item.id&quot;&gt;&lt;/hallo&gt;
&lt;/div&gt;
&lt;script&gt;
    const main ={
        data(){
            return{
                groceryList: [
                    {id:0,text:&quot;abc&quot;},
                    {id:1,text:&quot;xyz&quot;},
                    {id:2,text:&quot;hallo&quot;}
                ]
            }
        }
    } 
    const app = Vue.createApp(main)
    app.component(&quot;hallo&quot;,{
        props: [&quot;todo&quot;],
        template: `&lt;h1&gt;{{todo.text}}&lt;h1&gt;`
    })
    app.mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>上面简单说明了一下组件的概念,下面详细说明一下组件和组件实例</p><p>页面是这些组件的容器，因此，组件在页面中表达出来的是原生html</p><p>模板（template）：模板定义了数据和html dom的绑定关系</p><p>初始数据（data）：组件的初始数据，组件具有作用域，因此是处于封装私有状态的</p><p>接收的外部参数（props）：组件之间通过该参数进行数据的传递和分享(单向，只能从父组件中获取，不能进行修改,父传子)</p><p>方法（methods）：对数据的改动一般都在组件的方法内进行操作，通过v-on指令把输入事件和组件方法进行绑定</p><p>生命周期钩子（lifecycle hooks）：每个实例都会触发多个生命周期钩子，从创建到废弃的过程就是生命周期，可以在不同时候进行逻辑处理，另外还有组件生命周期</p><p>组件：一种对数据和方法的封装</p><p>mount()返回的是组件实例</p><p>组件实例：组件继承于组件，通过createApp()建立组件实例</p><p>当需要进行数据计算处理时，例如将两个数据合并，如果通过正常的表达式来表示，那么一旦数据处理复杂了，程序会显得很繁杂，vuejs中提供了一个叫计算属性的东西，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    {{hallo}}
&lt;/div&gt;
&lt;script&gt;
    Vue.createApp({
        data() {
            return {
               yes:{
                    main: &quot;abc&quot;
               }
            }
        },
        computed: {
            hallo() {
                return &quot;hallo&quot;+&quot; &quot;+this.yes.main
            }
        }
    }).mount('#app')
&lt;/script&gt;
</code></pre><p>样式绑定</p><pre><code>&lt;style&gt;
    .abc{
        width: 100px;
        height: 100px;
        background-color: #ccc;
    }
&lt;/style&gt;

&lt;div id=&quot;app&quot;&gt;
&lt;/div&gt;
&lt;script&gt;
const app = Vue.createApp({
    data() {
        return {
            classdata: &quot;abc&quot;
        }
    },
    template: `
        &lt;div :class = &quot;classdata&quot;&gt;hallo word&lt;/div&gt;
    `
})
app.mount('#app')
&lt;/script&gt;
</code></pre><p>组件是可重复使用的实例，例如：</p><pre><code>&lt;div class=&quot;app&quot;&gt;
    &lt;test&gt;&lt;/test&gt;
    &lt;test&gt;&lt;/test&gt;
&lt;/div&gt;

const app = Vue.createApp({})
app.component(&quot;test&quot;,{
    data() {
        return {
            abc: &quot;hallo&quot;
        }
    },
    template: `
        &lt;div&gt;
            {{abc}} word
        &lt;/div&gt;`
})
app.mount(&quot;#app&quot;)
</code></pre><p>全局组件</p><p>一般来说组件的数据是独享的，只有全局组件才能进行数据访问，例如：</p><pre><code>const app = Vue.createApp({
    template: `
        &lt;div&gt;
            &lt;test&gt;&lt;/test&gt;
            &lt;abc&gt;&lt;abc&gt;
        &lt;/div&gt;
    `
        // 父组件
})

app.component(&quot;test&quot;,{
    template: `&lt;abc&gt;&lt;abc&gt;`
        // 全局组件
})

app.component(&quot;abc&quot;,{
    data() {
        return {
            text: &quot;hallo word&quot;
        }
    },
    template: ` &lt;div&gt;{{text}}&lt;/div&gt; ` 
        // 全局组件
})

app.mount('#app')
</code></pre><p>abc组件分享了数据给test组件</p><p>局部组件</p><pre><code>&lt;test&gt;&lt;/test&gt;
&lt;Test_datea&gt;&lt;/Test_datea&gt;


const Test_date ={
    template: &quot;&lt;p&gt;hallo word&lt;/p&gt;&quot;
    // 局部组件
}
const Test_datea ={
    template: &quot;&lt;p&gt;hallo hhh&lt;/p&gt;&quot;
    // 局部组件
}
const app = Vue.createApp({
    components: {
        &quot;test&quot; :Test_date
        Test_datea
    }
}).mount('#app')
</code></pre><p>其中test为组件名，指向了Test_date局部组件，</p><p>父子组件之间传递数据</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;test :name=&quot;text&quot;&gt;&lt;/test&gt;
&lt;/div&gt;
&lt;script&gt;
const app = Vue.createApp({
    data() {
        return {
             text: &quot;hallo&quot;,
        }
    }
})
app.component(&quot;test&quot;,{
    props: [&quot;name&quot;],
    template: `&lt;p&gt;{{name}}&lt;/p&gt;`
})
app.mount('#app')
&lt;/script&gt;
</code></pre><p>静态传值只能传字符串类型，如果要传其他数据类型或者想动态传递数据，可以使用v-bind</p><p>通过循环来输出一组数据</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;test v-for=&quot;data in datas&quot; :key=&quot;data.id&quot; :href=&quot;data.url&quot; :text=&quot;data.text&quot;&gt;&lt;/test&gt;
&lt;/div&gt;
&lt;script&gt;
const app = Vue.createApp({
    data() {
        return {
            datas: [
                {id: 1, url: &quot;https://xiaochenabc123.test.com&quot;, text: &quot;hallo&quot;},
                {id: 2, url: &quot;https://test.xiaochenabc123.test.com&quot;, text: &quot;abcxyz&quot;}
            ]
        }
    }
})
app.component(&quot;test&quot;,{
    props: [&quot;text&quot;],
    template: `&lt;a&gt;&lt;p&gt;{{text}}&lt;/p&gt;&lt;/a&gt;`
})
app.mount('#app')
&lt;/script&gt;
</code></pre><p>传值校验</p><p>props中的值进行验证，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;test text=&quot;123&quot; url=&quot;https://xiaochenabc123.test.com&quot; main=&quot;yes&quot; ifmain=11&gt;&lt;/test&gt;
&lt;/div&gt;
&lt;script&gt;
const app = Vue.createApp({})
app.component(&quot;test&quot;,{
    props: {
        text: String, // 基本类型验证 null和undefined会通过任何类型验证，如果不是这个类型，将返回警告
        url: [Number,String], // 多个类型验证，当数据不是这的类型
        main: {
            type: String, // 类型String，必填，如果设置没有该值
            required: true
        },
        hallo: {
            type: String, //  类型String，带默认值default
            default: &quot;hallo vuejs&quot;
        },
        obj: {
            type: Object, // 类型Object，带默认值函数
            default: function(){
                return{
                    text: &quot;abc&quot;
                }
            }
        },
        ifmain: { 
            validator: function(value){
                return(value&gt;10)  // 验证函数
            }
        }
    },
    template: `
        &lt;p&gt;{{text}}&lt;/p&gt;
        &lt;p&gt;{{url}}&lt;/p&gt;
        &lt;p&gt;{{main}}&lt;/p&gt;
        &lt;p&gt;{{hallo}}&lt;/p&gt;
        &lt;p&gt;{{obj}}&lt;/p&gt;
        &lt;p&gt;{{ifmain}}&lt;/p&gt;
    `
})
app.mount('#app')
&lt;/script&gt;
</code></pre><hr><p>vuejs事件修饰符</p><p>.stop：阻止冒泡事件的发生，只触发自身的事件，一个子元素定义了事件，但是它的父元素也定义了一个事件，而且这两个事件的触发机制还是一样的，那么就会导致这两个事件都触发，而想避免发生就需要在目标元素上的事件加上.stop，例如：</p><pre><code>&lt;div id=&quot;app&quot; @click = &quot;divclick&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;GO&quot; @click.stop = &quot;inputclick&quot;&gt;
&lt;/div&gt;
</code></pre><p>.prevent：拦截默认事件的发生，有一些标记拥有自身的默认事件，例如a标记，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;a href=&quot;https://xiaochenabc123.test.com&quot; @click.prevent = &quot;alinkclick&quot;&gt;{{data}}&lt;/a&gt;
&lt;/div&gt;
&lt;script&gt;
    const hallo ={
        data(){
            return{
                data: &quot;GO&quot;
            }
        },
        methods: {
            alinkclick: function(){
                console.log(&quot;hallo&quot;)
            },
        },
    }
    Vue.createApp(hallo).mount(&quot;#app&quot;)
&lt;/script&gt;
</code></pre><p>这里阻止了a标记的默认事件</p><p>.capture：捕获事件，当发生冒泡事件时，先触发带有该修饰符的，如果有多个，则从父元素到子元素触发</p><p>触发机制：优先触发带有.capture的，然后再按照从内往外的冒泡</p><p>.self：只有当事件在该元素上时才触发，冒泡和捕获都无法让其触发事件，只要当事件发生在该元素本身才会触发</p><p>.once：指定该绑定的事件只会触发一次</p><p>.stop和.self的区别：.stop会阻止全部冒泡事件，而.self只阻止自身的冒泡</p><p>.passive：每一次发生事件，浏览器都去查询有没有preventDefault来阻止该事件的默认行为，.passive就是来声明，没有使用preventDefault来阻止该事件的默认行为，因为其是告诉没有使用阻止事件的默认行为，所有passive是和prevent冲突，不能一起使用，否则.prevent会被忽略</p><p>因为在移动端，一般都是监听滚动事件比较多，而每移动一次都会触发一次事件，会进行查询有没有使用prevent，可能会导致滑动卡顿，使用passive能有效提升移动端的性能和流畅度</p><hr><p>生命周期钩子函数会在某一些特定的时刻自动触发，方便在该时刻完成一些工作</p><p>vue实例生命周期</p><p>vue实例的创建，运行，到销毁期间，会触发一些叫生命周期钩子的函数，可以通过该来监听数据变化</p><p>按照生命周期排序：</p><p>beforeCreate：实例刚刚初始化之后，数据观察和事件机制（data 和 methods）都还未初始化，不能获取dom节点</p><p>created：数据观察和事件机制（data 和 methods）都已经初始化，dom节点处理完成，组件未加载</p><p>beforeMount：实例已经加载完毕，但是还没有执行挂载操作，得不到具体的DOM元素</p><p>mounted：实例已经加载完毕，也执行了挂载操作，DOM已被渲染出来</p><p>beforeUpdate：处于数据更新之前，data中的值是最新的，但是页面上还是旧的数据，还没有重新处理dom节点</p><p>updated：处于数据更新之后，data中的值和页面上的数据都已经更新，dom节点也被重新处理</p><p>beforeUnmount：实例销毁之前，实例还是在可用状态，可使用this获取实例</p><p>unmounted：实例销毁后，数据绑定和事件监听器全部清除，子实例销毁</p><p>例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;


const app = Vue.createApp({
    data(){
        return{
            message: 'hallo word'
        }
    },
    beforeCreate() {
        console.log(&quot;beforeCreate&quot;)
    },
    created() {
        console.log(&quot;created&quot;)
    },
    beforeMount(){
        console.log(&quot;beforeMount&quot;)
    },
    mounted() {
        console.log(&quot;mounted&quot;)
    },
    beforeUpdate() {
        console.log(&quot;beforeUpdate&quot;)
    },
    updated() {
        console.log(&quot;updated&quot;)
    },
    beforeUnmount() {
        console.log(&quot;beforeUnmount&quot;)
    },
    unmounted() {
        console.log(&quot;unmounted&quot;)
    },
    template: &quot;&lt;h2&gt;{{message}}&lt;/h2&gt;&quot;
    
})
let main = app.mount(&quot;#app&quot;)
setTimeout(()=&gt;{
    main.$data.message = 'abc' // 挂载3秒后触发更新事件
},3000)
setTimeout(() =&gt; {
    app.unmount() // 6秒后触发销毁事件
}, 6000)
</code></pre><p>访问组件的生命周期</p><p>vue组件周期</p><p>实例生命周期加on就是组件周期</p><p>beforeCreate和created统一为setup()</p><p>beforeMount为onBeforeMout，mounted为onMounted，beforeUpdate为onBeforeUpdate，updated为onUpdated，beforeUnmount为onBeforeUnmount，unmounted为onUnmounted</p><p>setup：data 和 method 都已经初始化</p><p>onBeforeMount：组件被挂载到dom节点之前</p><p>onMounted：组件被挂载到dom节点完毕</p><p>onBeforeUpdate：组件更新之前</p><p>onUpdated：组件更新之后</p><p>onBeforeUnmount：组件销毁之前</p><p>onUnmounted：组件销毁完毕之后</p><p>onErrorCaptured：当捕获到来自子孙组件的异常时</p><p>onRenderTracked：当虚拟DOM重新渲染时调用</p><p>onRenderTriggered：当虚拟DOM重新渲染被触发时调用</p><p>onActivated：当被包含在中的组件时</p><p>onDeactivated: 当被包含在中的组件发生改变时（例如切换组件，原来的组件销毁时）</p><p>注意：使用的组件会把数据保留在内存中，避免需要重新加载多次数据</p><hr><p>实例的data()是一个函数，并非方法，vue在创建vue的组件实例过程中会调用该函数，以$data的形式进行存储在vue实例中，data中的所有值都可以通过实例来暴露（访问或者修改），例如：</p><pre><code>const hallo = Vue.createApp({
    data() {
        return {
            hallovuejs: &quot;hallo vuejs!&quot;
        }
    }
}).mount(&quot;#app&quot;)
console.log(hallo.$data.hallovuejs)
console.log(hallo.hallovuejs)
</code></pre><hr><p>方法</p><p>vue允许使用methods向组件实例添加方法</p><p>vue会自动为methods绑定this，使其始终指向组件实例</p><p>methods一样可以在组件模板中暴露，也可以在模板中用做事件监听</p><pre><code>&lt;div @click=&quot;alinkclick&quot;&gt;&lt;/div&gt;
</code></pre><hr><p>计算属性</p><p>计算属性和方法的区别就是：计算属性只在其依赖发生变化才重新计算，只要依赖未发生改变，那么就会直接从缓存中获取，不会再执行其函数</p><p>如果使用一个方法来计算时，那么data()返回的值，发生一次改变，事件方法就会重新计算一次，因此涉及计算类的使用计算属性，而不是方法</p><p>例如：</p><pre><code>const app = Vue.createApp({
    data() {
        return {
            hallovuejs: &quot;hallo vuejs!&quot;
        }
    },
    computed: {
        hallo(){
            return this.hallovuejs == &quot;hallo vuejs!&quot; ? &quot;Yes&quot; : &quot;No&quot;
        }
    }
}).mount(&quot;#app&quot;)
</code></pre><hr><p>watch监听器</p><p>watch接收2个参数，被监听的data()属性值，回调函数，当监听的变量发生改变时，自动执行回调函数，例如</p><pre><code>const app = Vue.createApp({
    data() {
        return {
            num: 100
        }
    },
    watch: {
        num(current, prev) {
            console.log('num发生改变')
            console.log(&quot;改变之后的值:&quot;, current)
            console.log(&quot;改变之前的值:&quot;, prev)
        }
    }
})
let vm = app.mount(&quot;#app&quot;)
vm.num = 300
vm.$data.num = 600
</code></pre><p>另外一种使用方法</p><pre><code>const count = ref(100) 
watch(count,(current, prev) =&gt; {
    console.log('num发生改变')
    console.log(&quot;改变之后的值:&quot;,current)
    console.log(&quot;改变之前的值:&quot;,prev)
})
</code></pre><p>watch和计算属性的区别：虽然都可以监听data()属性值的改变，但是计算属性会在页面渲染时触发一次，而watch只在被监听的发生改变时触发，而且watch可以得到改变之后的值和改变之前的值</p><p>watch可以监听多个值</p><hr><p>class绑定</p><p>vue允许使用:class对象来动态切换class，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p :class=&quot;{container: yes,nav: no}&quot;&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
const hallo = Vue.createApp({
    data() {
        return {
            yes: true,
            no: false
        }
    }
}).mount('#app')
&lt;/script&gt;
</code></pre><p>而class的存在取决于键值对的值，允许传入多个值，也可以直接调用对象，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p :class=&quot;classnav&quot;&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
const hallo = Vue.createApp({
    data() {
        return {
            classnav: {
                container: false,
                nav: true
            }
        }
    }
}).mount('#app')
&lt;/script&gt;
</code></pre><p>vue也允许通过数组来传入class，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p :class=&quot;[classnav,classa]&quot;&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
const hallo = Vue.createApp({
    data() {
        return {
            classnav: &quot;nav&quot;,
            classa: &quot;texta&quot;
        }
    }
}).mount('#app')
&lt;/script&gt;
</code></pre><p>同样也允许使用三元表达式，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p :class=&quot;[no ? classnav: '',classa]&quot;&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
const hallo = Vue.createApp({
    data() {
        return {
           no: false,
           classa: &quot;texta&quot;
        }
    }
}).mount('#app')
&lt;/script&gt;
</code></pre><p>始终添加classa，classnav取决已经no的值</p><p>vue也是允许在数组中使用对象来处理</p><p>如果在组件中已经绑定了class，而在调用其又加上其他class，那么就会合并，vue允许在组件中进行:class，如果有多个元素，在调用时绑定class，但是又想指定其class给予某个，可以使用$attrs组件属性，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;test class=&quot;nav&quot;&gt;&lt;/test&gt;
&lt;/div&gt;
&lt;script&gt;
const hallo = Vue.createApp({}).component(&quot;test&quot;,{
    template: `
        &lt;div&gt;hallo&lt;/div&gt;
        &lt;div :class=&quot;$attrs.class&quot;&gt;vuejs&lt;/div&gt;
        `
}).mount('#app')
&lt;/script&gt;
</code></pre><p>上面只有&lt;div>vuejs&lt;/div>接收到class</p><hr><p>内联样式绑定（:style）</p><p>例子：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;div :style=&quot;{ color: a, margin: b + 'px' }&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
const hallo = Vue.createApp({
    data() {
        return {
            a: &quot;#ccc&quot;,
            b: 300
        }
    },
}).mount('#app')
&lt;/script&gt;
</code></pre><p>多重值</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;div :style=&quot;{ color: ['#ccc','#fff','#000']}&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>一般来说只会选择最后一个（前提是浏览器支持）</p><hr><p>列表渲染</p><p>v-for可以将一个数组迭代成一组元素</p><p>使用的形式是 item in items，items为数组，item为迭代的元素，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;div v-for=&quot;item in items&quot; :key=&quot;item.message&quot;&gt;
        {{ item.message }}
    &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
const hallo = Vue.createApp({
    data() {
        return {
            items: [{message: &quot;xyz&quot;},{message: &quot;abc&quot;},{message: &quot;hallo&quot;}]
        }
    },
}).mount('#app')
</code></pre><p>而:key的作用是为了更加效率的渲染dom，更快判断出某个不存在的元素，可以根据key动态来重新排列元素的顺序，key的目的是保证唯一性</p><p>v-for支持index参数，即当前的索引，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;div v-for=&quot;(item,index) in items&quot;&gt;
        {{ index }}:{{ item.message }}
    &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
const hallo = Vue.createApp({
    data() {
        return {
            items: [{message: &quot;xyz&quot;},{message: &quot;abc&quot;},{message: &quot;hallo&quot;}]
        }
    },
}).mount('#app')
&lt;/script&gt;
</code></pre><p>in可以用of替代</p><pre><code>&lt;div v-for=&quot;(item,index) of items&quot;&gt;
</code></pre><p>v-for也可以使用对象(从某个角度来看，数组也是对象的一种)，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;div v-for=&quot;(item,key) of items&quot; &gt;
        {{ key }}:{{ item }}
    &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
const hallo = Vue.createApp({
    data() {
        return {
            items: {
                hallo: &quot;yes&quot;,
                abc: &quot;2002&quot;,
                xyz: &quot;np&quot;
            }
        }
    },
}).mount('#app')
</code></pre><p>第二参数为键名，这里命名为key，实质上就是一个key</p><p>也可以加index做为第三个参数，作为索引值</p><p>vue在渲染元素时，如果数据的顺序发生改变，vue是不会将dom元素进行适配顺序，而是重新更新数据，确保正确渲染</p><p>v-for也支持整数</p><pre><code>&lt;div v-for=&quot;a in 6&quot; :key=&quot;a&quot;&gt;&lt;/div&gt;
</code></pre><p>和遍历一样，会重复对应的次数</p><hr><p>事件处理</p><p>一般用v-on进行监听事件，例如：</p><pre><code>&lt;div v-on:click=&quot;boom&quot;&gt;&lt;/div&gt;
</code></pre><p>多个事件用逗号,分开</p><p>可以简写为@click=&ldquo;boom&rdquo;，boom是方法，不推荐直接将逻辑写在事件v-on，而是使用一个方法来调用，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;div @click=&quot;boom('yes')&quot;&gt;
        hallo
    &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
const hallo = Vue.createApp({
    data() {
        return {
            abc: &quot;hallo&quot;
        }
    },
    methods: {
        boom(a){
            console.log(this.abc + &quot;boom&quot;)
            console.log(a)
        }
    }
}).mount('#app')
</code></pre><p>按键修饰符</p><p>一般用于监听键盘事件，精确的知道某个按键是否被触发</p><p>.enter：顾名思义 回车键</p><p>.tab：tab键</p><p>.delete：删除或者退格</p><p>.esc：esc键</p><p>.space：空格键</p><p>.up：上键</p><p>.down：下键</p><p>.left：左键&lt;</p><p>.right: 右键></p><p>系统修饰符</p><p>.ctrl：ctrl键</p><p>.alt：alt键</p><p>.shift：shift键</p><p>.meta：在win为windows键，在mac为command键</p><p>例如：</p><pre><code>&lt;input @keydown.enter=&quot;submit&quot; /&gt;
</code></pre><p>上面只要触发一个要求就会被触发</p><p>.exact：精确触发</p><p>@keydown.enter.exact // 只有当enter被按下时触发</p><p>@keydown.exact // 只有在没有任何系统修饰符被按下才触发</p><p>鼠标修饰符</p><p>@click.left：鼠标右键</p><p>@click.right：鼠标右键</p><p>@click.middle：鼠标中键</p><p>例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;test class=&quot;nav&quot;&gt;&lt;/test&gt;
&lt;/div&gt;
&lt;script&gt;
const hallo = Vue.createApp({}).component(&quot;test&quot;,{
    methods: {
        entersubmit(){
            console.log('回车事件已触发')
        }
        clickmouse(){
            console.log('鼠标中键事件已触发')
        }
    }
    template: `
        &lt;input @keydown.enter.exact=&quot;submit&quot; /&gt;
        &lt;div @click.middle = &quot;clickmouse&quot;&gt;hallo word&lt;/div&gt;
        `
}).mount('#app')
&lt;/script&gt;
</code></pre><hr><p>自定义指令（directive）</p><p>vue允许指定义指令，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-hallo&gt;
&lt;/div&gt;
&lt;script&gt;
const app = Vue.createApp({})
app.directive(&quot;hallo&quot;,{
    mounted(abc) {
        abc.focus()
    },
})
app.mount('#app')
&lt;/script&gt;
</code></pre><p>这里的abc指定的是当前元素</p><p>局部指令：组件中接受directives选项</p><p>指令的钩子函数</p><p>created：当绑定元素的属性和事件监听器被应用之前调用</p><p>beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用</p><p>mounted：绑定元素的父组件被挂载后调用</p><p>beforeUpdate：更新包含组件的VNode之前调用</p><p>updated：包含组件的VNode及其子组件的VNode更新后调用</p><p>beforeUnmount：在卸载绑定元素的父组件之前调用</p><p>unmounted：当指令与元素解除绑定，并且父组件也被卸载时调用一次</p><hr><p>表单输入绑定</p><p>v-model可以用于数据的双向绑定，但是v-model会忽略表单元素的初始值，而使用实例中的数据作为数据源（需要在data中声明初始值）</p><p>复选框的数据绑定返回的是布尔值，也是可以将数据绑定到一个数组中，例如：</p><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;checkbox&quot; value=&quot;hallo&quot; v-model=&quot;datas&quot;/&gt;
    &lt;label for=&quot;hallo&quot;&gt;hallo&lt;/label&gt;
    &lt;input type=&quot;checkbox&quot; value=&quot;abc&quot; v-model=&quot;datas&quot;/&gt;
    &lt;label for=&quot;abc&quot;&gt;abc&lt;/label&gt;
    &lt;input type=&quot;checkbox&quot; value=&quot;xyz&quot; v-model=&quot;datas&quot;/&gt;
    &lt;label for=&quot;xyz&quot;&gt;xyz&lt;/label&gt;
    &lt;p&gt;
        data: {{datas}}
    &lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
const hallo = Vue.createApp({
    data() {
        return {
            datas: []
        }
    },
}).mount('#app')
&lt;/script&gt;
</code></pre><p>单选框（radio），数据存放在字符串中，输出的也是字符串（选择框和输入框也是字符串）</p><p>如果想输入或者选择返回的不是字符串，而是其他类型，可以使用v-model.number，当然也是可以进行手动转类型，但是v-model.number可以自动判断输入是否是数字还是字符串</p><p>true-value和false-value可以在被选中或者取消选中时触发，例如：</p><pre><code>data: {{datas}}
&lt;input type=&quot;checkbox&quot; v-model.lazy=&quot;datas&quot; true-value=&quot;halloword&quot; false-value=&quot;hahahah&quot;/&gt;
</code></pre><p>v-model.lazy是v-model数据双向绑定的懒加载，在每次input事件（失去焦点）触发后将输入框的值与数据进行同步</p><p>v-model.trim可以自动过滤掉输入数据的首尾空格</p><hr><p>组件</p><p>全局注册</p><p>app.component</p><p>局部注册</p><pre><code>const componentA = {}

components: {
    'component-a': componentA,
}
</code></pre><p>局部注册的组件，在其子组件是不可用的</p><p>通过Props传递数据给子组件</p><p>通过Props共享一些数据，例如：</p><pre><code>app.component('titles', {
    props: ['title'],
    template: `&lt;h3&gt;{{ title }}&lt;/h3&gt;`
})

&lt;titles title=&quot;hallo&quot;&gt;&lt;/titles&gt;
</code></pre><p>在上面的例子里，title=&ldquo;hallo"被传递数据给模板，任何值的可以传递给props，如果一个值被传递给props属性，那么这个值就成了这个组件实例的共享数据，这个值可以在模板中访问</p><p>监听子组件事件</p><p>使用自定义事件监听子组件，通过子组件事件来告诉父组件应该做什么，例如：</p><pre><code>template: `
    &lt;button @click=&quot;$emit('hallomain')&quot;&gt;
        app
    &lt;/button&gt;
`

&lt;div :style=&quot;{fontWeight: yes}&quot;&gt;
    &lt;hallo @hallomain=&quot;yes += 1&quot;&gt;&lt;/hallo&gt;
&lt;/div&gt;
</code></pre><p>也可以在组件的emits中列出事件</p><pre><code>app.component({
    emits: [&quot;hallomain&quot;]
})
</code></pre><p>事件也可以用来返回一个值
&lt;button @click="$emit(&lsquo;hallomain&rsquo;,1)">
app</p><pre><code>&lt;hallo @hallomain=&quot;yes += $event&quot;&gt;&lt;/hallo&gt;
</code></pre><p>这个值可以使用$event访问到，事件也可以是指向方法的，用事件来触发方法的使用，例如：@hallomain= &ldquo;hallo&rdquo;</p><p>给这个方法定义一下，在methods选项</p><p>组件也可以使用v-model（model-value）</p><pre><code>&lt;hallo :model-value=&quot;hallomain&quot; @update:model-value=&quot;hallomain = $event&quot;&gt;&lt;/hallo&gt;
</code></pre><p>如果是表单元素，例如input也想用自定义事件，需要将value绑定到props上，当input事件被触发时，就会将value通过自定义事件抛出，例如：</p><pre><code>app.component({
    props: [&quot;valueData&quot;],
    emits: [&quot;hallomain&quot;],
    template: `
        &lt;input :value=&quot;valueData&quot; @input=&quot;$emit(&quot;hallomain&quot;,$event.target.value)&quot;&gt;
    `
})
</code></pre><p>vue允许向父组件传递给子组件一些内容，例如：</p><pre><code>template: `
    &lt;div class=&quot;hallo&quot;&gt;
        &lt;div&gt;hallo&lt;/div&gt;
        &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
`
&lt;hallo&gt;vuejs&lt;/hallo&gt;
</code></pre><p>通过vue的自定义元素来插入，父组件的vuejs插入到slot自定义元素中</p><p>如果一个子组件定义了多个slot元素，可以使用name属性和slot属性进行分配，例如：</p><pre><code>&lt;div slot=&quot;main&quot;&gt;&lt;/div&gt;
</code></pre><p>发现name属性值和slot属性值相同时，就会分配该插槽到该元素中</p><p>单向数据流：父组件可以修改子组件数据，但是子组件不能修改父组件的数据</p><p>单向数据流的目的是确保组件的独立性，不然多个子组件都可以乱改父组件的数据，导致不知道按哪个数据为准了</p><p>如果想做到类似修改父组件，可以向获取父组件的数据到自己的data数据中，然后赋值给一个属性，通过修改该属性来做到类似修改了父组件的情况（实质上并没有影响到父组件），例如:</p><pre><code>app.component('hallo', {
    props: ['num'],
    data(){
        return{
            num: this.value
        }
    }
    template: `&lt;div&gt;{{num}}&lt;/div&gt;`
})
</code></pre><p>在上面的例子中，value就是父组件的数据，将其获取到num中，然后就可以改变num了</p><p>Non-Props：当父组件发送一个参数给子组件，但是子组件没有接收到这个参数时，子组件会原封不动的复制到自己的属性上的特性，例如：</p><pre><code>const app = Vue.createApp({
    template: `
        &lt;div&gt;
            &lt;hallo num='hahaha'/&gt;
        &lt;/div
    `
})
app.component('hallo', {
    // props: ['num'],
    template: `&lt;div&gt;hallo word&lt;/div&gt;`
})
const vm = app.mount(&quot;#app&quot;)
</code></pre><p>可以利用Non-Props的特性，直接在父组件下，给子组件定义一些属性，例如style，class等等，只要子组件没有props接收该数据，都会原封不动的应用在自己的属性中</p><p>如果不想使用Non-Props的特性，又不想被影响，可以使用inheritAttrs属性</p><pre><code>app.component('hallo', {
    inheritAttrs: false,
    template: `&lt;div&gt;hallo word&lt;/div&gt;`
})
</code></pre><p>$attrs属性，当一个组件内部是多重嵌套，或者没有根时（指有多个同级元素），拥有该属性的元素才可以获取到利用Non-Props的特性传递的属性，实现属性穿透，而不用再手动传递了</p><pre><code>const app = Vue.createApp({
    template: `
        &lt;div&gt;
            &lt;hallo num='hahaha'/&gt;
        &lt;/div
    `
})
app.component('hallo', {
    template: `
        &lt;div v-bind=&quot;$attrs&quot;&gt;
            &lt;div&gt;
                &lt;div&gt;
                    &lt;div&gt;&lt;/div&gt;
                    &lt;div v-bind=&quot;$attrs&quot;&gt;&lt;/div&gt;
                    &lt;div&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div v-bind=&quot;$attrs&quot;&gt;
                hallo word
            &lt;/div&gt;
            &lt;div&gt;
                hallo hahaha
            &lt;/div&gt;
        &lt;/div&gt;
    `
})
</code></pre><p>在上面这个例子中，只有带有$attrs属性的元素才能获取该传递的属性</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaochenabc123.github.io/tags/vuejs/>vuejs</a></li></ul><nav class=paginav><a class=prev href=https://xiaochenabc123.github.io/posts/24/><span class=title>« Prev</span><br><span>css常见布局</span></a>
<a class=next href=https://xiaochenabc123.github.io/posts/22/><span class=title>Next »</span><br><span>HTML全局属性笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://xiaochenabc123.github.io/>小陈的个人博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>