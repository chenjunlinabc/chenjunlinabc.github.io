<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang学习笔记 | 小陈的个人博客</title><meta name=keywords content="golang"><meta name=description content="Golang又叫go语言，golang是它的全称，是由Google开发的一种静态强类型，编译型，并发型，并具有垃圾回收功能的编程语言
go语言确保达到静态编译语言的安全和性能的同时，又达到动态语言的开发维护效率
Go语言天生支持并发，提供自动垃圾回收机制
go的源文件是xxx.go
值得一提的是哔哩哔哩网站后端就是用golang开发，这个足以说明golang的并发功能有多强大了
检查是否安装成功go
go version
环境配置
GOROOT对应着go的安装目录
GOPATH对应着go的源代码目录（可以放多个目录）
GOBIN对应着 go install安装和编译的二进制程序的安装目录
检查go环境
go env
源程序默认为UTF-8编码，;可省略
第一个go程序
package mainimport &#34;fmt&#34;func main(){fmt.Println(&#34;hallo golang&#34;)}go run hallo.go
当然作为一个编译型语言，编译成二进制文件是支持的
go build hallo.go
作为一个静态强类型语言，如果学过java的话，理解还是很轻松的
定义包 package : 必须在源程序上声明该文件是属性那个包的
引入包 import : 导入包，引用外部包开扩展功能
注释
// 单行
/* 多 行 */
标识符命名规范：第一个字母必须是字母或者下划线，而且不能是关键字，特殊符号只支持下划线
常用的数据类型有：
整型：int（有符号），uint（无符号），rune，int/unint(8,16,32,64)
浮点型：float(32,64)，comple
布尔型：bool（true，false）（bool默认值为false）
字符串型：string
数组：array
结构体：struct
变量
var abc string = &ldquo;hallo&rdquo;
注意：如果声明变量了，但是没有初始化，那个该变量的值为系统默认设置的值（零值）
定义多个变量
var abc xyz string = &ldquo;hallo&rdquo;,&ldquo;word&rdquo;"><meta name=author content="Me"><link rel=canonical href=https://xiaochenabc123.github.io/posts/96/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaochenabc123.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xiaochenabc123.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://xiaochenabc123.github.io/favicon.ico><link rel=apple-touch-icon href=https://xiaochenabc123.github.io/favicon.ico><link rel=mask-icon href=https://xiaochenabc123.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Golang学习笔记"><meta property="og:description" content="Golang又叫go语言，golang是它的全称，是由Google开发的一种静态强类型，编译型，并发型，并具有垃圾回收功能的编程语言
go语言确保达到静态编译语言的安全和性能的同时，又达到动态语言的开发维护效率
Go语言天生支持并发，提供自动垃圾回收机制
go的源文件是xxx.go
值得一提的是哔哩哔哩网站后端就是用golang开发，这个足以说明golang的并发功能有多强大了
检查是否安装成功go
go version
环境配置
GOROOT对应着go的安装目录
GOPATH对应着go的源代码目录（可以放多个目录）
GOBIN对应着 go install安装和编译的二进制程序的安装目录
检查go环境
go env
源程序默认为UTF-8编码，;可省略
第一个go程序
package mainimport &#34;fmt&#34;func main(){fmt.Println(&#34;hallo golang&#34;)}go run hallo.go
当然作为一个编译型语言，编译成二进制文件是支持的
go build hallo.go
作为一个静态强类型语言，如果学过java的话，理解还是很轻松的
定义包 package : 必须在源程序上声明该文件是属性那个包的
引入包 import : 导入包，引用外部包开扩展功能
注释
// 单行
/* 多 行 */
标识符命名规范：第一个字母必须是字母或者下划线，而且不能是关键字，特殊符号只支持下划线
常用的数据类型有：
整型：int（有符号），uint（无符号），rune，int/unint(8,16,32,64)
浮点型：float(32,64)，comple
布尔型：bool（true，false）（bool默认值为false）
字符串型：string
数组：array
结构体：struct
变量
var abc string = &ldquo;hallo&rdquo;
注意：如果声明变量了，但是没有初始化，那个该变量的值为系统默认设置的值（零值）
定义多个变量
var abc xyz string = &ldquo;hallo&rdquo;,&ldquo;word&rdquo;"><meta property="og:type" content="article"><meta property="og:url" content="https://xiaochenabc123.github.io/posts/96/"><meta property="og:image" content="https://xiaochenabc123.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-09T01:00:00+00:00"><meta property="article:modified_time" content="2021-09-09T01:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://xiaochenabc123.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang学习笔记"><meta name=twitter:description content="Golang又叫go语言，golang是它的全称，是由Google开发的一种静态强类型，编译型，并发型，并具有垃圾回收功能的编程语言
go语言确保达到静态编译语言的安全和性能的同时，又达到动态语言的开发维护效率
Go语言天生支持并发，提供自动垃圾回收机制
go的源文件是xxx.go
值得一提的是哔哩哔哩网站后端就是用golang开发，这个足以说明golang的并发功能有多强大了
检查是否安装成功go
go version
环境配置
GOROOT对应着go的安装目录
GOPATH对应着go的源代码目录（可以放多个目录）
GOBIN对应着 go install安装和编译的二进制程序的安装目录
检查go环境
go env
源程序默认为UTF-8编码，;可省略
第一个go程序
package mainimport &#34;fmt&#34;func main(){fmt.Println(&#34;hallo golang&#34;)}go run hallo.go
当然作为一个编译型语言，编译成二进制文件是支持的
go build hallo.go
作为一个静态强类型语言，如果学过java的话，理解还是很轻松的
定义包 package : 必须在源程序上声明该文件是属性那个包的
引入包 import : 导入包，引用外部包开扩展功能
注释
// 单行
/* 多 行 */
标识符命名规范：第一个字母必须是字母或者下划线，而且不能是关键字，特殊符号只支持下划线
常用的数据类型有：
整型：int（有符号），uint（无符号），rune，int/unint(8,16,32,64)
浮点型：float(32,64)，comple
布尔型：bool（true，false）（bool默认值为false）
字符串型：string
数组：array
结构体：struct
变量
var abc string = &ldquo;hallo&rdquo;
注意：如果声明变量了，但是没有初始化，那个该变量的值为系统默认设置的值（零值）
定义多个变量
var abc xyz string = &ldquo;hallo&rdquo;,&ldquo;word&rdquo;"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xiaochenabc123.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Golang学习笔记","item":"https://xiaochenabc123.github.io/posts/96/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang学习笔记","name":"Golang学习笔记","description":"Golang又叫go语言，golang是它的全称，是由Google开发的一种静态强类型，编译型，并发型，并具有垃圾回收功能的编程语言\ngo语言确保达到静态编译语言的安全和性能的同时，又达到动态语言的开发维护效率\nGo语言天生支持并发，提供自动垃圾回收机制\ngo的源文件是xxx.go\n值得一提的是哔哩哔哩网站后端就是用golang开发，这个足以说明golang的并发功能有多强大了\n检查是否安装成功go\ngo version\n环境配置\nGOROOT对应着go的安装目录\nGOPATH对应着go的源代码目录（可以放多个目录）\nGOBIN对应着 go install安装和编译的二进制程序的安装目录\n检查go环境\ngo env\n源程序默认为UTF-8编码，;可省略\n第一个go程序\npackage main\rimport \u0026quot;fmt\u0026quot;\rfunc main(){\rfmt.Println(\u0026quot;hallo golang\u0026quot;)\r}\rgo run hallo.go\n当然作为一个编译型语言，编译成二进制文件是支持的\ngo build hallo.go\n作为一个静态强类型语言，如果学过java的话，理解还是很轻松的\n定义包 package : 必须在源程序上声明该文件是属性那个包的\n引入包 import : 导入包，引用外部包开扩展功能\n注释\n// 单行\n/* 多 行 */\n标识符命名规范：第一个字母必须是字母或者下划线，而且不能是关键字，特殊符号只支持下划线\n常用的数据类型有：\n整型：int（有符号），uint（无符号），rune，int/unint(8,16,32,64)\n浮点型：float(32,64)，comple\n布尔型：bool（true，false）（bool默认值为false）\n字符串型：string\n数组：array\n结构体：struct\n变量\nvar abc string = \u0026ldquo;hallo\u0026rdquo;\n注意：如果声明变量了，但是没有初始化，那个该变量的值为系统默认设置的值（零值）\n定义多个变量\nvar abc xyz string = \u0026ldquo;hallo\u0026rdquo;,\u0026ldquo;word\u0026rdquo;","keywords":["golang"],"articleBody":"Golang又叫go语言，golang是它的全称，是由Google开发的一种静态强类型，编译型，并发型，并具有垃圾回收功能的编程语言\ngo语言确保达到静态编译语言的安全和性能的同时，又达到动态语言的开发维护效率\nGo语言天生支持并发，提供自动垃圾回收机制\ngo的源文件是xxx.go\n值得一提的是哔哩哔哩网站后端就是用golang开发，这个足以说明golang的并发功能有多强大了\n检查是否安装成功go\ngo version\n环境配置\nGOROOT对应着go的安装目录\nGOPATH对应着go的源代码目录（可以放多个目录）\nGOBIN对应着 go install安装和编译的二进制程序的安装目录\n检查go环境\ngo env\n源程序默认为UTF-8编码，;可省略\n第一个go程序\npackage main\rimport \"fmt\"\rfunc main(){\rfmt.Println(\"hallo golang\")\r}\rgo run hallo.go\n当然作为一个编译型语言，编译成二进制文件是支持的\ngo build hallo.go\n作为一个静态强类型语言，如果学过java的话，理解还是很轻松的\n定义包 package : 必须在源程序上声明该文件是属性那个包的\n引入包 import : 导入包，引用外部包开扩展功能\n注释\n// 单行\n/* 多 行 */\n标识符命名规范：第一个字母必须是字母或者下划线，而且不能是关键字，特殊符号只支持下划线\n常用的数据类型有：\n整型：int（有符号），uint（无符号），rune，int/unint(8,16,32,64)\n浮点型：float(32,64)，comple\n布尔型：bool（true，false）（bool默认值为false）\n字符串型：string\n数组：array\n结构体：struct\n变量\nvar abc string = “hallo”\n注意：如果声明变量了，但是没有初始化，那个该变量的值为系统默认设置的值（零值）\n定义多个变量\nvar abc xyz string = “hallo”,“word”\n而且go会根据提供值来判断数据类型是什么，例如：\nvar xyz = 666\ngo还提供一个特殊的运算符 :=，可以在变量不被声明的情况下使用，例如：\nhallo,word := “hallo”, “word”\n:=在实质开发中会经常使用的\ngo类型强制转换（和java一样，高精度转为低精度会失真）\nvar abc int = 666\nvar xyz float = 3.14\nvar gg string = “123”\nfloat(abc) // 强制转换为浮点数\nint(xyz) // 强制转为整型，会失去小数点之后的数值\nstrconv.Itoa(abc) // 强制转为字符串\nstrconv.Atoi(gg) // 强制转为整型\n注意：同一作用域中不能重复声明，而且必须要声明变量才能使用，而且必须要使用\n声明多个变量\nvar abc,xyz,hallo int\nvar(\rabc int\rxyz float\r)\r常量\n和其他语言一样，常量表示的就是不可修改的变量\nconst abc, xyz int = 123, 666\ngo还提供了一种特殊的定义方式，例如：\nconst(\ra = \"hi\"\rb = \"hallo\"\r)\r如果声明多个常量时，省略了值那么就是表示和第一行值相同，例如：\nconst(\ra = 123\rb\rc\r)\r注意：定义的时候必须赋值\niota常量计数器\nconst(\ra = iota\rb\r_\rd\r)\riota在出现const关键字时重置为0，const每增加一行常量声明，iota加1（自增长），_（下划线，空白标识符（占位），常用于忽略函数多个返回值，例如err）为跳过某些值\n类型\ngolang的数据类型分为基本数据类型和复合数据类型\n基本数据类型有整型，浮点型，字符串，布尔型\n复合数据类型有数组，函数，切片，结构体，字典（map），通道（channel），接口\n注意：像整型有很多种，像int8，int16，int32，uint8，uint16等等，如果直接写int的话，在不同的操作系统中是不一样的，32为操作系统的int指的是int32，64位操作系统指int64\n可使用unsafe.Sizeof查看变量的长度（在内存中的存储空间），例如：\nvar num100 = 100\rfmt.Println(unsafe.Sizeof(num100))\r值类型：值类型被声明变量后，不管有没有赋值，都会分配内存给它，也就是说值类型的声明不需要分配内存，因为在声明的时候已经分配好了内存\n引用类型：变量存储的是一个地址，地址对应的内存空间就是真正存储数据的，引用类型必须申请内存才能使用，例如make()\n自定义类型：可以使用type关键字来自定义类型，例如：type Testint int // 将Testint定义为int类型\n类型转换\n注意：高位转低位会出现精度丢失，例如\nvar abc int16 = 666\rfmt.Println(int8(abc)) // -102\r数字字面量语法\ngo1.13版本+，引入了数字字面量语法，方便使用二进制，八进制，十六进制的格式定义数字，例如:\nabc := 0b10100010101000001011\rfmt.Println(abc) // 666123\r0b表示二进制\n0o表示八进制\n0x表示十六进制\n进制的转换\nvar abc int64 = 100\rfmt.Println(abc)\ra := strconv.FormatInt(abc, 2) // 二进制\rfmt.Println(a)\rb := strconv.FormatInt(abc, 8) // 八进制\rfmt.Println(b)\rc := strconv.FormatInt(abc, 10) // 十进制（默认）\rfmt.Println(c)\rd := strconv.FormatInt(abc, 16) // 十六进制\rfmt.Println(d)\r浮点型（也就是小数）\nGo的浮点型分为float32和float64\nfloat32的浮点数的最大范围为3.4028234663852886e+38，可用math.MaxFloat32输出查看\nfloat64的浮点数的最大范围为1.7976931348623157e+308，可用math.MaxFloat64输出查看\nvar pi = math.Pi\rfmt.Printf(\"%f\\n\", pi) // 默认小数点6位\rfmt.Printf(\"%.10f\\n\", pi) // 指定输出小数点后几位\r字符串\ngo语言字符串编码为UTF-8\n例如： hallo := “你好 Word”\n可输出多行字符串\nvar str123 = `第一行\r第二行\r第三行`\rfmt.Println(str123)\rlen()：字符串长度\n+或fmt.Sprintf：拼接字符串\nstrings.Index()：返回字符在字符串中的位置\nstrings.contains：返回是否包含某个字符\n布尔类型\nvar abc = false var xyz = true\nbyte和rune类型\n组成字符串的元素叫字符，可遍历字符串获取字符\ngo语言的字符分为2种类型，分别为uint8（byte，表示ACII码的一个字符）和rune类型（表示一个UTF-8字符）\n因此使用非ACII码的字符，需要使用rune类型（一个汉字占3个字节，字母只占一个字节）\n注意：修改字符串必须将其转换为byte或者rune类型，完成修改后再转回string，例如：\nhallo := \"你好,golang\"\rabc := []rune(hallo)\rabc[0] = '您'\rfmt.Println(string(abc))\r整型转字符串类型\nvar a int = 100\rb := fmt.Sprintf(\"%d\", a)\rfmt.Printf(b)\r字符串转整型或者浮点型\nstr := \"666\"\rstr1 := \"3.14\"\rstrScore, err := strconv.Atoi(str)\rfmt.Println(strScore, err) // err为转换失败的信息\rnum, err := strconv.ParseInt(str, 10, 64)\rfmt.Println(num, err)\rnum1, err := strconv.ParseFloat(str1, 10)\rfmt.Println(num1, err)\r运算符\n+：加，-减，*乘，/除，%求余\n注意：在go中，++和–是单独使用的，是没有++i的，正确写法例如：\nvar i int = 64\ri++\r// ++i 错误\rif判断\npackage main\rimport \"fmt\"\rfunc main(){\rabc := 123\rif abc \u003e666{\rfmt.Println(\"abc大于666\")\r} else if abc \u003c 666{\rfmt.Println(\"abc小于666\")\r}else{\rfmt.Println(abc)\r}\r}\rif的另一种写法：\nif abc:=123; xyz\u003e=100{\rfmt.Println(\"abc\u003e=100\")\r}\rswitch判断（用于对大量的值进行判断）\nxyz := \"abc\"\rswitch xyz {\rcase \"abc\":\rfmt.Println(\"1\")\rcase \"123\":\rfmt.Println(\"2\")\rdefault:\rfmt.Println(xyz)\r}\rswitch判断的另一种使用方法\nswitch abc := \"hallo\"; abc {\rcase \"hallo\":{\rfmt.Println(\"hallo\")\rbreak\r// 不用break也能跳出switch语句\r}\rcase \"hi\",\"hello\":{\r// 多个值用逗号分隔\rfmt.Println(\"hi\")\rfmt.Println(\"hello\")\rbreak\t}\rdefault:{\rfmt.Println(\"hallo word\")\rbreak\r}\r}\r如果想继续执行下一个case，可以使用fallthrough语句（switch最后一个分支不要使用fallthrough语句，否则报错，而且不能在case语句中间使用，必须是在case语句最后一个语句中使用）例如：\nfunc hallo() int {\rabc := 100 + 666 + 123\rreturn abc\r}\rfunc main() {\rswitch abc := hallo(); {\rcase abc \u003e 500:\rfmt.Printf(\"num \u003c 500\\n\")\rfallthrough\rcase abc \u003e 666:\rfmt.Printf(\"num \u003c 666\\n\")\rfallthrough\rcase abc \u003e 123:\rfmt.Printf(\"num \u003c 123\\n\")\r}\r}\rfor循环\nfor abc := 1; abc\u003c10 ; abc++{\rfmt.Println(abc)\r}\rgolang是没有while循环语句，但是可以使用for循环来做出类似的功能\nabc := 1\rfor abc\u003c10 {\rfmt.Println(abc)\rabc++\r}\rfor循环可用break，goto，return，panic语句退出循环\nbreak跳出循环\n一次性跳出多层循环 break LOOP\ncontinue是退出当前循环\ngoto是无条件转移到goto语句的行，可用于跳出循环，条件转移，例如：\nfunc main() {\rvar abc int = 123\rLOOP:\rfor abc \u003c 666 {\rif abc == 233 {\rabc = abc + 1\rgoto LOOP\r}\rfmt.Printf(abc)\rabc++\r}\r}\rreturn可用于函数或者方法中，用于跳出当前函数或者方法，如果return语句在main函数中，将是终止程序运行，在普通函数中，将是终止当前函数执行（return后面的程序不执行了）\n当return没有带返回值，将是终止，如果带返回值，那么就是终止并且返回值\ngo语言并没有像java那样的异常嵌套机制，go语言用panic-and-recover来替代\npanic可中断原来的流程控制，某个函数调用了panic，将终止该函数的执行，如果有延迟函数（defer）则执行该defer函数，返回其调用者，一直到goroutine（goroutine是go语言的轻量级线程，由runtime管理，go语言会智能的将goroutine中的任务合理分配给每个CPU，go程序在运行时，会给main()函数建立一个默认goroutine，用go关键字创建goroutine，例如：go 函数名(参数)）的全部函数都返回，然后打印panic信息，堆栈信息，最后到终止程序\npanic：在任何地方都可以触发 recover：只在用了defer修饰的函数内有效\n注意：平时不要用panic-and-recover，而是errors，只有当程序不能继续执行了才用，例如出现不可恢复的错误，不能再让它继续执行了，这里举个例子：\nfunc abc() {\rfmt.Println(\"hallo word\")\r}\rfunc hallo() {\rdefer func() {\rerr := recover()\rif err != nil {\rfmt.Println(\"hallo word\")\r}\r}()\rpanic(\"runtime error!!!\")\r}\rfunc main() {\rabc()\rhallo()\r}\rerrors（在go语言中，发生错误，是通过返回errprs值，来对errprs值进行修改或者忽略，当没有错误时，rrprs值为nil，因此可以通过判断errors的值是否为nil来知道是否出现错误，以及处理错误）\nfor range循环（可用于遍历数组，字符串，字典（map），切片（数组），channel（通道））\nfor range循环数组，字符串，切片返回索引和值，字典（map）返回键和值，channel（通道）返回通道内的值\n例如：\nvar abc = \"hallo word\"\rfor key, index := range abc {\rfmt.Printf(\"%v:%c,\", key, index)\r}\r数组（在go中，数组是指同一系列，同一类型的数据集合，组成数组的数据叫元素，go语言的数组的元素是被分配到连续的内存地址中，索引元素是速度非常快的）\nvar abc [16]int // 定义int类型，元素个数为16的数组\rabc[0] = 10\rabc[1] = 66\rfmt.Println(abc)\rvar xyz = [3]string {\"hallo word\",\"golang\",\"hahaha\"}\rfmt.Println(xyz)\rvar a = [...]int{1, 2, 3, 4, 5} // 自动判断数组长度\rfmt.Println(a)\rb := [...]int{1: 66, 3: 100}\rfmt.Println(b)\r遍历数组\nhallo := [...]int{1: 66, 3: 100}\rfor i := 0; i \u003c len(hallo); i++ {\rfmt.Print(hallo[i], \"\\n\")\r}\r也可以用for range方法\n数组是值类型，将数组赋值给另一个变量，会生成副本，修改另一个变量，只会修改副本，不会修改原来的数组，例如：\nhallo := [...]int{1: 66, 3: 100}\rabc := hallo\rabc[1] = 100\rfmt.Println(hallo, abc)\r可以看到在golang中数组不是引用类型\n二维数组\nvar abc = [...][2]int{{100,123},{222,333},{666,60}}\rfmt.Println(abc)\rfor i := 0; i \u003c len(abc); i++ {\rfor j := 0; j \u003c len(abc[0]); j++ {\rfmt.Println(abc[i][j])\r}\r}\r数组的初始值为nil（nil表示为空）\n知识点：指针和引用类型的默认值为nil，需要分配空间\n切片\n切片和数组类似（切片是基于数组类型进行一层封装），不过切片是引用类型（调用的只是在内存中的地址，指针）的\nvar hallo = []int{100, 2333, 666}\rabc := hallo\rabc[0] = 123\rxyz = abc[1:2]\rfmt.Println(hallo, abc, xyz)\rfor i := 0; i \u003c len(abc); i++ {\rfmt.Print(abc[i], \"\\n\")\r}\r长度用len()获取，容量用cap()获取\nmake函数创建切片\nvar data = make([]int, 2, 8) // int类型，长度为2，容量为8\rfmt.Printf(\"长度：%d, 容量%d\", len(data), cap(data))\rappend()切片扩容\nvar hallo = []int64{100, 2333, 666}\rhallo = append(hallo, 123)\rfmt.Println(hallo) // 100, 2333, 666, 123\rabc := []int64{1,3,4,5,6}\rhallo = append(hallo, abc...) // 将两个切片合并\rfmt.Println(hallo) // 100,2333,666,123,1,3,4,5,6\rcopy()函数复制切片（可以理解为深拷贝）\nvar hallo = []int64{100, 2333, 666}\rvar abc = make([]int64, len(hallo), len(hallo))\rcopy(hallo, abc)\rabc[0] = 4\rfmt.Println(hallo,abc)\r删除切片的值（golang中并没有删除切片的值的方法，不过可以用append()实现）\nvar hallo = []int64{100, 2333, 666}\rhallo = append(hallo[:2], hallo[3:]...)\rfmt.Println(hallo)\r遍历切片和数组一样\nmap（字典）\nmap（字典）是无序的基于key-value的数据结构，在golang中map是引用类型\nvar abc = make(map[string]int) // string是键的类型，int是键对应的值的类型\rabc[\"user\"] = 123\rabc[\"pass\"] = 666\rfmt.Println(abc)\rfmt.Println(abc[\"pass\"])\r或者\nvar hallo = map[string]string {\r\"user\":\"root\",\r\"pass\":\"abchahaha\",\r}\rfmt.Println(hallo)\r遍历map\nvar hallo = map[string]string {\r\"user\":\"root\",\r\"pass\":\"abchahaha\",\r}\rfor key, value := range hallo {\rfmt.Println(\"key:\", key, \" value:\", value)\r}\r判断map中某个键值是否存在\nvar hallo = map[string]string {\r\"user\":\"root\",\r\"pass\":\"abchahaha\",\r}\rvalue, yes := hallo[\"pass\"] // 返回2个值。value为返回结果，yes为是否存在该键值\rfmt.Println(value, yes)\rdelete()删除键值对\nvar hallo = map[string]string {\r\"user\":\"root\",\r\"pass\":\"abchahaha\",\r}\rdelete(hallo, \"pass\")\rvalue, no := hallo[\"pass\"]\rfmt.Println(value, no)\r通道\nGolang中还有一个特殊的类型chan，这个类型一般用来线程之间的数据传输\n声明chan\nvar a chan int a := make(chan int, 1) a \u003c- 999 b := \u003c- a\nchan底层是指针，指针初始值为空，需要实例化，make()就是实例化了chan\n\u003c- 999：将值放进通道\n\u003c- a : 将 999 从通道中提取出来\n函数\n函数通过func关键字来声明和定义函数\nfunc hallo(a ...string){\rfmt.Println(a)\r}\rfunc main(){\rhallo(\"hallo golang!!!\")\r}\r匿名函数\nfunc main() {\rfunc () {\rfmt.Println(\"我是匿名函数\")\r}()\r}\r因为没有函数名，没法像正常函数那样被调用，需要将其赋值或者作为立即执行函数\n返回值\nfunc hallo(a, b int) (int,int,int) {\rx := a+b\ry := a-b\rz := a*b\rreturn x, y, z\r}\rfunc main(){\rabc, xyz, go := hallo(6,3)\rfmt.Println(abc, xyz, go)\r}\r当然也是可以自动返回\nfunc hallo(a, b int) (x int,y int,z int){}\ngolang的全局变量和局部变量\n全局变量：常驻内存中，污染全局\n局部变量：不常驻内存中，不污染全局\n闭包：让变量可以常驻内存的同时，不污染全局\n闭包的写法：\nfunc hallo() func() int {\ri := 123\rreturn func() int {\rreturn i + 666\r}\r}\rfunc main() {\rvar abc = hallo()\rfmt.Println(abc())\r}\r或者\nfunc hallo() func(a int) int {\rvar i = 10\rreturn func(a int) int {\ri = i + a\rreturn i\r}\r}\rfunc main() {\rvar abc = hallo()\rfmt.Println(abc(666))\r}\rdefer修饰语句可以延迟执行语句，例如：\nfmt.Println(\"1\")\rdefer fmt.Println(\"2\")\rfmt.Println(\"3\")\r如果使用多个defer修饰语句，会逆序执行（先使用defer最后执行，最后使用defer，最早执行（相对于使用defer修饰的语句））\n在golang中的time包提供了时间显示和测量时间的函数\n获取时间（年-月-日）例如：\ntimedata := time.Now()\ryear := timedata.Year()\rmonth := timedata.Month()\rday := timedata.Day()\rfmt.Printf(\"%d-%02d-%02d \\n\", year, month, day)\r格式化日期（在golang中，并且不是使用Y-m-d H:M:S模板格式化，而且是使用Go的诞生时间：2006年1月2日 15点04分）\n例如：\ntimedata := time.Now()\rfmt.Println(timedata.Format(\"2006-01-02 15:04:05\")) // 24小时制\rfmt.Println(timedata.Format(\"2006-01-02 03:04:05\")) // 12小时制\r获取时间戳（时间戳是自1070年1月1日08:00:00GMT至今的总毫秒数，又叫Unix时间戳）\n例如：\ntimedata := time.Now()\runixTime := timedata.Unix() // 毫秒时间戳\runixNaTime := timedata.UnixNano() // 纳秒时间戳\rfmt.Println(unixTime,unixNaTime)\r时间戳转正常日期\nvar abc = time.Unix(1642746020, 0)\rvar xyz = abc.Format(\"2006-01-02 15:04:05\")\rfmt.Println(xyz)\r正常日期转时间戳\nvar abc = \"2022-01-21 14:21:55\"\rvar tmp = \"2006-01-02 15:04:05\"\rtimedata, err := time.ParseInLocation(tmp, abc, time.Local)\rfmt.Println(timedata.Unix())\r时间的间隔（两个时间之间的间隔，单位为纳秒，time.Duration是time定义的类型，表示一段时间间隔，最大可以表示290年）\ndata := time.Now()\rabc := data.Add(time.Hour)\rxyz := data.Add(time.Second)\rfmt.Println(abc) // 输出1个小时后的时间\rfmt.Println(xyz) // 输出1秒后的时间\r指针\ngolang的指针有3个概念，地址，类型，取值\n\u0026：获取地址，*：根据地址取值\na := 100\rb := \u0026a\rfmt.Println(b) // 获取地址\rfmt.Println(*b) // 根据地址取值\r*b = 666 fmt.Println(a) // 根据地址修改值，改变内存中的值，会改变原来的变量值\r注意：指针必须在创建内存后才能使用（其他引用类型也是一样，需要用make分配空间或者在定义的时候分配空间，值类型在声明的时候已经分配了默认空间，因此值类型不用分配空间）\nnew关键字分配内存（new是一个内置函数，调用new函数得到的是指定类型的指针，并且指针对应的值为该类型的零值）\nabc := new(int)\rfmt.Printf(abc)\rfmt.Println(*abc)\rmake和new的区别：虽然这两个都是用来内存分配的，不过make是用于map，channel，切片（slice）的初始化，返回的值为这3个类型的本身，而new是用来类型的内存分配，内存对应的值为类型的零值，返回的值为指向类型的指针\nGolang语言是面向对象语言又不是，虽然有类型和方法，也支持面向对象的编程风格，但是go没有对象（object）这个类型，也没有类（class）的概念，在go中用结构体替代面向对象语言的类（class）\ntype关键字（go通过type关键字定义结构体，结构体是值类型）\n自定义类型（type也可以来定义自定义类型）\ntype dataStr string\rdataStr自定义类型具备string类型的特性\ntype dataStr string\rfunc main() {\rvar abc dataStr = \"hallo word\"\rfmt.Printf(\"%v %T\", abc, abc)\r}\r类型别名（只是别名，实质上还是同一个类型）\ntype dataStr = string\r结构体的定义以及初始化（type关键字和struct关键字）\ntype Data struct{\ruser string // 定义结构体\rage int\rpass string\r}\rfunc main(){\rvar data Data // 实例化\rdata.user = \"root\"\rdata.age = 20\rdata.pass = \"123456789\"\rfmt.Printf(\"%#v\", data)\r}\r也可以使用new关键字实例化\nfunc main(){\rvar data = new(Data) // 实例化\rdata.user = \"root\"\r// 等于 (*data).user = \"root\"\rdata.age = 20\rdata.pass = \"123456789\"\rfmt.Printf(\"%#v\", data) // 结构体指针\r}\r在golang中支持直接对结构体指针使用，来访问结构体的属性\n另外几种实例化结构体的方法\nvar data = \u0026Data{\rdata.user = \"root\",\rdata.age = 20,\rdata.pass = \"123456789\",\r}\rfmt.Printf(\"%#v\", data)\rvar data = Data{\rdata.user = \"root\",\rdata.age = 20,\rdata.pass = \"123456789\",\r}\rfmt.Printf(\"%#v\", data)\rvar data = Data{\r\"root\",\r20,\r\"123456789\",\r}\rfmt.Printf(\"%#v\", data)\r结构体的方法和接收\ntype Data struct{\r// 定义结构体\ruser string age int\rpass string\r}\rfunc (d Data) DataMain() {\r// 定义方法\rfmt.Print(\"user:\", d.user)\rfmt.Print(\"age:\", d.age)\rfmt.Print(\"pass:\", d.pass)\rfmt.Println()\r}\rfunc (d *Data) GetData(user string, age int, pass string) {\r// 接收方法，因为结构体是值类型，需要使用指针\rd.user = user\rd.age = age\rd.pass = pass\r}\rfunc main() {\rvar data = Data{\r\"root\",\r20,\r\"123456789\",\r}\rdata.DataMain()\rdata.GetData(\"admin\", 22, \"abc12345\")\rdata.DataMain()\r}\r输出结果为：\nuser:rootage:20pass:123456789 user:adminage:22pass:abc12345\n自定义类型方法（类型一样可以定义方法）\ntype dataStr string\rfunc (d dataStr) dataInfo(){\rfmt.Println(\"hallo golang\") // 自定义类型的自定义方法\r}\rfunc main() {\rvar abc dataStr = \"hallo word\"\rabc.dataInfo()\r}\r结构体匿名字段（go允许字段在声明的时候没有字段名，只有类型，因为结构体要求字段名唯一，因此在同一个结构体中同种类型的匿名字段只能出现一次）\ntype Data struct{\r// 定义结构体\rstring int\rstring\r}\rfunc main(){\rvar data = Data{\r// 结构体匿名字段\r\"root\",\r20,\r\"123456789\",\r} }\r注意：结构体的字段类型可以是任意类型（包括自定义类型，结构体类型），但是如果类型是引用类型（例如map，指针）需要先使用make分配空间再使用\n结构体嵌套\ntype Data struct{\r// 定义结构体\ruser string age int\rpass string\rdatamain DataMain //嵌套DataMain结构体\r}\rtype DataMain struct{\r// 定义结构体\remail string\rphone string\r}\rfunc main() {\rvar d Data\rd.user = \"xiaochen\"\rd.age = 20\rd.pass = \"123456789\"\rvar datamain DataMain\rdatamain.email = \"a@xiaochenabc123.test.com\"\rdatamain.phone = \"18888888888\"\rd.datamain = datamain\rfmt.Printf(\"%#v\", d)\r}\r输出结果为main.Data{user:“xiaochen”, age:20, pass:“123456789”, datamain:main.DataMain{email:“a@xiaochenabc123.test.com”, phone:“18888888888”}}\n嵌套结构体可能出现字段名相同，go默认先从父结构体查找，如果没有再到子结构体中查找，这时如果子结构体存在相同的字段，会报错，因为不知道该设置哪个字段（所以字段名要全局唯一）\n结构体继承（可以理解为类的继承，实质效果和结构体嵌套类似）\ntype Data struct{\r// 定义结构体\ruser string age int\rpass string\rDataMain //通过结构体嵌套实现继承\r}\rfunc (data Data) datamax() {\rfmt.Printf(\"email: %v \\n\", data.email)\r}\rtype DataMain struct{\r// 定义结构体\remail string\rphone string\r}\rfunc (datamain DataMain) dataabc() {\rfmt.Printf(\"email: %v \\n\", datamain.email)\r}\rfunc main() {\rvar data = Data{\ruser: \"root\",\rDataMain: DataMain{\remail: \"a@xiaochenabc123.test.com\",\r},\r}\rdata.datamax();\rdata.dataabc();\r}\r可以看到Data结构体拥有DataMain结构体的方法\n注意结构体的字段首字母要大写，表示公有，小写为私用\ngo结构体和json序列化\n将结构体转换为json叫json序列化，将json转换为结构体叫json反序列化\njson序列化和json反序列化主要依赖于encoding/json包的json.Marshal()方法和json.Unmarshal()方法\ntype Data struct{\r// 定义结构体\rUser string Age int\rPass string\r}\rfunc main() {\rvar data = Data{\rUser: \"root\",\rAge: 20,\rPass: \"123456789\",\r}\r// 结构体转换成Json（返回值为是byte类型的切片）\rjsonByte, _ := json.Marshal(data)\r// byte类型转string类型\rjsonStr := string(jsonByte)\rfmt.Printf(string(jsonByte))\rfmt.Printf(jsonStr)\r}\rjson字符串转结构体\ntype Data struct{\r// 定义结构体\rUser string Age string\rPass string\r}\rfunc main() {\r// Json字符串转换成结构体\rvar str = `{\"User\":\"root\",\"Age\":\"20\",\"Pass\":\"123456789\"}`\rvar data = Data{}\r// 第一个参数是传入byte类型的json字符串，第二个参数需要传入转换的地址\rerr := json.Unmarshal([]byte(str), \u0026data)\rif err != nil {\rfmt.Printf(\"转换失败 \\n\")\r} else {\rfmt.Printf(\"%#v \\n\", data)\r}\r}\r结构体标签（tag）\ntag是结构体的元信息，可以在运行时通过反射的机制读取出来，tag在结构体字段后面定义，用反引号包裹，tag是以键值对的方式组成，不同的tag用空格分隔\ntype Data struct{\r// 定义结构体，并且使用结构体标签\rUser string `json:\"user\"`\rAge string `json:\"age\"`\rPass string `json:\"pass\"`\r}\rfunc main() {\rvar data = Data{\rUser: \"root\",\rAge: \"20\",\rPass: \"123456789\",\r}\rjsonByte, _ := json.Marshal(data)\r// byte类型转string类型\rjsonStr := string(jsonByte)\rfmt.Printf(jsonStr)\rvar str = `{\"User\":\"admin\",\"Age\":\"22\",\"Pass\":\"abc12345\"}`\rvar datajson = Data{}\rerr := json.Unmarshal([]byte(str), \u0026datajson)\rif err != nil {\rfmt.Printf(\"转换失败 \\n\")\r} else {\rfmt.Printf(\"%#v \\n\", datajson)\r}\r}\r包(package)是多个源码的集合，是一种代码复用方案，像fmt，time，encoding/json都是go的内置包\ngo中的包分为3种，内置包（go提供的内置包，可以直接引入使用），自定义包（自己写的包），第三方包（也是自定义包，不过不是自己写的，需要下载到本地才能使用）\n包管理器（go mod）（在1.11版本之前需要使用自定义包的话，需要将项目放在GOPATH环境变量中，1.13之后将彻底不需要GOPATH）\n初始化项目（生成go.mod来管理项目的依赖（包括go版本和要使用到的包））\ngo mod init go_test\n如果要引入go_test项目的包，需要import “go_test/包名”，包名根据package设置\npackage 包名\n注意：包名不能和文件夹的名字相同，包名不能出现-符号，一个文件夹中直接包含的文件只能归1个package，同一个package的文件不能在多个文件夹中，而且只有引入了包名为main的程序，编译后会得到可执行文件，如果没有包含main包的程序编译不会得到可执行文件\ninit()初始化函数：导入包，自动触发包内部的init()函数的调用\ngo会先从main包开始检查其导入的所有包，每个包又可能导入了其他包，因此形成了一个树状包引入关系，根据引入的顺序来决定编译的顺序\n最后导入的包最先初始化并且调用其init()函数\ngolang第三包仓库https://pkg.go.dev/\ngo install 编译并安装包（当存在GOBIN环境变量时，编译完成的二进制文件放到$GOBIN下，如果不存在默认放到GOPATH/bin下，源码默认在$HOME/sdk下）\ngo install github.com/tal-tech/go-zero@1.4.1\ngo get 全局安装包（Go 1.17版本中已被弃用，推荐使用go install ）\ngo get github.com/tal-tech/go-zero\ngo mod download 全局安装包\n依赖自动下载到$GOPATH/pkg/mod目录，多个项目可共享缓存的mod，使用该命令之前需要在项目引入第三方包\ngo mod vendor 将依赖复制到当前项目的vendor中，需要在项目引入第三方包\ngo mod vendor\n其他命令\ngo mod edit 编辑go.mod文件\ngo mod tidy 自动处理go.mod中多引入和少引入的包（没有使用的module移除，缺少引入的module将自动引入构建，确保go.mod与模块中的源代码一致）\ngo mod graph 打印模块依赖图\ngo mod verify 校验依赖，检查下载的第三方库是否本地修改，如果没有修改则返回0（校验成功），否则返回非0（校验失败）\ngo mod why 解释为啥需要包\n使用Modules\nGO111MODULE：1.12版本之前的，要设置环境变量GO111MODULE，之后就不需要了通过设置GO111MODULE来开启或者关闭go module\nGO111MODULE = off 禁用go module，编译时在GOPATH和vendor中查找包 GO111MODULE = on 启用go module，编译时忽略GOPATH和vendor，只根据go.mod下载依赖 GO111MODULE=auto 默认值，当项目在GOPATH/src之外，并且项目的根目录有go.mod文件时启用go module\nwindows设置GO111MODULE\nset GO111MODULE=on|off|auto\nMacOS或者Linux设置GO111MODULE\nexport GO111MODULE=on|off|auto\noff和auto，下载的包安装在GOPATH/src目录下\nno，下载的包安装在GOPATH/pkg/mod/下，也在这个目录下查找包（不在GOPATH/src查找）\n也可以手动修改环境变量，GO111MODULE变量，值为on|off|auto\nGOPROXY：GO代理服务器，是Go官方提供的中间代理的方式来包下载，需要设置GOPROXY环境变量\n常见的代理服务器地址：\ngoproxy.io； goproxy.cn：由国内的七牛云提供\n一键设置GOPROXY：\nwindows：go env -w GOPROXY=https://goproxy.cn,direct\nLinux或者macOS：export GOPROXY=https://goproxy.cn\n注意：go语言在1.13版本后，GOPROXY默认为https://proxy.golang.org，如果下载缓慢或者无法访问请设置为https://goproxy.cn\n也可以手动修改环境变量，GOPROXY变量，值为https://goproxy.cn\n依赖的安装（注意：需要移除把项目从GOPATH移除（GOPATH下不允许有go.mod），否则报错$GOPATH/go.mod exists but should not）\ngo get下载指定版本的依赖包\ngo get -u 升级项目中的包到最新的次要版本或者修订版本 go get -u=patch 升级项目中的包到最新的修订版本 go get 包名@版本号 下载对应包的指定版本或者将对应包升级到指定的版本，版本号可以是v1.x.x之类的，也是可以是git的分支，tag，git提交的哈希值\n手动修改go.mod，执行go mod download或者使用go get\ngo的接口（interface）是一种抽象数据类型，接口定义了对象的行为规范，只负责定义规范，并不实现，接口的规范实现由具体的对象来实现\n接口是一组函数method的集合，接口不能存在任何变量，接口中的全部方法都没有方法体\ntype TestData interface{\r// 定义一个TestData接口\rtest()\rdata()\r}\rtype Data struct {\r// 实现接口\rUser string\r}\rfunc (d Data) test() {\rfmt.Println(d.User, \"Test\")\r}\rfunc (d Data) data() {\rfmt.Println(d.User, \"Data\")\r}\rfunc main() {\rvar datamain TestData = Data{\r\"root\",\r}\rdatamain.test()\rdatamain.data()\r}\r空接口（接口允许不定义任何方法，不定义任何方法的接口就是空接口）\ntype Maxdata interface {\r// 定义一个空接口，空接口表示没有约束，任何类型都能实现空接口\r}\rfunc main() {\rvar abc Maxdata\rvar str = \"hallo word\"\rabc = str\rfmt.Println(abc)\r}\rGo1.18版本已添加any关键字来表示泛型\nfunc main(){\rvar abc any\rabc = 'hallo any'\rfmt.Println(abc)\r}\r实质上any还是空接口interface{}的类型别名，type any = interface{}\n空接口也可用来当做类型，表示任意类型（类似于Java中的Object类型）\n空接口还可以用来当做函数的参数，表示可以接收任意类型的函数参数\nfunc Data(abc interface{}) {\rfmt.println(abc)\r}\r使用空接口来实现可以保存任意类型的map\nvar dataInfo = make(map[string]interface{})\rdataInfo[\"uesr\"] = \"root\"\rdataInfo[\"age\"] = 20\rdataInfo[\"pass\"] = \"123456789\"\r使用空接口来实现一个空接口类型的切片\nvar dataslice = make([]interface{}, 6, 6)\rdataslice[0] = \"root\"\rdataslice[1] = 20\rdataslice[3] = \"123456789\"\r类型断言\n接口的值是由具体类型和具体类型的值组成，称为接口的动态类型和动态值\n判断空接口的值的类型，需要使用类型断言，语法格式为：类型为interface{}的变量.(断言这个变量可能是的类型)\n例如：\nvar abc interface{}\rabc = 123\rvalue, isInt := abc.(int)\rif isInt {\rfmt.Println(\"int类型, 值为：\", value)\r} else {\rfmt.Println(\"不是int类型，断言失败\")\r}\rGo并发\n还是讲一下进程和线程的区别\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源的分配和调度的基本单位，每个进程都拥有一个自己的地址空间，进程至少有5种基本状态，分别是：初始状态，执行状态，等待状态，就绪状态，终止状态\n线程（Thread）是进程的执行实例，是程序执行的最小单位，是操作系统能够进行运算调度的最小单位，一个进程可以创建多个线程，同一个进程的线程共享进程的内存信息，同一个进程的多个可以并发执行，一个线程要执行，必须至少有一个进程\n并发和并行的区别\n并发：指一个时间段中有多个线程（程序）被快速的轮换执行（处于启动运行到运行完毕之间），在一个时间段中只有一个线程（程序）在执行，在宏观上感觉是多个线程同时被处理，如果多线程操作在一个cpu上，操作系统将cpu运行时间分隔为若干个时间段，将时间段分配给各个线程执行，在一个时间段的线程执行时，其他线程将处于挂起状态，这就叫并发\n并行：当系统拥有多个cpu（1个以上）时，一个cpu执行一个线程，另一个线程执行另一个线程，同时进行处理，这就叫并行\n并发和并行的区别：并发一个时间段只能执行一个线程（多个线程需要排队执行），并行可以在一个时间段中同时执行多个线程\n当多线程程序在单核CPU上执行时，就是并发，在多核CPU执行时，就是并行，当线程数大于CPU核数，那么既有并行又有并发\ngo的主线程和协程（goroutine）：主线程可调起多个协程，而多协程就是可以实现并行或者并发了\n每个goroutine (协程) 默认占用内存远比 Java 、C的线程少（goroutine是2kb，加上协程调度内存开销也比线程少，因此goroutine是轻量级线程）\n通过go关键字开启goroutine即可实现协程功能，goroutine的调度由golang运行时进行管理，例如\nvar wg sync.WaitGroup // 协程计数器\rfunc data1() {\rfor i := 0; i \u003c 5; i++ {\rfmt.Println(\"hallo word\")\rtime.Sleep(time.Millisecond * 100)\r}\rwg.Done() // 程序结束则协程计数器减1\r}\rfunc data2() {\rfor a := 0; a \u003c 5; a++ {\rfmt.Println(\"hallo golang\")\rtime.Sleep(time.Millisecond * 100)\r}\rwg.Done() // 程序结束则协程计数器减1\r}\rfunc main() {\rwg.Add(1) // 协程计数器加1\rgo data1()\rwg.Add(1) // 协程计数器加1\rgo data2()\rfor i := 0; i \u003c 5; i++ {\rfmt.Println(\"hallo hahaha\")\rtime.Sleep(time.Millisecond * 100)\r}\rwg.Wait() // 等待所有的协程执行完毕\rfmt.Println(\"主线程结束\")\r}\r通过time.Sleep设置100毫秒定时，可以看到并没有顺序输出，因为这里使用了多协程\ngo运行时的调度器通过GOMAXPROCS参数来确定使用多少个OS线程来执行，默认值为计算机的cpu核心数，例如32核的计数器，调度器将程序同时调度到32个OS线程上，通过runtime.GOMAXPROCS()设置当前程序发时的CPU逻辑核心数，runtime.NumCPU()获取计算机的CPU核心数\n注意：go1.5版本之前，默认使用单核心，1.5版本之后默认使用全部核心数\nCpu := runtime.NumCPU() // 获取cpu个数\rfmt.Println(\"cpu核心数:\", Cpu)\rruntime.GOMAXPROCS(runtime.NumCPU() - 1) // 设置要使用的CPU数量\r看看多协程实质执行效果\nvar vg sync.WaitGroup\rfunc data(num int) {\rfor i := 0; i \u003c= 10; i++ {\rfmt.Printf(\"协程%v输出的%v条数据 \\n\", num, i)\r}\rvg.Done()\r}\rfunc main() {\rfor i := 0; i \u003c= 10; i++ {\rgo data(i)\rvg.Add(1)\r}\rvg.Wait()\rfmt.Println(\"主线程结束\")\r}\r通道（channel）是传输数据的一种数据结构（类型），被用来多个goroutine之间传递信息通讯，可以让goroutine发送特定值给另一个goroutine\ngo语言的并发模型是CSP（Communicating Sequential Processes），goroutine是并发体，channel是通信\nchannel遵循先入先出（First In First Out）的规则，保证数据的顺序，channel类型是引用类型\n声明管道（通过chan关键字声明）\nvar ch1 chan int // 声明传递整型的管道\rvar ch2 chan string // 声明传递字符串的管道\r因为其是引用类型，需要使用make()声明内存空间才能使用\nch1 = make(chan int, 10) // 创建一个可以存储10个int类型的管道\rch2 = make(chan string, 10) // 创建一个可以存储10个string类型的管道\r管道具备发送数据，接收数据和关闭管道功能，其中发送和接收都使用\u003c-符号表示，例如：\nch2 \u003c- \"hall word\" // 将hall word发送到ch2管道里\rdata := \u003c- ch2 // 接收ch2管道的数据\rclose(ch2) // 通过内置的close函数关闭管道\r管道也有容量，长度，用cap(), len()获取\n管道阻塞：当管道没有数据，还进行接收，就会出现阻塞，同样当管道容量不足了，还进行发送数据，也会导致阻塞\n注意：当管道被关闭，还继续给管道添加数据或者接收数据将导致panic: send on closed channel报错，如果goroutine执行完毕，管道不关闭，将抛出fatal error: all goroutines are asleep - deadlock!错误\n另外使用for range循环在管道取值，在使用for range之前一定要关闭管道，使用for循环遍历管道就不需要关闭管道了\ngoroutine和channel协作\nfunc data(ch1 chan int) {\rfor i := 0; i \u003c= 5; i++ {\rfmt.Println(\"写入:\", i)\rch1 \u003c- i\rtime.Sleep(time.Millisecond * 100)\r}\rwg.Done()\r}\rfunc dataGet(ch1 chan int) {\rfor a := 0; a \u003c= 5; a++ {\rfmt.Println(\"接收:\", \u003c-ch1)\rtime.Sleep(time.Millisecond * 100)\r}\rwg.Done()\r}\rfunc main() {\rch1 := make(chan int, 5)\rwg.Add(1)\rgo data(ch1)\rwg.Add(1)\rgo dataGet(ch1)\rwg.Wait()\rfmt.Println(\"主线程结束\")\r}\rdata函数写入数据到ch1，dataGet函数接收数据，并且可以看到管道写入数据后，会等待接收数据\n单向管道（限制管道在函数中只能接收数据或者只能发送数据，管道默认可接收可发送）\n声明只可发送的管道（不能接收）\nvar ch = make(chan\u003c- int, 5)\rch \u003c- 10\r声明只可读的管道（不能发送）\nvar ch1 = make(\u003c-chan int, 5)\r\u003c- ch1\r使用select关键字实现多路复用，来从多个管道接收数据，因为管道的特性，没有数据可以接收会导致阻塞\nselect关键字类似于switch语句，有case分支和default分支，一个case负责一个管道的发送和接收，select会等待某个case通信操作完成，再执行case分支的语句\n例如：\nvar ch1 = make(chan int, 10)\rch1 \u003c- 1\rch1 \u003c- 2\rch1 \u003c- 10\rch1 \u003c- 8\rch1 \u003c- 0\rch1 \u003c- 23\rvar ch2 = make(chan string, 10)\rch2 \u003c- \"hallo word\"\rch2 \u003c- \"hallo golang\"\rfor {\rselect {\rcase data:= \u003c- ch1:\rfmt.Println(\"读取ch1的数据：\", data)\rcase data:= \u003c- ch2:\rfmt.Println(\"读取ch2的数据：\", data)\rdefault:\rfmt.Println(\"所有的数据获取完毕\")\rreturn\r}\r}\r可以看到管道发送数据和接收数据是按照顺序的，另外使用select获取数据时，不要关闭管道（当使用完再关闭）\n并发安全和锁\n在并发环境中，可能会出现并发访问的问题，需要使用互斥锁\n互斥锁是并发时对共享资源进行控制访问的手段，使用sync标准库的Mutex结构体定义，sync.Mutex有两个指针方法，分别是Lock()和Unlock()\nvar mutex sync.Mutex // 定义锁\rmutex.Lock() // 上锁\rmutex.Unlock() // 解锁\r当禁止访问公共资源时上锁，当需要访问公共资源时解锁\n互斥锁实质上就是当一个goroutine访问时，其他goroutine不能访问，避免竞争，如果只读不写的话，也不会出现资源竞争的情况，因为写数据，需要保证数据同步，当写数据，又不能保证数据同步就是会出现资源竞争了\n读取数据和读取数据之间不会资源竞争的特性衍生出另外一种锁，叫做读写锁\n读写锁可以将多个读取并发，同时读取，并且对修改数据是完全互斥的，当一个goroutine修改数据（写）时，其他goroutine不能读取数据也是不能写数据\n在go语言中，读写锁用sync.RWMutex定义\nvar mu sync.RWMutex // 定义读写锁\rmu.RLock() // 上锁\rmu.RUnlock() // 解锁\r操作文件和目录\n使用os.Open读取文件\nfile, err := os.Open(\"./data.txt\") // 读取文件\rdefer file.Close() // 关闭文件流\rif err != nil {\rfmt.Println(\"打开文件出错\")\r}\rvar bytedata = make([]byte, 1024)\rfor {\rn, err := file.Read(bytedata) // n为字节数, err是判断是否读取到末尾，值为nil没读取到末尾，值为io.EOF读取到末尾\rif err == io.EOF {\rfmt.Printf(\"读取完毕\")\rbreak\r}\rfmt.Printf(\"读取到了%v 个字节 \\n\", n)\rvar strdata []byte\rstrdata := append(strdata, bytedata...)\rfmt.Println(string(strdata))\r}\r另一种读取方式（bufio，读取大文件推荐使用这个）\nfile, err := os.Open(\"./data.txt\") // 读取文件\rdefer file.Close() // 关闭文件流\rif err != nil {\rfmt.Println(\"打开文件出错\")\r}\rreader := bufio.NewReader(file)\rvar fileStr string\rvar count int = 0\rfor {\rstr, err := reader.ReadString('\\n')\rif err == io.EOF {\rfileStr += str\rfmt.Println(\"读取结束\", count)\rbreak\r}\rif err != nil {\rfmt.Println(err)\rbreak\r}\rcount ++\rfileStr += str\r}\rfmt.Println(fileStr)\r读取小文件（ioutil）\nStrdata, err:= ioutil.ReadFile(\"./data.txt\")\rif err != nil {\rfmt.Println(\"打开文件出错\")\r}\rfmt.Println(string(Strdata))\r写入文件（os.OpenFile）\nfile, err := os.OpenFile(\"./data.txt\", os.O_RDWR | os.O_APPEND, 777) // 打开文件\rdefer file.Close() // 关闭文件流\rif err != nil {\rfmt.Println(\"打开文件出错\")\r}\rstr := \"hallo word\"\rfile.WriteString(str) // 写入文件\r这里os.OpenFile接收3个参数，分别是要打开的文件的路径，打开文件的模式（多个模式用|隔开），文件的权限（和Linux文件权限一样，用八进制表示，读（04），写（02），执行（01），一般为777或者755）\nos.O_WRONLY：只读 os.O_CREATE：创建 os.O_RDONLY：只读 os.O_RDWR：读写 os.O_TRUNC：清空 os.O_APPEND：追加\nbufio写入\nfile, err := os.OpenFile(\"./main/test.txt\", os.O_RDWR | os.O_APPEND, 777) // 打开文件\rdefer file.Close()\rif err != nil {\rfmt.Println(\"打开文件出错\")\r}\rwriter := bufio.NewWriter(file)\rwriter.WriteString(\"hallo word\")\rwriter.Flush()\rioutil写入\nstr := \"hallo word\"\rioutil.WriteFile(\"./data.txt\", []byte(str), 777)\r复制内容到文件\nStr, err := ioutil.ReadFile(\"./data.txt\")\rif err != nil {\rfmt.Println(\"读取文件出错\")\rreturn\r}\rioutil.WriteFile(\"./data1.txt\", Str, 777)\r创建目录\nos.Mkdir(\"./test\", 777)\n删除文件和目录\nos.Remove(\"data1.txt\") // 删除文件\ros.Remove(\"./test) // 删除目录\ros.RemoveAll(\"./test1\") // 和Remove一样，不过这个会递归删除所有子目录和文件\r重命名\nfile := \"./data.txt\"\rerr1 := os.Rename(file,\"test.txt\")\rif err1 != nil {\rpanic(err1)\r} else {\rfmt.Println(\"文件重命名成功\")\r}\rfolder := \"./demo\"\rerr2 := os.Rename(folder, \"demo1\")\rif err2 != nil {\rpanic(err1)\r} else {\rfmt.Println(\"目录重命名成功\")\r}\r","wordCount":"2656","inLanguage":"en","datePublished":"2021-09-09T01:00:00Z","dateModified":"2021-09-09T01:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaochenabc123.github.io/posts/96/"},"publisher":{"@type":"Organization","name":"小陈的个人博客","logo":{"@type":"ImageObject","url":"https://xiaochenabc123.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaochenabc123.github.io/ accesskey=h title="小陈的个人博客 (Alt + H)"><img src=https://xiaochenabc123.github.io/favicon.ico alt aria-label=logo height=35>小陈的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xiaochenabc123.github.io/ title=首页><span>首页</span></a></li><li><a href=https://xiaochenabc123.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://xiaochenabc123.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://xiaochenabc123.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://xiaochenabc123.github.io/links/ title=链接><span>链接</span></a></li><li><a href=https://xiaochenabc123.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://xiaochenabc123.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xiaochenabc123.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://xiaochenabc123.github.io/posts/>Posts</a></div><h1 class=post-title>Golang学习笔记</h1><div class=post-meta><span title='2021-09-09 01:00:00 +0000 UTC'>2021-09-09</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://xiaochenabc123.github.io//posts/Golang%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Golang又叫go语言，golang是它的全称，是由Google开发的一种静态强类型，编译型，并发型，并具有垃圾回收功能的编程语言</p><p>go语言确保达到静态编译语言的安全和性能的同时，又达到动态语言的开发维护效率</p><p>Go语言天生支持并发，提供自动垃圾回收机制</p><p>go的源文件是xxx.go</p><p>值得一提的是哔哩哔哩网站后端就是用golang开发，这个足以说明golang的并发功能有多强大了</p><p>检查是否安装成功go</p><p>go version</p><p>环境配置</p><p>GOROOT对应着go的安装目录</p><p>GOPATH对应着go的源代码目录（可以放多个目录）</p><p>GOBIN对应着 go install安装和编译的二进制程序的安装目录</p><p>检查go环境</p><p>go env</p><p>源程序默认为UTF-8编码，;可省略</p><hr><p>第一个go程序</p><pre><code>package main
import &quot;fmt&quot;
func main(){
    fmt.Println(&quot;hallo golang&quot;)
}
</code></pre><p>go run hallo.go</p><p>当然作为一个编译型语言，编译成二进制文件是支持的</p><p>go build hallo.go</p><hr><p>作为一个静态强类型语言，如果学过java的话，理解还是很轻松的</p><p>定义包 package : 必须在源程序上声明该文件是属性那个包的</p><p>引入包 import : 导入包，引用外部包开扩展功能</p><p>注释</p><p>// 单行</p><p>/*
多
行
*/</p><p>标识符命名规范：第一个字母必须是字母或者下划线，而且不能是关键字，特殊符号只支持下划线</p><p>常用的数据类型有：</p><p>整型：int（有符号），uint（无符号），rune，int/unint(8,16,32,64)</p><p>浮点型：float(32,64)，comple</p><p>布尔型：bool（true，false）（bool默认值为false）</p><p>字符串型：string</p><p>数组：array</p><p>结构体：struct</p><hr><p>变量</p><p>var abc string = &ldquo;hallo&rdquo;</p><p>注意：如果声明变量了，但是没有初始化，那个该变量的值为系统默认设置的值（零值）</p><p>定义多个变量</p><p>var abc xyz string = &ldquo;hallo&rdquo;,&ldquo;word&rdquo;</p><p>而且go会根据提供值来判断数据类型是什么，例如：</p><p>var xyz = 666</p><p>go还提供一个特殊的运算符 :=，可以在变量不被声明的情况下使用，例如：</p><p>hallo,word := &ldquo;hallo&rdquo;, &ldquo;word&rdquo;</p><p>:=在实质开发中会经常使用的</p><p>go类型强制转换（和java一样，高精度转为低精度会失真）</p><p>var abc int = 666</p><p>var xyz float = 3.14</p><p>var gg string = &ldquo;123&rdquo;</p><p>float(abc) // 强制转换为浮点数</p><p>int(xyz) // 强制转为整型，会失去小数点之后的数值</p><p>strconv.Itoa(abc) // 强制转为字符串</p><p>strconv.Atoi(gg) // 强制转为整型</p><p>注意：同一作用域中不能重复声明，而且必须要声明变量才能使用，而且必须要使用</p><p>声明多个变量</p><p>var abc,xyz,hallo int</p><pre><code>var(
    abc int
    xyz float
)
</code></pre><hr><p>常量</p><p>和其他语言一样，常量表示的就是不可修改的变量</p><p>const abc, xyz int = 123, 666</p><p>go还提供了一种特殊的定义方式，例如：</p><pre><code>const(
    a = &quot;hi&quot;
    b = &quot;hallo&quot;
)
</code></pre><p>如果声明多个常量时，省略了值那么就是表示和第一行值相同，例如：</p><pre><code>const(
    a = 123
    b
    c
)
</code></pre><p>注意：定义的时候必须赋值</p><p>iota常量计数器</p><pre><code>const(
    a = iota
    b
    _
    d
)
</code></pre><p>iota在出现const关键字时重置为0，const每增加一行常量声明，iota加1（自增长），_（下划线，空白标识符（占位），常用于忽略函数多个返回值，例如err）为跳过某些值</p><hr><p>类型</p><p>golang的数据类型分为基本数据类型和复合数据类型</p><p>基本数据类型有整型，浮点型，字符串，布尔型</p><p>复合数据类型有数组，函数，切片，结构体，字典（map），通道（channel），接口</p><p>注意：像整型有很多种，像int8，int16，int32，uint8，uint16等等，如果直接写int的话，在不同的操作系统中是不一样的，32为操作系统的int指的是int32，64位操作系统指int64</p><p>可使用unsafe.Sizeof查看变量的长度（在内存中的存储空间），例如：</p><pre><code>var num100 = 100
fmt.Println(unsafe.Sizeof(num100))
</code></pre><p>值类型：值类型被声明变量后，不管有没有赋值，都会分配内存给它，也就是说值类型的声明不需要分配内存，因为在声明的时候已经分配好了内存</p><p>引用类型：变量存储的是一个地址，地址对应的内存空间就是真正存储数据的，引用类型必须申请内存才能使用，例如make()</p><p>自定义类型：可以使用type关键字来自定义类型，例如：type Testint int // 将Testint定义为int类型</p><p>类型转换</p><p>注意：高位转低位会出现精度丢失，例如</p><pre><code>var abc int16 = 666
fmt.Println(int8(abc)) // -102
</code></pre><p>数字字面量语法</p><p>go1.13版本+，引入了数字字面量语法，方便使用二进制，八进制，十六进制的格式定义数字，例如:</p><pre><code>abc := 0b10100010101000001011
fmt.Println(abc) // 666123
</code></pre><p>0b表示二进制</p><p>0o表示八进制</p><p>0x表示十六进制</p><p>进制的转换</p><pre><code>var abc int64 = 100
fmt.Println(abc)
a := strconv.FormatInt(abc, 2) // 二进制
fmt.Println(a)
b := strconv.FormatInt(abc, 8) // 八进制
fmt.Println(b)
c := strconv.FormatInt(abc, 10) // 十进制（默认）
fmt.Println(c)
d := strconv.FormatInt(abc, 16) // 十六进制
fmt.Println(d)
</code></pre><p>浮点型（也就是小数）</p><p>Go的浮点型分为float32和float64</p><p>float32的浮点数的最大范围为3.4028234663852886e+38，可用math.MaxFloat32输出查看</p><p>float64的浮点数的最大范围为1.7976931348623157e+308，可用math.MaxFloat64输出查看</p><pre><code>var pi = math.Pi
fmt.Printf(&quot;%f\n&quot;, pi)    // 默认小数点6位
fmt.Printf(&quot;%.10f\n&quot;, pi) // 指定输出小数点后几位
</code></pre><p>字符串</p><p>go语言字符串编码为UTF-8</p><p>例如：
hallo := &ldquo;你好 Word&rdquo;</p><p>可输出多行字符串</p><pre><code>var str123 = `第一行
第二行
第三行`
fmt.Println(str123)
</code></pre><p>len()：字符串长度</p><p>+或fmt.Sprintf：拼接字符串</p><p>strings.Index()：返回字符在字符串中的位置</p><p>strings.contains：返回是否包含某个字符</p><p>布尔类型</p><p>var abc = false
var xyz = true</p><p>byte和rune类型</p><p>组成字符串的元素叫字符，可遍历字符串获取字符</p><p>go语言的字符分为2种类型，分别为uint8（byte，表示ACII码的一个字符）和rune类型（表示一个UTF-8字符）</p><p>因此使用非ACII码的字符，需要使用rune类型（一个汉字占3个字节，字母只占一个字节）</p><p>注意：修改字符串必须将其转换为byte或者rune类型，完成修改后再转回string，例如：</p><pre><code>hallo := &quot;你好,golang&quot;
abc := []rune(hallo)
abc[0] = '您'
fmt.Println(string(abc))
</code></pre><p>整型转字符串类型</p><pre><code>var a int = 100
b := fmt.Sprintf(&quot;%d&quot;, a)
fmt.Printf(b)
</code></pre><p>字符串转整型或者浮点型</p><pre><code>str := &quot;666&quot;
str1 := &quot;3.14&quot;
strScore, err := strconv.Atoi(str)
fmt.Println(strScore, err) // err为转换失败的信息
num, err := strconv.ParseInt(str, 10, 64)
fmt.Println(num, err)
num1, err := strconv.ParseFloat(str1, 10)
fmt.Println(num1, err)
</code></pre><hr><p>运算符</p><p>+：加，-减，*乘，/除，%求余</p><p>注意：在go中，++和&ndash;是单独使用的，是没有++i的，正确写法例如：</p><pre><code>var i int = 64
i++
// ++i 错误
</code></pre><hr><p>if判断</p><pre><code>package main
import &quot;fmt&quot;
func main(){
    abc := 123
    if abc &gt;666{
        fmt.Println(&quot;abc大于666&quot;)
    } else if abc &lt; 666{
        fmt.Println(&quot;abc小于666&quot;)
    }else{
        fmt.Println(abc)
    }
}
</code></pre><p>if的另一种写法：</p><pre><code>if abc:=123; xyz&gt;=100{
    fmt.Println(&quot;abc&gt;=100&quot;)
}
</code></pre><p>switch判断（用于对大量的值进行判断）</p><pre><code>xyz := &quot;abc&quot;
switch xyz {
    case &quot;abc&quot;:
        fmt.Println(&quot;1&quot;)
    case &quot;123&quot;:
        fmt.Println(&quot;2&quot;)
    default:
        fmt.Println(xyz)
}
</code></pre><p>switch判断的另一种使用方法</p><pre><code>switch abc := &quot;hallo&quot;; abc {
    case &quot;hallo&quot;:{
        fmt.Println(&quot;hallo&quot;)
        break
        // 不用break也能跳出switch语句
    }
case &quot;hi&quot;,&quot;hello&quot;:{
        // 多个值用逗号分隔
        fmt.Println(&quot;hi&quot;)
        fmt.Println(&quot;hello&quot;)
        break	
    }
default:{
        fmt.Println(&quot;hallo word&quot;)
        break
    }
}
</code></pre><p>如果想继续执行下一个case，可以使用fallthrough语句（switch最后一个分支不要使用fallthrough语句，否则报错，而且不能在case语句中间使用，必须是在case语句最后一个语句中使用）例如：</p><pre><code>func hallo() int {
abc := 100 + 666 + 123
return abc
}
func main() {
switch abc := hallo(); {
case abc &gt; 500:
    fmt.Printf(&quot;num &lt; 500\n&quot;)
    fallthrough
case abc &gt; 666:
    fmt.Printf(&quot;num &lt; 666\n&quot;)
    fallthrough
case abc &gt; 123:
    fmt.Printf(&quot;num &lt; 123\n&quot;)
}
}
</code></pre><p>for循环</p><pre><code>for abc := 1; abc&lt;10 ; abc++{
    fmt.Println(abc)
}
</code></pre><p>golang是没有while循环语句，但是可以使用for循环来做出类似的功能</p><pre><code>abc := 1
for abc&lt;10 {
    fmt.Println(abc)
    abc++
}
</code></pre><p>for循环可用break，goto，return，panic语句退出循环</p><p>break跳出循环</p><p>一次性跳出多层循环 break LOOP</p><p>continue是退出当前循环</p><p>goto是无条件转移到goto语句的行，可用于跳出循环，条件转移，例如：</p><pre><code>func main() {
    var abc int = 123
LOOP:
    for abc &lt; 666 {
        if abc == 233 {
            abc = abc + 1
            goto LOOP
        }
        fmt.Printf(abc)
        abc++
    }
}
</code></pre><p>return可用于函数或者方法中，用于跳出当前函数或者方法，如果return语句在main函数中，将是终止程序运行，在普通函数中，将是终止当前函数执行（return后面的程序不执行了）</p><p>当return没有带返回值，将是终止，如果带返回值，那么就是终止并且返回值</p><p>go语言并没有像java那样的异常嵌套机制，go语言用panic-and-recover来替代</p><p>panic可中断原来的流程控制，某个函数调用了panic，将终止该函数的执行，如果有延迟函数（defer）则执行该defer函数，返回其调用者，一直到goroutine（goroutine是go语言的轻量级线程，由runtime管理，go语言会智能的将goroutine中的任务合理分配给每个CPU，go程序在运行时，会给main()函数建立一个默认goroutine，用go关键字创建goroutine，例如：go 函数名(参数)）的全部函数都返回，然后打印panic信息，堆栈信息，最后到终止程序</p><p>panic：在任何地方都可以触发
recover：只在用了defer修饰的函数内有效</p><p>注意：平时不要用panic-and-recover，而是errors，只有当程序不能继续执行了才用，例如出现不可恢复的错误，不能再让它继续执行了，这里举个例子：</p><pre><code>func abc() {
fmt.Println(&quot;hallo word&quot;)
}
func hallo() {
defer func() {
    err := recover()
    if err != nil {
	fmt.Println(&quot;hallo word&quot;)
    }
    }()
    panic(&quot;runtime error!!!&quot;)
}
func main() {
abc()
hallo()
}
</code></pre><p>errors（在go语言中，发生错误，是通过返回errprs值，来对errprs值进行修改或者忽略，当没有错误时，rrprs值为nil，因此可以通过判断errors的值是否为nil来知道是否出现错误，以及处理错误）</p><p>for range循环（可用于遍历数组，字符串，字典（map），切片（数组），channel（通道））</p><p>for range循环数组，字符串，切片返回索引和值，字典（map）返回键和值，channel（通道）返回通道内的值</p><p>例如：</p><pre><code>var abc = &quot;hallo word&quot;
for key, index := range abc {
    fmt.Printf(&quot;%v:%c,&quot;, key, index)
}
</code></pre><hr><p>数组（在go中，数组是指同一系列，同一类型的数据集合，组成数组的数据叫元素，go语言的数组的元素是被分配到连续的内存地址中，索引元素是速度非常快的）</p><pre><code>var abc [16]int // 定义int类型，元素个数为16的数组
abc[0] = 10
abc[1] = 66
fmt.Println(abc)
var xyz = [3]string {&quot;hallo word&quot;,&quot;golang&quot;,&quot;hahaha&quot;}
fmt.Println(xyz)
var a = [...]int{1, 2, 3, 4, 5} // 自动判断数组长度
fmt.Println(a)
b := [...]int{1: 66, 3: 100}
fmt.Println(b)
</code></pre><p>遍历数组</p><pre><code>hallo := [...]int{1: 66, 3: 100}
for i := 0; i &lt; len(hallo); i++ {
    fmt.Print(hallo[i], &quot;\n&quot;)
}
</code></pre><p>也可以用for range方法</p><p>数组是值类型，将数组赋值给另一个变量，会生成副本，修改另一个变量，只会修改副本，不会修改原来的数组，例如：</p><pre><code>hallo := [...]int{1: 66, 3: 100}
abc := hallo
abc[1] = 100
fmt.Println(hallo, abc)
</code></pre><p>可以看到在golang中数组不是引用类型</p><p>二维数组</p><pre><code>var abc = [...][2]int{{100,123},{222,333},{666,60}}
fmt.Println(abc)
for i := 0; i &lt; len(abc); i++ {
    for j := 0; j &lt; len(abc[0]); j++ {
        fmt.Println(abc[i][j])
    }
}
</code></pre><p>数组的初始值为nil（nil表示为空）</p><p>知识点：指针和引用类型的默认值为nil，需要分配空间</p><hr><p>切片</p><p>切片和数组类似（切片是基于数组类型进行一层封装），不过切片是引用类型（调用的只是在内存中的地址，指针）的</p><pre><code>var hallo = []int{100, 2333, 666}
abc := hallo
abc[0] = 123
xyz = abc[1:2]
fmt.Println(hallo, abc, xyz)
for i := 0; i &lt; len(abc); i++ {
    fmt.Print(abc[i], &quot;\n&quot;)
}
</code></pre><p>长度用len()获取，容量用cap()获取</p><p>make函数创建切片</p><pre><code>var data = make([]int, 2, 8) // int类型，长度为2，容量为8
fmt.Printf(&quot;长度：%d, 容量%d&quot;, len(data), cap(data))
</code></pre><p>append()切片扩容</p><pre><code>var hallo = []int64{100, 2333, 666}
hallo = append(hallo, 123)
fmt.Println(hallo) // 100, 2333, 666, 123
abc := []int64{1,3,4,5,6}
hallo = append(hallo, abc...) // 将两个切片合并
fmt.Println(hallo) // 100,2333,666,123,1,3,4,5,6
</code></pre><p>copy()函数复制切片（可以理解为深拷贝）</p><pre><code>var hallo = []int64{100, 2333, 666}
var abc = make([]int64, len(hallo), len(hallo))
copy(hallo, abc)
abc[0] = 4
fmt.Println(hallo,abc)
</code></pre><p>删除切片的值（golang中并没有删除切片的值的方法，不过可以用append()实现）</p><pre><code>var hallo = []int64{100, 2333, 666}
hallo = append(hallo[:2], hallo[3:]...)
fmt.Println(hallo)
</code></pre><p>遍历切片和数组一样</p><hr><p>map（字典）</p><p>map（字典）是无序的基于key-value的数据结构，在golang中map是引用类型</p><pre><code>var abc = make(map[string]int) // string是键的类型，int是键对应的值的类型
abc[&quot;user&quot;] = 123
abc[&quot;pass&quot;] = 666
fmt.Println(abc)
fmt.Println(abc[&quot;pass&quot;])
</code></pre><p>或者</p><pre><code>var hallo = map[string]string {
    &quot;user&quot;:&quot;root&quot;,
    &quot;pass&quot;:&quot;abchahaha&quot;,
}
fmt.Println(hallo)
</code></pre><p>遍历map</p><pre><code>var hallo = map[string]string {
    &quot;user&quot;:&quot;root&quot;,
    &quot;pass&quot;:&quot;abchahaha&quot;,
}
for key, value := range hallo {
    fmt.Println(&quot;key:&quot;, key, &quot; value:&quot;, value)
}
</code></pre><p>判断map中某个键值是否存在</p><pre><code>var hallo = map[string]string {
    &quot;user&quot;:&quot;root&quot;,
    &quot;pass&quot;:&quot;abchahaha&quot;,
}
value, yes := hallo[&quot;pass&quot;] // 返回2个值。value为返回结果，yes为是否存在该键值
fmt.Println(value, yes)
</code></pre><p>delete()删除键值对</p><pre><code>var hallo = map[string]string {
    &quot;user&quot;:&quot;root&quot;,
    &quot;pass&quot;:&quot;abchahaha&quot;,
}
delete(hallo, &quot;pass&quot;)
value, no := hallo[&quot;pass&quot;]
fmt.Println(value, no)
</code></pre><hr><p>通道</p><p>Golang中还有一个特殊的类型chan，这个类型一般用来线程之间的数据传输</p><p>声明chan</p><p>var a chan int
a := make(chan int, 1)
a &lt;- 999
b := &lt;- a</p><p>chan底层是指针，指针初始值为空，需要实例化，make()就是实例化了chan</p><p>&lt;- 999：将值放进通道</p><p>&lt;- a : 将 999 从通道中提取出来</p><hr><p>函数</p><p>函数通过func关键字来声明和定义函数</p><pre><code>func hallo(a ...string){
    fmt.Println(a)
}
func main(){
    hallo(&quot;hallo golang!!!&quot;)
}
</code></pre><p>匿名函数</p><pre><code>func main() {
func () {
    fmt.Println(&quot;我是匿名函数&quot;)
}()
}
</code></pre><p>因为没有函数名，没法像正常函数那样被调用，需要将其赋值或者作为立即执行函数</p><p>返回值</p><pre><code>func hallo(a, b int) (int,int,int) {
    x := a+b
    y := a-b
    z := a*b
    return x, y, z
}
func main(){
    abc, xyz, go := hallo(6,3)
    fmt.Println(abc, xyz, go)
}
</code></pre><p>当然也是可以自动返回</p><p>func hallo(a, b int) (x int,y int,z int){}</p><p>golang的全局变量和局部变量</p><p>全局变量：常驻内存中，污染全局</p><p>局部变量：不常驻内存中，不污染全局</p><p>闭包：让变量可以常驻内存的同时，不污染全局</p><p>闭包的写法：</p><pre><code>func hallo() func() int {
i := 123
return func() int {
    return i + 666
}
}
func main() {
var abc = hallo()
fmt.Println(abc())
}
</code></pre><p>或者</p><pre><code>func hallo() func(a int) int {
var i = 10
return func(a int) int {
    i = i + a
    return i
    }
}
func main() {
var abc = hallo()
fmt.Println(abc(666))
}
</code></pre><p>defer修饰语句可以延迟执行语句，例如：</p><pre><code>fmt.Println(&quot;1&quot;)
defer fmt.Println(&quot;2&quot;)
fmt.Println(&quot;3&quot;)
</code></pre><p>如果使用多个defer修饰语句，会逆序执行（先使用defer最后执行，最后使用defer，最早执行（相对于使用defer修饰的语句））</p><hr><p>在golang中的time包提供了时间显示和测量时间的函数</p><p>获取时间（年-月-日）例如：</p><pre><code>timedata := time.Now()
year := timedata.Year()
month := timedata.Month()
day := timedata.Day()
fmt.Printf(&quot;%d-%02d-%02d \n&quot;, year, month, day)
</code></pre><p>格式化日期（在golang中，并且不是使用Y-m-d H:M:S模板格式化，而且是使用Go的诞生时间：2006年1月2日 15点04分）</p><p>例如：</p><pre><code>timedata := time.Now()
fmt.Println(timedata.Format(&quot;2006-01-02 15:04:05&quot;)) // 24小时制
fmt.Println(timedata.Format(&quot;2006-01-02 03:04:05&quot;)) // 12小时制
</code></pre><p>获取时间戳（时间戳是自1070年1月1日08:00:00GMT至今的总毫秒数，又叫Unix时间戳）</p><p>例如：</p><pre><code>timedata := time.Now()
unixTime := timedata.Unix() // 毫秒时间戳
unixNaTime := timedata.UnixNano() // 纳秒时间戳
fmt.Println(unixTime,unixNaTime)
</code></pre><p>时间戳转正常日期</p><pre><code>var abc = time.Unix(1642746020, 0)
var xyz = abc.Format(&quot;2006-01-02 15:04:05&quot;)
fmt.Println(xyz)
</code></pre><p>正常日期转时间戳</p><pre><code>var abc = &quot;2022-01-21 14:21:55&quot;
var tmp = &quot;2006-01-02 15:04:05&quot;
timedata, err := time.ParseInLocation(tmp, abc, time.Local)
fmt.Println(timedata.Unix())
</code></pre><p>时间的间隔（两个时间之间的间隔，单位为纳秒，time.Duration是time定义的类型，表示一段时间间隔，最大可以表示290年）</p><pre><code>data := time.Now()
abc := data.Add(time.Hour)
xyz := data.Add(time.Second)
fmt.Println(abc) // 输出1个小时后的时间
fmt.Println(xyz) // 输出1秒后的时间
</code></pre><hr><p>指针</p><p>golang的指针有3个概念，地址，类型，取值</p><p>&：获取地址，*：根据地址取值</p><pre><code>a := 100
b := &amp;a
fmt.Println(b) // 获取地址
fmt.Println(*b) // 根据地址取值
*b = 666 
fmt.Println(a) // 根据地址修改值，改变内存中的值，会改变原来的变量值
</code></pre><p>注意：指针必须在创建内存后才能使用（其他引用类型也是一样，需要用make分配空间或者在定义的时候分配空间，值类型在声明的时候已经分配了默认空间，因此值类型不用分配空间）</p><p>new关键字分配内存（new是一个内置函数，调用new函数得到的是指定类型的指针，并且指针对应的值为该类型的零值）</p><pre><code>abc :=  new(int)
fmt.Printf(abc)
fmt.Println(*abc)
</code></pre><p>make和new的区别：虽然这两个都是用来内存分配的，不过make是用于map，channel，切片（slice）的初始化，返回的值为这3个类型的本身，而new是用来类型的内存分配，内存对应的值为类型的零值，返回的值为指向类型的指针</p><hr><p>Golang语言是面向对象语言又不是，虽然有类型和方法，也支持面向对象的编程风格，但是go没有对象（object）这个类型，也没有类（class）的概念，在go中用结构体替代面向对象语言的类（class）</p><p>type关键字（go通过type关键字定义结构体，结构体是值类型）</p><p>自定义类型（type也可以来定义自定义类型）</p><pre><code>type dataStr string
</code></pre><p>dataStr自定义类型具备string类型的特性</p><pre><code>type dataStr string
func main() {
    var abc dataStr = &quot;hallo word&quot;
    fmt.Printf(&quot;%v %T&quot;, abc, abc)
}
</code></pre><p>类型别名（只是别名，实质上还是同一个类型）</p><pre><code>type dataStr = string
</code></pre><p>结构体的定义以及初始化（type关键字和struct关键字）</p><pre><code>type Data struct{
    user string // 定义结构体
    age int
    pass string
}
func main(){
    var data Data // 实例化
    data.user = &quot;root&quot;
    data.age = 20
    data.pass = &quot;123456789&quot;
    fmt.Printf(&quot;%#v&quot;, data)
}
</code></pre><p>也可以使用new关键字实例化</p><pre><code>func main(){
    var data = new(Data) // 实例化
    data.user = &quot;root&quot;
    // 等于 (*data).user = &quot;root&quot;
    data.age = 20
    data.pass = &quot;123456789&quot;
    fmt.Printf(&quot;%#v&quot;, data) // 结构体指针
}
</code></pre><p>在golang中支持直接对结构体指针使用，来访问结构体的属性</p><p>另外几种实例化结构体的方法</p><pre><code>var data = &amp;Data{
    data.user = &quot;root&quot;,
    data.age = 20,
    data.pass = &quot;123456789&quot;,
}
fmt.Printf(&quot;%#v&quot;, data)


var data = Data{
    data.user = &quot;root&quot;,
    data.age = 20,
    data.pass = &quot;123456789&quot;,
}
fmt.Printf(&quot;%#v&quot;, data)


var data = Data{
    &quot;root&quot;,
    20,
    &quot;123456789&quot;,
}
fmt.Printf(&quot;%#v&quot;, data)
</code></pre><p>结构体的方法和接收</p><pre><code>type Data struct{
    // 定义结构体
    user string 
    age int
    pass string
}
func (d Data) DataMain() {
    // 定义方法
    fmt.Print(&quot;user:&quot;, d.user)
    fmt.Print(&quot;age:&quot;, d.age)
    fmt.Print(&quot;pass:&quot;, d.pass)
    fmt.Println()
}
func (d *Data) GetData(user string, age int, pass string)  {
    // 接收方法，因为结构体是值类型，需要使用指针
    d.user = user
    d.age = age
    d.pass = pass
}
func main() {
    var data = Data{
        &quot;root&quot;,
        20,
        &quot;123456789&quot;,
    }
    data.DataMain()
    data.GetData(&quot;admin&quot;, 22, &quot;abc12345&quot;)
    data.DataMain()
}
</code></pre><p>输出结果为：</p><p>user:rootage:20pass:123456789
user:adminage:22pass:abc12345</p><p>自定义类型方法（类型一样可以定义方法）</p><pre><code>type dataStr string
func (d dataStr) dataInfo(){
    fmt.Println(&quot;hallo golang&quot;) // 自定义类型的自定义方法
}
func main() {
    var abc dataStr = &quot;hallo word&quot;
    abc.dataInfo()
}
</code></pre><p>结构体匿名字段（go允许字段在声明的时候没有字段名，只有类型，因为结构体要求字段名唯一，因此在同一个结构体中同种类型的匿名字段只能出现一次）</p><pre><code>type Data struct{
    // 定义结构体
    string 
    int
    string
}
func main(){
    var data = Data{
        // 结构体匿名字段
        &quot;root&quot;,
         20,
         &quot;123456789&quot;,
    }  
}
</code></pre><p>注意：结构体的字段类型可以是任意类型（包括自定义类型，结构体类型），但是如果类型是引用类型（例如map，指针）需要先使用make分配空间再使用</p><p>结构体嵌套</p><pre><code>type Data struct{
    // 定义结构体
    user string 
    age int
    pass string
    datamain DataMain //嵌套DataMain结构体
}
type DataMain struct{
    // 定义结构体
    email string
    phone string
}

func main() {
    var d Data
    d.user = &quot;xiaochen&quot;
    d.age = 20
    d.pass = &quot;123456789&quot;
    var datamain DataMain
    datamain.email = &quot;a@xiaochenabc123.test.com&quot;
    datamain.phone = &quot;18888888888&quot;
    d.datamain = datamain
    fmt.Printf(&quot;%#v&quot;, d)
}
</code></pre><p>输出结果为main.Data{user:&ldquo;xiaochen&rdquo;, age:20, pass:&ldquo;123456789&rdquo;, datamain:main.DataMain{email:&ldquo;<a href=mailto:a@xiaochenabc123.test.com>a@xiaochenabc123.test.com</a>&rdquo;, phone:&ldquo;18888888888&rdquo;}}</p><p>嵌套结构体可能出现字段名相同，go默认先从父结构体查找，如果没有再到子结构体中查找，这时如果子结构体存在相同的字段，会报错，因为不知道该设置哪个字段（所以字段名要全局唯一）</p><p>结构体继承（可以理解为类的继承，实质效果和结构体嵌套类似）</p><pre><code>type Data struct{
    // 定义结构体
    user string 
    age int
    pass string
    DataMain //通过结构体嵌套实现继承
}
func (data Data) datamax()  {
    fmt.Printf(&quot;email:  %v \n&quot;, data.email)
}
type DataMain struct{
    // 定义结构体
    email string
    phone string
}
func (datamain DataMain) dataabc()  {
    fmt.Printf(&quot;email: %v  \n&quot;, datamain.email)
}
func main() {
    var data = Data{
        user: &quot;root&quot;,
        DataMain: DataMain{
            email: &quot;a@xiaochenabc123.test.com&quot;,
        },
    }
    data.datamax();
    data.dataabc();
}
</code></pre><p>可以看到Data结构体拥有DataMain结构体的方法</p><p>注意结构体的字段首字母要大写，表示公有，小写为私用</p><p>go结构体和json序列化</p><p>将结构体转换为json叫json序列化，将json转换为结构体叫json反序列化</p><p>json序列化和json反序列化主要依赖于encoding/json包的json.Marshal()方法和json.Unmarshal()方法</p><pre><code>type Data struct{
    // 定义结构体
    User string 
    Age int
    Pass string
}
func main() {
    var data = Data{
        User: &quot;root&quot;,
        Age: 20,
        Pass: &quot;123456789&quot;,
    }
    // 结构体转换成Json（返回值为是byte类型的切片）
    jsonByte, _ := json.Marshal(data)
    // byte类型转string类型
    jsonStr := string(jsonByte)
    fmt.Printf(string(jsonByte))
    fmt.Printf(jsonStr)
}
</code></pre><p>json字符串转结构体</p><pre><code>type Data struct{
    // 定义结构体
    User string 
    Age string
    Pass string
}
func main() {
    // Json字符串转换成结构体
    var str = `{&quot;User&quot;:&quot;root&quot;,&quot;Age&quot;:&quot;20&quot;,&quot;Pass&quot;:&quot;123456789&quot;}`
    var data = Data{}
    // 第一个参数是传入byte类型的json字符串，第二个参数需要传入转换的地址
    err := json.Unmarshal([]byte(str), &amp;data)
    if err != nil {
        fmt.Printf(&quot;转换失败 \n&quot;)
    } else {
        fmt.Printf(&quot;%#v \n&quot;, data)
    }
}
</code></pre><p>结构体标签（tag）</p><p>tag是结构体的元信息，可以在运行时通过反射的机制读取出来，tag在结构体字段后面定义，用反引号包裹，tag是以键值对的方式组成，不同的tag用空格分隔</p><pre><code>type Data struct{
    // 定义结构体，并且使用结构体标签
    User string `json:&quot;user&quot;`
    Age string `json:&quot;age&quot;`
    Pass string `json:&quot;pass&quot;`
}
func main() {
    var data = Data{
        User: &quot;root&quot;,
        Age: &quot;20&quot;,
        Pass: &quot;123456789&quot;,
    }
    jsonByte, _ := json.Marshal(data)
    // byte类型转string类型
    jsonStr := string(jsonByte)
    fmt.Printf(jsonStr)
    var str = `{&quot;User&quot;:&quot;admin&quot;,&quot;Age&quot;:&quot;22&quot;,&quot;Pass&quot;:&quot;abc12345&quot;}`
    var datajson = Data{}
    err := json.Unmarshal([]byte(str), &amp;datajson)
    if err != nil {
        fmt.Printf(&quot;转换失败 \n&quot;)
    } else {
        fmt.Printf(&quot;%#v \n&quot;, datajson)
    }
}
</code></pre><hr><p>包(package)是多个源码的集合，是一种代码复用方案，像fmt，time，encoding/json都是go的内置包</p><p>go中的包分为3种，内置包（go提供的内置包，可以直接引入使用），自定义包（自己写的包），第三方包（也是自定义包，不过不是自己写的，需要下载到本地才能使用）</p><p>包管理器（go mod）（在1.11版本之前需要使用自定义包的话，需要将项目放在GOPATH环境变量中，1.13之后将彻底不需要GOPATH）</p><p>初始化项目（生成go.mod来管理项目的依赖（包括go版本和要使用到的包））</p><p>go mod init go_test</p><p>如果要引入go_test项目的包，需要import &ldquo;go_test/包名&rdquo;，包名根据package设置</p><p>package 包名</p><p>注意：包名不能和文件夹的名字相同，包名不能出现-符号，一个文件夹中直接包含的文件只能归1个package，同一个package的文件不能在多个文件夹中，而且只有引入了包名为main的程序，编译后会得到可执行文件，如果没有包含main包的程序编译不会得到可执行文件</p><p>init()初始化函数：导入包，自动触发包内部的init()函数的调用</p><p>go会先从main包开始检查其导入的所有包，每个包又可能导入了其他包，因此形成了一个树状包引入关系，根据引入的顺序来决定编译的顺序</p><p>最后导入的包最先初始化并且调用其init()函数</p><p>golang第三包仓库https://pkg.go.dev/</p><p>go install 编译并安装包（当存在GOBIN环境变量时，编译完成的二进制文件放到$GOBIN下，如果不存在默认放到GOPATH/bin下，源码默认在$HOME/sdk下）</p><p>go install <a href=mailto:github.com/tal-tech/go-zero@1.4.1>github.com/tal-tech/go-zero@1.4.1</a></p><p>go get 全局安装包（Go 1.17版本中已被弃用，推荐使用go install ）</p><p>go get github.com/tal-tech/go-zero</p><p>go mod download 全局安装包</p><p>依赖自动下载到$GOPATH/pkg/mod目录，多个项目可共享缓存的mod，使用该命令之前需要在项目引入第三方包</p><p>go mod vendor 将依赖复制到当前项目的vendor中，需要在项目引入第三方包</p><p>go mod vendor</p><p>其他命令</p><p>go mod edit 编辑go.mod文件</p><p>go mod tidy 自动处理go.mod中多引入和少引入的包（没有使用的module移除，缺少引入的module将自动引入构建，确保go.mod与模块中的源代码一致）</p><p>go mod graph 打印模块依赖图</p><p>go mod verify 校验依赖，检查下载的第三方库是否本地修改，如果没有修改则返回0（校验成功），否则返回非0（校验失败）</p><p>go mod why 解释为啥需要包</p><p>使用Modules</p><p>GO111MODULE：1.12版本之前的，要设置环境变量GO111MODULE，之后就不需要了通过设置GO111MODULE来开启或者关闭go module</p><p>GO111MODULE = off 禁用go module，编译时在GOPATH和vendor中查找包
GO111MODULE = on 启用go module，编译时忽略GOPATH和vendor，只根据go.mod下载依赖
GO111MODULE=auto 默认值，当项目在GOPATH/src之外，并且项目的根目录有go.mod文件时启用go module</p><p>windows设置GO111MODULE</p><p>set GO111MODULE=on|off|auto</p><p>MacOS或者Linux设置GO111MODULE</p><p>export GO111MODULE=on|off|auto</p><p>off和auto，下载的包安装在GOPATH/src目录下</p><p>no，下载的包安装在GOPATH/pkg/mod/下，也在这个目录下查找包（不在GOPATH/src查找）</p><p>也可以手动修改环境变量，GO111MODULE变量，值为on|off|auto</p><p>GOPROXY：GO代理服务器，是Go官方提供的中间代理的方式来包下载，需要设置GOPROXY环境变量</p><p>常见的代理服务器地址：</p><p>goproxy.io；
goproxy.cn：由国内的七牛云提供</p><p>一键设置GOPROXY：</p><p>windows：go env -w GOPROXY=https://goproxy.cn,direct</p><p>Linux或者macOS：export GOPROXY=https://goproxy.cn</p><p>注意：go语言在1.13版本后，GOPROXY默认为https://proxy.golang.org，如果下载缓慢或者无法访问请设置为https://goproxy.cn</p><p>也可以手动修改环境变量，GOPROXY变量，值为https://goproxy.cn</p><p>依赖的安装（注意：需要移除把项目从GOPATH移除（GOPATH下不允许有go.mod），否则报错$GOPATH/go.mod exists but should not）</p><p>go get下载指定版本的依赖包</p><p>go get -u 升级项目中的包到最新的次要版本或者修订版本
go get -u=patch 升级项目中的包到最新的修订版本
go get 包名@版本号 下载对应包的指定版本或者将对应包升级到指定的版本，版本号可以是v1.x.x之类的，也是可以是git的分支，tag，git提交的哈希值</p><p>手动修改go.mod，执行go mod download或者使用go get</p><hr><hr><p>go的接口（interface）是一种抽象数据类型，接口定义了对象的行为规范，只负责定义规范，并不实现，接口的规范实现由具体的对象来实现</p><p>接口是一组函数method的集合，接口不能存在任何变量，接口中的全部方法都没有方法体</p><pre><code>type TestData interface{
    // 定义一个TestData接口
    test()
    data()
}
type Data struct {
    // 实现接口
    User string
}
func (d Data) test()  {
    fmt.Println(d.User, &quot;Test&quot;)
}
func (d Data) data()  {
    fmt.Println(d.User, &quot;Data&quot;)
}
func main() {
    var datamain TestData = Data{
        &quot;root&quot;,
    }
    datamain.test()
    datamain.data()
}
</code></pre><p>空接口（接口允许不定义任何方法，不定义任何方法的接口就是空接口）</p><pre><code>type Maxdata interface {
    // 定义一个空接口，空接口表示没有约束，任何类型都能实现空接口
}
func main() {
    var abc Maxdata
    var str = &quot;hallo word&quot;
    abc = str
    fmt.Println(abc)
}
</code></pre><p>Go1.18版本已添加any关键字来表示泛型</p><pre><code>func main(){
    var abc any
    abc = 'hallo any'
    fmt.Println(abc)
}
</code></pre><p>实质上any还是空接口interface{}的类型别名，type any = interface{}</p><p>空接口也可用来当做类型，表示任意类型（类似于Java中的Object类型）</p><p>空接口还可以用来当做函数的参数，表示可以接收任意类型的函数参数</p><pre><code>func Data(abc interface{}) {
    fmt.println(abc)
}
</code></pre><p>使用空接口来实现可以保存任意类型的map</p><pre><code>var dataInfo = make(map[string]interface{})
dataInfo[&quot;uesr&quot;] = &quot;root&quot;
dataInfo[&quot;age&quot;] = 20
dataInfo[&quot;pass&quot;] = &quot;123456789&quot;
</code></pre><p>使用空接口来实现一个空接口类型的切片</p><pre><code>var dataslice = make([]interface{}, 6, 6)
dataslice[0] = &quot;root&quot;
dataslice[1] = 20
dataslice[3] = &quot;123456789&quot;
</code></pre><p>类型断言</p><p>接口的值是由具体类型和具体类型的值组成，称为接口的动态类型和动态值</p><p>判断空接口的值的类型，需要使用类型断言，语法格式为：类型为interface{}的变量.(断言这个变量可能是的类型)</p><p>例如：</p><pre><code>var abc interface{}
abc = 123
value, isInt := abc.(int)
if isInt {
    fmt.Println(&quot;int类型, 值为：&quot;, value)
} else {
    fmt.Println(&quot;不是int类型，断言失败&quot;)
}
</code></pre><hr><p>Go并发</p><p>还是讲一下进程和线程的区别</p><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源的分配和调度的基本单位，每个进程都拥有一个自己的地址空间，进程至少有5种基本状态，分别是：初始状态，执行状态，等待状态，就绪状态，终止状态</p><p>线程（Thread）是进程的执行实例，是程序执行的最小单位，是操作系统能够进行运算调度的最小单位，一个进程可以创建多个线程，同一个进程的线程共享进程的内存信息，同一个进程的多个可以并发执行，一个线程要执行，必须至少有一个进程</p><p>并发和并行的区别</p><p>并发：指一个时间段中有多个线程（程序）被快速的轮换执行（处于启动运行到运行完毕之间），在一个时间段中只有一个线程（程序）在执行，在宏观上感觉是多个线程同时被处理，如果多线程操作在一个cpu上，操作系统将cpu运行时间分隔为若干个时间段，将时间段分配给各个线程执行，在一个时间段的线程执行时，其他线程将处于挂起状态，这就叫并发</p><p>并行：当系统拥有多个cpu（1个以上）时，一个cpu执行一个线程，另一个线程执行另一个线程，同时进行处理，这就叫并行</p><p>并发和并行的区别：并发一个时间段只能执行一个线程（多个线程需要排队执行），并行可以在一个时间段中同时执行多个线程</p><p>当多线程程序在单核CPU上执行时，就是并发，在多核CPU执行时，就是并行，当线程数大于CPU核数，那么既有并行又有并发</p><p>go的主线程和协程（goroutine）：主线程可调起多个协程，而多协程就是可以实现并行或者并发了</p><p>每个goroutine (协程) 默认占用内存远比 Java 、C的线程少（goroutine是2kb，加上协程调度内存开销也比线程少，因此goroutine是轻量级线程）</p><p>通过go关键字开启goroutine即可实现协程功能，goroutine的调度由golang运行时进行管理，例如</p><pre><code>var wg sync.WaitGroup // 协程计数器
func data1() {
    for i := 0; i &lt; 5; i++ {
        fmt.Println(&quot;hallo word&quot;)
        time.Sleep(time.Millisecond * 100)
    }
    wg.Done() // 程序结束则协程计数器减1
}
func data2() {
    for a := 0; a &lt; 5; a++ {
        fmt.Println(&quot;hallo golang&quot;)
        time.Sleep(time.Millisecond * 100)
    }
    wg.Done() // 程序结束则协程计数器减1
}
func main() {
    wg.Add(1) // 协程计数器加1
    go data1()
    wg.Add(1) // 协程计数器加1
    go data2()
    for i := 0; i &lt; 5; i++ {
        fmt.Println(&quot;hallo hahaha&quot;)
        time.Sleep(time.Millisecond * 100)
    }
    wg.Wait() // 等待所有的协程执行完毕
    fmt.Println(&quot;主线程结束&quot;)
}
</code></pre><p>通过time.Sleep设置100毫秒定时，可以看到并没有顺序输出，因为这里使用了多协程</p><p>go运行时的调度器通过GOMAXPROCS参数来确定使用多少个OS线程来执行，默认值为计算机的cpu核心数，例如32核的计数器，调度器将程序同时调度到32个OS线程上，通过runtime.GOMAXPROCS()设置当前程序发时的CPU逻辑核心数，runtime.NumCPU()获取计算机的CPU核心数</p><p>注意：go1.5版本之前，默认使用单核心，1.5版本之后默认使用全部核心数</p><pre><code>Cpu := runtime.NumCPU() // 获取cpu个数
fmt.Println(&quot;cpu核心数:&quot;, Cpu)
runtime.GOMAXPROCS(runtime.NumCPU() - 1) // 设置要使用的CPU数量
</code></pre><p>看看多协程实质执行效果</p><pre><code>var vg sync.WaitGroup
func data(num int) {
    for i := 0; i &lt;= 10; i++ {
        fmt.Printf(&quot;协程%v输出的%v条数据 \n&quot;, num, i)
    }
    vg.Done()
}
func main() {
    for i := 0; i &lt;= 10; i++ {
        go data(i)
        vg.Add(1)
    }
    vg.Wait()
    fmt.Println(&quot;主线程结束&quot;)
}
</code></pre><p>通道（channel）是传输数据的一种数据结构（类型），被用来多个goroutine之间传递信息通讯，可以让goroutine发送特定值给另一个goroutine</p><p>go语言的并发模型是CSP（Communicating Sequential Processes），goroutine是并发体，channel是通信</p><p>channel遵循先入先出（First In First Out）的规则，保证数据的顺序，channel类型是引用类型</p><p>声明管道（通过chan关键字声明）</p><pre><code>var ch1 chan int // 声明传递整型的管道
var ch2 chan string // 声明传递字符串的管道
</code></pre><p>因为其是引用类型，需要使用make()声明内存空间才能使用</p><pre><code>ch1 = make(chan int, 10) // 创建一个可以存储10个int类型的管道
ch2 = make(chan string, 10) // 创建一个可以存储10个string类型的管道
</code></pre><p>管道具备发送数据，接收数据和关闭管道功能，其中发送和接收都使用&lt;-符号表示，例如：</p><pre><code>ch2 &lt;- &quot;hall word&quot; // 将hall word发送到ch2管道里
data := &lt;- ch2 // 接收ch2管道的数据
close(ch2) // 通过内置的close函数关闭管道
</code></pre><p>管道也有容量，长度，用cap(), len()获取</p><p>管道阻塞：当管道没有数据，还进行接收，就会出现阻塞，同样当管道容量不足了，还进行发送数据，也会导致阻塞</p><p>注意：当管道被关闭，还继续给管道添加数据或者接收数据将导致panic: send on closed channel报错，如果goroutine执行完毕，管道不关闭，将抛出fatal error: all goroutines are asleep - deadlock!错误</p><p>另外使用for range循环在管道取值，在使用for range之前一定要关闭管道，使用for循环遍历管道就不需要关闭管道了</p><p>goroutine和channel协作</p><pre><code>func data(ch1 chan int) {
    for i := 0; i &lt;= 5; i++ {
        fmt.Println(&quot;写入:&quot;, i)
        ch1 &lt;- i
        time.Sleep(time.Millisecond * 100)
    }
    wg.Done()
}
func dataGet(ch1 chan int) {
    for a := 0; a &lt;= 5; a++ {
        fmt.Println(&quot;接收:&quot;, &lt;-ch1)
        time.Sleep(time.Millisecond * 100)
    }
    wg.Done()
}
func main() {
    ch1 := make(chan int, 5)
    wg.Add(1)
    go data(ch1)
    wg.Add(1)
    go dataGet(ch1)
    wg.Wait()
    fmt.Println(&quot;主线程结束&quot;)
}
</code></pre><p>data函数写入数据到ch1，dataGet函数接收数据，并且可以看到管道写入数据后，会等待接收数据</p><p>单向管道（限制管道在函数中只能接收数据或者只能发送数据，管道默认可接收可发送）</p><p>声明只可发送的管道（不能接收）</p><pre><code>var ch = make(chan&lt;- int, 5)
ch &lt;- 10
</code></pre><p>声明只可读的管道（不能发送）</p><pre><code>var ch1 = make(&lt;-chan int, 5)
&lt;- ch1
</code></pre><p>使用select关键字实现多路复用，来从多个管道接收数据，因为管道的特性，没有数据可以接收会导致阻塞</p><p>select关键字类似于switch语句，有case分支和default分支，一个case负责一个管道的发送和接收，select会等待某个case通信操作完成，再执行case分支的语句</p><p>例如：</p><pre><code>var ch1 = make(chan int, 10)
ch1 &lt;- 1
ch1 &lt;- 2
ch1 &lt;- 10
ch1 &lt;- 8
ch1 &lt;- 0
ch1 &lt;- 23
var ch2 = make(chan string, 10)
ch2 &lt;- &quot;hallo word&quot;
ch2 &lt;- &quot;hallo golang&quot;
for {
    select {
        case data:= &lt;- ch1:
        fmt.Println(&quot;读取ch1的数据：&quot;, data)
        case data:= &lt;- ch2:
        fmt.Println(&quot;读取ch2的数据：&quot;, data)
        default:
        fmt.Println(&quot;所有的数据获取完毕&quot;)
        return
    }
}
</code></pre><p>可以看到管道发送数据和接收数据是按照顺序的，另外使用select获取数据时，不要关闭管道（当使用完再关闭）</p><p>并发安全和锁</p><p>在并发环境中，可能会出现并发访问的问题，需要使用互斥锁</p><p>互斥锁是并发时对共享资源进行控制访问的手段，使用sync标准库的Mutex结构体定义，sync.Mutex有两个指针方法，分别是Lock()和Unlock()</p><pre><code>var mutex sync.Mutex  // 定义锁
mutex.Lock() // 上锁
mutex.Unlock() // 解锁
</code></pre><p>当禁止访问公共资源时上锁，当需要访问公共资源时解锁</p><p>互斥锁实质上就是当一个goroutine访问时，其他goroutine不能访问，避免竞争，如果只读不写的话，也不会出现资源竞争的情况，因为写数据，需要保证数据同步，当写数据，又不能保证数据同步就是会出现资源竞争了</p><p>读取数据和读取数据之间不会资源竞争的特性衍生出另外一种锁，叫做读写锁</p><p>读写锁可以将多个读取并发，同时读取，并且对修改数据是完全互斥的，当一个goroutine修改数据（写）时，其他goroutine不能读取数据也是不能写数据</p><p>在go语言中，读写锁用sync.RWMutex定义</p><pre><code>var mu sync.RWMutex // 定义读写锁
mu.RLock() // 上锁
mu.RUnlock() // 解锁
</code></pre><hr><p>操作文件和目录</p><p>使用os.Open读取文件</p><pre><code>file, err := os.Open(&quot;./data.txt&quot;) // 读取文件
defer file.Close() // 关闭文件流
if err != nil {
    fmt.Println(&quot;打开文件出错&quot;)
}
var bytedata = make([]byte, 1024)
for {
    n, err := file.Read(bytedata) // n为字节数, err是判断是否读取到末尾，值为nil没读取到末尾，值为io.EOF读取到末尾
    if err == io.EOF {
        fmt.Printf(&quot;读取完毕&quot;)
        break
    }
    fmt.Printf(&quot;读取到了%v 个字节 \n&quot;, n)
    var strdata []byte
    strdata := append(strdata, bytedata...)
    fmt.Println(string(strdata))
}
</code></pre><p>另一种读取方式（bufio，读取大文件推荐使用这个）</p><pre><code>file, err := os.Open(&quot;./data.txt&quot;) // 读取文件
defer file.Close() // 关闭文件流
if err != nil {
    fmt.Println(&quot;打开文件出错&quot;)
}
reader := bufio.NewReader(file)
var fileStr string
    var count int = 0
    for {
        str, err := reader.ReadString('\n')
        if err == io.EOF {
            fileStr += str
            fmt.Println(&quot;读取结束&quot;, count)
            break
        }
        if err != nil {
            fmt.Println(err)
            break
        }
        count ++
        fileStr += str
    }
fmt.Println(fileStr)
</code></pre><p>读取小文件（ioutil）</p><pre><code>Strdata, err:= ioutil.ReadFile(&quot;./data.txt&quot;)
if err != nil {
    fmt.Println(&quot;打开文件出错&quot;)
}
fmt.Println(string(Strdata))
</code></pre><p>写入文件（os.OpenFile）</p><pre><code>file, err := os.OpenFile(&quot;./data.txt&quot;, os.O_RDWR | os.O_APPEND, 777) // 打开文件
defer file.Close() // 关闭文件流
if err != nil {
    fmt.Println(&quot;打开文件出错&quot;)
}
str := &quot;hallo word&quot;
file.WriteString(str) // 写入文件
</code></pre><p>这里os.OpenFile接收3个参数，分别是要打开的文件的路径，打开文件的模式（多个模式用|隔开），文件的权限（和Linux文件权限一样，用八进制表示，读（04），写（02），执行（01），一般为777或者755）</p><p>os.O_WRONLY：只读
os.O_CREATE：创建
os.O_RDONLY：只读
os.O_RDWR：读写
os.O_TRUNC：清空
os.O_APPEND：追加</p><p>bufio写入</p><pre><code>file, err := os.OpenFile(&quot;./main/test.txt&quot;, os.O_RDWR | os.O_APPEND, 777) // 打开文件
defer file.Close()
if err != nil {
    fmt.Println(&quot;打开文件出错&quot;)
}
writer := bufio.NewWriter(file)
writer.WriteString(&quot;hallo word&quot;)
writer.Flush()
</code></pre><p>ioutil写入</p><pre><code>str := &quot;hallo word&quot;
ioutil.WriteFile(&quot;./data.txt&quot;, []byte(str), 777)
</code></pre><p>复制内容到文件</p><pre><code>Str, err := ioutil.ReadFile(&quot;./data.txt&quot;)
if err != nil {
    fmt.Println(&quot;读取文件出错&quot;)
    return
}
ioutil.WriteFile(&quot;./data1.txt&quot;, Str, 777)
</code></pre><p>创建目录</p><p>os.Mkdir("./test", 777)</p><p>删除文件和目录</p><pre><code>os.Remove(&quot;data1.txt&quot;) // 删除文件
os.Remove(&quot;./test) // 删除目录
os.RemoveAll(&quot;./test1&quot;) // 和Remove一样，不过这个会递归删除所有子目录和文件
</code></pre><p>重命名</p><pre><code>file := &quot;./data.txt&quot;
err1 := os.Rename(file,&quot;test.txt&quot;)
if err1 != nil {
    panic(err1)
} else {
    fmt.Println(&quot;文件重命名成功&quot;)
}
folder := &quot;./demo&quot;
err2 := os.Rename(folder, &quot;demo1&quot;)
if err2 != nil {
    panic(err1)
} else {
    fmt.Println(&quot;目录重命名成功&quot;)
}
</code></pre><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaochenabc123.github.io/tags/golang/>golang</a></li></ul><nav class=paginav><a class=prev href=https://xiaochenabc123.github.io/posts/97/><span class=title>« Prev</span><br><span>Redis学习笔记</span></a>
<a class=next href=https://xiaochenabc123.github.io/posts/95/><span class=title>Next »</span><br><span>简单使用Jest-JavaScript测试工具</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://xiaochenabc123.github.io/>小陈的个人博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>