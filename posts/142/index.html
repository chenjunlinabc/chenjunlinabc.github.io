<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust学习笔记 | 知政的个人博客</title>
<meta name=keywords content="Rust"><meta name=description content='Rust由非盈利组织Mozilla基金会开发，像著名的Mozilla Firefox浏览器和MDN Web Docs都出自该基金会
安装
官方推荐使用Rustup来安装（Rustup是rust的安装器和版本管理工具）
通过rustup-init来安装Rust
https://www.rust-lang.org/zh-CN/tools/install
windows直接安装pustup-init.exe来安装（需联网）,默认通过vc安装，建议选择2自定义安装
Linux或者macOS则直接执行以下命令
curl &ndash;proto &lsquo;=https&rsquo; &ndash;tlsv1.2 -sSf https://sh.rustup.rs | sh
注意：Rust的一些包，可能还依赖C编译器，因此最好安装一下GCC
检查是否安装完成
rustc &ndash;version
如果喜欢用Visual Studio Code开发，可搭配rust-analyzer插件来使用
更新rust
rustup update
卸载rust和rustup
rustup self uninstall
在安装rustup的同时也会安装Cargo
Cargo是rust的项目构建工具和包管理器
检查是否安装成功
cargo &ndash;version
创建第一个rust项目
cargo new halloword
其中Cargo.toml文件是项目的依赖库文件
通过编辑Cargo.toml文件来添加依赖
rust依赖可通过https://crates.io/查找
[package]name = "hallo_word"version = "0.0.1"edition = "2021"[dependencies]hyper = "0.14.20" # 来自https://crates.io/# hyper = { git = "https://github.com/hyperium/hyper" } # 来自第三方社区# hyper = { path = ".'><meta name=author content="Me"><link rel=canonical href=https://99999.fun/posts/142/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css rel="preload stylesheet" as=style><link rel=icon href=https://99999.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://99999.fun/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://99999.fun/favicon.ico><link rel=apple-touch-icon href=https://99999.fun/favicon.ico><link rel=mask-icon href=https://99999.fun/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://99999.fun/posts/142/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Rust学习笔记"><meta property="og:description" content='Rust由非盈利组织Mozilla基金会开发，像著名的Mozilla Firefox浏览器和MDN Web Docs都出自该基金会
安装
官方推荐使用Rustup来安装（Rustup是rust的安装器和版本管理工具）
通过rustup-init来安装Rust
https://www.rust-lang.org/zh-CN/tools/install
windows直接安装pustup-init.exe来安装（需联网）,默认通过vc安装，建议选择2自定义安装
Linux或者macOS则直接执行以下命令
curl &ndash;proto &lsquo;=https&rsquo; &ndash;tlsv1.2 -sSf https://sh.rustup.rs | sh
注意：Rust的一些包，可能还依赖C编译器，因此最好安装一下GCC
检查是否安装完成
rustc &ndash;version
如果喜欢用Visual Studio Code开发，可搭配rust-analyzer插件来使用
更新rust
rustup update
卸载rust和rustup
rustup self uninstall
在安装rustup的同时也会安装Cargo
Cargo是rust的项目构建工具和包管理器
检查是否安装成功
cargo &ndash;version
创建第一个rust项目
cargo new halloword
其中Cargo.toml文件是项目的依赖库文件
通过编辑Cargo.toml文件来添加依赖
rust依赖可通过https://crates.io/查找
[package]name = "hallo_word"version = "0.0.1"edition = "2021"[dependencies]hyper = "0.14.20" # 来自https://crates.io/# hyper = { git = "https://github.com/hyperium/hyper" } # 来自第三方社区# hyper = { path = ".'><meta property="og:type" content="article"><meta property="og:url" content="https://99999.fun/posts/142/"><meta property="og:image" content="https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-28T13:22:00+00:00"><meta property="article:modified_time" content="2022-03-28T13:22:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Rust学习笔记"><meta name=twitter:description content='Rust由非盈利组织Mozilla基金会开发，像著名的Mozilla Firefox浏览器和MDN Web Docs都出自该基金会
安装
官方推荐使用Rustup来安装（Rustup是rust的安装器和版本管理工具）
通过rustup-init来安装Rust
https://www.rust-lang.org/zh-CN/tools/install
windows直接安装pustup-init.exe来安装（需联网）,默认通过vc安装，建议选择2自定义安装
Linux或者macOS则直接执行以下命令
curl &ndash;proto &lsquo;=https&rsquo; &ndash;tlsv1.2 -sSf https://sh.rustup.rs | sh
注意：Rust的一些包，可能还依赖C编译器，因此最好安装一下GCC
检查是否安装完成
rustc &ndash;version
如果喜欢用Visual Studio Code开发，可搭配rust-analyzer插件来使用
更新rust
rustup update
卸载rust和rustup
rustup self uninstall
在安装rustup的同时也会安装Cargo
Cargo是rust的项目构建工具和包管理器
检查是否安装成功
cargo &ndash;version
创建第一个rust项目
cargo new halloword
其中Cargo.toml文件是项目的依赖库文件
通过编辑Cargo.toml文件来添加依赖
rust依赖可通过https://crates.io/查找
[package]name = "hallo_word"version = "0.0.1"edition = "2021"[dependencies]hyper = "0.14.20" # 来自https://crates.io/# hyper = { git = "https://github.com/hyperium/hyper" } # 来自第三方社区# hyper = { path = ".'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://99999.fun/posts/"},{"@type":"ListItem","position":2,"name":"Rust学习笔记","item":"https://99999.fun/posts/142/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust学习笔记","name":"Rust学习笔记","description":"Rust由非盈利组织Mozilla基金会开发，像著名的Mozilla Firefox浏览器和MDN Web Docs都出自该基金会\n安装\n官方推荐使用Rustup来安装（Rustup是rust的安装器和版本管理工具）\n通过rustup-init来安装Rust\nhttps://www.rust-lang.org/zh-CN/tools/install\nwindows直接安装pustup-init.exe来安装（需联网）,默认通过vc安装，建议选择2自定义安装\nLinux或者macOS则直接执行以下命令\ncurl \u0026ndash;proto \u0026lsquo;=https\u0026rsquo; \u0026ndash;tlsv1.2 -sSf https://sh.rustup.rs | sh\n注意：Rust的一些包，可能还依赖C编译器，因此最好安装一下GCC\n检查是否安装完成\nrustc \u0026ndash;version\n如果喜欢用Visual Studio Code开发，可搭配rust-analyzer插件来使用\n更新rust\nrustup update\n卸载rust和rustup\nrustup self uninstall\n在安装rustup的同时也会安装Cargo\nCargo是rust的项目构建工具和包管理器\n检查是否安装成功\ncargo \u0026ndash;version\n创建第一个rust项目\ncargo new halloword\n其中Cargo.toml文件是项目的依赖库文件\n通过编辑Cargo.toml文件来添加依赖\nrust依赖可通过https://crates.io/查找\n[package]\rname = \u0026quot;hallo_word\u0026quot;\rversion = \u0026quot;0.0.1\u0026quot;\redition = \u0026quot;2021\u0026quot;\r[dependencies]\rhyper = \u0026quot;0.14.20\u0026quot; # 来自https://crates.io/\r# hyper = { git = \u0026quot;https://github.com/hyperium/hyper\u0026quot; } # 来自第三方社区\r# hyper = { path = \u0026quot;.","keywords":["Rust"],"articleBody":"Rust由非盈利组织Mozilla基金会开发，像著名的Mozilla Firefox浏览器和MDN Web Docs都出自该基金会\n安装\n官方推荐使用Rustup来安装（Rustup是rust的安装器和版本管理工具）\n通过rustup-init来安装Rust\nhttps://www.rust-lang.org/zh-CN/tools/install\nwindows直接安装pustup-init.exe来安装（需联网）,默认通过vc安装，建议选择2自定义安装\nLinux或者macOS则直接执行以下命令\ncurl –proto ‘=https’ –tlsv1.2 -sSf https://sh.rustup.rs | sh\n注意：Rust的一些包，可能还依赖C编译器，因此最好安装一下GCC\n检查是否安装完成\nrustc –version\n如果喜欢用Visual Studio Code开发，可搭配rust-analyzer插件来使用\n更新rust\nrustup update\n卸载rust和rustup\nrustup self uninstall\n在安装rustup的同时也会安装Cargo\nCargo是rust的项目构建工具和包管理器\n检查是否安装成功\ncargo –version\n创建第一个rust项目\ncargo new halloword\n其中Cargo.toml文件是项目的依赖库文件\n通过编辑Cargo.toml文件来添加依赖\nrust依赖可通过https://crates.io/查找\n[package]\rname = \"hallo_word\"\rversion = \"0.0.1\"\redition = \"2021\"\r[dependencies]\rhyper = \"0.14.20\" # 来自https://crates.io/\r# hyper = { git = \"https://github.com/hyperium/hyper\" } # 来自第三方社区\r# hyper = { path = \"../hyper\" } # 来自本地文件\r构建依赖到项目中\ncargo build halloword\n当构建完成后，会在项目的根目录中创建一个名叫Cargo.lock的文件，该文件记录项目依赖的版本\nsrc/main.rs是该项目的程序编写文件\n在src/main.rs添加以下内容\nfn main() {\rprintln!(\"hallo, world\");\r};\r进入该项目根目录运行该项目\ncargo run\n或者直接编译main.rs\nrustc main.rs ./main\n注意：在windows上，需要加.exe，.\\main.exe\n在hallo word例子中看到，fn是创建函数的关键字，main是函数名，该函数调用了println!()，其实这是一个macro（宏），“hallo, world\"作为字符串参数传递到了该宏中\n另外cargo提供了一个命令，来不用生成二进制文件的前提下构建项目，来检查项目的错误\ncargo check\nbuild和run默认是debug版本的，如果需要编译release版本执行cargo build –release\n在rust中函数是一等公民，其中main函数是程序的入口函数（和golang一样）\n注释可以让rust编译器忽略，例如：// hallo word\n多行注释可使用块注释，例如：\n/*\rhallo\rword\r*/\r文档注释，行注释例如：\n/// 1\r/// 2\r/// 3\r文档块注释，例如：\n/**\rhallo\rword\r*/\r注意：文档注释必须位于lib类型的包中，文档注释看使用md语法\n可使用cargo doc命令，来对文档注释生成html文件，放在target/doc目录下，也可以使用 cargo doc –open 生成文档后自动打开html网页\n变量通过let关键字来创建\nfn main() {\rlet mut abc = \"hallo word\";\rabc = \"hhh\";\rprintln!(\" abc: {}\",abc);\r};\r注意：rust变量默认是不能变得，需要通过mut关键字来让变量可变\n变量存在遮蔽性，如果使用let关键重复声明同一个变量，会遮蔽之前声明的变量的值和类型\n变量的遮蔽性和mut关键字的区别是，mut关键字无法修改变量的类型，mut关键字修改的只能是相同类型的值\n常量通过const关键字来创建\nfn main() {\rconst ABC = \"hallo word\";\rprintln!(\" ABC: {}\",ABC);\r};\r常量不可变，也不能使用mut，而且必须声明类型（字面量也算是一种类型声明）\n数据类型\nrust是静态型编译语言，因此需要在编译之前就知道全部变量的类型\nrust有4大基础类型，这个基础类型又叫标量类型，分别是整型，浮点型，布尔型，字符型\n整型就是没有小数的整数（分符号类型和无符号类型，区别是是否为负数，可能为负数使用有符号类型，不可能为负数使用无符号类型）\n整型使用u表示无符号类型，用i表示有符号类型，再声明使用多少位的空间，例如i32，就是占32位空间的有符号类型\n还有2个特殊的类型，isize和usize，这个类型取决程序执行环境的系统架构，使用64位架构就是占64位空间\n整型支持十进制，八进制，二进制，十六进制和字节，rust默认使用i32类型\n注意：使用有符号类型会将以二进制补码的方式来存储\n浮点类型，就是带小数的数字，rust的浮点型有2个类型，分别是f32和f64，默认是f64，f64是双精度浮点型，f32类型是单精度，并且全部类型都是具备符号的（可为负数）\n布尔类型，布尔类型只能是这2个值得其中之一，true和false，布尔类型使用bool关键字来声明，例如 let a: bool = true;,当然也是可以使用字面量来声明\n字符类型，字符类型使用单引号包括，并且只能表示一个Unicode字符（因为字符类型只使用4个字节）\n字符串类型使用双引号表示，可表示多个字符，使用String表示，例如：\nlet a:String = \"hallo word\";\rprinln!(\"{}\",a);\r除了标量类型外还有复合类型，复合类型有6种，分别是元组和数组，枚举，结构体，字符串，切片\n元组类型就是无法扩展和收缩的数组（元组可使用不同的类型），长度是固定的，例如：\nlet a: (i64, f64) = (100,3.14);\r获取元组的元素可通过解构的方式来完成，例如：\nlet a: (i64, f64) = (100,3.14);\rlet (b,c) = a;\r也可以通过索引值来获取，例如：\nlet a: (i64, f64) = (100,3.14);\rlet b = a.1;\r元组的索引是从0开始的\n数组类型和元组不同，数组的类型必须是相同类型的，数组长度也是固定的\nlet a = [1,233,666];\rrust也提供了动态数组（vector），动态数组将被分配到堆内存空间，而普通数组会被分配到栈内存空间\n动态数组使用Vec的方式来声明，动态数组也不能使用不同的类型，但是动态数组可以扩展空间和缩小，而且全部元素在内存是相邻排列的，可使用Vec::new()来创建一个空的动态数组，例如：\nlet a: Vev = Vec::new();\r当然也可以提供初始值来创建\nlet b = vec![2,4,68];\rrust可以根据字面量来自动推断出类型\n动态数组增加元素使用push方法，例如：\nlet mut a: Vev = Vec::new()； a.push(1); a.push(2); a.push(3); a.push(4); a.push(5);\n注意：动态数组离开当前作用域会被丢弃销毁\n获取动态数组的元素，可通过get方法或者索引来完成，例如：\nlet a = vec![2,4,68];\rlet b = a.get(2);\rlet c = \u0026a[2];\rget方法和索引的区别是，get方法访问超过数组不存在的元素是不会报错的，而是返回none，而索引访问是会导致报错，程序崩溃的\n遍历动态数组\nlet a = vec![2,4,68];\rfot i in \u0026a{\rprintln!(\"{}\",i);\r};\r动态数组支持枚举类型，这可以让动态数组存储不同类型的值，例如；\nenum Hallo{\rInt(i64),\rText(String),\r};\rlet a = vec![\rHallo::Int(666),\rHallo::Text(Sting::from(\"hallo word\")),\r];\r函数，是rust的第一个公民，main函数是rust程序入口文件，而且函数定义可在main函数之前或者之后，使用fn关键字来声明，例如：\nfn hallo_word(){\rprintln!(\"hallo word\");\r};\rfn main(){\rhallo_word();\r};\r函数参数\nfn main(){\ra(666);\r};\rfn a(x:i64){\rprintln!(\"{}\",x);\r};\r函数返回值\nfn main(){\ra(666);\r};\rfn a(x:i64) -\u003e{\rx+123\r};\r注意：返回值使用-\u003e返回，而且不能使用分号，因为语句无法作为返回值返回\nif判断\nlet a = 1;\rif a \u003c10{\rprintln!(\"true \u003e10\");\r}else if(a\u003e0){\rprintln!(\"true \u003e10\");\r}else{\rprintln!('none')\r};\r注意：if判断必须提供一个布尔类型的值，否则会抛出错误\n表达式是可以赋值给变量的，例如：let boola = true; let a = if boola{1} else{2}\nrust的循环有3种，分别是for，while，以及loop\nfor遍历循环（常用于遍历集合元素），例如：\nlet a = [1,2,3,45,6];\rfor b in a {\rprintln!(\"{}\",b);\r};\rwhile循环，条件为真执行，为假停止循环。例如：\nlet mut a = 0\rwhile a \u003c= 10{\rprintln!(\"hallo wrod\");\ra +=1;\r};\rloop关键字可以一直执行语句，直到被跳出（可使用break关键字），例如：\nlet mut count = 0;\rloop{\rprintln!(\"hallo word\");\rif (count == 5){\rbreak;\r};\rcount +=1;\r};\rloop循环可以搞个标签，来指定终止哪次循环（嵌套循环下），例如：‘a’: loop{ break ‘a’}\ncontinue操作符可跳出当前循环，去执行下次循环，一般搭配if分支语句来使用\n所有权\n所有权是rust的特性之一，无需gc垃圾回收机制就可以保证内存安全\n作用域是一个语句块在程序中有效的范围，在该范围内的变量是有效的，离开该范围后将自动释放内存空间\n释放内存空间是使用rust提供的一个叫drop函数，会在结尾}自动调用该函数\n当一个变量的值是指针时，赋值给另一个变量，当这2个变量离开作用域后，会导致二次释放，因为这2个变量指向的是同一个内存空间地址，二次释放会导致内存污染，这个指针实质上是在堆上的\nrust为了解决二次释放导致的内存安全问题，当一个存在指针值的变量赋值给另一个变量后，会销毁第一个变量，而无需再等到离开作用域，第一个变量将变成是无效的，这个赋值将不是复制，而是剪切板一样，移动数据\n如果需要复制堆的数据，可使用clone方法，例如：\nlet a = String::from(\"hallo word\");\rlet b = a.clone();\rprintln!(\"{},{}\"a,b);\r注意：移动数据只针对栈上的指针之类的有效，如果是赋值的是整型之类存在在栈上的，是不需要移动，因为复制指针这些\"引用类型\"需要耗费性能，rust通过copy trait标注来决定是否赋值给其他变量后，这个变量是否还有效，只要类型实现了copy trait就可以\n支持copy trait的类型：全部整数类型，布尔类型，浮点类型，字符类型，元组（部分类型支持）\n为了避免需要引用变量而导致原变量失效，rust提供了引用功能，例如：\nlet a = String::from(\"hallo word\");\rlet b = \u0026a;\r引用不会具备该值的所有权，但是可以指向这个值\n引用实质上是借用的，是不能修改借用的值，如果想修改可提前对具备所有权的变量声明mut可变，例如：\nlet mut a = String::from(\"hallo\");\rlet b = \u0026mut a;\r注意：同一个作用域中只能有一个对这个数据进行可变引用，使用多个可变引用会报错，这是为了避免竞争\n切片类型也是没有所有权的，对切片类型进行操作，是不会影响到原来的值，例如：\nlet a = String::from(\"hallo world\");\rlet hello = \u0026a[0..5];\rlet world = \u0026a[6..11];\ra.clear();\r结构体与元组一样，元素可以是多个类型，但是和元组不同的是，结构图具备元素别名，并且使用struct来定义结构体，例如：\nstruct Name{\rid: i64,\rusername: String,\remail: String,\rpass: String,\r};\r上面例子就是一个结构体，这个结构体的名称叫Name，具备4个字段，每个字段有自己对于的字段名称和类型\n有结构体当然也有结构体实例，结构体是结构体实例的抽象\nlet name1 = Name{\rid: 1,\rusername: String::from(\"root\"),\remail: String::form(\"a@xiaochenabc123.test.com\"),\rpass: String::form(\"123456789\"),\r};\rprintln!(\"hallo {}\", name1.username);\rname1.email = String::from(\"b@xiaochenabc123.test.com\");\r注意：结构体实例必须按照结构体每个字段的类型要求进行初始化，不需要按照结构体声明的字段顺序一样\n利用函数返回值来完成结构体的实例化，例如：\nfn NameTest(username: String, email: String, pass: String) -\u003e{\rName{\rusername,\remail,\rpass,\r};\r};\rfn main(){\rlet name01 = NameTest(\"user01\",\"test@xiaochenabc123.test.com\",\"12356987\");\rprintln!(\"hallo {}\", name01.username);\r};\r基于已有的实例，创建新的实例，例如：\nlet name2 = Name{\rusername: String::from(\"uesr02\"),\r..name01\r};\r注意：其中..name01是表示其他字段将从name01实例中获取\n元组结构体（结构体字段没名称的就叫元组结构体）\nstruct Abc(i64,bool,f64);\rlet abc1 = Abc(100,true,3.14);\r单元结构体（这玩意和go的空结构体一样，只定义一个结构体，但是没有字段和属性）\nstruct Xyz;\rlet xyz1 = Xyz;\r结构体的所有权：当使用已有的实例，创建新的实例时，改变的字段的所有权将会被转移到新的实例，原有的实例的那个字段将失效，其他字段正常，因此使用结构体应该避免使用引用类型\n枚举\nenum HomeTest{\rHallo,\rXyz,\rAbc,\rHahaha(i64)\r};\rstruct Demo{\rhome: HomeTest,\rid: i64,\r}\rfn main(){\rlet test1 = HomeTest::Hallo;\rlet test2 = HomeTest::Abc;\rprintln!(test1);\rprintln!(test2);\rlet a = Demo{\rhome: HomeTest::Abc,\rid: 1,\r}\rlet b = Demo{\rhome: HomeTest::Hallo,\rid: 2,\r}\r}\r上面例子中，通过enum关键字声明并且定义一个枚举类型，这个枚举类型有3个枚举成员，通过::操作符来访问枚举的成员，枚举是一种类型，因此可用于函数参数类型，结构体类型等等\n枚举的成员可以是任何类型的数据，也可以限制成员的数据类型，结构体使用{}，单个使用()，多个可使用逗号分割\nrust的空值使用Option枚举类型来表示，而不是null\nOption，Some，None都包含在prelude标准库中，不需要在源码中声明，或者引用，直接就可以使用\nOption枚举类型的实现\nenum Option {\rSome(T),\rNone,\r};\r表示一个空值\nlet null1: Option = None;\r如果使用None，则需要提前提供是什么类型，因为无法通过None来推断出类型\nOption比null好的原因是，Option(T)和任何类型都不相同，无法将Option和i64类型的值进行处理\n如果有值则：\nlet num1:Option = Some(233);\r如果使用Some，表示有个值存于Some中\n使用Option枚举类型：\nfn Test(a:Option) -\u003e Option {\rmatch a {\rSome(i) =\u003e Some(i),\rNone =\u003e None,\r}\r}\rlet abc = Some(666);\rlet xyz = Test(abc);\r上面例子中，通过Test函数传入一个Option类型的参数，并且返回一个Option类型的值，使用match模式匹配，如果传入None则返回None，传入Some(i64)，则返回其本身（也就是Some(i64)）\n模式匹配\nmatch语句\nenum Demo{\rHallo,\rAbc,\rXyz,\r};\rlet test1 = Demo::Xyz;\rlet test2 = match test1 {\rDemo::Hallo =\u003e \"hallo word\",\rDemo::Abc | Demo::Xyz =\u003e \"hallo abcxyz\",\r},\r_ =\u003e\"0\",\r};\r上面例子中进行匹配Demo对应的枚举类型，match会穷尽列出全部已知的可能，如果存在不知道的可能，使用下划线_来表示，match语句与switch语句很像，match的分支必须指向一个表达式，而且每个分支的表达式结果必须是相同类型的\n假如只想对单个模式来进行处理，可使用if let语句，例如：\nlet test1 = Demo::Xyz;\rif let Test2(Demo::Xyz) = test1{\rprintln!(\"hallo wrod\");\r}\r上面例子中，如果匹配到Demo::Xyz，输出hallo wrod，如果不匹配则忽略\n注意：match和if let会在模式匹配时进行覆盖老值，绑定新的值\nmatches!宏匹配，可以将一个表达式和模式来进行匹配，返回结果是布尔值，例如：\nlet a = 1;\rassert!(matches!(1..100 | -1..-100));\r方法\nrust使用impl关键字来定义方法\nstruct Demo {\rid: i64,\ruser: String,\r}\rimpl Demo {\rfn new(id: i64, user: String) -\u003e Demo {\rDemo{\rid: id,\ruser: user,\r}\r}\rfn printa(\u0026self){\rprintln!(self.user)\r}\r}\rfn mian(){\rlet a = Demo{\rid: 1,\ruser: \"root\",\r}\ra.printa()\r}\r\u0026self为借用Demo结构体，new函数是Demo方法的关联函数，用于初始化结构体实例\n\u0026self是self: \u0026Self的简写，self有所有权，而\u0026self是表示不可变借用，\u0026mut self就是可变借用\nimpl Demo是struct Demo的实现，另外rust允许方法名与结构体的字段名相同，调用方法加()，否则就是在访问字段\nrust自动引用和解引用：当一个对象调用方法时，会自动为该对象添加\u0026，\u0026mut，*来确保该对象能与方法匹配\n关联函数：当一个存在于impl中，但是没有使用self的函数就被叫关联函数，通常存在impl中的new函数是结构体的构造实例器（rust没有使用new作为关键字，并不强制使用new）\n关联函数因为不是方法，需要使用::来调用，例如Demo::new(2,“admin”)\nrust允许将结构体定义成多个impl块，而不需要全部都写到一块，更灵活扩展\n枚举类型也可被实现\n泛型与特征\n泛型，当需要对可能存在不同类型的数据处理，但是处理逻辑是一样时，可使用泛型来避免重复，例如：\nfn test","wordCount":"1323","inLanguage":"en","datePublished":"2022-03-28T13:22:00Z","dateModified":"2022-03-28T13:22:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://99999.fun/posts/142/"},"publisher":{"@type":"Organization","name":"知政的个人博客","logo":{"@type":"ImageObject","url":"https://99999.fun/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://99999.fun/ accesskey=h title="知政的个人博客 (Alt + H)"><img src=https://99999.fun/favicon.ico alt aria-label=logo height=35>知政的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://99999.fun/ title=首页><span>首页</span></a></li><li><a href=https://99999.fun/categories/ title=分类><span>分类</span></a></li><li><a href=https://99999.fun/archives/ title=归档><span>归档</span></a></li><li><a href=https://99999.fun/tags/ title=标签><span>标签</span></a></li><li><a href=https://99999.fun/links/ title=链接><span>链接</span></a></li><li><a href=https://99999.fun/about/ title=关于><span>关于</span></a></li><li><a href=https://99999.fun/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://99999.fun/>Home</a>&nbsp;»&nbsp;<a href=https://99999.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Rust学习笔记</h1><div class=post-meta><span title='2022-03-28 13:22:00 +0000 UTC'>2022-03-28</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://99999.fun//posts/Rust%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Rust由非盈利组织Mozilla基金会开发，像著名的Mozilla Firefox浏览器和MDN Web Docs都出自该基金会</p><p>安装</p><p>官方推荐使用Rustup来安装（Rustup是rust的安装器和版本管理工具）</p><p>通过rustup-init来安装Rust</p><p><a href=https://www.rust-lang.org/zh-CN/tools/install>https://www.rust-lang.org/zh-CN/tools/install</a></p><p>windows直接安装pustup-init.exe来安装（需联网）,默认通过vc安装，建议选择2自定义安装</p><p>Linux或者macOS则直接执行以下命令</p><p>curl &ndash;proto &lsquo;=https&rsquo; &ndash;tlsv1.2 -sSf <a href=https://sh.rustup.rs>https://sh.rustup.rs</a> | sh</p><p>注意：Rust的一些包，可能还依赖C编译器，因此最好安装一下GCC</p><p>检查是否安装完成</p><p>rustc &ndash;version</p><p>如果喜欢用Visual Studio Code开发，可搭配rust-analyzer插件来使用</p><p>更新rust</p><p>rustup update</p><p>卸载rust和rustup</p><p>rustup self uninstall</p><p>在安装rustup的同时也会安装Cargo</p><p>Cargo是rust的项目构建工具和包管理器</p><p>检查是否安装成功</p><p>cargo &ndash;version</p><p>创建第一个rust项目</p><p>cargo new halloword</p><p>其中Cargo.toml文件是项目的依赖库文件</p><p>通过编辑Cargo.toml文件来添加依赖</p><p>rust依赖可通过https://crates.io/查找</p><pre><code>[package]
name = &quot;hallo_word&quot;
version = &quot;0.0.1&quot;
edition = &quot;2021&quot;
[dependencies]
hyper = &quot;0.14.20&quot; # 来自https://crates.io/
# hyper = { git = &quot;https://github.com/hyperium/hyper&quot; } # 来自第三方社区
# hyper = { path = &quot;../hyper&quot; } # 来自本地文件
</code></pre><p>构建依赖到项目中</p><p>cargo build halloword</p><p>当构建完成后，会在项目的根目录中创建一个名叫Cargo.lock的文件，该文件记录项目依赖的版本</p><p>src/main.rs是该项目的程序编写文件</p><p>在src/main.rs添加以下内容</p><pre><code>fn main() {
    println!(&quot;hallo, world&quot;);
};
</code></pre><p>进入该项目根目录运行该项目</p><p>cargo run</p><p>或者直接编译main.rs</p><p>rustc main.rs
./main</p><p>注意：在windows上，需要加.exe，.\main.exe</p><p>在hallo word例子中看到，fn是创建函数的关键字，main是函数名，该函数调用了println!()，其实这是一个macro（宏），&ldquo;hallo, world"作为字符串参数传递到了该宏中</p><p>另外cargo提供了一个命令，来不用生成二进制文件的前提下构建项目，来检查项目的错误</p><p>cargo check</p><p>build和run默认是debug版本的，如果需要编译release版本执行cargo build &ndash;release</p><hr><p>在rust中函数是一等公民，其中main函数是程序的入口函数（和golang一样）</p><p>注释可以让rust编译器忽略，例如：// hallo word</p><p>多行注释可使用块注释，例如：</p><pre><code>/*
    hallo
    word
*/
</code></pre><p>文档注释，行注释例如：</p><pre><code>/// 1
/// 2
/// 3
</code></pre><p>文档块注释，例如：</p><pre><code>/**
    hallo
    word
*/
</code></pre><p>注意：文档注释必须位于lib类型的包中，文档注释看使用md语法</p><p>可使用cargo doc命令，来对文档注释生成html文件，放在target/doc目录下，也可以使用 cargo doc &ndash;open 生成文档后自动打开html网页</p><p>变量通过let关键字来创建</p><pre><code>fn main() {
    let mut abc = &quot;hallo word&quot;;
    abc = &quot;hhh&quot;;
    println!(&quot; abc: {}&quot;,abc);
};
</code></pre><p>注意：rust变量默认是不能变得，需要通过mut关键字来让变量可变</p><p>变量存在遮蔽性，如果使用let关键重复声明同一个变量，会遮蔽之前声明的变量的值和类型</p><p>变量的遮蔽性和mut关键字的区别是，mut关键字无法修改变量的类型，mut关键字修改的只能是相同类型的值</p><p>常量通过const关键字来创建</p><pre><code>fn main() {
    const ABC = &quot;hallo word&quot;;
    println!(&quot; ABC: {}&quot;,ABC);
};
</code></pre><p>常量不可变，也不能使用mut，而且必须声明类型（字面量也算是一种类型声明）</p><hr><p>数据类型</p><p>rust是静态型编译语言，因此需要在编译之前就知道全部变量的类型</p><p>rust有4大基础类型，这个基础类型又叫标量类型，分别是整型，浮点型，布尔型，字符型</p><p>整型就是没有小数的整数（分符号类型和无符号类型，区别是是否为负数，可能为负数使用有符号类型，不可能为负数使用无符号类型）</p><p>整型使用u表示无符号类型，用i表示有符号类型，再声明使用多少位的空间，例如i32，就是占32位空间的有符号类型</p><p>还有2个特殊的类型，isize和usize，这个类型取决程序执行环境的系统架构，使用64位架构就是占64位空间</p><p>整型支持十进制，八进制，二进制，十六进制和字节，rust默认使用i32类型</p><p>注意：使用有符号类型会将以二进制补码的方式来存储</p><p>浮点类型，就是带小数的数字，rust的浮点型有2个类型，分别是f32和f64，默认是f64，f64是双精度浮点型，f32类型是单精度，并且全部类型都是具备符号的（可为负数）</p><p>布尔类型，布尔类型只能是这2个值得其中之一，true和false，布尔类型使用bool关键字来声明，例如 let a: bool = true;,当然也是可以使用字面量来声明</p><p>字符类型，字符类型使用单引号包括，并且只能表示一个Unicode字符（因为字符类型只使用4个字节）</p><p>字符串类型使用双引号表示，可表示多个字符，使用String表示，例如：</p><pre><code>let a:String = &quot;hallo word&quot;;
prinln!(&quot;{}&quot;,a);
</code></pre><p>除了标量类型外还有复合类型，复合类型有6种，分别是元组和数组，枚举，结构体，字符串，切片</p><p>元组类型就是无法扩展和收缩的数组（元组可使用不同的类型），长度是固定的，例如：</p><pre><code>let a: (i64, f64) = (100,3.14);
</code></pre><p>获取元组的元素可通过解构的方式来完成，例如：</p><pre><code>let a: (i64, f64) = (100,3.14);
let (b,c) = a;
</code></pre><p>也可以通过索引值来获取，例如：</p><pre><code>let a: (i64, f64) = (100,3.14);
let b = a.1;
</code></pre><p>元组的索引是从0开始的</p><p>数组类型和元组不同，数组的类型必须是相同类型的，数组长度也是固定的</p><pre><code>let a = [1,233,666];
</code></pre><p>rust也提供了动态数组（vector），动态数组将被分配到堆内存空间，而普通数组会被分配到栈内存空间</p><p>动态数组使用Vec的方式来声明，动态数组也不能使用不同的类型，但是动态数组可以扩展空间和缩小，而且全部元素在内存是相邻排列的，可使用Vec::new()来创建一个空的动态数组，例如：</p><pre><code>let a: Vev&lt;u64&gt; = Vec::new();
</code></pre><p>当然也可以提供初始值来创建</p><pre><code>let b = vec![2,4,68];
</code></pre><p>rust可以根据字面量来自动推断出类型</p><p>动态数组增加元素使用push方法，例如：</p><p>let mut a: Vev = Vec::new()；
a.push(1);
a.push(2);
a.push(3);
a.push(4);
a.push(5);</p><p>注意：动态数组离开当前作用域会被丢弃销毁</p><p>获取动态数组的元素，可通过get方法或者索引来完成，例如：</p><pre><code>let a = vec![2,4,68];
let b = a.get(2);
let c = &amp;a[2];
</code></pre><p>get方法和索引的区别是，get方法访问超过数组不存在的元素是不会报错的，而是返回none，而索引访问是会导致报错，程序崩溃的</p><p>遍历动态数组</p><pre><code>let a = vec![2,4,68];
fot i in &amp;a{
    println!(&quot;{}&quot;,i);
};
</code></pre><p>动态数组支持枚举类型，这可以让动态数组存储不同类型的值，例如；</p><pre><code>enum Hallo{
    Int(i64),
    Text(String),
};
let a = vec![
    Hallo::Int(666),
    Hallo::Text(Sting::from(&quot;hallo word&quot;)),
];
</code></pre><p>函数，是rust的第一个公民，main函数是rust程序入口文件，而且函数定义可在main函数之前或者之后，使用fn关键字来声明，例如：</p><pre><code>fn hallo_word(){
    println!(&quot;hallo word&quot;);
};
fn main(){
    hallo_word();
};
</code></pre><p>函数参数</p><pre><code>fn main(){
    a(666);
};
fn a(x:i64){
    println!(&quot;{}&quot;,x);
};
</code></pre><p>函数返回值</p><pre><code>fn main(){
    a(666);
};
fn a(x:i64) -&gt;{
    x+123
};
</code></pre><p>注意：返回值使用->返回，而且不能使用分号，因为语句无法作为返回值返回</p><hr><p>if判断</p><pre><code>let a = 1;
if a &lt;10{
    println!(&quot;true &gt;10&quot;);
}else if(a&gt;0){
    println!(&quot;true &gt;10&quot;);
}else{
    println!('none')
};
</code></pre><p>注意：if判断必须提供一个布尔类型的值，否则会抛出错误</p><p>表达式是可以赋值给变量的，例如：let boola = true; let a = if boola{1} else{2}</p><p>rust的循环有3种，分别是for，while，以及loop</p><p>for遍历循环（常用于遍历集合元素），例如：</p><pre><code>let a = [1,2,3,45,6];
for b in a {
    println!(&quot;{}&quot;,b);
};
</code></pre><p>while循环，条件为真执行，为假停止循环。例如：</p><pre><code>let mut a = 0
while a &lt;= 10{
    println!(&quot;hallo wrod&quot;);
    a +=1;
};
</code></pre><p>loop关键字可以一直执行语句，直到被跳出（可使用break关键字），例如：</p><pre><code>let mut count = 0;
loop{
    println!(&quot;hallo word&quot;);
    if (count == 5){
        break;
    };
    count +=1;
};
</code></pre><p>loop循环可以搞个标签，来指定终止哪次循环（嵌套循环下），例如：&lsquo;a&rsquo;: loop{ break &lsquo;a&rsquo;}</p><p>continue操作符可跳出当前循环，去执行下次循环，一般搭配if分支语句来使用</p><hr><p>所有权</p><p>所有权是rust的特性之一，无需gc垃圾回收机制就可以保证内存安全</p><p>作用域是一个语句块在程序中有效的范围，在该范围内的变量是有效的，离开该范围后将自动释放内存空间</p><p>释放内存空间是使用rust提供的一个叫drop函数，会在结尾}自动调用该函数</p><p>当一个变量的值是指针时，赋值给另一个变量，当这2个变量离开作用域后，会导致二次释放，因为这2个变量指向的是同一个内存空间地址，二次释放会导致内存污染，这个指针实质上是在堆上的</p><p>rust为了解决二次释放导致的内存安全问题，当一个存在指针值的变量赋值给另一个变量后，会销毁第一个变量，而无需再等到离开作用域，第一个变量将变成是无效的，这个赋值将不是复制，而是剪切板一样，移动数据</p><p>如果需要复制堆的数据，可使用clone方法，例如：</p><pre><code>let a = String::from(&quot;hallo word&quot;);
let b = a.clone();
println!(&quot;{},{}&quot;a,b);
</code></pre><p>注意：移动数据只针对栈上的指针之类的有效，如果是赋值的是整型之类存在在栈上的，是不需要移动，因为复制指针这些"引用类型"需要耗费性能，rust通过copy trait标注来决定是否赋值给其他变量后，这个变量是否还有效，只要类型实现了copy trait就可以</p><p>支持copy trait的类型：全部整数类型，布尔类型，浮点类型，字符类型，元组（部分类型支持）</p><p>为了避免需要引用变量而导致原变量失效，rust提供了引用功能，例如：</p><pre><code>let a = String::from(&quot;hallo word&quot;);
let b = &amp;a;
</code></pre><p>引用不会具备该值的所有权，但是可以指向这个值</p><p>引用实质上是借用的，是不能修改借用的值，如果想修改可提前对具备所有权的变量声明mut可变，例如：</p><pre><code>let mut a = String::from(&quot;hallo&quot;);
let b = &amp;mut a;
</code></pre><p>注意：同一个作用域中只能有一个对这个数据进行可变引用，使用多个可变引用会报错，这是为了避免竞争</p><p>切片类型也是没有所有权的，对切片类型进行操作，是不会影响到原来的值，例如：</p><pre><code>let a = String::from(&quot;hallo world&quot;);
let hello = &amp;a[0..5];
let world = &amp;a[6..11];
a.clear();
</code></pre><hr><p>结构体与元组一样，元素可以是多个类型，但是和元组不同的是，结构图具备元素别名，并且使用struct来定义结构体，例如：</p><pre><code>struct Name{
    id: i64,
    username: String,
    email: String,
    pass: String,
};
</code></pre><p>上面例子就是一个结构体，这个结构体的名称叫Name，具备4个字段，每个字段有自己对于的字段名称和类型</p><p>有结构体当然也有结构体实例，结构体是结构体实例的抽象</p><pre><code>let name1 = Name{
    id: 1,
    username: String::from(&quot;root&quot;),
    email: String::form(&quot;a@xiaochenabc123.test.com&quot;),
    pass: String::form(&quot;123456789&quot;),
};
println!(&quot;hallo {}&quot;, name1.username);
name1.email = String::from(&quot;b@xiaochenabc123.test.com&quot;);
</code></pre><p>注意：结构体实例必须按照结构体每个字段的类型要求进行初始化，不需要按照结构体声明的字段顺序一样</p><p>利用函数返回值来完成结构体的实例化，例如：</p><pre><code>fn NameTest(username: String, email: String, pass: String) -&gt;{
    Name{
        username,
        email,
        pass,
    };
};
fn main(){
    let name01 = NameTest(&quot;user01&quot;,&quot;test@xiaochenabc123.test.com&quot;,&quot;12356987&quot;);
    println!(&quot;hallo {}&quot;, name01.username);
};
</code></pre><p>基于已有的实例，创建新的实例，例如：</p><pre><code>let name2 = Name{
    username: String::from(&quot;uesr02&quot;),
    ..name01
};
</code></pre><p>注意：其中..name01是表示其他字段将从name01实例中获取</p><p>元组结构体（结构体字段没名称的就叫元组结构体）</p><pre><code>struct Abc(i64,bool,f64);
let abc1 = Abc(100,true,3.14);
</code></pre><p>单元结构体（这玩意和go的空结构体一样，只定义一个结构体，但是没有字段和属性）</p><pre><code>struct Xyz;
let xyz1 = Xyz;
</code></pre><p>结构体的所有权：当使用已有的实例，创建新的实例时，改变的字段的所有权将会被转移到新的实例，原有的实例的那个字段将失效，其他字段正常，因此使用结构体应该避免使用引用类型</p><hr><p>枚举</p><pre><code>enum HomeTest{
    Hallo,
    Xyz,
    Abc,
    Hahaha(i64)
};
struct Demo{
    home: HomeTest,
    id: i64,
}
fn main(){
    let test1 = HomeTest::Hallo;
    let test2 = HomeTest::Abc;
    println!(test1);
    println!(test2);
    let a = Demo{
        home: HomeTest::Abc,
        id: 1,
    }
    let b = Demo{
        home: HomeTest::Hallo,
        id: 2,
    }
}
</code></pre><p>上面例子中，通过enum关键字声明并且定义一个枚举类型，这个枚举类型有3个枚举成员，通过::操作符来访问枚举的成员，枚举是一种类型，因此可用于函数参数类型，结构体类型等等</p><p>枚举的成员可以是任何类型的数据，也可以限制成员的数据类型，结构体使用{}，单个使用()，多个可使用逗号分割</p><p>rust的空值使用Option枚举类型来表示，而不是null</p><p>Option，Some，None都包含在prelude标准库中，不需要在源码中声明，或者引用，直接就可以使用</p><p>Option枚举类型的实现</p><pre><code>enum Option&lt;T&gt; {
    Some(T),
    None,
};
</code></pre><p>表示一个空值</p><pre><code>let null1: Option&lt;i64&gt; = None;
</code></pre><p>如果使用None，则需要提前提供是什么类型，因为无法通过None来推断出类型</p><p>Option比null好的原因是，Option(T)和任何类型都不相同，无法将Option和i64类型的值进行处理</p><p>如果有值则：</p><pre><code>let num1:Option &lt;i64&gt; = Some(233);
</code></pre><p>如果使用Some，表示有个值存于Some中</p><p>使用Option枚举类型：</p><pre><code>fn Test(a:Option&lt;i64&gt;) -&gt; Option&lt;i64&gt; {
    match a {
        Some(i) =&gt; Some(i),
        None =&gt; None,
    }
}
let abc = Some(666);
let xyz = Test(abc);
</code></pre><p>上面例子中，通过Test函数传入一个Option类型的参数，并且返回一个Option类型的值，使用match模式匹配，如果传入None则返回None，传入Some(i64)，则返回其本身（也就是Some(i64)）</p><hr><p>模式匹配</p><p>match语句</p><pre><code>enum Demo{
    Hallo,
    Abc,
    Xyz,
};
let test1 = Demo::Xyz;
let test2 = match test1 {
    Demo::Hallo =&gt; &quot;hallo word&quot;,
    Demo::Abc | Demo::Xyz =&gt; &quot;hallo abcxyz&quot;,
    },
    _ =&gt;&quot;0&quot;,
};
</code></pre><p>上面例子中进行匹配Demo对应的枚举类型，match会穷尽列出全部已知的可能，如果存在不知道的可能，使用下划线_来表示，match语句与switch语句很像，match的分支必须指向一个表达式，而且每个分支的表达式结果必须是相同类型的</p><p>假如只想对单个模式来进行处理，可使用if let语句，例如：</p><pre><code>let test1 = Demo::Xyz;
if let Test2(Demo::Xyz) = test1{
    println!(&quot;hallo wrod&quot;);
}
</code></pre><p>上面例子中，如果匹配到Demo::Xyz，输出hallo wrod，如果不匹配则忽略</p><p>注意：match和if let会在模式匹配时进行覆盖老值，绑定新的值</p><p>matches!宏匹配，可以将一个表达式和模式来进行匹配，返回结果是布尔值，例如：</p><pre><code>let a = 1;
assert!(matches!(1..100 | -1..-100));
</code></pre><hr><p>方法</p><p>rust使用impl关键字来定义方法</p><pre><code>struct Demo {
    id: i64,
    user: String,
}
impl Demo {
    fn new(id: i64, user: String) -&gt; Demo {
        Demo{
            id: id,
            user: user,
        }
    }
    fn printa(&amp;self){
        println!(self.user)
    }
}
fn mian(){
    let a = Demo{
        id: 1,
        user: &quot;root&quot;,
    }
    a.printa()
}
</code></pre><p>&amp;self为借用Demo结构体，new函数是Demo方法的关联函数，用于初始化结构体实例</p><p>&amp;self是self: &amp;Self的简写，self有所有权，而&amp;self是表示不可变借用，&amp;mut self就是可变借用</p><p>impl Demo是struct Demo的实现，另外rust允许方法名与结构体的字段名相同，调用方法加()，否则就是在访问字段</p><p>rust自动引用和解引用：当一个对象调用方法时，会自动为该对象添加&，&amp;mut，*来确保该对象能与方法匹配</p><p>关联函数：当一个存在于impl中，但是没有使用self的函数就被叫关联函数，通常存在impl中的new函数是结构体的构造实例器（rust没有使用new作为关键字，并不强制使用new）</p><p>关联函数因为不是方法，需要使用::来调用，例如Demo::new(2,&ldquo;admin&rdquo;)</p><p>rust允许将结构体定义成多个impl块，而不需要全部都写到一块，更灵活扩展</p><p>枚举类型也可被实现</p><hr><p>泛型与特征</p><p>泛型，当需要对可能存在不同类型的数据处理，但是处理逻辑是一样时，可使用泛型来避免重复，例如：</p><pre><code>fn test&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T {
    a + b
}
fn mian(){
    println!(&quot;{}&quot;,test(1,2));
    println!(&quot;{}&quot;,test(3.14,1.23));
}
</code></pre><p>注意：T是泛型参数，泛型参数是可自定义的，不过一般都是用T（表示Type），T可以表示任何类型，但是不是所有类型可以进行比较运算处理的，需要通过特征（这里是&lt;T: std::ops::Add&lt;Output = T>）来限制T的类型</p><p>结构体泛型</p><pre><code>struct Demo&lt;T&gt;{
    a: T,
    b: T,
}
fn main(){
    let x = Demo{a: 1,b: 21};
    let y = Demo{a: 1.23, b: 3.14};
    let z = Demo{a: &quot;hallo word&quot;, b: &quot;hahaha&quot;}
}
</code></pre><p>注意：结构体中使用T泛型的，必须是相同类型，因为第一个字段被赋值，会推断T类型为该赋值的实质类型，因此会报错的</p><p>如果想使用类型不同，又想使用泛型，可使用多个泛型参数来分别表示不同的类型</p><p>枚举泛型，Option枚举类型就是使用了泛型的，这里就不写了</p><p>方法泛型，例如：</p><pre><code>struct Demo&lt;T, U&gt; {
    id: T,
    user: U,
}
impl&lt;T,U&gt; Demo&lt;T,U&gt; {
    fn new(id: T, user: U) -&gt; Demo&lt;T,U&gt; {
        Demo{
            id: id,
            user: user,
        }
    }
    fn printa(&amp;self){
        println!(self.user)
    }
}
</code></pre><p>注意：使用泛型参数必须在提前声明</p><p>const泛型（Rust 1.51 版本引入）</p><p>const泛型是针对值的泛型，而不是针对类型，例如：</p><pre><code>fn Demo&lt;T: std::fmt::Debug,const U:i64&gt;(a:[T; U]){
    println!(&quot;{:?}&quot; a)
}
fn main(){
    let a: [i64:5] = [0,123,666,888,987];
    Demo(a)
    let a: [i64:2] = [0,123];
    Demo(a)
}
</code></pre><p>rust在编译阶段会对泛型的多个类型生成独立的代码（单态），会牺牲一些编译完成文件的大小和编译速度</p><p>特征</p><p>声明一个特征使用trait关键字，例如：</p><pre><code>pub trait Demo {
    fn DemoTest(&amp;self);
}
</code></pre><p>实现一个特征</p><pre><code>pub struct Home {
    pub user: String,
    pub pass: String,
}
impl Demo for Home {
    fn DemoTest(&amp;self) -&gt; String {
        format!(&quot;用户是{},密码是{}&quot;,self.user,self.pass);
    }
}
pub struct Abc {
    pub admin: String,
    pub rank: String,
}
impl Demo for Abc {
    fn DemoTest(&amp;self) -&gt; String {
        format!(&quot;管理者是{},管理等级是{}&quot;,self.admin,self.rank);
    }
}

fn main() {
    let home1 = Home{user: &quot;xiaochen&quot;,padd: &quot;abc123456789&quot;};
    let xyz = Abc{admin: &quot;main&quot;,rank: &quot;max&quot;};
println!(&quot;{}&quot;,home1.DemoTest());
println!(&quot;{}&quot;,xyz.DemoTest());
}
</code></pre><p>从上面的例子中可以看出，特征是定义了一种行为，实现该特征就可使用该行为，特征和结构体，枚举类型是很像的，但是特征可被共享到每个实现上（因为rust没有继承概念，但是行为/方法是相同的）</p><p>注意：特征存在一种规则，想实现一个特征必须至少一个是在当前作用域定义的，这个规则是为了避免不会破坏特征和实现的定义</p><p>默认实现（无需实现该方法，默认使用该实现，也可对默认实现进行重载）</p><pre><code>pub trait Demo {
    fn DemoTest(&amp;self) -&gt; String {
        String::form(&quot;hallo wrod&quot;);
    }
}
</code></pre><p>只要在实现中没有重载该方法，就会使用默认实现</p><p>特征作为函数参数</p><pre><code>pub fn Demo1(data: &amp;impl Demo){
    println!(&quot;{}&quot;,data.DemoTest());
}
</code></pre><p>在上面例子中，data函数参数实现了Demo特征，当然也可以使用其他实现了Demo特征的类型来作为参数</p><p>特征约束</p><pre><code>pub fn Demo2&lt;T: Demo&gt; (data: &amp;T){}
</code></pre><p>上面例子就是特征约束，特征约束可限制函数参数必须是实现了Demo特征的类型</p><p>多重约束</p><pre><code>pub fn Demo3&lt;T: Demo + AbcTest&gt; (data: &amp;T){}
</code></pre><p>或者</p><pre><code>pub fn Demo3(data: &amp;(impl Demo + AbcTest)){}
</code></pre><p>上面例子就是多重约束，可限制参数必须使用Demo特征，还必须实现AbcTest特征</p><p>Where 约束（简写多重约束）</p><pre><code>pub fn Demo4&lt;T&gt;(data: &amp;T) -&gt; String
    where T: Demo + AbcTest,
    {}
</code></pre><p>特征约束高级应用</p><pre><code>impl &lt;T:Dome1 + Dome2&gt; Demo&lt;T&gt; {
    fn Test1(&amp;self){
        println!(&quot;hallo word&quot;);
    }
}
</code></pre><p>上面例子中，只有实现了Dome1特征和Dome2特征的Demo才拥有Test1方法</p><p>impl Demo也可以声明返回了一个类型，这个类型实现了Demo特征，例如：</p><pre><code>fn Demo5() -&gt; impl Demo {
    Home{
        user: String::from(&quot;xiaochen&quot;),
        padd: String::from(&quot;abc123456789&quot;),
    };
}
</code></pre><hr><p>集合类型</p><p>集合类型，在rust中是特殊的类型，因为集合类型可以表示多个值，而其他数据类型大多只能表示一个值，集合类型的值被分配到堆内存上，集合类型分3种，分别是vector动态数组（每个元素分配的空间都是一致的，大小，宽度，高度），HashMap KV存储（每个元素都是成对，一个k对应着另一个v），以及String类型</p><p>创建vector动态数组</p><pre><code>let mut a: Vec(i64) = Vec::new();
</code></pre><p>注意：rust编译器可通过a.push()自行推导出数据类型，因此不显式声明类型也是没问题的</p><p>还可以通过vec!宏来创建，例如：</p><pre><code>let mut a = vec![123,666,888,1000];
</code></pre><p>更新动态数组，通过push方法来完成，例如：</p><pre><code>let mut a = Vec::new();
a.push(123);
</code></pre><p>读取元素，有2种方式，分别是下标索引，get方法，例如：</p><pre><code>let mut a = vec![123,666,888,1000];
let b: &amp;i32 = &amp;a[3];
    match a.get(3){
            Some(c) =&gt; println!(&quot;{c}&quot;),
            None =&gt; println!(&quot;没有这个元素&quot;)
    }
</code></pre><p>集合类型的下标索引从0开始，&amp;a[3]是借用a动态数组的第4个元素，也就是1000，最后获取导该元素的引用</p><p>get方法的返回值是Option&lt;&amp;T>，因此需要match来匹配解构出目标值</p><p>下标索引和get方法的区别，很简单，就是下标索引会出现数组越界问题（报错），而get方法通过Option&lt;&amp;T>。如果不存在该值会返回None（安全，不报错）</p><p>动态数组和其他类型一样，超出作用域外，会被自动销毁</p><p>注意：动态数组的大小是可变的，因此当原数组大小不够时，会分配一个更大的内存空间，再将原数组拷贝到这个更大的内存空间的新数组上，因此在push之前不要进行任何引用避免分配到新内存空间后，之前的引用指到一块无效的内存，rust编译器会自动检查，如果在push之前进行了引用（包括不可变借用和可变借用），如果在push之后没有使用，就正常通过，如果使用了，会报错</p><p>可创建指定大小的Vector，通过Vec::with_capacity(10)来完成</p><p>迭代遍历动态数组元素</p><pre><code>let mut a = vec![123,666,888,1000];
for i in &amp;mut a {
    *i += 1;
    println!(&quot;{i}&quot;);
}
</code></pre><p>通过枚举类型和特征对象来实现动态数组存储不同类型的元素，例如：</p><p>枚举类型</p><pre><code>enum Abc {
    id(i64),
    user(String),
    padd(String),
}
fn useraddr(abc:Abc){
    println!(&quot;{:?}&quot;,abc);
}

fn main(){
    let a = vec![
        Abc::id(1); 
        Abc::user(&quot;admin&quot;.to_string()); 
        Abc::padd(String::from(&quot;123456&quot;)); 
    ]
    for i in a {
        useraddr(i);
    }
}
</code></pre><p>特征对象</p><pre><code>trait Abc {
    fn useraddr(&amp;self);
}
struct id(i64);
imp Abc for id {
    fn useraddr(&amp;self) {
        println!(&quot;id: {:?}&quot;,self.0)
    }
}

struct user(String);
imp Abc for user {
    fn useraddr(&amp;self) {
        println!(&quot;user: {:?}&quot;,self.0)
    }
}

struct padd(String);
imp Abc for padd {
    fn useraddr(&amp;self) {
        println!(&quot;padd: {:?}&quot;,self.0)
    }
}
fn main() {
    let a: Vec&lt;data&lt;dyn Abc&gt;&gt; = vec![
        data::new(id(1)),
        data::new(user(&quot;admin&quot;.to_string())),
        data::new(padd(&quot;123456&quot;.to_string())),
    ];
    for i in a {
        i.useraddr();
    }
}
</code></pre><p>注意：必须表示数组中存储的是哪个特征的对象，例如上面例子中的Vec&lt;data>，表示是特征Abc的对象</p><p>HashMap KV存储和动态数组不同，存储的是映射的KV键值对，可通过一个键查询到值，查询效率非常高，复杂度为O(1)</p><p>创建HashMap KV存储</p><p>可通过new方法创建，例如：</p><pre><code>use std::collections::HashMap;
let mut hashdata = HashMap::new();
hashdata.insert(&quot;uesr&quot;,&quot;admin&quot;);
hashdata.insert(&quot;padd&quot;,&quot;admin12345&quot;);
</code></pre><p>注意：HashMap没有包含在Rust的prelude中，需要手动从标准库中use引入</p><p>可创建指定大小的HashMap，通过HashMap::with_capacity(10)来完成</p><p>可以通过迭代器和collect方法创建，例如：</p><pre><code>use std::collections::HashMap;
let DataList = vec![
    (&quot;牛奶&quot;.to_string(), 3),
    (&quot;方便面&quot;.to_string(), 4),
    (&quot;可乐&quot;.to_string(), 3),
];
let MapData: HashMap&lt;_,_&gt; = DataList.into_iter().collect();
println!(&quot;{:?}&quot;,MapData)
</code></pre><p>注意：HashMap的所有权取决于kv的类型，如果类型实现了Copy特征，那么改类型被复制到HashMap中，如果没有实现，则所有权转移到HashMap</p><p>获取HashMap元素通过get方法，例如：</p><pre><code>use std::collections::HashMap;
let mut abc = HashMap::new();
abc.insert(String::from(&quot;雪糕&quot;), 4);
let test = String::from(&quot;雪糕&quot;);
let testSearch: Option&lt;&amp;i32&gt; = abc.get(&amp;test);
let testScore: i32 = testSearch.get(&amp;test).copied().unwrap_or(0);
</code></pre><p>上面例子使用了借用规则，避免获取元素时，发生所有权的转移，并且使用Option&lt;&amp;i32>类型，如果没有该对象，返回None，安全</p><p>更新HashMap的中，例如：</p><pre><code>use std::collections::HashMap;
let mut data1 = HashMap::new();
   data1.insert(&quot;薯条&quot;, 5);
   let a = data1.insert(&quot;薯条&quot;, 10);
assert_eq!(a, Some(5));
   let b = data1.get(&quot;薯条&quot;);
assert_eq!(b, Some(&amp;10));
let c = data1.entry(&quot;啤酒&quot;).or_insert(5);
assert_eq!(*c, 5);
</code></pre><p>上面例子中包含覆盖值；查询新插入的值；查询目标值，如果不存在则插入新值，3种情况</p><p>注意：不是所有类型都可以作为hashmap的key，能否作为取决于类型是否实现了std::cmp::Eq特征（相等比较），目前HashMap使用的哈希函数是SipHash散列函数</p><hr><p>类型转换</p><hr><p>包和模块</p><hr><p>格式化输出</p><hr><p>生命周期</p><hr><p>错误处理</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://99999.fun/tags/rust/>Rust</a></li></ul><nav class=paginav><a class=prev href=https://99999.fun/posts/144/><span class=title>« Prev</span><br><span>简单了解a11y无障碍</span>
</a><a class=next href=https://99999.fun/posts/141/><span class=title>Next »</span><br><span>Flutter框架学习笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://99999.fun/>知政的个人博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>