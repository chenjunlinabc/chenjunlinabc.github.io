<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入学习vuejs | 知政的个人博客</title>
<meta name=keywords content="vuejs"><meta name=description content="Vue CLI是vue官方脚手架，可以快速创建vue项目
安装vue-cli3
npm install -g @vue/cli
或者
yarn global add @vue/cli
升级
npm update -g @vue/cli
或者
yarn global upgrade &ndash;latest @vue/cli
创建vue项目
vue create vue-demo
如果提示vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称，可以使用npx vue create vue-demo
default (babel, eslint) // 默认选项，包含babel和eslint
Manually select features // 自定义创建配置工程
一般比较常用的有Babel，TypeScript，Router，CSS Pre-processors，Linter / Formatter
空格为选择，enter为下一步
跑vue项目
npm run serve
或者
yarn start/yarn run dev
如果运行报错error Component name &ldquo;Home&rdquo; should always be multi-word vue/multi-word-component-names
只需要在vue.config.js添加lintOnSave: false配置，例如：
module.exports = defineConfig({transpileDependencies: true,lintOnSave: false})这个问题的原因在于vue-cli默认开启了ESLint检测，关闭就好了"><meta name=author content="Me"><link rel=canonical href=https://99999.fun/posts/75/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css rel="preload stylesheet" as=style><link rel=icon href=https://99999.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://99999.fun/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://99999.fun/favicon.ico><link rel=apple-touch-icon href=https://99999.fun/favicon.ico><link rel=mask-icon href=https://99999.fun/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="深入学习vuejs"><meta property="og:description" content="Vue CLI是vue官方脚手架，可以快速创建vue项目
安装vue-cli3
npm install -g @vue/cli
或者
yarn global add @vue/cli
升级
npm update -g @vue/cli
或者
yarn global upgrade &ndash;latest @vue/cli
创建vue项目
vue create vue-demo
如果提示vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称，可以使用npx vue create vue-demo
default (babel, eslint) // 默认选项，包含babel和eslint
Manually select features // 自定义创建配置工程
一般比较常用的有Babel，TypeScript，Router，CSS Pre-processors，Linter / Formatter
空格为选择，enter为下一步
跑vue项目
npm run serve
或者
yarn start/yarn run dev
如果运行报错error Component name &ldquo;Home&rdquo; should always be multi-word vue/multi-word-component-names
只需要在vue.config.js添加lintOnSave: false配置，例如：
module.exports = defineConfig({transpileDependencies: true,lintOnSave: false})这个问题的原因在于vue-cli默认开启了ESLint检测，关闭就好了"><meta property="og:type" content="article"><meta property="og:url" content="https://99999.fun/posts/75/"><meta property="og:image" content="https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-07T23:25:00+00:00"><meta property="article:modified_time" content="2021-08-07T23:25:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="深入学习vuejs"><meta name=twitter:description content="Vue CLI是vue官方脚手架，可以快速创建vue项目
安装vue-cli3
npm install -g @vue/cli
或者
yarn global add @vue/cli
升级
npm update -g @vue/cli
或者
yarn global upgrade &ndash;latest @vue/cli
创建vue项目
vue create vue-demo
如果提示vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称，可以使用npx vue create vue-demo
default (babel, eslint) // 默认选项，包含babel和eslint
Manually select features // 自定义创建配置工程
一般比较常用的有Babel，TypeScript，Router，CSS Pre-processors，Linter / Formatter
空格为选择，enter为下一步
跑vue项目
npm run serve
或者
yarn start/yarn run dev
如果运行报错error Component name &ldquo;Home&rdquo; should always be multi-word vue/multi-word-component-names
只需要在vue.config.js添加lintOnSave: false配置，例如：
module.exports = defineConfig({transpileDependencies: true,lintOnSave: false})这个问题的原因在于vue-cli默认开启了ESLint检测，关闭就好了"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://99999.fun/posts/"},{"@type":"ListItem","position":2,"name":"深入学习vuejs","item":"https://99999.fun/posts/75/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入学习vuejs","name":"深入学习vuejs","description":"Vue CLI是vue官方脚手架，可以快速创建vue项目\n安装vue-cli3\nnpm install -g @vue/cli\n或者\nyarn global add @vue/cli\n升级\nnpm update -g @vue/cli\n或者\nyarn global upgrade \u0026ndash;latest @vue/cli\n创建vue项目\nvue create vue-demo\n如果提示vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称，可以使用npx vue create vue-demo\ndefault (babel, eslint) // 默认选项，包含babel和eslint\nManually select features // 自定义创建配置工程\n一般比较常用的有Babel，TypeScript，Router，CSS Pre-processors，Linter / Formatter\n空格为选择，enter为下一步\n跑vue项目\nnpm run serve\n或者\nyarn start/yarn run dev\n如果运行报错error Component name \u0026ldquo;Home\u0026rdquo; should always be multi-word vue/multi-word-component-names\n只需要在vue.config.js添加lintOnSave: false配置，例如：\nmodule.exports = defineConfig({\rtranspileDependencies: true,\rlintOnSave: false\r})\r这个问题的原因在于vue-cli默认开启了ESLint检测，关闭就好了","keywords":["vuejs"],"articleBody":"Vue CLI是vue官方脚手架，可以快速创建vue项目\n安装vue-cli3\nnpm install -g @vue/cli\n或者\nyarn global add @vue/cli\n升级\nnpm update -g @vue/cli\n或者\nyarn global upgrade –latest @vue/cli\n创建vue项目\nvue create vue-demo\n如果提示vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称，可以使用npx vue create vue-demo\ndefault (babel, eslint) // 默认选项，包含babel和eslint\nManually select features // 自定义创建配置工程\n一般比较常用的有Babel，TypeScript，Router，CSS Pre-processors，Linter / Formatter\n空格为选择，enter为下一步\n跑vue项目\nnpm run serve\n或者\nyarn start/yarn run dev\n如果运行报错error Component name “Home” should always be multi-word vue/multi-word-component-names\n只需要在vue.config.js添加lintOnSave: false配置，例如：\nmodule.exports = defineConfig({\rtranspileDependencies: true,\rlintOnSave: false\r})\r这个问题的原因在于vue-cli默认开启了ESLint检测，关闭就好了\nVue-router是vue官方推出的vue官方路由管理工具，和vue核心深度集成\n该Vue-router路由被用于单页面应用，组件的切换，而不想其他那样可以使用超链接来切换页面\n安装router\nnpm install vue-router –save-dev\n或者\nvue add router\n例如：\nApp.vue\nhallo index\rhallo\rrouter.js\nimport {createRouter, createWebHashHistory} from \"vue-router\"\rimport Hallo from './components/Hallo'\rimport Home from './components/Home'\rimport Index from './components/Index' const routes = [ {\rpath: \"/Home\", name: \"Home\", component: Home,\rchildren: [\r{path:\"/\",component: Home},\r{path:\"Index\",component: Index}\r]\r},\r{\rpath: \"/Hallo\",\rname: \"Hallo\",\rcomponent: Hallo\r}\r]\rconst router = createRouter({\rhistory: createWebHashHistory(),\rroutes: routes\r})\rexport default router\rmain.js\nimport { createApp } from 'vue'\rimport App from './App.vue'\rimport router from './router'\rcreateApp(App).use(router).mount('#app')\r为路由匹配到组件（路由视图），它会表示渲染出使用切换的组件\npath是链接路径，name为链接名称，component为导入的组件模板名，多个地址用逗号分开，children为子路由声明，\n带参数的动态路由\nUser.vue\n{{ $route.params.id }}\rrouter.js\n{ path: “/User/:id”, name: “User”, component: User }\n访问http://localhost:8080/#/User/admin\n可以看页面显示了admin，说明通过路由传递了参数到模板中，其中id的参数在模板是以$route.params.id方式获取的\n去掉#：因为我这里vue-router路由模式设置为hash（createWebHashHistory），需要开启history（createWebHistory）\nimport {createWebHistory} from \"vue-router\"\rconst router = createRouter({\rhistory: createWebHistory(),\rroutes: routes\r})\r获取获取以什么开头的路由\n{\rpath: '/User:pathMatch(.*)*',\rname: 'User',\rcomponent: User\r},\r可以看到使用了路由，例如http://localhost:8080/Useraaa/等等，只要是Userxxx以及Userxxx/xxx都会渲染User组件\npath: ‘/User:afterUser(.*)’,这个效果和上面一样\n当Url需要纯数字时：\n{\rpath: '/User/:id(\\\\d+)',\rname: 'User',\rcomponent: User\r},\rhttp://localhost:8080/User/666\n复用参数（0个或多个用*，1个或多个用+）\n在上面的基础上改：\n{\rpath: '/User/:id(\\\\d+)+',\rname: 'User',\rcomponent: User\r},\r访问http://localhost:8080/#/User/666/111，可以看到，模板的{{ $route.params.id }}，渲染出[ “666”, “111” ]这样的数组，而不是字符串了，因此可以使用$route.params.id[1]，来精确获取第几个路由\n嵌套路由（User路由中使用了Admin路由，子路由）\nUser.vue\n{{ $route.params.id }}\rUserAdmin.vue\nhallo admin\rrouter.js\n{\rpath: '/User/:id(\\\\d+)+',\rname: 'User',\rcomponent: User,\rchildren: [\r{\rpath: 'admin',\rcomponent: UserAdmin\r}\r]\r},\r访问http://localhost:8080/#/User/666/admin，可以看到hallo admin\n编程式路由（非router-link）\nApp.vue\ngo\r可以看到点击了go，就会跳转到http://localhost:8080/User/123\n除了通过字符串外，还可以router.push({path: ‘/User/123’})\n传递参数（模板{{ $route.params.id }}）\nparams方式\nrouter.push({name: ‘User’, params: { id: 666 }})\n访问http://localhost:8080/User/666\nquery方式\nrouter.push({path: ‘/User’, query: { id: 123 }})\n访问http://localhost:8080/User?id=123\nquery方式获取参数，需要使用{{$route.query.id}}，而不是$route.params.id了\nhash方式\nrouter.push({ path: ‘/User’, hash: ‘#admin’ })\n访问http://localhost:8080/User#admin\n使用{{$route.hash}}获取参数\n动态路由参数\nlet user = ‘admin’ router.push({ name: ‘User’, params: { user } })\nreplace（使用该跳转，将不会创建会话历史记录，会替代上一个会话的记录）\nrouter.replace({ path: ‘/User’})\n使用replace: true参数也是可以给push设置（push的replace默认为false）\nrouter.push({ path: ‘/User’, replace: true })\n会话历史记录跳跃\n前进n条记录（前进2页） router.go(2)\n返回n条记录（后退2页面）\nrouter.go(-2)\n例如：\nApp.vue\nimport {useRouter} from 'vue-router'\rexport default{\rsetup(){\rconst router = useRouter()\rlet goAdmin = () =\u003e{\rrouter.go(2)\r}\rreturn{\rgoAdmin\r}\r}\r}\r路由的name属性的作用：\n除了像这样用外Go\n还可以用name属性指向一个路由的path，防止路由地址写错，设置params属性给模板接收参数（这个参数不会作用于URL），Go\n当需要在同级下渲染多个router-view，如何确保其router-view渲染的是自己想要的，利用router-view的name属性（该属性默认值为default）\nApp.vue\nrouter.js\nimport User from './components/User.vue' import A from './components/a.vue' import B from './components/b.vue' import C from './components/c.vue' const routes = [ {\rpath: '/User',\rname: 'User',\rcomponents:{\rdefault: User,\ra:A,\rb:B,\rc:C\r}\r}\r]\rconst router = createRouter({\rhistory: createWebHashHistory(),\rroutes: routes\r})\rexport default router\r访问http://localhost:8080/User，可以看到渲染出了a组件，b组件，c组件\n其中router.js的小写a就是指向了router-view的name属性，大写的A就是组件，和name属性对应上（键值对），将其对应渲染到相应的router-view中\ncomponents属性为多组件配置\n重定向（当希望访问到某个路由时，能跳转到另一个路由时）\nconst routes = [ {\rpath: \"/Home\", name: \"Home\",\rredirect: '/', components: {\rdefault: Home\r}\r}\r]\r访问http://localhost:8080/Home\n设置还可以指向一个路由的name属性，const routes = [{ path: ‘/Home’, redirect: { name: ‘User’ } }]\n另外如果一个路由使用了redirect重定向，那么是可以不用写component了，因为不会真正访问到（访问到就重定向到另一个路由了），但是存在子路由时就需要写component了\n当重定向发生时，也需要传递参数到重定向时，例如：\n{\rpath: '/User/:id',\rname: 'User',\rcomponents:{\rdefault: User,\r} ,\rredirect: to =\u003e{\rreturn { path: '/', query: { id: to.params.id } }\r}\r}\r当访问http://localhost:8080/User/123时，会重定向到http://localhost:8080/?id=123，如果/User/123的123，被传到query了，另外还可以在重定向的目标组件模板用{{$route.query.id}}获取到该参数\n重定向别名\n{\rpath: \"/Home\", name: \"Home\",\rcomponents: {\rdefault: Home,\r},\ralias: '/User',\r}\r别名就是访问http://localhost:8080/User/时，实质上是访问/Home这个路由，和redirect的区别就是，redirect会改变URL，而alias不会改变URL\n利用子路由来给多路由匹配组件\n{\rpath: \"/Home/:id\", name: \"Home\",\rcomponent: Home,\rchildren: [\r{ path: '', component: Homea, alias: [':id','admin', '/User'] },\r]\r}\r当访问http://localhost:8080/Home/123，http://localhost:8080/Home/admin，http://localhost:8080/User时，渲染的是Home组件\n路由props传参（通过props接收参数）\nroutes.js\n{\rpath: '/hallo/:id',\rcomponent: Home,\rprops: true\r}\rHome.vue\nhallo {{id}}\r当props为true时，其route.query（router.params）将被设置为该组件的属性，可直接访问其参数\n对于有命名视图的路由，必须为每个命名视图定义props配置，例如：\n{\rpath: \"/Home/:id\", name: \"Home\",\rcomponents: {\rdefault: Home,\rindex: Index\r},\rprops:{\rdefault: true, index: false\r}, },\r在上面例子中props是对象形式，可以看到index组件就算props接收了id参数，但是因为其路由props设置了false，导致其route.query（router.params）没有设置为该组件的属性，因此没有id参数\nroutes.js\n{\rpath: \"/Home\", name: \"Home\",\rcomponent: Home,\rprops: (route) =\u003e ({id : route.query.id }) },\rHome.vue\nhallo {{id}}\r访问http://localhost:8080/Home?id=123，Home输出123\n上面例子中route.query.id就是当前query（id=123），将其传入到id中，然后模板接收\n注意：函数模式请不要用于多组件components中，在多组件components中，需要给除default外的组件设置router-view的name属性\n导航守卫（导航守卫实质上就是路由跳转时的钩子函数，守卫是异步执行的）\n全局前置守卫：beforeEach\nrouter.beforeEach((to,form)=\u003e{ return false})\n守卫接收2个参数，to是跳转的目标路由，form是跳转离开的路由，返回值如果为false时，表示取消当前导航，当返回值为路由地址时，会跳转到该路由地址，还有一个next()可选参数，该可选参数表示放行\n当next(false)时，表示取消当前导航，当next(’/Home’)时，会跳转到/Home（和router.push类似）\n如果守卫抛出Error时，取消导航并且调用router.onError()\n守卫正常时是undefined或返回true\n例如：\nroutes.js\nconst router = createRouter({\rhistory: createWebHistory(),\rroutes: routes\r})\rrouter.beforeEach((to, from, next) =\u003e {\rif (to.name !== \"Home\") {\rnext({\rname: 'Home'\r})\r} else {\rnext()\r}\r})\r像上面的例子中，全局路由守卫将会监听要跳转的路由的name属性是否为Home，如果不是Home就会调用next()方法跳转到name为Home的路由，如果是Home的话守卫放行\n全局解析守卫：beforeResolve\n全局解析守卫和全局前置守卫类似，都是路由跳转前调用，但是beforeResolve会在beforeEach（全局前置守卫）和beforeRouteEnter（组件路由守卫）之后触发，afterEach（全局后置守卫）之前触发\nrouter.beforeResolve((to, from, next) =\u003e {\rif (to.name !== \"Home\") {\rnext({\rname: 'Home'\r})\r} else {\rnext()\r}\r})\r可以看到效果和beforeEach一样\n全局后置守卫：afterEach（没有next()，全局后置守卫顾名思义，就是路由跳转后触发）\nrouter.afterEach((to, from) =\u003e {\rconsole.log(to.name)\rconsole.log(from.name)\r})\r路由独享的守卫beforeEach（在路由内部定义的beforeEach守卫）\n{\rpath: \"/Home\", name: \"Home\",\rcomponent: Home,\rbeforeEach: (to,from) =\u003e{\rif (to.name !== \"Home\") {\rnext({\rname: 'Home'\r})\r} else {\rnext()\r}\r}\r},\r路由独享的守卫beforeEach只在进入路由时触发（params，query，hash改变并不会触发）\n组件路由守卫：beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave\nbeforeRouteEnter：在渲染该组件时对应的路由被确定前触发，在该守卫触发时，组件实例未被创建，因此不能获取组件实例的任何东西\nbeforeRouteUpdate：当前路由发送改变，但是该组件又被复用时触发，比如传参，只是改变参数，但是复用了当前组件，该守卫触发时，组件实例已被挂载，可访问组件实例\nbeforeRouteLeave：当导航离开渲染该组件的路由时触发，可访问组件实例\n例如：\nHome.vue\nexport default {\rbeforeRouteEnter(to, from, next) {\rnext(vm =\u003e{\rconsole.log(vm) // 可以看到vm是组件实例，说明可以通过next来访问组件实例，next()会在导航被确认时被回调\r})\r},\rbeforeRouteUpdate(to, from, next) {\rif (to.name !== \"Home\") {\rnext({\rname: 'Home'\r})\r} else {\rnext({\rname: 'User'\r})\r}\rconsole.log(to.name)\rconsole.log(from.name)\r},\rbeforeRouteLeave(to, from, next) {\rif(to.name !==\"Home\"){\rif(confirm('您的信息还未保存，确定要离开吗？') == true){\rnext()\r}else{\rnext(false)\r}\r}\rconsole.log(to.name)\rconsole.log(from.name)\r},\r}\r路由元信息（路由meta字段属性）\n{\rpath: \"/Home\", name: \"Home\",\rcomponent: Home,\rmeta: { ha: false }\r}\r},\rrouter.beforeEach((to, from, next) =\u003e {\rif (to.name == 'Home' \u0026\u0026 to.meta.ha){\rnext()\r}else{\rnext(false)\r}\r})\r路由懒加载（动态导入）\nconst User = () =\u003e import('./components/User.vue')\rconst routes = [{ path: '/User', name: 'User'\rcomponent: User }]\r动态路由\nconst routes = [{ path: '/:id', name: 'User'\rcomponent: User }]\rconst router = createRouter({\rhistory: createWebHistory(),\rroutes: routes\r})\rrouter.addRoute({ path: '/Home',name: 'Home', component: Home }) // 添加路由\rrouter.removeRoute('Home') // 删除路由\r注意：当路由被删除时，路由别名和子路由同时也被删除\n不只是在路由router中设置，还可以在路由守卫设置，而且当2个addRoute路由的name重名时，也会触发删除路由，当路由没有name属性时，可通过定义回调函数，让其重新添加路由（实质上是删除路由，因为重复了）,例如：\nconst RoutesData = router.addRoute(path: '/Index', component: Home )\rRoutesData()\r嵌套路由\nrouter.addRoute({ path: '/User', name: 'User', component: User })\rrouter.addRoute('User', { path: 'Admin', component: Home })\rvue中解决xss脚本攻击（依赖于xss模块）\nnpm install xss –save\n引用xss模块\nimport xss from 'xss'\rObject.defineProperty(Vue.prototype, '$xss', {\rvalue: xss\r})\r在评论框或者其他输入框等等要针对免疫xss地方使用$xss()方法\n自定义拦截规则\n在data字段，return字段下设置白名单，格式就是标签名加属性，只要不是白名单的标签和属性，就是会被过滤掉\noptions : {\rwhiteList: {\ra: ['href', 'title'],\rdiv: ['class']\r}\r}\rvue中解决html和Markdown转换\nMarkdownToHtml（处理md转换为html）\nnpm install showdown –save\n使用方法：\nimport showdown\rlet converter = new showdown.Converter()\rlet text = '# hallo word' // md格式的文本\rlet html = converter.makeHtml(text)\rHtmlToMarkdown（处理html转换为md）\nnpm install turndown –save\n使用方法：\nimport turndown\rlet turndownService = new turndown()\rlet markdown = turndownService.turndown('hallo word')\rvuejs是声明式视图层框架，视图层框架分为命令式和声明式两种，命令式关注过程，声明式关注结果，命令式的代码描述了工作过程，而声明式的代码只声明，结果由框架来提供\nvuejs内部实现肯定是命令式的，但是进行封装了工作过程，对外暴露的是声明式，声明式的性能并没有命令式的性能优，因为命令式的工作流程一目了然，去除或者添加某个功能，理论上能做到最优性能\n而声明式只关注了结果，需要查找前后代码的差异（虚拟dom+diff算法），然后再更新，vuejs选择声明式的方案是为了可维性，不需要关心工作过程，只需要关注结果就好了\n虚拟DOM对比innerHTML操作DOM\n创建DOM：虚拟DOM和innerHTML操作DOM都是创建所有DOM元素，因此虚拟DOM和innerHTML操作DOM基本上性能是一致的（DOM层计算）\n更新DOM：innerHTML操作DOM更新是先重新创建HTML字符串，然后再更新DOM元素（销毁旧的DOM元素，重新创建一个完整的DOM元素），而虚拟DOM是通过创建新的JavaScript对象，然后前后俩个JavaScript对象进行DIff比较，得到差异，只更新差异\n不难看出，虚拟DOM的优势在于更新DOM\n渲染器的作用就是将虚拟DOM（JavaScript对象）渲染成真实的DOM\n渲染器将JavaScript对象的值获得，并且以原生JavaScript方式渲染出来，当tag为字符串时，渲染标签元素，如果是函数（或者对象）那么表示该是组件，组件函数返回值本身就是虚拟DOM，如果是对象的话，获取对象的render函数，得到其返回值（这个实质上也是虚拟DOM），编译器（模板）原理上和渲染器是一样的\ntransition（过渡和动画）\n过渡：元素属性从一个属性过渡为另一个属性，例如元素的背景颜色从黑色过渡到白色\n动画：一个元素从一个地方移动到另一个地方\nvue内置了组件和API来完成动画和过渡\n过渡：\nconst app = Vue.createApp({\rdata(){\rreturn {\rishallo: false\r}\r},\rmethods:{\ronhalloClick(){\rthis.ishallo = ! this.ishallo\r}\r},\rtemplate: ` 点我隐藏/显示\rhallo word\r`\r})\rconst vm = app.mount(\"#app\")\r动画\nvue\nconst app = Vue.createApp({\rdata(){\rreturn {\rishallo: false\r}\r},\rtemplate: ` 点我触发动画\rhallo word\r`\r})\rconst vm = app.mount(\"#app\")\rcss样式\n.hallo {\ranimation: hallo 1s linear\r}\r@keyframes hallo {\r0% {\rtransform: translate3d(0px, 0, 0)\r}\r10% {\rtransform: translate3d(-2px, 0, 0)\r}\r60% {\rtransform: translate3d(2px, 0, 0)\r}\r100% {\rtransform: translate3d(0px, 0, 0)\r}\r}\r硬件加速：使用了perspective，backface-visibility和transform: translateZ()都可以触发硬件加速\n解决过渡和动画时间不一致\n，当使用该属性，动画结束，过渡会跟着结束\n，当使用该属性，过渡结束，动画会跟着结束\n统一管理动画和过渡时间\n，该属性值单位为毫秒，意思为1秒后结束动画和过渡\n，enter为进入动画和过渡时间，leave为离开动画和过渡时间\ntransition内置组件在一个过渡周期会触发6个状态，分别是v-enter-from，v-enter-active，v-enter-to，v-leave-from，v-leave-active，v-leave-to\nv-enter-from：表示过渡的开始状态，元素插入之前触发，元素插入后的下一帧移除\nv-enter-active：表示过渡生效时状态，在元素插入之前触发，在动画和过渡完成后移除\nv-enter-to：表示过渡的结束状态，在元素插入后下一帧触发，在动画和过渡完成后移除\nv-leave-from：表示离开过渡的开始状态，离开过渡时立即触发，下一帧后移除\nv-leave-active：表示离开过渡的生效状态，离开过渡时立即触发，在动画和过渡完成后移除\nv-leave-to：表示离开过渡的结束状态，离开过渡后下一帧触发，在动画和过渡完成后移除\n用法：\nconst app = Vue.createApp({\rdata(){\rreturn {\rishallo: false\r}\r},\rtemplate: ` 点我触发动画\rhallo word\r`\r})\rconst vm = app.mount(\"#app\")\r样式\n.v-enter-active{\ranimation: hallo 1s; // 表示入场时触发时hallo动画\r}\r.v-leave-active{\ranimation: hallo 1s; // 表示出场时触发时hallo动画\r}\r@keyframes hallo {\r0% {\rtransform: translate3d(0px, 0, 0)\r}\r10% {\rtransform: translate3d(-2px, 0, 0)\r}\r60% {\rtransform: translate3d(2px, 0, 0)\r}\r100% {\rtransform: translate3d(0px, 0, 0)\r}\r}\r关闭css动画：，使用该属性表示将通过组件事件来触发动画，不再使用css动画了\n过渡模式：，该属性有2个值，out-in和in-out，默认同时进行\nout-in：当前元素先进行过渡，完成后新元素过渡进入\nin-out：新元素先进行过渡，完成后当前元素过渡离开\n该常用于动态组件的切换过渡，也是说out-in是当前元素先进行过渡，切换到新元素时，过渡进入，而in-out是新元素过渡，切换到当前元素时过渡离开\nname属性：，该属性表示自动生成css过渡类名，像例子中的，将生成为.hallo-enter等等，就是将过渡周期中的6个状态的v改成name属性值了\nvue devtools调试工具\n下载https://github.com/vuejs/vue-devtools\n解压，并且在该目录执行npm install\n修改manifest.json（该文件在项目目录的packages/shell-chrome），将persistent改为true\n打包npm run build\n以谷歌浏览器为例子，加载已解压的扩展程序，选择刚刚打包的目录的packages/shell-chrome文件夹\nvue3引入了tree-shaking技术，当没有在项目中使用某个模块时，那么该模块的代码将不会出现在打包中\nvue3抛弃了Object.defineProperty，改用Proxy来做数据的响应式\nvue3不再使用src托管，而采用monorepo管理\nvue3采用typescript编写源码，对typescript的兼容更好，vue2使用的是flow来处理类型检查\nvue3提供了Composition API，对于逻辑复用支持更好\n","wordCount":"1221","inLanguage":"en","datePublished":"2021-08-07T23:25:00Z","dateModified":"2021-08-07T23:25:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://99999.fun/posts/75/"},"publisher":{"@type":"Organization","name":"知政的个人博客","logo":{"@type":"ImageObject","url":"https://99999.fun/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://99999.fun/ accesskey=h title="知政的个人博客 (Alt + H)"><img src=https://99999.fun/favicon.ico alt aria-label=logo height=35>知政的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://99999.fun/ title=首页><span>首页</span></a></li><li><a href=https://99999.fun/categories/ title=分类><span>分类</span></a></li><li><a href=https://99999.fun/archives/ title=归档><span>归档</span></a></li><li><a href=https://99999.fun/tags/ title=标签><span>标签</span></a></li><li><a href=https://99999.fun/links/ title=链接><span>链接</span></a></li><li><a href=https://99999.fun/about/ title=关于><span>关于</span></a></li><li><a href=https://99999.fun/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://99999.fun/>Home</a>&nbsp;»&nbsp;<a href=https://99999.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">深入学习vuejs</h1><div class=post-meta><span title='2021-08-07 23:25:00 +0000 UTC'>2021-08-07</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://99999.fun//posts/%e6%b7%b1%e5%85%a5%e5%ad%a6%e4%b9%a0vuejs.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Vue CLI是vue官方脚手架，可以快速创建vue项目</p><p>安装vue-cli3</p><p>npm install -g @vue/cli</p><p>或者</p><p>yarn global add @vue/cli</p><p>升级</p><p>npm update -g @vue/cli</p><p>或者</p><p>yarn global upgrade &ndash;latest @vue/cli</p><p>创建vue项目</p><p>vue create vue-demo</p><p>如果提示vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称，可以使用npx vue create vue-demo</p><p>default (babel, eslint) // 默认选项，包含babel和eslint</p><p>Manually select features // 自定义创建配置工程</p><p>一般比较常用的有Babel，TypeScript，Router，CSS Pre-processors，Linter / Formatter</p><p>空格为选择，enter为下一步</p><p>跑vue项目</p><p>npm run serve</p><p>或者</p><p>yarn start/yarn run dev</p><p>如果运行报错error Component name &ldquo;Home&rdquo; should always be multi-word vue/multi-word-component-names</p><p>只需要在vue.config.js添加lintOnSave: false配置，例如：</p><pre><code>module.exports = defineConfig({
    transpileDependencies: true,
    lintOnSave: false
})
</code></pre><p>这个问题的原因在于vue-cli默认开启了ESLint检测，关闭就好了</p><hr><p>Vue-router是vue官方推出的vue官方路由管理工具，和vue核心深度集成</p><p>该Vue-router路由被用于单页面应用，组件的切换，而不想其他那样可以使用超链接来切换页面</p><p>安装router</p><p>npm install vue-router &ndash;save-dev</p><p>或者</p><p>vue add router</p><p>例如：</p><p>App.vue</p><pre><code>&lt;template&gt;
    &lt;router-link to=&quot;/Home/Index&quot;&gt;hallo index&lt;/router-link&gt;
    &lt;router-link to=&quot;/Hallo&quot;&gt;hallo&lt;/router-link&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/template&gt;
</code></pre><p>router.js</p><pre><code>import {createRouter, createWebHashHistory} from &quot;vue-router&quot;
import Hallo from './components/Hallo'
import Home from './components/Home'
import Index from './components/Index'      
const routes = [ 
{
    path: &quot;/Home&quot;,         
    name: &quot;Home&quot;,     
    component: Home,
    children: [
        {path:&quot;/&quot;,component: Home},
        {path:&quot;Index&quot;,component: Index}
    ]
},
{
    path: &quot;/Hallo&quot;,
    name: &quot;Hallo&quot;,
    component: Hallo
}
]
const router = createRouter({
    history: createWebHashHistory(),
    routes: routes
})
export default router
</code></pre><p>main.js</p><pre><code>import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
createApp(App).use(router).mount('#app')
</code></pre><p>为路由匹配到组件（路由视图），它会表示渲染出使用切换的组件</p><p>path是链接路径，name为链接名称，component为导入的组件模板名，多个地址用逗号分开，children为子路由声明，</p><p>带参数的动态路由</p><p>User.vue</p><pre><code>&lt;template&gt;
    &lt;div&gt;
        {{ $route.params.id }}
    &lt;/div&gt;
&lt;/template&gt;
</code></pre><p>router.js</p><p>{
path: &ldquo;/User/:id&rdquo;,
name: &ldquo;User&rdquo;,
component: User
}</p><p>访问http://localhost:8080/#/User/admin</p><p>可以看页面显示了admin，说明通过路由传递了参数到模板中，其中id的参数在模板是以$route.params.id方式获取的</p><p>去掉#：因为我这里vue-router路由模式设置为hash（createWebHashHistory），需要开启history（createWebHistory）</p><pre><code>import {createWebHistory} from &quot;vue-router&quot;
const router = createRouter({
    history: createWebHistory(),
    routes: routes
})
</code></pre><p>获取获取以什么开头的路由</p><pre><code>{
    path: '/User:pathMatch(.*)*',
    name: 'User',
    component: User
},
</code></pre><p>可以看到使用了路由，例如http://localhost:8080/Useraaa/等等，只要是Userxxx以及Userxxx/xxx都会渲染User组件</p><p>path: &lsquo;/User:afterUser(.*)&rsquo;,这个效果和上面一样</p><p>当Url需要纯数字时：</p><pre><code>{
    path: '/User/:id(\\d+)',
    name: 'User',
    component: User
},
</code></pre><p>http://localhost:8080/User/666</p><p>复用参数（0个或多个用*，1个或多个用+）</p><p>在上面的基础上改：</p><pre><code>{
    path: '/User/:id(\\d+)+',
    name: 'User',
    component: User
},
</code></pre><p>访问http://localhost:8080/#/User/666/111，可以看到，模板的{{ $route.params.id }}，渲染出[ &ldquo;666&rdquo;, &ldquo;111&rdquo; ]这样的数组，而不是字符串了，因此可以使用$route.params.id[1]，来精确获取第几个路由</p><p>嵌套路由（User路由中使用了Admin路由，子路由）</p><p>User.vue</p><pre><code>&lt;template&gt;
    &lt;div&gt;
        {{ $route.params.id }}
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre><p>UserAdmin.vue</p><pre><code>&lt;template&gt;
    &lt;div&gt;
    hallo admin
    &lt;/div&gt;
&lt;/template&gt;
</code></pre><p>router.js</p><pre><code>{
    path: '/User/:id(\\d+)+',
    name: 'User',
    component: User,
    children: [
      {
        path: 'admin',
        component: UserAdmin
      }
    ]
},
</code></pre><p>访问http://localhost:8080/#/User/666/admin，可以看到hallo admin</p><p>编程式路由（非router-link）</p><p>App.vue</p><pre><code>&lt;template&gt;
  &lt;div @click=&quot;goAdmin&quot;&gt;go&lt;/div&gt;
  &lt;br/&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/template&gt;
&lt;script&gt;
  import {useRouter} from 'vue-router'
  export default{
    setup(){
      const router = useRouter()
      let goAdmin = () =&gt;{
        router.push(&quot;/User/123&quot;)
      }
      return{
        goAdmin
      }
    }
  }
&lt;/script&gt;
</code></pre><p>可以看到点击了&lt;div @click=&ldquo;goAdmin&rdquo;>go，就会跳转到http://localhost:8080/User/123</p><p>除了通过字符串外，还可以router.push({path: &lsquo;/User/123&rsquo;})</p><p>传递参数（模板{{ $route.params.id }}）</p><p>params方式</p><p>router.push({name: &lsquo;User&rsquo;, params: { id: 666 }})</p><p>访问http://localhost:8080/User/666</p><p>query方式</p><p>router.push({path: &lsquo;/User&rsquo;, query: { id: 123 }})</p><p>访问http://localhost:8080/User?id=123</p><p>query方式获取参数，需要使用{{$route.query.id}}，而不是$route.params.id了</p><p>hash方式</p><p>router.push({ path: &lsquo;/User&rsquo;, hash: &lsquo;#admin&rsquo; })</p><p>访问http://localhost:8080/User#admin</p><p>使用{{$route.hash}}获取参数</p><p>动态路由参数</p><p>let user = &lsquo;admin&rsquo;
router.push({ name: &lsquo;User&rsquo;, params: { user } })</p><p>replace（使用该跳转，将不会创建会话历史记录，会替代上一个会话的记录）</p><p>router.replace({ path: &lsquo;/User&rsquo;})</p><p>使用replace: true参数也是可以给push设置（push的replace默认为false）</p><p>router.push({ path: &lsquo;/User&rsquo;, replace: true })</p><p>会话历史记录跳跃</p><p>前进n条记录（前进2页）
router.go(2)</p><p>返回n条记录（后退2页面）</p><p>router.go(-2)</p><p>例如：</p><p>App.vue</p><pre><code>import {useRouter} from 'vue-router'
export default{
  setup(){
    const router = useRouter()
    let goAdmin = () =&gt;{
      router.go(2)
    }
    return{
      goAdmin
    }
  }
}
</code></pre><p>路由的name属性的作用：</p><p>除了像这样用外Go</p><p>还可以用name属性指向一个路由的path，防止路由地址写错，设置params属性给模板接收参数（这个参数不会作用于URL），Go</p><p>当需要在同级下渲染多个router-view，如何确保其router-view渲染的是自己想要的，利用router-view的name属性（该属性默认值为default）</p><p>App.vue</p><p></p><p>router.js</p><pre><code>import User from './components/User.vue' 
import A from './components/a.vue'   
import B from './components/b.vue'   
import C from './components/c.vue' 
const routes = [ 
    {
        path: '/User',
        name: 'User',
        components:{
          default: User,
          a:A,
          b:B,
          c:C
        }
    }
]
const router = createRouter({
    history: createWebHashHistory(),
    routes: routes
})
export default router
</code></pre><p>访问http://localhost:8080/User，可以看到渲染出了a组件，b组件，c组件</p><p>其中router.js的小写a就是指向了router-view的name属性，大写的A就是组件，和name属性对应上（键值对），将其对应渲染到相应的router-view中</p><p>components属性为多组件配置</p><p>重定向（当希望访问到某个路由时，能跳转到另一个路由时）</p><pre><code>const routes = [ 
    {
        path: &quot;/Home&quot;,         
        name: &quot;Home&quot;,
        redirect: '/',  
        components: {
            default: Home
        }
    }
]
</code></pre><p>访问http://localhost:8080/Home</p><p>设置还可以指向一个路由的name属性，const routes = [{ path: &lsquo;/Home&rsquo;, redirect: { name: &lsquo;User&rsquo; } }]</p><p>另外如果一个路由使用了redirect重定向，那么是可以不用写component了，因为不会真正访问到（访问到就重定向到另一个路由了），但是存在子路由时就需要写component了</p><p>当重定向发生时，也需要传递参数到重定向时，例如：</p><pre><code>{
    path: '/User/:id',
    name: 'User',
    components:{
      default: User,
    } ,
    redirect: to =&gt;{
      return { path: '/', query: { id: to.params.id } }
    }
}
</code></pre><p>当访问http://localhost:8080/User/123时，会重定向到http://localhost:8080/?id=123，如果/User/123的123，被传到query了，另外还可以在重定向的目标组件模板用{{$route.query.id}}获取到该参数</p><p>重定向别名</p><pre><code>{
    path: &quot;/Home&quot;,         
    name: &quot;Home&quot;,
    components: {
        default: Home,
    },
    alias: '/User',
}
</code></pre><p>别名就是访问http://localhost:8080/User/时，实质上是访问/Home这个路由，和redirect的区别就是，redirect会改变URL，而alias不会改变URL</p><p>利用子路由来给多路由匹配组件</p><pre><code>{
    path: &quot;/Home/:id&quot;,         
    name: &quot;Home&quot;,
    component: Home,
    children: [
        { 
            path: '', 
            component: Homea, 
            alias: [':id','admin', '/User'] 
        },
    ]
}
</code></pre><p>当访问http://localhost:8080/Home/123，http://localhost:8080/Home/admin，http://localhost:8080/User时，渲染的是Home组件</p><p>路由props传参（通过props接收参数）</p><p>routes.js</p><pre><code>{
    path: '/hallo/:id',
    component: Home,
    props: true
}
</code></pre><p>Home.vue</p><pre><code>&lt;template&gt;
    &lt;div&gt;
        hallo {{id}}
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    props: ['id']
}
&lt;/script&gt;
</code></pre><p>当props为true时，其route.query（router.params）将被设置为该组件的属性，可直接访问其参数</p><p>对于有命名视图的路由，必须为每个命名视图定义props配置，例如：</p><pre><code>{
    path: &quot;/Home/:id&quot;,         
    name: &quot;Home&quot;,
    components: {
        default: Home,
        index: Index
    },
    props:{
        default: true, 
        index: false
    },      
},
</code></pre><p>在上面例子中props是对象形式，可以看到index组件就算props接收了id参数，但是因为其路由props设置了false，导致其route.query（router.params）没有设置为该组件的属性，因此没有id参数</p><p>routes.js</p><pre><code>{
    path: &quot;/Home&quot;,         
    name: &quot;Home&quot;,
    component: Home,
    props: (route) =&gt; ({id : route.query.id }) 
},
</code></pre><p>Home.vue</p><pre><code>&lt;template&gt;
    &lt;div&gt;
        hallo {{id}}
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    props: ['id']
}
&lt;/script&gt;
</code></pre><p>访问http://localhost:8080/Home?id=123，Home输出123</p><p>上面例子中route.query.id就是当前query（id=123），将其传入到id中，然后模板接收</p><p>注意：函数模式请不要用于多组件components中，在多组件components中，需要给除default外的组件设置router-view的name属性</p><hr><p>导航守卫（导航守卫实质上就是路由跳转时的钩子函数，守卫是异步执行的）</p><p>全局前置守卫：beforeEach</p><p>router.beforeEach((to,form)=>{ return false})</p><p>守卫接收2个参数，to是跳转的目标路由，form是跳转离开的路由，返回值如果为false时，表示取消当前导航，当返回值为路由地址时，会跳转到该路由地址，还有一个next()可选参数，该可选参数表示放行</p><p>当next(false)时，表示取消当前导航，当next(&rsquo;/Home&rsquo;)时，会跳转到/Home（和router.push类似）</p><p>如果守卫抛出Error时，取消导航并且调用router.onError()</p><p>守卫正常时是undefined或返回true</p><p>例如：</p><p>routes.js</p><pre><code>const router = createRouter({
    history: createWebHistory(),
    routes: routes
})
router.beforeEach((to, from, next) =&gt; {
    if (to.name !== &quot;Home&quot;) {
        next({
            name: 'Home'
        })
    } else {
        next()
    }
})
</code></pre><p>像上面的例子中，全局路由守卫将会监听要跳转的路由的name属性是否为Home，如果不是Home就会调用next()方法跳转到name为Home的路由，如果是Home的话守卫放行</p><p>全局解析守卫：beforeResolve</p><p>全局解析守卫和全局前置守卫类似，都是路由跳转前调用，但是beforeResolve会在beforeEach（全局前置守卫）和beforeRouteEnter（组件路由守卫）之后触发，afterEach（全局后置守卫）之前触发</p><pre><code>router.beforeResolve((to, from, next) =&gt; {
    if (to.name !== &quot;Home&quot;) {
        next({
            name: 'Home'
        })
    } else {
        next()
    }
})
</code></pre><p>可以看到效果和beforeEach一样</p><p>全局后置守卫：afterEach（没有next()，全局后置守卫顾名思义，就是路由跳转后触发）</p><pre><code>router.afterEach((to, from) =&gt; {
    console.log(to.name)
    console.log(from.name)
})
</code></pre><p>路由独享的守卫beforeEach（在路由内部定义的beforeEach守卫）</p><pre><code>{
    path: &quot;/Home&quot;,         
    name: &quot;Home&quot;,
    component: Home,
    beforeEach: (to,from) =&gt;{
        if (to.name !== &quot;Home&quot;) {
            next({
                name: 'Home'
            })
        } else {
            next()
        }
    }
},
</code></pre><p>路由独享的守卫beforeEach只在进入路由时触发（params，query，hash改变并不会触发）</p><p>组件路由守卫：beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave</p><p>beforeRouteEnter：在渲染该组件时对应的路由被确定前触发，在该守卫触发时，组件实例未被创建，因此不能获取组件实例的任何东西</p><p>beforeRouteUpdate：当前路由发送改变，但是该组件又被复用时触发，比如传参，只是改变参数，但是复用了当前组件，该守卫触发时，组件实例已被挂载，可访问组件实例</p><p>beforeRouteLeave：当导航离开渲染该组件的路由时触发，可访问组件实例</p><p>例如：</p><p>Home.vue</p><pre><code>export default {
    beforeRouteEnter(to, from, next) {
        next(vm =&gt;{
            console.log(vm) // 可以看到vm是组件实例，说明可以通过next来访问组件实例，next()会在导航被确认时被回调
        })
    },
    beforeRouteUpdate(to, from, next) {
        if (to.name !== &quot;Home&quot;) {
            next({
                name: 'Home'
            })
        } else {
            next({
                name: 'User'
            })
        }
        console.log(to.name)
        console.log(from.name)
    },
    beforeRouteLeave(to, from, next) {
        if(to.name !==&quot;Home&quot;){
            if(confirm('您的信息还未保存，确定要离开吗？') == true){
                next()
            }else{
                next(false)
            }
        }
        console.log(to.name)
        console.log(from.name)
    },
}
</code></pre><p>路由元信息（路由meta字段属性）</p><pre><code>{
    path: &quot;/Home&quot;,         
    name: &quot;Home&quot;,
    component: Home,
    meta: { ha: false }
    }
},

router.beforeEach((to, from, next) =&gt; {
    if (to.name == 'Home' &amp;&amp; to.meta.ha){
        next()
    }else{
      next(false)
    }
})
</code></pre><p>路由懒加载（动态导入）</p><pre><code>const User = () =&gt; import('./components/User.vue')
const routes = [{ 
    path: '/User', 
    name: 'User'
    component: User 
}]
</code></pre><p>动态路由</p><pre><code>const routes = [{ 
    path: '/:id', 
    name: 'User'
    component: User 
}]
const router = createRouter({
    history: createWebHistory(),
    routes: routes
})
router.addRoute({ path: '/Home',name: 'Home', component: Home }) // 添加路由
router.removeRoute('Home') // 删除路由
</code></pre><p>注意：当路由被删除时，路由别名和子路由同时也被删除</p><p>不只是在路由router中设置，还可以在路由守卫设置，而且当2个addRoute路由的name重名时，也会触发删除路由，当路由没有name属性时，可通过定义回调函数，让其重新添加路由（实质上是删除路由，因为重复了）,例如：</p><pre><code>const RoutesData = router.addRoute(path: '/Index', component: Home )
RoutesData()
</code></pre><p>嵌套路由</p><pre><code>router.addRoute({  path: '/User', name: 'User', component: User })
router.addRoute('User', { path: 'Admin', component: Home })
</code></pre><hr><p>vue中解决xss脚本攻击（依赖于xss模块）</p><p>npm install xss &ndash;save</p><p>引用xss模块</p><pre><code>import xss from 'xss'
Object.defineProperty(Vue.prototype, '$xss', {
    value: xss
})
</code></pre><p>在评论框或者其他输入框等等要针对免疫xss地方使用$xss()方法</p><p>自定义拦截规则</p><p>在data字段，return字段下设置白名单，格式就是标签名加属性，只要不是白名单的标签和属性，就是会被过滤掉</p><pre><code>options : {
    whiteList: {
        a: ['href', 'title'],
        div: ['class']
      }
}
</code></pre><hr><p>vue中解决html和Markdown转换</p><p>MarkdownToHtml（处理md转换为html）</p><p>npm install showdown &ndash;save</p><p>使用方法：</p><pre><code>import showdown
let converter = new showdown.Converter()
let text = '# hallo word' // md格式的文本
let html = converter.makeHtml(text)
</code></pre><p>HtmlToMarkdown（处理html转换为md）</p><p>npm install turndown &ndash;save</p><p>使用方法：</p><pre><code>import turndown
let turndownService = new turndown()
let markdown = turndownService.turndown('&lt;h1&gt;hallo word&lt;/h1&gt;')
</code></pre><hr><p>vuejs是声明式视图层框架，视图层框架分为命令式和声明式两种，命令式关注过程，声明式关注结果，命令式的代码描述了工作过程，而声明式的代码只声明，结果由框架来提供</p><p>vuejs内部实现肯定是命令式的，但是进行封装了工作过程，对外暴露的是声明式，声明式的性能并没有命令式的性能优，因为命令式的工作流程一目了然，去除或者添加某个功能，理论上能做到最优性能</p><p>而声明式只关注了结果，需要查找前后代码的差异（虚拟dom+diff算法），然后再更新，vuejs选择声明式的方案是为了可维性，不需要关心工作过程，只需要关注结果就好了</p><p>虚拟DOM对比innerHTML操作DOM</p><p>创建DOM：虚拟DOM和innerHTML操作DOM都是创建所有DOM元素，因此虚拟DOM和innerHTML操作DOM基本上性能是一致的（DOM层计算）</p><p>更新DOM：innerHTML操作DOM更新是先重新创建HTML字符串，然后再更新DOM元素（销毁旧的DOM元素，重新创建一个完整的DOM元素），而虚拟DOM是通过创建新的JavaScript对象，然后前后俩个JavaScript对象进行DIff比较，得到差异，只更新差异</p><p>不难看出，虚拟DOM的优势在于更新DOM</p><p>渲染器的作用就是将虚拟DOM（JavaScript对象）渲染成真实的DOM</p><p>渲染器将JavaScript对象的值获得，并且以原生JavaScript方式渲染出来，当tag为字符串时，渲染标签元素，如果是函数（或者对象）那么表示该是组件，组件函数返回值本身就是虚拟DOM，如果是对象的话，获取对象的render函数，得到其返回值（这个实质上也是虚拟DOM），编译器（模板）原理上和渲染器是一样的</p><hr><p>transition（过渡和动画）</p><p>过渡：元素属性从一个属性过渡为另一个属性，例如元素的背景颜色从黑色过渡到白色</p><p>动画：一个元素从一个地方移动到另一个地方</p><p>vue内置了组件和API来完成动画和过渡</p><p>过渡：</p><pre><code>const app = Vue.createApp({
    data(){
        return {
            ishallo: false
        }
    },
    methods:{
        onhalloClick(){
            this.ishallo = ! this.ishallo
        }
    },
    template: `  
        &lt;button @click='onhalloClick'&gt;点我隐藏/显示&lt;/button&gt;
        &lt;transition&gt;
            &lt;div v-if=&quot;ishallo&quot;&gt;hallo word&lt;/div&gt;
        &lt;/transition&gt;
    `
})
const vm = app.mount(&quot;#app&quot;)
</code></pre><p>动画</p><p>vue</p><pre><code>const app = Vue.createApp({
    data(){
        return {
            ishallo: false
        }
    },
    template: `  
        &lt;div :class='{ hallo: ishallo }'&gt;
            &lt;button @click='ishallo = true'&gt;点我触发动画&lt;/button&gt;
            &lt;div v-if=&quot;ishallo&quot;&gt;hallo word&lt;/div&gt;
        &lt;/div&gt;
    `
})
const vm = app.mount(&quot;#app&quot;)
</code></pre><p>css样式</p><pre><code>.hallo {
    animation: hallo 1s linear
}
@keyframes hallo {
    0% {
        transform: translate3d(0px, 0, 0)
    }
    10% {
        transform: translate3d(-2px, 0, 0)
    }
    60% {
        transform: translate3d(2px, 0, 0)
    }
    100% {
        transform: translate3d(0px, 0, 0)
    }
}
</code></pre><p>硬件加速：使用了perspective，backface-visibility和transform: translateZ()都可以触发硬件加速</p><p>解决过渡和动画时间不一致</p><p>，当使用该属性，动画结束，过渡会跟着结束</p><p>，当使用该属性，过渡结束，动画会跟着结束</p><p>统一管理动画和过渡时间</p><p>，该属性值单位为毫秒，意思为1秒后结束动画和过渡</p><p>，enter为进入动画和过渡时间，leave为离开动画和过渡时间</p><p>transition内置组件在一个过渡周期会触发6个状态，分别是v-enter-from，v-enter-active，v-enter-to，v-leave-from，v-leave-active，v-leave-to</p><p>v-enter-from：表示过渡的开始状态，元素插入之前触发，元素插入后的下一帧移除</p><p>v-enter-active：表示过渡生效时状态，在元素插入之前触发，在动画和过渡完成后移除</p><p>v-enter-to：表示过渡的结束状态，在元素插入后下一帧触发，在动画和过渡完成后移除</p><p>v-leave-from：表示离开过渡的开始状态，离开过渡时立即触发，下一帧后移除</p><p>v-leave-active：表示离开过渡的生效状态，离开过渡时立即触发，在动画和过渡完成后移除</p><p>v-leave-to：表示离开过渡的结束状态，离开过渡后下一帧触发，在动画和过渡完成后移除</p><p>用法：</p><pre><code>const app = Vue.createApp({
    data(){
        return {
            ishallo: false
        }
    },
    template: `  
        &lt;transition&gt;
            &lt;button @click='ishallo = true'&gt;点我触发动画&lt;/button&gt;
            &lt;div v-if=&quot;ishallo&quot;&gt;hallo word&lt;/div&gt;
        &lt;/transition&gt;
    `
})
const vm = app.mount(&quot;#app&quot;)
</code></pre><p>样式</p><pre><code>.v-enter-active{
    animation: hallo 1s; // 表示入场时触发时hallo动画
}
.v-leave-active{
    animation: hallo 1s;  // 表示出场时触发时hallo动画
}
@keyframes hallo {
    0% {
        transform: translate3d(0px, 0, 0)
    }
    10% {
        transform: translate3d(-2px, 0, 0)
    }
    60% {
        transform: translate3d(2px, 0, 0)
    }
    100% {
        transform: translate3d(0px, 0, 0)
    }
}
</code></pre><p>关闭css动画：，使用该属性表示将通过组件事件来触发动画，不再使用css动画了</p><p>过渡模式：，该属性有2个值，out-in和in-out，默认同时进行</p><p>out-in：当前元素先进行过渡，完成后新元素过渡进入</p><p>in-out：新元素先进行过渡，完成后当前元素过渡离开</p><p>该常用于动态组件的切换过渡，也是说out-in是当前元素先进行过渡，切换到新元素时，过渡进入，而in-out是新元素过渡，切换到当前元素时过渡离开</p><p>name属性：，该属性表示自动生成css过渡类名，像例子中的，将生成为.hallo-enter等等，就是将过渡周期中的6个状态的v改成name属性值了</p><hr><p>vue devtools调试工具</p><p>下载https://github.com/vuejs/vue-devtools</p><p>解压，并且在该目录执行npm install</p><p>修改manifest.json（该文件在项目目录的packages/shell-chrome），将persistent改为true</p><p>打包npm run build</p><p>以谷歌浏览器为例子，加载已解压的扩展程序，选择刚刚打包的目录的packages/shell-chrome文件夹</p><p>vue3引入了tree-shaking技术，当没有在项目中使用某个模块时，那么该模块的代码将不会出现在打包中</p><p>vue3抛弃了Object.defineProperty，改用Proxy来做数据的响应式</p><p>vue3不再使用src托管，而采用monorepo管理</p><p>vue3采用typescript编写源码，对typescript的兼容更好，vue2使用的是flow来处理类型检查</p><p>vue3提供了Composition API，对于逻辑复用支持更好</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://99999.fun/tags/vuejs/>vuejs</a></li></ul><nav class=paginav><a class=prev href=https://99999.fun/posts/74/><span class=title>« Prev</span><br><span>NextJS学习笔记</span>
</a><a class=next href=https://99999.fun/posts/73/><span class=title>Next »</span><br><span>gulp学习笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://99999.fun/>知政的个人博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>