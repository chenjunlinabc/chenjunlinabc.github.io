<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>css3学习笔记 | 小陈的个人博客</title><meta name=keywords content="css"><meta name=description content="盒子模型
盒模型在css中是用来封装html元素的，因为本质上来看像个盒子一样，所以叫盒模型或者盒子模型，术语叫box model
外边距（margin）：一般用于控制同辈元素之间的间距
边框（border）：在内边距和内容之外的边框
内边距（padding）：内边框是用于控制内容的距离
内容（content）：内容，一般为文本和图像
例子：建立一个宽度为100px，10px的内边距，10px的外边距，10px的红色边框的盒子
div{ width: 100px; borde: 10px solid red; padding: 10px; margin: 10px; } top，bottom，left，right分别代表了上，下，左，右
或者padding: 上，右，下，左，只有一个数字就表示上，下，左，右都是这个数值
有两个数值就是分别代表上下和左右，有三个数值表示上和左右和下
这个盒子大小应该是内容的宽度+内边距+边框+外边距
100+20+20+20=160
两种盒模型
IE 盒子模型（box-sizing content-box）（怪异盒模型）
IE盒模型的width与height是content、padding和border的总和
调用IE盒模型 box-sizing: border-box;
W3C标准盒模型（box-sizing content-box）
标准盒模型的width与height只含content，不包括padding和border
调用W3C标准盒模型 box-sizing: content-box;
在IE6，7，8浏览器中不声明DOCTYPE类型，那么在IE6，7，8浏览器中会将盒子模型解释为IE盒子模型
如果在页面中声明了DOCTYPE类型，那么所有的浏览器都会把盒模型解释为W3C盒模型
JavaScript获取盒模型的宽和高（这里的DOM不是指整个dom，而是某个元素）
DOM.style.width和DOM.style.height（只能获取内联样式）
DOM.currentStyle.width和DOM.currentStyle.height（只支持IE）
window.getComputedStyle(DOM).width和window.getComputedStyle(DOM).height（兼容性好）
获取元素相对于视窗的位置(top,right,bottom,left都可以获取)
let data = DOM.getBoundingClientRect() data.top
有BFC特性的元素是一个被“隔离”的容器，该容器里面的元素不会在布局上影响到外面的元素
满足下面其中一个条件就触发BFC特性
body 根元素
浮动元素 float除none外的值
绝对定位元素 position (absolute、fixed)
display 为 inline-block、table-cells、flex
overflow 除了 visible 以外的值 (hidden、auto、scroll)
BFC的特性："><meta name=author content="Me"><link rel=canonical href=https://chenjunlinabc.github.io/posts/11/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://chenjunlinabc.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://chenjunlinabc.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://chenjunlinabc.github.io/favicon.ico><link rel=apple-touch-icon href=https://chenjunlinabc.github.io/favicon.ico><link rel=mask-icon href=https://chenjunlinabc.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="css3学习笔记"><meta property="og:description" content="盒子模型
盒模型在css中是用来封装html元素的，因为本质上来看像个盒子一样，所以叫盒模型或者盒子模型，术语叫box model
外边距（margin）：一般用于控制同辈元素之间的间距
边框（border）：在内边距和内容之外的边框
内边距（padding）：内边框是用于控制内容的距离
内容（content）：内容，一般为文本和图像
例子：建立一个宽度为100px，10px的内边距，10px的外边距，10px的红色边框的盒子
div{ width: 100px; borde: 10px solid red; padding: 10px; margin: 10px; } top，bottom，left，right分别代表了上，下，左，右
或者padding: 上，右，下，左，只有一个数字就表示上，下，左，右都是这个数值
有两个数值就是分别代表上下和左右，有三个数值表示上和左右和下
这个盒子大小应该是内容的宽度+内边距+边框+外边距
100+20+20+20=160
两种盒模型
IE 盒子模型（box-sizing content-box）（怪异盒模型）
IE盒模型的width与height是content、padding和border的总和
调用IE盒模型 box-sizing: border-box;
W3C标准盒模型（box-sizing content-box）
标准盒模型的width与height只含content，不包括padding和border
调用W3C标准盒模型 box-sizing: content-box;
在IE6，7，8浏览器中不声明DOCTYPE类型，那么在IE6，7，8浏览器中会将盒子模型解释为IE盒子模型
如果在页面中声明了DOCTYPE类型，那么所有的浏览器都会把盒模型解释为W3C盒模型
JavaScript获取盒模型的宽和高（这里的DOM不是指整个dom，而是某个元素）
DOM.style.width和DOM.style.height（只能获取内联样式）
DOM.currentStyle.width和DOM.currentStyle.height（只支持IE）
window.getComputedStyle(DOM).width和window.getComputedStyle(DOM).height（兼容性好）
获取元素相对于视窗的位置(top,right,bottom,left都可以获取)
let data = DOM.getBoundingClientRect() data.top
有BFC特性的元素是一个被“隔离”的容器，该容器里面的元素不会在布局上影响到外面的元素
满足下面其中一个条件就触发BFC特性
body 根元素
浮动元素 float除none外的值
绝对定位元素 position (absolute、fixed)
display 为 inline-block、table-cells、flex
overflow 除了 visible 以外的值 (hidden、auto、scroll)
BFC的特性："><meta property="og:type" content="article"><meta property="og:url" content="https://chenjunlinabc.github.io/posts/11/"><meta property="og:image" content="https://chenjunlinabc.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-16T09:21:00+00:00"><meta property="article:modified_time" content="2021-06-16T09:21:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chenjunlinabc.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="css3学习笔记"><meta name=twitter:description content="盒子模型
盒模型在css中是用来封装html元素的，因为本质上来看像个盒子一样，所以叫盒模型或者盒子模型，术语叫box model
外边距（margin）：一般用于控制同辈元素之间的间距
边框（border）：在内边距和内容之外的边框
内边距（padding）：内边框是用于控制内容的距离
内容（content）：内容，一般为文本和图像
例子：建立一个宽度为100px，10px的内边距，10px的外边距，10px的红色边框的盒子
div{ width: 100px; borde: 10px solid red; padding: 10px; margin: 10px; } top，bottom，left，right分别代表了上，下，左，右
或者padding: 上，右，下，左，只有一个数字就表示上，下，左，右都是这个数值
有两个数值就是分别代表上下和左右，有三个数值表示上和左右和下
这个盒子大小应该是内容的宽度+内边距+边框+外边距
100+20+20+20=160
两种盒模型
IE 盒子模型（box-sizing content-box）（怪异盒模型）
IE盒模型的width与height是content、padding和border的总和
调用IE盒模型 box-sizing: border-box;
W3C标准盒模型（box-sizing content-box）
标准盒模型的width与height只含content，不包括padding和border
调用W3C标准盒模型 box-sizing: content-box;
在IE6，7，8浏览器中不声明DOCTYPE类型，那么在IE6，7，8浏览器中会将盒子模型解释为IE盒子模型
如果在页面中声明了DOCTYPE类型，那么所有的浏览器都会把盒模型解释为W3C盒模型
JavaScript获取盒模型的宽和高（这里的DOM不是指整个dom，而是某个元素）
DOM.style.width和DOM.style.height（只能获取内联样式）
DOM.currentStyle.width和DOM.currentStyle.height（只支持IE）
window.getComputedStyle(DOM).width和window.getComputedStyle(DOM).height（兼容性好）
获取元素相对于视窗的位置(top,right,bottom,left都可以获取)
let data = DOM.getBoundingClientRect() data.top
有BFC特性的元素是一个被“隔离”的容器，该容器里面的元素不会在布局上影响到外面的元素
满足下面其中一个条件就触发BFC特性
body 根元素
浮动元素 float除none外的值
绝对定位元素 position (absolute、fixed)
display 为 inline-block、table-cells、flex
overflow 除了 visible 以外的值 (hidden、auto、scroll)
BFC的特性："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://chenjunlinabc.github.io/posts/"},{"@type":"ListItem","position":2,"name":"css3学习笔记","item":"https://chenjunlinabc.github.io/posts/11/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"css3学习笔记","name":"css3学习笔记","description":"盒子模型\n盒模型在css中是用来封装html元素的，因为本质上来看像个盒子一样，所以叫盒模型或者盒子模型，术语叫box model\n外边距（margin）：一般用于控制同辈元素之间的间距\n边框（border）：在内边距和内容之外的边框\n内边距（padding）：内边框是用于控制内容的距离\n内容（content）：内容，一般为文本和图像\n例子：建立一个宽度为100px，10px的内边距，10px的外边距，10px的红色边框的盒子\ndiv{ width: 100px; borde: 10px solid red; padding: 10px; margin: 10px; } top，bottom，left，right分别代表了上，下，左，右\n或者padding: 上，右，下，左，只有一个数字就表示上，下，左，右都是这个数值\n有两个数值就是分别代表上下和左右，有三个数值表示上和左右和下\n这个盒子大小应该是内容的宽度+内边距+边框+外边距\n100+20+20+20=160\n两种盒模型\nIE 盒子模型（box-sizing content-box）（怪异盒模型）\nIE盒模型的width与height是content、padding和border的总和\n调用IE盒模型 box-sizing: border-box;\nW3C标准盒模型（box-sizing content-box）\n标准盒模型的width与height只含content，不包括padding和border\n调用W3C标准盒模型 box-sizing: content-box;\n在IE6，7，8浏览器中不声明DOCTYPE类型，那么在IE6，7，8浏览器中会将盒子模型解释为IE盒子模型\n如果在页面中声明了DOCTYPE类型，那么所有的浏览器都会把盒模型解释为W3C盒模型\nJavaScript获取盒模型的宽和高（这里的DOM不是指整个dom，而是某个元素）\nDOM.style.width和DOM.style.height（只能获取内联样式）\nDOM.currentStyle.width和DOM.currentStyle.height（只支持IE）\nwindow.getComputedStyle(DOM).width和window.getComputedStyle(DOM).height（兼容性好）\n获取元素相对于视窗的位置(top,right,bottom,left都可以获取)\nlet data = DOM.getBoundingClientRect() data.top\n有BFC特性的元素是一个被“隔离”的容器，该容器里面的元素不会在布局上影响到外面的元素\n满足下面其中一个条件就触发BFC特性\nbody 根元素\n浮动元素 float除none外的值\n绝对定位元素 position (absolute、fixed)\ndisplay 为 inline-block、table-cells、flex\noverflow 除了 visible 以外的值 (hidden、auto、scroll)\nBFC的特性：","keywords":["css"],"articleBody":"盒子模型\n盒模型在css中是用来封装html元素的，因为本质上来看像个盒子一样，所以叫盒模型或者盒子模型，术语叫box model\n外边距（margin）：一般用于控制同辈元素之间的间距\n边框（border）：在内边距和内容之外的边框\n内边距（padding）：内边框是用于控制内容的距离\n内容（content）：内容，一般为文本和图像\n例子：建立一个宽度为100px，10px的内边距，10px的外边距，10px的红色边框的盒子\ndiv{ width: 100px; borde: 10px solid red; padding: 10px; margin: 10px; } top，bottom，left，right分别代表了上，下，左，右\n或者padding: 上，右，下，左，只有一个数字就表示上，下，左，右都是这个数值\n有两个数值就是分别代表上下和左右，有三个数值表示上和左右和下\n这个盒子大小应该是内容的宽度+内边距+边框+外边距\n100+20+20+20=160\n两种盒模型\nIE 盒子模型（box-sizing content-box）（怪异盒模型）\nIE盒模型的width与height是content、padding和border的总和\n调用IE盒模型 box-sizing: border-box;\nW3C标准盒模型（box-sizing content-box）\n标准盒模型的width与height只含content，不包括padding和border\n调用W3C标准盒模型 box-sizing: content-box;\n在IE6，7，8浏览器中不声明DOCTYPE类型，那么在IE6，7，8浏览器中会将盒子模型解释为IE盒子模型\n如果在页面中声明了DOCTYPE类型，那么所有的浏览器都会把盒模型解释为W3C盒模型\nJavaScript获取盒模型的宽和高（这里的DOM不是指整个dom，而是某个元素）\nDOM.style.width和DOM.style.height（只能获取内联样式）\nDOM.currentStyle.width和DOM.currentStyle.height（只支持IE）\nwindow.getComputedStyle(DOM).width和window.getComputedStyle(DOM).height（兼容性好）\n获取元素相对于视窗的位置(top,right,bottom,left都可以获取)\nlet data = DOM.getBoundingClientRect() data.top\n有BFC特性的元素是一个被“隔离”的容器，该容器里面的元素不会在布局上影响到外面的元素\n满足下面其中一个条件就触发BFC特性\nbody 根元素\n浮动元素 float除none外的值\n绝对定位元素 position (absolute、fixed)\ndisplay 为 inline-block、table-cells、flex\noverflow 除了 visible 以外的值 (hidden、auto、scroll)\nBFC的特性：\nBFC是页面上的独立容器，该容器使用类型浮动之类会影响布局的元素都不会影响到外界的布局或者元素\n例子：\n1.当处于同一个BFC容器时，外边距会进行重叠，为了避免重叠，可以将其放在不同的BFC容器内\n2.当容器内的元素使用的浮动，将其脱离了文档流，要触发容器的BFC，那么BFC容器要包含使用了浮动的元素\n3.当第一个元素使用了浮动，希望第二个元素不被浮动元素影响，要在第二个元素上触发BFC特性\nflex为Flexible Box 的缩写，意为\"弹性盒模型\"，为其盒模型提供足够大的灵活性\ndiv{ display: flex; } 使用flex布局的元素，被称为flex容器，该元素的所有子元素为该容器的成员，称为flex项目\nflex-direction\n一般用到四个值\nrow：在水平方向上，起点在左 row-reverse：在水平方向上，起点在右 column：在垂直方向上，起点在上。 column-reverse：在垂直方向上，起点在下。\nflex-wrap\n一般用到三个值\nnowrap：不换行 wrap：当容器宽度不足时换行，第一行在上方 wrap-reverse：当容器宽度不足时换行，第一行在下方\nflex-flow是flex-direction和flex-wrap简写版，它们两个的属性都可以使用 例如flex-flow: row-reverse wrap-reverse;\n表达了换行，第一行在下方，起点在右\njustify-content\n定义项目在主轴上的对齐方式\nflex-star：左对齐\nflex-end：右对齐\ncenter： 居中\nspace-between：两端对齐，每个项目之间的间隔都相等\nspace-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边框的间隔大一倍\nalign-items\nflex-start：头部对齐 flex-end：底部对齐 center：居中对齐 baseline: 项目的第一行文字的基线对齐 stretch：当项目没有设置高度或设置为auto时，将占满整个容器的高度\nalign-content\nflex-start：元素位于容器的开头 flex-end：元素位于容器的结尾 center：元素位于容器的中心 space-between：元素位于各行之间留有空白的容器内 space-around：元素位于各行之前、之间、之后都留有空白的容器内 stretch：默认值，元素被拉伸以适应容器\n单独用于元素的属性\norder 控制元素的顺序，数值越小排列就越靠前\norder:1\nflex-grow 控制元素的宽度\n如果都为1，还有剩余的空间，那么将会等分剩余的空间\n如果有一个为2，那么为2所占的剩余空间比为1的大1倍\nflex-grow: 2\nflex-shrink 控制元素宽度\n如果都为1时，当空间不足时，将会等比例缩小\n如果有一个为2时，那么当空间不足时\nflex-shrink: 2\nflex-basis 控制元素的初始宽度\n\\flex-basis: 100px flex 控制元素都有相同的宽度，不会被内容的长度撑开 \\flex: 1 align-self 控制元素单独对齐方式\nalign-self: auto | flex-start | flex-end | center | baseline | stretch;\n背景\n定位\n在box盒子内部的背景默认是在盒子的内边距的左上角对齐\nbackground-origin属性则规定background是相对于什么位置来定位的\n.box{ width: 300px; height: 300px; padding: 10px; margin: 10px; background: url(\"hallo.jpg\"); background-origin: padding-box; } background-origin属性值有3个，padding-box：相对于内边距定位，border-box：相对于边框定位，content-box：相对于内容区域\n裁切\n.box{ width: 300px; height: 300px; padding: 10px; margin: 10px; background: url(\"hallo.jpg\"); background-clip: padding-box; } background-clip属性提供相对于什么位置进行背景裁切，该属性值和background-origin一样\n背景尺寸\n.box{ width: 300px; height: 300px; padding: 10px; margin: 10px; background: url(\"hallo.jpg\"); background-size: 100px 100px; } background-size属性可以直接指定大小，也是可以cover或者contain填充\ncover会按照原来的缩放比来填满整个盒子，而contain是按照原来缩放比，完整的填充盒子（不会填满）\n边框\n边框阴影\n.box{ width: 300px; height: 300px; border: 1px solid red; box-shadow: 0px 0px 6px #ccc; border-radius: 6px; } box-shadow，第一个值为阴影在水平方向的偏移量（正数为正方向，负数为反方向）\n第二个值为阴影在垂直方向的偏移量（正数为朝下，负数为朝上）\n第三个值为阴影的模糊度\n第四个值为阴影的颜色\nborder-radius为边框圆角\n边框图片\n.box{ width: 300px; height: 300px; border: 1px solid red; border-image-source: url(\"hallo.jpg\"); // 边框图片 border-image-slice: 10; // 边框图片向内的偏移量 border-image-repeat: round; // 边框图片的平铺方式 border-image-width: 10px; // 边框图片的宽度 } border-image-repeat有4个常用值\nstretch（默认值）：拉伸图形来填充\nrepeat：平铺（重复）图形来填充\nround：如果无法完整平铺，那么就进行缩放来适应\nspace：如果无法完整平铺，那么就进行扩展来适应\n文本阴影\ntext-shadow，有4个值，分别是水平方向的偏移量，垂直方向的偏移量，模糊度，阴影的颜色\n伪类选择器\n:first-child：选择父元素中的第一个子元素 :last-child：选择父元素中的最后一个子元素 :nth-child(n) ：选择父元素中正数第n个子元素 :nth-last-child(n) ：选择父元素中倒数第n个子元素\nn的值必须要大于等于0，也可以是表达式\n:target：选择被锚链接指向 ::selection：选择被鼠标选中\n例如：\n:target{ background-color: #ccc; } \\跳转至1\n…\n1\n或者\np::selection:{ background-color: #ccc; } xxx\n…\nxxx\n::first-line：选择第一行 ::first-letter：选择第一个字符\n例如：\ndiv{ width: 100px; height: 100px; } div::first-line{ background-color: #ccc; } div::first-letter{ background-color: #000; } sjdasfkdskbdsalkddsfjdslsakfbsdlss xxx test 过渡\n.box1 { width: 300px; height: 300px; background-color: red; transition-property: all; transition-duration: 3s; } .box1:hover { width: 500px; height: 500px; background-color: #ccc; } transition-property：表示哪些属性要参与到过渡动画效果，all表示全部\ntransition-duration：表示过渡执行时间\ntransition-delay: 设置过渡执行前等待的时间\ntransition-timing-function：过渡的速度类型，linear为相同速度，ease为开始慢速，变快，然后慢速结束，ease-in慢速开始，ease-out慢速结束，ease-in-out以慢速开始和结束，cubic-bezier开始到结束的不同速度过渡，用小数来表示进度，例如cubic-bezier(0.1, 0.3, 0.6, 0.1)\nCSS3 border-image\nborder-image可以在元素的边框上绘制图像，规范要求使用borde-images时边框样式必须存在\nborder-image: url(./logo.jpg) 10 repeat\n上面这行代表使用图片logo.jpg，裁剪位置10，使用重复方式\n图片：使用url()调用，路径可以是绝对或者相对，也可以不用图片，即none\n裁剪位置：默认单位为px，10表示10px，不需要写单位\n支持使用百分百，例如300px*100px的图片，30%就是裁剪图片90px*30px的四个边的大小 也可以使用4个数，代表上右下左要裁剪的数值\n重复方式只是其中一种方式，可以用于设置图像边界是否要重复或者拉伸，铺满\n重复（repeat)，拉伸（stretch）,平铺（round）\nstretch（拉伸）为默认值，所以会裁剪出来的图片比边框小，就会拉伸，以保证填满边框\n可以使用两个参数，当使用一个参数时，水平方向以及垂直方向都使用这个参数\n当使用两个参数时，第一个参数代表水平方向，第二个参数表示垂直方向\nborder-image还有4个子属性\n指定要用于绘制边框的图像的位置\nborder-image-source\n图像边界向内收缩\nborder-image-slice\n图像边界的宽度\n可以使用带单位的，百分百，不带单位的（倍数），auto\nborder-image-width\n指定在边框外部绘制 border-image-area 的量\n就是原本的位置向外拉伸\nborder-image-outset\n用于设置图像边界是否要重复或者拉伸，铺满\nborder-image-repeat\n引入css 内联css： // 要写在开始标签中\n嵌入css： div{color: #fff;}\n外部css: 优先级：内联 \u003e 嵌入 \u003e 外部\n选择器\n标签选择器：div{} id选择器：#main{} 类选择器：.main{} 子选择器：.main\u003ediv{} 后代选择器：.main div{} 通用选择器：*{} 伪类选择器：a:{} 分组选择器：div,span{} id选择器只能在文档中使用一次，类选择器可以使用多次\n选择器的优先级是: 内联 \u003e id \u003e 类 \u003e 标签 \u003e 通配符\n标签的权值为1\n类选择器的权值为10\nID选择器的权值为100\n伪类选择器是10\n权值越大，优先级就越大\n优先级最大的!important,例如：\ndiv{color:#fff!important;}\n样式\n字体font-family div{font-family:“Microsoft Yahei”;}\n字体大小font-size div{font-size:16px;}\n字体粗细font-weight div{font-weight:bold;}\n字体样式font-style div{font-style:normal;}\n字体颜色color div{color:#fff;}\n文本样式text-decoration div{text-decoration:none;}\n文本首行缩进text-indent div{text-indent:2em;}\n文本行间间距line-height div{line-height:2em;}\n增加或减少每一个文字的间距 letter-spacing div{letter-spacing:10px;}\n增加或减少每个英文单词之间的间距word-spacing div{word-spacing:10px;}\n文本对齐方式text-align div{text-align:center;}\n定位： 定位有两种，绝对定位和相当定位\n相对定位和绝对定位都有四个属性\nleft（左），top(头)，right（右），bottom（底）\n绝对定位：\n设置绝对定位的元素会脱离文档流，所以不会占用空间\ndiv{ position: absolute; } 绝对定位的元素的位置相对于元素最近的已定位的祖先元素，如果没有，那么相对于最初的包含块（也就是body）\n相对定位：\n相对定位的元素的位置相对于元素最初的位置，使用相对定位时，元素会占据原来的空间，所以，移动元素会覆盖其他元素\ndiv{ position: relative; } css有下面这些选择器\nid选择器（#myid） 类选择器（.myclassname） 标签选择器（div,h1,p） 后代选择器（h1p） 相邻后代选择器（子）选择器（ul\u003eli） 兄弟选择器（li~a） 相邻兄弟选择器（li+a） 属性选择器（a[rel=“external”]） 伪类选择器（a:hover,li:nth-child） 伪元素选择器（::before、::after） 通配符选择器（*）\n在css3中使用单冒号来表示伪类，用双冒号来表示伪元素\n伪类一般用于匹配元素的一些状态，而伪元素一般用于匹配元素的位置\nCSS3 圆角\n使用border-radius属性\n可以使用1——4个值\n1个值，表示四个角都使用这个值\n2个值，表示第一个值对应左上和右下，第二个值对应左下和右上\n3个值，表示第一个值对应左上，第二个值对应左下和右上，第三个值表示右下\n4个值，表示第一个值对应左上，第二个值对应右上，第三个值表示右下，第四个值表示左下\n单独设置圆角\n左上角 border-top-left-radius 右上角\tborder-top-right-radius\n右下角 border-bottom-right-radius 左下角 border-bottom-left-radius\ncss阴影\nbox-shadow: 10px 10px 10px #fff;\n第一个值是阴影水平位移，第二个值为阴影垂直位移，第三个值为模糊半径\n第四个值为阴影颜色\ntransition属性 例如: div{ width: 100px; height: 100px; background: #000; transition: width 1s; } div:hover{ background: #f6f6f6; }\nz-index属性\n该属性用于堆叠元素的顺序，高级的元素会堆叠在低级的元素前面，例如：\n#app{ z-index: -1; } font-family属性\n该属性用于设置元素字体，可以设置多个字体，当第一个字体不支持时，自动尝试设置下一个字体\n@keyframes 规则：这个规则是可以将样式以动画方式（特定时间）逐渐地从当前样式修改为新的样式，当超过特定时间又恢复原来的样式\n#app{ width: 100px; height: 100px; background-color: #000; animation-name: test; animation-duration: 6s; animation-delay: 3s; animation-iteration-count: infinite; } @keyframes test { from{ background-color: #000; } to{ background-color: #ccc; } } background-image\n该属性可以添加背景，可以添加多张背景，例如：\n#app{ background-image: url(1.jpg),url(2.jpg); background-position: left top,right bottom; background-repeat: no-repeat,repeat; } background-size\n该属性可以指定背景的大小，例如： #app{ background-image: url(1.jpg); background-repeat: no-repeat; background-size: 100px 100px; }\nbackground-origin\n该属性可以指定背景的位置区域（外边框（border-box），内边框（padding-box），内容区（content-box）），例如：\nbackground-color: content-box; background-clip\n该属性可以将背景裁剪到指定位置（外边框（border-box），内边框（padding-box），内容区（content-box），例如：\nbackground-clip: content-box; 渐变分为线性渐变（直线）和径向渐变（中心）\n线性渐变（默认从上到下）\n#app{ width: 300px; height: 300px; background-image: linear-gradient(#ccc,#000); } 从左到右\n#app{ width: 300px; height: 300px; background-image: linear-gradient(to right ,#ccc,#000); } 从左上角到右下角\n#app{ width: 300px; height: 300px; background-image: linear-gradient(to right bottom ,#ccc,#000); } 带角度的（不能指定方向）\n#app{ width: 300px; height: 300px; background-image: linear-gradient(30deg,#ccc,#000); } 带透明度的\n#app{ width: 300px; height: 300px; background-image: linear-gradient(30deg,rgb(255,0,0,1),rgb(0,0,0,0)); } 带重复的\n#app{ width: 300px; height: 300px; background-image: repeating-linear-gradient(#ccc, #fcfcfc 20%, #000 30%); } 径向渐变\n#app{ width: 300px; height: 300px; background-image: radial-gradient(#fff, #ccc, #000,#fc0000); } 必须要有两个以上的颜色，第一个颜色在中间，依次往外排\n同样可以设置每个颜色的占比\n#app{ width: 300px; height: 300px; background-image: radial-gradient(#fff 10%, #ccc 20%, #000 30%,#fc0000 40%); } 当元素是不正的，那么径向渐变默认就是椭圆的（ellipse），也可以指定为圆形的（circle）\n#app{ width: 300px; height: 250px; background-image: radial-gradient(circle,#fff, #ccc, #000,#fc0000); } 还提供了定义渐变大小的关键字，分别是closest-side，farthest-side，closest-corner，farthest-corner\n当然也提供了可以重复渐变的，例如：\n#app{ width: 300px; height: 250px; background-image: repeating-radial-gradient(circle,#000 20%, #fc0000 30% , yellow 50%); } 文本阴影\n#app{ text-shadow: 5px 5px 5px #000; } 值分别为水平阴影，垂直阴影，模糊度，阴影颜色\n元素盒子阴影\n#app{ box-shadow: 5px 5px 5px #000; } 容器文本溢出处理\n#app{ text-overflow: ellipsis; } 文本溢出默认为text-overflow: clip\n自动强制文本换行（当单词或者某个文本太长，就会强制换行，避免文本溢出）\n#app{ word-wrap: break-word; } @font-face 规则\n该规则允许使用客户端没有的字体，例如：\n@font-face { font-family: hallo; src: url(\"hallo.ttf\"); } div{ font-family: hallo; } 必需属性font-family：字体名称\nsrc：字体文件的url\n在需要用字体的元素上font-family: 字体名称\n过渡动画，会逐渐式加载样式，例如\n#app{ width: 100px; height: 100px; background-color: #333; transition: height 3s,width 3s,transform 3s; } #app:hover{ width: 300px; height: 300px; transform: rotate(360deg); } 当鼠标移动到该元素上，那么会在3秒内逐渐转换为指定样式，移开鼠标那么又会逐渐恢复原来的样式\ncolumn-count 属性，该属性可以将元素中的文本分成指定列，例如\n#app{ column-count: 3; } 每个列之间的距离使用column-gap属性指定，例如\n#app{ column-count: 3; column-gap: 20px; } column-rule-style属性可以指定每个列分隔的边框样式，例如下面样式为实线\n#app{ column-count: 3; column-gap: 20px; column-rule-style: solid; } column-rule-width属性可以指定列的边框之间的宽度，例如\n#app{ column-count: 3; column-gap: 20px; column-rule-style: solid; column-rule-width: 1px; } column-rule-color属性可以指定列的边框的颜色，例如：\n#app{ column-count: 3; column-gap: 20px; column-rule-style: solid; column-rule-width: 6px; column-rule-color: #000; } 当然列的边框的样式可以缩写，例如：\n#app{ column-rule: 6px solid #000; } 如果在父元素内，某个子元素不想被分列影响，直接指定子元素，例如\ndiv{ column-span: all; } column-width可以指定列的宽度，例如\ndiv{ column-width: 300px; } column-gap属性和column-width属性之间的区别，就是column-gap控制的是列与列之间的距离，而column-width控制的却是列本身的宽度\n动画，可以指定时间，在指定时间内逐渐成另一种样式，可以指定动画的过程的样式，例如\n#app{ width: 300px; height: 300px; background-color:#ccc; animation: hallo 5s; } @keyframes hallo{ 0% {background-color: #ccc;} 25% {background-color: #fff;} 50% {background-color: #222;} 75% {background-color: #f3f3f3} 100% {background-color: #777;} } 0%为动画开始，100%为动画结束，当动画结束时样式会恢复原来定义的样式，除了用百分比表示进度，也可以用from（起点）和to（终点）表示\n能修改颜色，当然也能修改位置，例如：\n#app{ width: 300px; height: 300px; background-color:#ccc; animation: hallo 5s; position: relative; } @keyframes hallo{ 0% { background-color: #ccc; top: 0px; left: 0px; } 25% { background-color: #fff; top: 0px; left: 300px; } 50% { background-color: #222; top: 300px; left: 300px; } 75% { background-color: #f3f3f3; top: 300px; left: 0px; } 100%{ background-color: #777; top: 0px; left: 0px; } } 二维改变样式\n旋转（值为正数则顺时针转，值为负数则逆时针转）\n#app{ width: 300px; height: 300px; background-color: #ccc; transform: rotate(60deg); } 平移(根据x（左），y（上）轴决定)\n#app{ width: 300px; height: 300px; background-color: #ccc; transform: translate(100px,100px); } 放大或者缩小\n#app{ width: 300px; height: 300px; background-color: #ccc; transform: scale(2,2); } 宽度和高度是原来的2倍\n倾斜(根据x（水平），y（垂直）轴决定，默认为0，值为负数则逆时针转)\n#app{ width: 300px; height: 300px; background-color: #ccc; transform: skew(10deg,30deg); } 同样也可以缩写为一个属性\n#app{ width: 300px; height: 300px; background-color:#ccc; transform:matrix(0.6,1.5,-0.5,1.2,3,3); } 这个6个值分别代表旋转，放大或者缩小，平移，倾斜\n三维改变样式\n#app{ width: 300px; height: 300px; background-color:#ccc; transform: rotateX(60deg); } #app{ width: 300px; height: 300px; background-color:#ccc; transform: rotateY(60deg); } #app{ width: 300px; height: 300px; background-color:#ccc; transform: rotateZ(60deg); } 旋转元素的起始位置\n#app{ width: 300px; height: 300px; background-color:#ccc; transform: rotate(60deg); transform-origin: 30% 60%; } 拓展\n#app{ width: 500px; height: 500px; perspective: 200; perspective-origin: 10% 20%; background-color: #000; } #app div{ width: 300px; height: 300px; background-color:#ccc; transform: rotateX(60deg); transform-style: preserve-3d; backface-visibility: hidden; } backface-visibility属性用于指定背面是否显示\nperspective-origin属性用于改变底部位置\nperspective属性用于查看透视图（z只支持3D元素）\ntransform-style属性用于是否保留3d位置保留\ncss强制换行，避免文本溢出容器\nwhite-space: pre-wrap; normal：默认，空白被忽略\nnowrap：文本不换行，文本在同一行继续\npre：保留空格，换行保留，不自动换行\npre-wrap：保留完整空格，保留换行符，自动换行\npre-line：保留空格（可能不完整），保留换行\nfilter属性滤镜\n该属性默认值为none\n背景为黑白\nfilter: grayscale(100%); 高斯模糊\nfilter: blur(3px); 亮度\nfilter: brightness(160%); 对比度\nfilter: contrast(160%); 透明度\nfilter: opacity(30%); 饱和度\nfilter: saturate(300%); 阴影\nfilter: drop-shadow(5px 5px 6px #ccc); 色相旋转\nfilter: hue-rotate(30deg); 颠倒输入\nfilter: invert(30%); 允许使用多个滤镜，多个滤镜有空格分开\n表格布局（现在很少用，一般都是用div+css）\n该元素会作为块级表格（例如table标签，有换行） display: table;\n内联表格（没换行） display: inline-table;\n表格行（例如tr） display: table-row;\n表格单元格（例如td） display: table-cell;\n表格标题 display: table-caption;\n单元格列 display: table-column;\n","wordCount":"1128","inLanguage":"en","datePublished":"2021-06-16T09:21:00Z","dateModified":"2021-06-16T09:21:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://chenjunlinabc.github.io/posts/11/"},"publisher":{"@type":"Organization","name":"小陈的个人博客","logo":{"@type":"ImageObject","url":"https://chenjunlinabc.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://chenjunlinabc.github.io/ accesskey=h title="小陈的个人博客 (Alt + H)"><img src=https://chenjunlinabc.github.io/favicon.ico alt aria-label=logo height=35>小陈的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://chenjunlinabc.github.io/ title=首页><span>首页</span></a></li><li><a href=https://chenjunlinabc.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://chenjunlinabc.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://chenjunlinabc.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://chenjunlinabc.github.io/links/ title=链接><span>链接</span></a></li><li><a href=https://chenjunlinabc.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://chenjunlinabc.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://chenjunlinabc.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://chenjunlinabc.github.io/posts/>Posts</a></div><h1 class=post-title>css3学习笔记</h1><div class=post-meta><span title='2021-06-16 09:21:00 +0000 UTC'>2021-06-16</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://chenjunlinabc.github.io//posts/css3%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>盒子模型</p><p>盒模型在css中是用来封装html元素的，因为本质上来看像个盒子一样，所以叫盒模型或者盒子模型，术语叫box model</p><p>外边距（margin）：一般用于控制同辈元素之间的间距</p><p>边框（border）：在内边距和内容之外的边框</p><p>内边距（padding）：内边框是用于控制内容的距离</p><p>内容（content）：内容，一般为文本和图像</p><p>例子：建立一个宽度为100px，10px的内边距，10px的外边距，10px的红色边框的盒子</p><pre><code>div{
    width: 100px;
    borde: 10px solid red;
    padding: 10px;
    margin: 10px;
}
</code></pre><p>top，bottom，left，right分别代表了上，下，左，右</p><p>或者padding: 上，右，下，左，只有一个数字就表示上，下，左，右都是这个数值</p><p>有两个数值就是分别代表上下和左右，有三个数值表示上和左右和下</p><p>这个盒子大小应该是内容的宽度+内边距+边框+外边距</p><p>100+20+20+20=160</p><p>两种盒模型</p><p>IE 盒子模型（box-sizing content-box）（怪异盒模型）</p><p>IE盒模型的width与height是content、padding和border的总和</p><p>调用IE盒模型
box-sizing: border-box;</p><p>W3C标准盒模型（box-sizing content-box）</p><p>标准盒模型的width与height只含content，不包括padding和border</p><p>调用W3C标准盒模型
box-sizing: content-box;</p><p>在IE6，7，8浏览器中不声明DOCTYPE类型，那么在IE6，7，8浏览器中会将盒子模型解释为IE盒子模型</p><p>如果在页面中声明了DOCTYPE类型，那么所有的浏览器都会把盒模型解释为W3C盒模型</p><p>JavaScript获取盒模型的宽和高（这里的DOM不是指整个dom，而是某个元素）</p><p>DOM.style.width和DOM.style.height（只能获取内联样式）</p><p>DOM.currentStyle.width和DOM.currentStyle.height（只支持IE）</p><p>window.getComputedStyle(DOM).width和window.getComputedStyle(DOM).height（兼容性好）</p><p>获取元素相对于视窗的位置(top,right,bottom,left都可以获取)</p><p>let data = DOM.getBoundingClientRect()
data.top</p><hr><p>有BFC特性的元素是一个被“隔离”的容器，该容器里面的元素不会在布局上影响到外面的元素</p><p>满足下面其中一个条件就触发BFC特性</p><p>body 根元素</p><p>浮动元素 float除none外的值</p><p>绝对定位元素 position (absolute、fixed)</p><p>display 为 inline-block、table-cells、flex</p><p>overflow 除了 visible 以外的值 (hidden、auto、scroll)</p><p>BFC的特性：</p><p>BFC是页面上的独立容器，该容器使用类型浮动之类会影响布局的元素都不会影响到外界的布局或者元素</p><p>例子：</p><p>1.当处于同一个BFC容器时，外边距会进行重叠，为了避免重叠，可以将其放在不同的BFC容器内</p><p>2.当容器内的元素使用的浮动，将其脱离了文档流，要触发容器的BFC，那么BFC容器要包含使用了浮动的元素</p><p>3.当第一个元素使用了浮动，希望第二个元素不被浮动元素影响，要在第二个元素上触发BFC特性</p><hr><p>flex为Flexible Box 的缩写，意为"弹性盒模型"，为其盒模型提供足够大的灵活性</p><pre><code>div{
    display: flex;
}
</code></pre><p>使用flex布局的元素，被称为flex容器，该元素的所有子元素为该容器的成员，称为flex项目</p><p>flex-direction</p><p>一般用到四个值</p><p>row：在水平方向上，起点在左
row-reverse：在水平方向上，起点在右
column：在垂直方向上，起点在上。
column-reverse：在垂直方向上，起点在下。</p><hr><p>flex-wrap</p><p>一般用到三个值</p><p>nowrap：不换行
wrap：当容器宽度不足时换行，第一行在上方
wrap-reverse：当容器宽度不足时换行，第一行在下方</p><hr><p>flex-flow是flex-direction和flex-wrap简写版，它们两个的属性都可以使用
例如flex-flow: row-reverse wrap-reverse;</p><p>表达了换行，第一行在下方，起点在右</p><hr><p>justify-content</p><p>定义项目在主轴上的对齐方式</p><p>flex-star：左对齐</p><p>flex-end：右对齐</p><p>center： 居中</p><p>space-between：两端对齐，每个项目之间的间隔都相等</p><p>space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边框的间隔大一倍</p><hr><p>align-items</p><p>flex-start：头部对齐
flex-end：底部对齐
center：居中对齐
baseline: 项目的第一行文字的基线对齐
stretch：当项目没有设置高度或设置为auto时，将占满整个容器的高度</p><hr><p>align-content</p><p>flex-start：元素位于容器的开头
flex-end：元素位于容器的结尾
center：元素位于容器的中心
space-between：元素位于各行之间留有空白的容器内
space-around：元素位于各行之前、之间、之后都留有空白的容器内
stretch：默认值，元素被拉伸以适应容器</p><hr><p>单独用于元素的属性</p><p>order
控制元素的顺序，数值越小排列就越靠前</p><p>order:1</p><hr><p>flex-grow
控制元素的宽度</p><p>如果都为1，还有剩余的空间，那么将会等分剩余的空间</p><p>如果有一个为2，那么为2所占的剩余空间比为1的大1倍</p><p>flex-grow: 2</p><hr><p>flex-shrink
控制元素宽度</p><p>如果都为1时，当空间不足时，将会等比例缩小</p><p>如果有一个为2时，那么当空间不足时</p><p>flex-shrink: 2</p><hr><p>flex-basis
控制元素的初始宽度</p><h2 id=flex-basis-100px>\flex-basis: 100px<a hidden class=anchor aria-hidden=true href=#flex-basis-100px>#</a></h2><h2 id=flex-1>flex
控制元素都有相同的宽度，不会被内容的长度撑开
\flex: 1</h2><p>align-self
控制元素单独对齐方式</p><p>align-self: auto | flex-start | flex-end | center | baseline | stretch;</p><hr><p>背景</p><p>定位</p><p>在box盒子内部的背景默认是在盒子的内边距的左上角对齐</p><p>background-origin属性则规定background是相对于什么位置来定位的</p><pre><code>.box{
    width: 300px;
    height: 300px;
    padding: 10px;
    margin: 10px;
    background: url(&quot;hallo.jpg&quot;);
    background-origin: padding-box;
}
</code></pre><p>background-origin属性值有3个，padding-box：相对于内边距定位，border-box：相对于边框定位，content-box：相对于内容区域</p><p>裁切</p><pre><code>.box{
    width: 300px;
    height: 300px;
    padding: 10px;
    margin: 10px;
    background: url(&quot;hallo.jpg&quot;);
    background-clip: padding-box;
}
</code></pre><p>background-clip属性提供相对于什么位置进行背景裁切，该属性值和background-origin一样</p><p>背景尺寸</p><pre><code>.box{
    width: 300px;
    height: 300px;
    padding: 10px;
    margin: 10px;
    background: url(&quot;hallo.jpg&quot;);
    background-size: 100px 100px;
}
</code></pre><p>background-size属性可以直接指定大小，也是可以cover或者contain填充</p><p>cover会按照原来的缩放比来填满整个盒子，而contain是按照原来缩放比，完整的填充盒子（不会填满）</p><p>边框</p><p>边框阴影</p><pre><code>.box{
    width: 300px;
    height: 300px;
    border: 1px solid red;
    box-shadow: 0px 0px 6px #ccc;
    border-radius: 6px;
}
</code></pre><p>box-shadow，第一个值为阴影在水平方向的偏移量（正数为正方向，负数为反方向）</p><p>第二个值为阴影在垂直方向的偏移量（正数为朝下，负数为朝上）</p><p>第三个值为阴影的模糊度</p><p>第四个值为阴影的颜色</p><p>border-radius为边框圆角</p><p>边框图片</p><pre><code>.box{
    width: 300px;
    height: 300px;
    border: 1px solid red;
    border-image-source: url(&quot;hallo.jpg&quot;); // 边框图片
    border-image-slice: 10; // 边框图片向内的偏移量
    border-image-repeat: round; // 边框图片的平铺方式
    border-image-width: 10px; // 边框图片的宽度
}
</code></pre><p>border-image-repeat有4个常用值</p><p>stretch（默认值）：拉伸图形来填充</p><p>repeat：平铺（重复）图形来填充</p><p>round：如果无法完整平铺，那么就进行缩放来适应</p><p>space：如果无法完整平铺，那么就进行扩展来适应</p><p>文本阴影</p><p>text-shadow，有4个值，分别是水平方向的偏移量，垂直方向的偏移量，模糊度，阴影的颜色</p><p>伪类选择器</p><p>:first-child：选择父元素中的第一个子元素
:last-child：选择父元素中的最后一个子元素
:nth-child(n) ：选择父元素中正数第n个子元素
:nth-last-child(n) ：选择父元素中倒数第n个子元素</p><p>n的值必须要大于等于0，也可以是表达式</p><p>:target：选择被锚链接指向
::selection：选择被鼠标选中</p><p>例如：</p><pre><code>:target{
    background-color: #ccc;
}

&lt;p&gt;\&lt;a href=&quot;#a&quot;&gt;跳转至1&lt;/a&gt;&lt;/p&gt;
</code></pre><p>&mldr;</p><pre><code>&lt;p id=&quot;a&quot;&gt;1&lt;/p&gt;
</code></pre><p>或者</p><pre><code>p::selection:{
    background-color: #ccc;
}

&lt;p&gt;xxx&lt;/p&gt;
</code></pre><p>&mldr;</p><pre><code>&lt;p&gt;xxx&lt;/p&gt;
</code></pre><p>::first-line：选择第一行
::first-letter：选择第一个字符</p><p>例如：</p><pre><code>div{
    width: 100px;
    height: 100px;
}
div::first-line{
    background-color: #ccc;
}
div::first-letter{
    background-color: #000;
}

&lt;div&gt;
    sjdasfkdskbdsalkddsfjdslsakfbsdlss
    xxx
    test
&lt;/div&gt;
</code></pre><p>过渡</p><pre><code>.box1 {
	width: 300px;
	height: 300px;
	background-color: red;
	transition-property: all; 
	transition-duration: 3s;
}

.box1:hover {
	width: 500px;
	height: 500px;
	background-color: #ccc;
}
</code></pre><p>transition-property：表示哪些属性要参与到过渡动画效果，all表示全部</p><p>transition-duration：表示过渡执行时间</p><p>transition-delay: 设置过渡执行前等待的时间</p><p>transition-timing-function：过渡的速度类型，linear为相同速度，ease为开始慢速，变快，然后慢速结束，ease-in慢速开始，ease-out慢速结束，ease-in-out以慢速开始和结束，cubic-bezier开始到结束的不同速度过渡，用小数来表示进度，例如cubic-bezier(0.1, 0.3, 0.6, 0.1)</p><hr><p>CSS3 border-image</p><p>border-image可以在元素的边框上绘制图像，规范要求使用borde-images时边框样式必须存在</p><p>border-image: url(./logo.jpg) 10 repeat</p><p>上面这行代表使用图片logo.jpg，裁剪位置10，使用重复方式</p><p>图片：使用url()调用，路径可以是绝对或者相对，也可以不用图片，即none</p><p>裁剪位置：默认单位为px，10表示10px，不需要写单位</p><p>支持使用百分百，例如300px*100px的图片，30%就是裁剪图片90px*30px的四个边的大小
也可以使用4个数，代表上右下左要裁剪的数值</p><p>重复方式只是其中一种方式，可以用于设置图像边界是否要重复或者拉伸，铺满</p><p>重复（repeat)，拉伸（stretch）,平铺（round）</p><p>stretch（拉伸）为默认值，所以会裁剪出来的图片比边框小，就会拉伸，以保证填满边框</p><p>可以使用两个参数，当使用一个参数时，水平方向以及垂直方向都使用这个参数</p><p>当使用两个参数时，第一个参数代表水平方向，第二个参数表示垂直方向</p><hr><p>border-image还有4个子属性</p><p>指定要用于绘制边框的图像的位置</p><p>border-image-source</p><p>图像边界向内收缩</p><p>border-image-slice</p><p>图像边界的宽度</p><p>可以使用带单位的，百分百，不带单位的（倍数），auto</p><p>border-image-width</p><p>指定在边框外部绘制 border-image-area 的量</p><p>就是原本的位置向外拉伸</p><p>border-image-outset</p><p>用于设置图像边界是否要重复或者拉伸，铺满</p><p>border-image-repeat</p><hr><h2 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h2><p>引入css
内联css： // 要写在开始标签中</p><p>嵌入css：
div{color: #fff;}</p><p>外部css:</p><p>优先级：内联 > 嵌入 > 外部</p><hr><p>选择器</p><pre><code>标签选择器：div{}
id选择器：#main{}  &lt;div id=&quot;main&quot;&gt;
类选择器：.main{}  &lt;div class = &quot;main&quot;&gt;
子选择器：.main&gt;div{}
后代选择器：.main div{}
通用选择器：*{}
伪类选择器：a:{}
分组选择器：div,span{}
</code></pre><p>id选择器只能在文档中使用一次，类选择器可以使用多次</p><p>选择器的优先级是: 内联 > id > 类 > 标签 > 通配符</p><p>标签的权值为1</p><p>类选择器的权值为10</p><p>ID选择器的权值为100</p><p>伪类选择器是10</p><p>权值越大，优先级就越大</p><p>优先级最大的!important,例如：</p><p>div{color:#fff!important;}</p><hr><p>样式</p><p>字体font-family
div{font-family:&ldquo;Microsoft Yahei&rdquo;;}</p><p>字体大小font-size
div{font-size:16px;}</p><p>字体粗细font-weight
div{font-weight:bold;}</p><p>字体样式font-style
div{font-style:normal;}</p><p>字体颜色color
div{color:#fff;}</p><p>文本样式text-decoration
div{text-decoration:none;}</p><p>文本首行缩进text-indent
div{text-indent:2em;}</p><p>文本行间间距line-height
div{line-height:2em;}</p><p>增加或减少每一个文字的间距 letter-spacing
div{letter-spacing:10px;}</p><p>增加或减少每个英文单词之间的间距word-spacing
div{word-spacing:10px;}</p><p>文本对齐方式text-align
div{text-align:center;}</p><hr><p>定位：
定位有两种，绝对定位和相当定位</p><p>相对定位和绝对定位都有四个属性</p><p>left（左），top(头)，right（右），bottom（底）</p><p>绝对定位：</p><p>设置绝对定位的元素会脱离文档流，所以不会占用空间</p><pre><code>div{
    position: absolute;
}
</code></pre><p>绝对定位的元素的位置相对于元素最近的已定位的祖先元素，如果没有，那么相对于最初的包含块（也就是body）</p><p>相对定位：</p><p>相对定位的元素的位置相对于元素最初的位置，使用相对定位时，元素会占据原来的空间，所以，移动元素会覆盖其他元素</p><pre><code>div{
    position: relative;
}
</code></pre><hr><p>css有下面这些选择器</p><p>id选择器（#myid）
类选择器（.myclassname）
标签选择器（div,h1,p）
后代选择器（h1p）
相邻后代选择器（子）选择器（ul>li）
兄弟选择器（li~a）
相邻兄弟选择器（li+a）
属性选择器（a[rel=&ldquo;external&rdquo;]）
伪类选择器（a:hover,li:nth-child）
伪元素选择器（::before、::after）
通配符选择器（*）</p><hr><p>在css3中使用单冒号来表示伪类，用双冒号来表示伪元素</p><p>伪类一般用于匹配元素的一些状态，而伪元素一般用于匹配元素的位置</p><hr><p>CSS3 圆角</p><p>使用border-radius属性</p><p>可以使用1——4个值</p><p>1个值，表示四个角都使用这个值</p><p>2个值，表示第一个值对应左上和右下，第二个值对应左下和右上</p><p>3个值，表示第一个值对应左上，第二个值对应左下和右上，第三个值表示右下</p><p>4个值，表示第一个值对应左上，第二个值对应右上，第三个值表示右下，第四个值表示左下</p><p>单独设置圆角</p><p>左上角
border-top-left-radius
右上角
border-top-right-radius<br>右下角
border-bottom-right-radius
左下角
border-bottom-left-radius</p><hr><p>css阴影</p><p>box-shadow: 10px 10px 10px #fff;</p><p>第一个值是阴影水平位移，第二个值为阴影垂直位移，第三个值为模糊半径</p><p>第四个值为阴影颜色</p><hr><p>transition属性
例如:
div{
width: 100px;
height: 100px;
background: #000;
transition: width 1s;
}
div:hover{
background: #f6f6f6;
}</p><hr><p>z-index属性</p><p>该属性用于堆叠元素的顺序，高级的元素会堆叠在低级的元素前面，例如：</p><pre><code>#app{
     z-index: -1;
}
</code></pre><p>font-family属性</p><p>该属性用于设置元素字体，可以设置多个字体，当第一个字体不支持时，自动尝试设置下一个字体</p><p>@keyframes 规则：这个规则是可以将样式以动画方式（特定时间）逐渐地从当前样式修改为新的样式，当超过特定时间又恢复原来的样式</p><pre><code>#app{
    width: 100px;
    height: 100px;
    background-color: #000;
    animation-name: test;
    animation-duration: 6s;
    animation-delay: 3s;
    animation-iteration-count: infinite;
}
@keyframes test {
    from{
        background-color: #000;
    }
    to{
        background-color: #ccc;
    }
    
}
</code></pre><p>background-image</p><p>该属性可以添加背景，可以添加多张背景，例如：</p><pre><code>#app{
    background-image: url(1.jpg),url(2.jpg);
    background-position: left top,right bottom;
    background-repeat: no-repeat,repeat;
}
</code></pre><p>background-size</p><p>该属性可以指定背景的大小，例如：
#app{
background-image: url(1.jpg);
background-repeat: no-repeat;
background-size: 100px 100px;
}</p><p>background-origin</p><p>该属性可以指定背景的位置区域（外边框（border-box），内边框（padding-box），内容区（content-box）），例如：</p><pre><code> background-color: content-box;
</code></pre><p>background-clip</p><p>该属性可以将背景裁剪到指定位置（外边框（border-box），内边框（padding-box），内容区（content-box），例如：</p><pre><code> background-clip: content-box;
</code></pre><p>渐变分为线性渐变（直线）和径向渐变（中心）</p><p>线性渐变（默认从上到下）</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-image: linear-gradient(#ccc,#000);
}
</code></pre><p>从左到右</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-image: linear-gradient(to right ,#ccc,#000);
}
</code></pre><p>从左上角到右下角</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-image: linear-gradient(to right bottom ,#ccc,#000);
}
</code></pre><p>带角度的（不能指定方向）</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-image: linear-gradient(30deg,#ccc,#000);
}
</code></pre><p>带透明度的</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-image: linear-gradient(30deg,rgb(255,0,0,1),rgb(0,0,0,0));
}
</code></pre><p>带重复的</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-image: repeating-linear-gradient(#ccc, #fcfcfc 20%, #000 30%);
}
</code></pre><p>径向渐变</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-image: radial-gradient(#fff, #ccc, #000,#fc0000);
}
</code></pre><p>必须要有两个以上的颜色，第一个颜色在中间，依次往外排</p><p>同样可以设置每个颜色的占比</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-image: radial-gradient(#fff 10%, #ccc 20%, #000 30%,#fc0000 40%);
}
</code></pre><p>当元素是不正的，那么径向渐变默认就是椭圆的（ellipse），也可以指定为圆形的（circle）</p><pre><code>#app{
    width: 300px;
    height: 250px;
    background-image: radial-gradient(circle,#fff, #ccc, #000,#fc0000);
}
</code></pre><p>还提供了定义渐变大小的关键字，分别是closest-side，farthest-side，closest-corner，farthest-corner</p><p>当然也提供了可以重复渐变的，例如：</p><pre><code>#app{
    width: 300px;
    height: 250px;
    background-image: repeating-radial-gradient(circle,#000 20%, #fc0000 30% , yellow 50%);
}
</code></pre><p>文本阴影</p><pre><code>#app{
    text-shadow: 5px 5px 5px #000;
}
</code></pre><p>值分别为水平阴影，垂直阴影，模糊度，阴影颜色</p><p>元素盒子阴影</p><pre><code>#app{
    box-shadow: 5px 5px 5px #000;
}
</code></pre><p>容器文本溢出处理</p><pre><code>#app{
    text-overflow: ellipsis;
}
</code></pre><p>文本溢出默认为text-overflow: clip</p><p>自动强制文本换行（当单词或者某个文本太长，就会强制换行，避免文本溢出）</p><pre><code>#app{
    word-wrap: break-word;
}
</code></pre><p>@font-face 规则</p><p>该规则允许使用客户端没有的字体，例如：</p><pre><code>@font-face {
    font-family: hallo;
    src: url(&quot;hallo.ttf&quot;);
}

div{
     font-family: hallo;
}
</code></pre><p>必需属性font-family：字体名称</p><p>src：字体文件的url</p><p>在需要用字体的元素上font-family: 字体名称</p><p>过渡动画，会逐渐式加载样式，例如</p><pre><code>#app{
    width: 100px;
    height: 100px;
    background-color: #333;
    transition: height 3s,width 3s,transform 3s;
}

#app:hover{
    width: 300px;
    height: 300px;
    transform: rotate(360deg);
}
</code></pre><p>当鼠标移动到该元素上，那么会在3秒内逐渐转换为指定样式，移开鼠标那么又会逐渐恢复原来的样式</p><p>column-count 属性，该属性可以将元素中的文本分成指定列，例如</p><pre><code>#app{
    column-count: 3;
}
</code></pre><p>每个列之间的距离使用column-gap属性指定，例如</p><pre><code>#app{
    column-count: 3;
    column-gap: 20px;
}
</code></pre><p>column-rule-style属性可以指定每个列分隔的边框样式，例如下面样式为实线</p><pre><code>#app{
    column-count: 3;
    column-gap: 20px;
    column-rule-style: solid;
}
</code></pre><p>column-rule-width属性可以指定列的边框之间的宽度，例如</p><pre><code>#app{
    column-count: 3;
    column-gap: 20px;
    column-rule-style: solid;
    column-rule-width: 1px;
}
</code></pre><p>column-rule-color属性可以指定列的边框的颜色，例如：</p><pre><code>#app{
    column-count: 3;
    column-gap: 20px;
    column-rule-style: solid;
    column-rule-width: 6px;
    column-rule-color: #000;
}
</code></pre><p>当然列的边框的样式可以缩写，例如：</p><pre><code>#app{
    column-rule: 6px solid #000;
}
</code></pre><p>如果在父元素内，某个子元素不想被分列影响，直接指定子元素，例如</p><pre><code> div{
     column-span: all;
 }
</code></pre><p>column-width可以指定列的宽度，例如</p><pre><code> div{
     column-width: 300px;
 }
</code></pre><p>column-gap属性和column-width属性之间的区别，就是column-gap控制的是列与列之间的距离，而column-width控制的却是列本身的宽度</p><p>动画，可以指定时间，在指定时间内逐渐成另一种样式，可以指定动画的过程的样式，例如</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-color:#ccc;
    animation: hallo 5s;
}

@keyframes hallo{
    0%   {background-color: #ccc;}
    25%  {background-color: #fff;}
    50%  {background-color: #222;}
    75%  {background-color: #f3f3f3}
    100% {background-color: #777;}
}
</code></pre><p>0%为动画开始，100%为动画结束，当动画结束时样式会恢复原来定义的样式，除了用百分比表示进度，也可以用from（起点）和to（终点）表示</p><p>能修改颜色，当然也能修改位置，例如：</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-color:#ccc;
    animation: hallo 5s;
    position: relative;
}

@keyframes hallo{
    0%  {
        background-color: #ccc;
        top: 0px;
        left: 0px;
    }
    25% {
        background-color: #fff;
        top: 0px;
        left: 300px;
    }
    50% {
        background-color: #222;
        top: 300px;
        left: 300px;
    }
    75% {
        background-color: #f3f3f3;
        top: 300px;
        left: 0px;
    }
    100%{
        background-color: #777;
        top: 0px;
        left: 0px;
    }
}
</code></pre><p>二维改变样式</p><p>旋转（值为正数则顺时针转，值为负数则逆时针转）</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-color: #ccc;
    transform: rotate(60deg);
}
</code></pre><p>平移(根据x（左），y（上）轴决定)</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-color: #ccc;
    transform: translate(100px,100px);
}
</code></pre><p>放大或者缩小</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-color: #ccc;
    transform: scale(2,2);
}
</code></pre><p>宽度和高度是原来的2倍</p><p>倾斜(根据x（水平），y（垂直）轴决定，默认为0，值为负数则逆时针转)</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-color: #ccc;
    transform: skew(10deg,30deg);
}
</code></pre><p>同样也可以缩写为一个属性</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-color:#ccc;
    transform:matrix(0.6,1.5,-0.5,1.2,3,3);
}
</code></pre><p>这个6个值分别代表旋转，放大或者缩小，平移，倾斜</p><p>三维改变样式</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-color:#ccc;
    transform: rotateX(60deg);
}

#app{
    width: 300px;
    height: 300px;
    background-color:#ccc;
    transform: rotateY(60deg);
}

#app{
    width: 300px;
    height: 300px;
    background-color:#ccc;
    transform: rotateZ(60deg);
}
</code></pre><p>旋转元素的起始位置</p><pre><code>#app{
    width: 300px;
    height: 300px;
    background-color:#ccc;
    transform: rotate(60deg);
    transform-origin: 30% 60%;
}
</code></pre><p>拓展</p><pre><code>#app{
    width: 500px;
    height: 500px;
    perspective: 200;
    perspective-origin: 10% 20%;
    background-color: #000;
}

#app div{
    width: 300px;
    height: 300px;
    background-color:#ccc;
    transform: rotateX(60deg);
    transform-style: preserve-3d;
    backface-visibility: hidden;
}
</code></pre><p>backface-visibility属性用于指定背面是否显示</p><p>perspective-origin属性用于改变底部位置</p><p>perspective属性用于查看透视图（z只支持3D元素）</p><p>transform-style属性用于是否保留3d位置保留</p><hr><p>css强制换行，避免文本溢出容器</p><pre><code>white-space: pre-wrap;
</code></pre><p>normal：默认，空白被忽略</p><p>nowrap：文本不换行，文本在同一行继续</p><p>pre：保留空格，换行保留，不自动换行</p><p>pre-wrap：保留完整空格，保留换行符，自动换行</p><p>pre-line：保留空格（可能不完整），保留换行</p><hr><p>filter属性滤镜</p><p>该属性默认值为none</p><p>背景为黑白</p><pre><code>filter: grayscale(100%);
</code></pre><p>高斯模糊</p><pre><code>filter: blur(3px);
</code></pre><p>亮度</p><pre><code>filter: brightness(160%);
</code></pre><p>对比度</p><pre><code>filter: contrast(160%);
</code></pre><p>透明度</p><pre><code>filter: opacity(30%);
</code></pre><p>饱和度</p><pre><code>filter: saturate(300%);
</code></pre><p>阴影</p><pre><code>filter: drop-shadow(5px 5px 6px #ccc);
</code></pre><p>色相旋转</p><pre><code>filter: hue-rotate(30deg);
</code></pre><p>颠倒输入</p><pre><code>filter: invert(30%);
</code></pre><p>允许使用多个滤镜，多个滤镜有空格分开</p><hr><p>表格布局（现在很少用，一般都是用div+css）</p><p>该元素会作为块级表格（例如table标签，有换行）
display: table;</p><p>内联表格（没换行）
display: inline-table;</p><p>表格行（例如tr）
display: table-row;</p><p>表格单元格（例如td）
display: table-cell;</p><p>表格标题
display: table-caption;</p><p>单元格列
display: table-column;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://chenjunlinabc.github.io/tags/css/>css</a></li></ul><nav class=paginav><a class=prev href=https://chenjunlinabc.github.io/posts/12/><span class=title>« Prev</span><br><span>html5学习笔记</span></a>
<a class=next href=https://chenjunlinabc.github.io/posts/10/><span class=title>Next »</span><br><span>原生js实现瀑布流布局</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://chenjunlinabc.github.io/>小陈的个人博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>