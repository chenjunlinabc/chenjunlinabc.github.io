<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker容器的简单使用 | 知政的个人博客</title>
<meta name=keywords content="docker"><meta name=description content="docker是一个应用容器，可以将应用以及该应用的依赖打包到一个可以移植的容器中，应用在这个容器中运行
可以进行转移，修改，版本管理等操作，不用担心应用转移到别的服务器会出现依赖问题
将容器文件转移到别的服务器上，不会影响到容器，一次配置，可以在多个服务器上使用相同的环境
在以前，根本不可能实现或者保障一个服务器是运行多个应用，直到虚拟机的出现，虚拟机可以让空闲的服务器部署新的应用，但是虚拟机依赖于操作系统，操作系统又会占用CPU和内存，以及存储，而且虚拟机的移植性差启动缓慢，直到容器的出现
运行在相同的宿主机的容器是共享一个操作系统的，而且容器具备启动快，移植性强的特点（不用担心本地运行好好的，到生产环境就出一堆问题）
docker的多数项目和工具是使用golang编写的
Docker容器技术高度依赖于Linux内核，不管是在windwos或者Mac OS上都不是真正的容器化（只有在Linux系统上才能实现无虚拟化的真正容器化），都是在虚拟化Linux之后，在Linux虚拟机的基础上实现的
Docker三大件：镜像，容器，仓库
镜像被用来创建容器（而且镜像文件是复用，只可读的）
容器是镜像文件的实例，容器与容器之间是隔离的，容器可被启动，查看，暂停，退出，重启，删除
仓库是集中存储镜像文件的地方，Docker官方仓库：https://hub.docker.com/
Docker官网文档：https://docs.docker.com/
Docker是基于C/S架构（Client-Server）的系统，Docker的守护进程（Docker Daemon）运行在服务端上，客户端通过Docker Client和守护进程建立通信，守护进程可以接收客户端发送的指令并且可以管理服务端的容器
Docker Engine（引擎）会执行客户端发送的指令，来执行Docker内部的工作，每一项工作以Job的形式存在（一个job表示一个工作任务）
如果job（工作任务）需要镜像时，会从Docker Registry中下载获取镜像（如果本地存在则从本地获取，如果没有再从远程仓库获取）
当Docker容器需要创建网络环境时，通过Network driver创建并且配置Docker容器网络环境（通过网桥来暴露对外的端口和ip）
如果需要限制Docker容器运行资源或者执行用户指令时，通过Exec driver完成
网络的配置以及Exec driver的实现都是通过Libcontainer来实现的，Libcontainer是用来管理容器的包，该包基于go语言开发的，像创建容器，删除容器等等都可通过Libcontainer完成
安装docker（环境为ubuntu20.04）
如果之前安装过docker，需要先卸载
sudo apt remove docker docker-engine docker.io containerd runc
docker官方推荐使用docker的存储库来安装或者升级，而不是通过脚本或者通过下载deb软件的方式来安装
安装依赖
sudo apt install ca-certificates curl gnupg lsb-release
配置docker官方的GPG密钥
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg &ndash;dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
配置稳定Docker CE源
sudo add-apt-repository &ldquo;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable&rdquo;
安装docker引擎
sudo apt install docker-ce docker-ce-cli containerd."><meta name=author content="Me"><link rel=canonical href=https://99999.fun/posts/18/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css rel="preload stylesheet" as=style><link rel=icon href=https://99999.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://99999.fun/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://99999.fun/favicon.ico><link rel=apple-touch-icon href=https://99999.fun/favicon.ico><link rel=mask-icon href=https://99999.fun/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://99999.fun/posts/18/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Docker容器的简单使用"><meta property="og:description" content="docker是一个应用容器，可以将应用以及该应用的依赖打包到一个可以移植的容器中，应用在这个容器中运行
可以进行转移，修改，版本管理等操作，不用担心应用转移到别的服务器会出现依赖问题
将容器文件转移到别的服务器上，不会影响到容器，一次配置，可以在多个服务器上使用相同的环境
在以前，根本不可能实现或者保障一个服务器是运行多个应用，直到虚拟机的出现，虚拟机可以让空闲的服务器部署新的应用，但是虚拟机依赖于操作系统，操作系统又会占用CPU和内存，以及存储，而且虚拟机的移植性差启动缓慢，直到容器的出现
运行在相同的宿主机的容器是共享一个操作系统的，而且容器具备启动快，移植性强的特点（不用担心本地运行好好的，到生产环境就出一堆问题）
docker的多数项目和工具是使用golang编写的
Docker容器技术高度依赖于Linux内核，不管是在windwos或者Mac OS上都不是真正的容器化（只有在Linux系统上才能实现无虚拟化的真正容器化），都是在虚拟化Linux之后，在Linux虚拟机的基础上实现的
Docker三大件：镜像，容器，仓库
镜像被用来创建容器（而且镜像文件是复用，只可读的）
容器是镜像文件的实例，容器与容器之间是隔离的，容器可被启动，查看，暂停，退出，重启，删除
仓库是集中存储镜像文件的地方，Docker官方仓库：https://hub.docker.com/
Docker官网文档：https://docs.docker.com/
Docker是基于C/S架构（Client-Server）的系统，Docker的守护进程（Docker Daemon）运行在服务端上，客户端通过Docker Client和守护进程建立通信，守护进程可以接收客户端发送的指令并且可以管理服务端的容器
Docker Engine（引擎）会执行客户端发送的指令，来执行Docker内部的工作，每一项工作以Job的形式存在（一个job表示一个工作任务）
如果job（工作任务）需要镜像时，会从Docker Registry中下载获取镜像（如果本地存在则从本地获取，如果没有再从远程仓库获取）
当Docker容器需要创建网络环境时，通过Network driver创建并且配置Docker容器网络环境（通过网桥来暴露对外的端口和ip）
如果需要限制Docker容器运行资源或者执行用户指令时，通过Exec driver完成
网络的配置以及Exec driver的实现都是通过Libcontainer来实现的，Libcontainer是用来管理容器的包，该包基于go语言开发的，像创建容器，删除容器等等都可通过Libcontainer完成
安装docker（环境为ubuntu20.04）
如果之前安装过docker，需要先卸载
sudo apt remove docker docker-engine docker.io containerd runc
docker官方推荐使用docker的存储库来安装或者升级，而不是通过脚本或者通过下载deb软件的方式来安装
安装依赖
sudo apt install ca-certificates curl gnupg lsb-release
配置docker官方的GPG密钥
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg &ndash;dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
配置稳定Docker CE源
sudo add-apt-repository &ldquo;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable&rdquo;
安装docker引擎
sudo apt install docker-ce docker-ce-cli containerd."><meta property="og:type" content="article"><meta property="og:url" content="https://99999.fun/posts/18/"><meta property="og:image" content="https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-16T09:34:00+00:00"><meta property="article:modified_time" content="2021-06-16T09:34:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://99999.fun/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Docker容器的简单使用"><meta name=twitter:description content="docker是一个应用容器，可以将应用以及该应用的依赖打包到一个可以移植的容器中，应用在这个容器中运行
可以进行转移，修改，版本管理等操作，不用担心应用转移到别的服务器会出现依赖问题
将容器文件转移到别的服务器上，不会影响到容器，一次配置，可以在多个服务器上使用相同的环境
在以前，根本不可能实现或者保障一个服务器是运行多个应用，直到虚拟机的出现，虚拟机可以让空闲的服务器部署新的应用，但是虚拟机依赖于操作系统，操作系统又会占用CPU和内存，以及存储，而且虚拟机的移植性差启动缓慢，直到容器的出现
运行在相同的宿主机的容器是共享一个操作系统的，而且容器具备启动快，移植性强的特点（不用担心本地运行好好的，到生产环境就出一堆问题）
docker的多数项目和工具是使用golang编写的
Docker容器技术高度依赖于Linux内核，不管是在windwos或者Mac OS上都不是真正的容器化（只有在Linux系统上才能实现无虚拟化的真正容器化），都是在虚拟化Linux之后，在Linux虚拟机的基础上实现的
Docker三大件：镜像，容器，仓库
镜像被用来创建容器（而且镜像文件是复用，只可读的）
容器是镜像文件的实例，容器与容器之间是隔离的，容器可被启动，查看，暂停，退出，重启，删除
仓库是集中存储镜像文件的地方，Docker官方仓库：https://hub.docker.com/
Docker官网文档：https://docs.docker.com/
Docker是基于C/S架构（Client-Server）的系统，Docker的守护进程（Docker Daemon）运行在服务端上，客户端通过Docker Client和守护进程建立通信，守护进程可以接收客户端发送的指令并且可以管理服务端的容器
Docker Engine（引擎）会执行客户端发送的指令，来执行Docker内部的工作，每一项工作以Job的形式存在（一个job表示一个工作任务）
如果job（工作任务）需要镜像时，会从Docker Registry中下载获取镜像（如果本地存在则从本地获取，如果没有再从远程仓库获取）
当Docker容器需要创建网络环境时，通过Network driver创建并且配置Docker容器网络环境（通过网桥来暴露对外的端口和ip）
如果需要限制Docker容器运行资源或者执行用户指令时，通过Exec driver完成
网络的配置以及Exec driver的实现都是通过Libcontainer来实现的，Libcontainer是用来管理容器的包，该包基于go语言开发的，像创建容器，删除容器等等都可通过Libcontainer完成
安装docker（环境为ubuntu20.04）
如果之前安装过docker，需要先卸载
sudo apt remove docker docker-engine docker.io containerd runc
docker官方推荐使用docker的存储库来安装或者升级，而不是通过脚本或者通过下载deb软件的方式来安装
安装依赖
sudo apt install ca-certificates curl gnupg lsb-release
配置docker官方的GPG密钥
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg &ndash;dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
配置稳定Docker CE源
sudo add-apt-repository &ldquo;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable&rdquo;
安装docker引擎
sudo apt install docker-ce docker-ce-cli containerd."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://99999.fun/posts/"},{"@type":"ListItem","position":2,"name":"Docker容器的简单使用","item":"https://99999.fun/posts/18/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker容器的简单使用","name":"Docker容器的简单使用","description":"docker是一个应用容器，可以将应用以及该应用的依赖打包到一个可以移植的容器中，应用在这个容器中运行\n可以进行转移，修改，版本管理等操作，不用担心应用转移到别的服务器会出现依赖问题\n将容器文件转移到别的服务器上，不会影响到容器，一次配置，可以在多个服务器上使用相同的环境\n在以前，根本不可能实现或者保障一个服务器是运行多个应用，直到虚拟机的出现，虚拟机可以让空闲的服务器部署新的应用，但是虚拟机依赖于操作系统，操作系统又会占用CPU和内存，以及存储，而且虚拟机的移植性差启动缓慢，直到容器的出现\n运行在相同的宿主机的容器是共享一个操作系统的，而且容器具备启动快，移植性强的特点（不用担心本地运行好好的，到生产环境就出一堆问题）\ndocker的多数项目和工具是使用golang编写的\nDocker容器技术高度依赖于Linux内核，不管是在windwos或者Mac OS上都不是真正的容器化（只有在Linux系统上才能实现无虚拟化的真正容器化），都是在虚拟化Linux之后，在Linux虚拟机的基础上实现的\nDocker三大件：镜像，容器，仓库\n镜像被用来创建容器（而且镜像文件是复用，只可读的）\n容器是镜像文件的实例，容器与容器之间是隔离的，容器可被启动，查看，暂停，退出，重启，删除\n仓库是集中存储镜像文件的地方，Docker官方仓库：https://hub.docker.com/\nDocker官网文档：https://docs.docker.com/\nDocker是基于C/S架构（Client-Server）的系统，Docker的守护进程（Docker Daemon）运行在服务端上，客户端通过Docker Client和守护进程建立通信，守护进程可以接收客户端发送的指令并且可以管理服务端的容器\nDocker Engine（引擎）会执行客户端发送的指令，来执行Docker内部的工作，每一项工作以Job的形式存在（一个job表示一个工作任务）\n如果job（工作任务）需要镜像时，会从Docker Registry中下载获取镜像（如果本地存在则从本地获取，如果没有再从远程仓库获取）\n当Docker容器需要创建网络环境时，通过Network driver创建并且配置Docker容器网络环境（通过网桥来暴露对外的端口和ip）\n如果需要限制Docker容器运行资源或者执行用户指令时，通过Exec driver完成\n网络的配置以及Exec driver的实现都是通过Libcontainer来实现的，Libcontainer是用来管理容器的包，该包基于go语言开发的，像创建容器，删除容器等等都可通过Libcontainer完成\n安装docker（环境为ubuntu20.04）\n如果之前安装过docker，需要先卸载\nsudo apt remove docker docker-engine docker.io containerd runc\ndocker官方推荐使用docker的存储库来安装或者升级，而不是通过脚本或者通过下载deb软件的方式来安装\n安装依赖\nsudo apt install ca-certificates curl gnupg lsb-release\n配置docker官方的GPG密钥\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg \u0026ndash;dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\n配置稳定Docker CE源\nsudo add-apt-repository \u0026ldquo;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable\u0026rdquo;\n安装docker引擎\nsudo apt install docker-ce docker-ce-cli containerd.","keywords":["docker"],"articleBody":"docker是一个应用容器，可以将应用以及该应用的依赖打包到一个可以移植的容器中，应用在这个容器中运行\n可以进行转移，修改，版本管理等操作，不用担心应用转移到别的服务器会出现依赖问题\n将容器文件转移到别的服务器上，不会影响到容器，一次配置，可以在多个服务器上使用相同的环境\n在以前，根本不可能实现或者保障一个服务器是运行多个应用，直到虚拟机的出现，虚拟机可以让空闲的服务器部署新的应用，但是虚拟机依赖于操作系统，操作系统又会占用CPU和内存，以及存储，而且虚拟机的移植性差启动缓慢，直到容器的出现\n运行在相同的宿主机的容器是共享一个操作系统的，而且容器具备启动快，移植性强的特点（不用担心本地运行好好的，到生产环境就出一堆问题）\ndocker的多数项目和工具是使用golang编写的\nDocker容器技术高度依赖于Linux内核，不管是在windwos或者Mac OS上都不是真正的容器化（只有在Linux系统上才能实现无虚拟化的真正容器化），都是在虚拟化Linux之后，在Linux虚拟机的基础上实现的\nDocker三大件：镜像，容器，仓库\n镜像被用来创建容器（而且镜像文件是复用，只可读的）\n容器是镜像文件的实例，容器与容器之间是隔离的，容器可被启动，查看，暂停，退出，重启，删除\n仓库是集中存储镜像文件的地方，Docker官方仓库：https://hub.docker.com/\nDocker官网文档：https://docs.docker.com/\nDocker是基于C/S架构（Client-Server）的系统，Docker的守护进程（Docker Daemon）运行在服务端上，客户端通过Docker Client和守护进程建立通信，守护进程可以接收客户端发送的指令并且可以管理服务端的容器\nDocker Engine（引擎）会执行客户端发送的指令，来执行Docker内部的工作，每一项工作以Job的形式存在（一个job表示一个工作任务）\n如果job（工作任务）需要镜像时，会从Docker Registry中下载获取镜像（如果本地存在则从本地获取，如果没有再从远程仓库获取）\n当Docker容器需要创建网络环境时，通过Network driver创建并且配置Docker容器网络环境（通过网桥来暴露对外的端口和ip）\n如果需要限制Docker容器运行资源或者执行用户指令时，通过Exec driver完成\n网络的配置以及Exec driver的实现都是通过Libcontainer来实现的，Libcontainer是用来管理容器的包，该包基于go语言开发的，像创建容器，删除容器等等都可通过Libcontainer完成\n安装docker（环境为ubuntu20.04）\n如果之前安装过docker，需要先卸载\nsudo apt remove docker docker-engine docker.io containerd runc\ndocker官方推荐使用docker的存储库来安装或者升级，而不是通过脚本或者通过下载deb软件的方式来安装\n安装依赖\nsudo apt install ca-certificates curl gnupg lsb-release\n配置docker官方的GPG密钥\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg –dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\n配置稳定Docker CE源\nsudo add-apt-repository “deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian $(lsb_release -cs) stable”\n安装docker引擎\nsudo apt install docker-ce docker-ce-cli containerd.io\n或者直接使用docker官方提供的sh脚本\ncurl -s https://get.docker.com | sh （不推荐使用）\n如果需要安装指定版本的docker，可指定docker-ce和docker-ce-cli的版本\n查看源仓库中可安装的docker的版本\napt-cache madison docker-ce\n启动docker服务\nservice docker start\n关闭docker服务\nservice docker stop\n重启docker服务\nservice docker restart\n检查是否安装成功（创建一个测试容器，并且执行该容器，该容器会返回信息并且退出）\nsudo docker run hello-world\n或者docker version\n查看所有镜像\ndocker image ls或者docker images\n查看所有容器\ndocker ps\ndocker ps -a # 输出所有容器（包括未运行的）\ndocker ps -q # 只输出容器id\ndocker ps -a -q # 输出所有容器id\ndocker ps -n 5 # 输出最近创建的5个容器\ndocker ps -l # 显示最近创建的容器\nREPOSITORY：镜像名称，TAG：镜像的标签（一般为该镜像的版本号），IMAGE ID：镜像id，CREATED：镜像创建时间，SIZE：镜像大小\n镜像id实质上为该镜像的sha256\n注意：如果不指定版本，将默认使用latest版本的镜像\ndocker system df # 查看Docker的磁盘使用情况\ndocker stop 容器id（或者容器名都可以） -f # 关闭指定容器，-f为强制删除\ndocker stop $(docker ps -a -q) # 关闭所有容器\n删除指定容器\ndocker image rm 容器名称 # 例如 docker image rm centos\ndocker rmi 容器id # 删除指定镜像\ndocker rmi $(docker images -a -q) # 删除所有镜像\n查看所有正在运行的容器\ndocker container ls或者docker ps\n查看所有的容器（包括已经停止运行的）\ndocker container ls –all\n运行指定容器\ndocker container run 镜像名\n或者\ndocker run 镜像名\n启动容器\ndocker start 容器ID或者容器名\n重启容器\ndocker restart 容器ID或者容器名\n停止容器\ndocker stop 容器ID或者容器名\n强制停止运行容器\ndocker kill 容器ID或者容器名\n删除已经停止运行的容器\ndocker rm 容器ID\n注意：rm是删除容器，rmi是删除镜像\ndocker exec -it 容器ID bash # 在容器中打开新终端，并且启动新的进程，在这个情况下使用exit退出不会导致容器的暂停，而attach会导致容器的暂停，推荐使用exec\ndocker attach 容器ID # 直接进入容器启动命令的终端，不启动新的进程\ndocker run -it ubuntu /bin/bash # i表示以交互模式运行容器，t为给容器创建一个伪终端（搭配使用就是交互式容器）\ndocker run –name=“容器的新名称” 镜像名 # 为容器指定新名称，如果不指定，容器名称默认为镜像名\ndocker run -d 镜像名 # 后台运行容器并且返回容器id（以守护进程的方式后台运行容器）\ndocker run -p 80:8080 镜像名 # 运行并且映射指定容器的80端口到物理机的8080端口\ndocker run -P 镜像名 # 随机端口映射，不常用\n获取容器（从镜像源（docker hub）中下载到本地，docker提供大量已经配置好的容器，可以直接下载使用，修改）\ndocker image pull 镜像名 # 拉取某个镜像\ndocker search 镜像名 # 搜索查找某个镜像\nNAME：容器仓库名称，DESCRIPTION：容器描述，STARS：类似github的star，关注，喜欢 OFFICIAL：是否为官方，AUTOMATED：是否为自动构建\ndocker cp 容器id:容器内部的路径 目标主机的路径 # 将容器的文件备份（拷贝）到主机中\n导出导入容器（备份容器）\ndocker export 容器id \u003e 文件x.tar # 导出容器\ncar 文件x.tar | docker import - 镜像用户/镜像名:镜像版本号 # 导入容器\n修改容器源\n国内容器源\nhttp://hub-mirror.c.163.com # 网易云\nhttps://docker.mirrors.ustc.edu.cn # 中国科技大学\nhttps://mirror.ccs.tencentyun.com # 腾讯云\ndocker run hello-world –registry-mirror=https://mirror.ccs.tencentyun.com 容器名 # 只对当前指令起作用\n找到/etc/default/docker 插入\nDOCKER_OPTS=\"–registry-mirror=https://mirror.ccs.tencentyun.com\"\n或者\n找到/etc/docker/daemon.json，插入\n{“registry-mirrors”: [“https://mirror.ccs.tencentyun.com”]} # 可以插入多个源\n然后重启服务\n如果dockerhub满足不了，可以在hub已存在的容器中进行修改（安装，卸载…）\n或者使用Dockerfile，从零开始构建容器\nmkdir hallo \u0026\u0026 cd hallo # 新建一个文件夹，并且进入这个文件夹\nnano Dockerfile # 新建个文件，并且修改它\nFROM ubuntu:18.04 RUN apt -y update \u0026\u0026 apt install -y nginx \u0026\u0026 apt install -y mariadb-server \u0026\u0026 apt install -y php*\nFROM：基础镜像,操作都是基于这个基础镜像，RUM：执行指定指令（shell）\n其他参数，MAINTAINER：容器创建者，CMD：当容器启动时执行命令，只能有一条CMD命令，多条执行最后一条，容器run命令会覆盖cmd命令\nENTRYPOINT：当容器启动时执行命令，不可覆盖\nUSER：指定哪个用户来启动容器\nEXPOSE：容器内部开启端口，一般用于容器端口映射到主机端口上\nENV：环境变量\nADD：复制或者下载到容器，请确保本地或者docker仓库中有需要add的文件，例如：\nADD 文件路径（或者url） 目标容器的绝对路径\nVOLUME：切换目录用，类似cd\n打包容器\ndocker build -t 容器名 .\n这个“.”表示为当前路径\n如果正在运行docker，想退出可以使用ctrl+D，例如\n在centos中体验Ubuntu系统\n例如docker container run -it ubuntu bash\n如果想退出docker，可以在docker（run进去的容器）中输入exit\n如果想docker中的容器不停止， 快捷键 ctrl+p+q\n推送本地容器到docker仓库中\n首先需要一个docker仓库账号，例如https://hub.docker.com/或者https://cr.console.aliyun.com/cn-hangzhou/new # 阿里容器镜像服务，\ndocker login -u 账号 -p 密码 # 登录DockerHub账号\ndocker push hallo_word:yes\ndocker pull会默认推送带有latest标签的容器到本地，所以推荐把容器标签修改为latest，或者直接指定要推送哪个容器，精确到标签\ndocker tag hallo_word:yes hallo_word:latest\n推送到第三方仓库（例如：阿里容器镜像服务）\ndocker pull registry.cn-hangzhou.aliyuncs.com/xxx/xxx:latest # 推送容器到本地\ndocker login –username=xxx@qq.com registry.cn-hangzhou.aliyuncs.com # 登录的用户名为阿里云账号全名，密码为开通服务时设置的密码，如果是私有仓库，那么需要推送容器到本地之前执行，推送容器到本地之后再执行一次\ndocker tag 容器id registry.cn-hangzhou.aliyuncs.com/xxx/xxx:latest # 推送到阿里容器仓库\n端口映射（实质上并不是docker容器技术实现的，是利用了iptables）\ndocker配置文件hostconfig.json\ndocker run -d -p 8000:80 ubuntu // 将容器的8000端口映射到宿主机上的80端口\ndocker为啥比虚拟机性能好\ndocker不需要硬件资源的虚拟化，docker的容器的软件是可以直接使用物理机的硬件资源的（更好的利用硬件资源），而且docker是直接调用的宿主机的内核，不需要重新加载操作系统的OS内核（减少不必要的浪费）\n虚悬镜像（dangling image）：指的是仓库名，标签都是的镜像，一般出现在删除镜像出错时\n查找虚悬镜像\ndocker image ls -f dangling=true\n删除虚悬镜像\ndocker image prune #删除所有dangling image\n镜像是一种独立，可执行，轻量级的软件包，包含某个软件需要的所有内容，这个镜像包含应用程序，应用的配置依赖，这个镜像实质上就是一个可交付的运行环境\n镜像分层系统实现依赖于UnionFS\nUnionFS（联合文件系统）：是一种分层，轻量级的高性能文件系统，支持对文件系统的修改作为一次提交来一层一层的叠加，并且将不同的目录挂载到同一个虚拟文件系统下\n镜像可通过分层来基于基础镜像来制造各种应用镜像\nDocker镜像加载原理：通过UnionFS来一层一层组成，bootfs（boot file system）加载和引导内核，当boot加载完毕，内存使用权从bootfs转交到内核，系统卸载bootfs\nrootfs（root file system）就是操作系统，包含Linux系统中标准的/bin，/etc等目录\nDocker镜像为啥这么小的原因就是镜像只包含bootfs和rootfs，复用宿主机的内核\n镜像分层的好处：可复用，方便共享（复制迁移）资源，镜像的每一层都可以被共享，可复用\n镜像层是只读，容器层是可写的，当一个容器被启动，一个可写层被加载到镜像的顶部时，那么这一层被叫为容器层，容器层之下的都被叫为镜像层\ncommit命令提交副本来创建新镜像\ndocker commit -m=“注释” -a=“作者” 容器id 用户/镜像名:镜像版本号\n搭建私有仓库\ndocker私有仓库（Docker Registry）\nDocker Registry是docker提供的镜像，专门用来构建docker私有仓库\ndocker pull registry # 拉取Registry镜像\ndocker run -d -p 5000:5000 -v /test/registry/:/tmp/registry – privileged=true registry\n默认情况下，仓库被创建在容器的/var/lib/registry目录下（当然也可以通过容器卷来映射）\ndocker tag ubuntu 192.168.1.110:5000/ubuntu # 修改tag为符合私有仓库的规范\n这个私有仓库默认不支持http推送，需要修改/etc/docker/daemon.json\n“insecure-registries”: [“192.168.1.110:5000”]\n如果不生效，请重启docker服务\n推送镜像到私有仓库\ndocker push 192.168.1.110:5000/ubuntu\n查看私有仓库存储的镜像\ncurl -XGET http://192.168.1.110:5000/v2/_catalog\n获取私有仓库镜像到本地\ndocker pull 192.168.1.110:5000/ubuntu\n容器数据卷\n-v参数为启动自定义容器数据卷\n比如说docker run -d -p 5000:5000 -v /test/registry/:/tmp/registry – privileged=true registry\n/test/registry/为宿主机路径，/tmp/registry为容器内部路径，– privileged=true为开启privileged，（开启privileged后，容器内部的root才拥有真正的root权限，否则容器的root只是普通用户权限）\n容器数据卷用于数据的持久化（独立于容器的生命周期），可绕过联合文件系统来达到持续存在或者共享数据的目的，docker不会在删除容器时，删除容器挂载的数据卷，数据卷指定容器内部路径，任何在该路径存储的数据，都会被映射到宿主机指定的那个目录下\n在数据卷中的任何更改都不会认为是镜像的更新，而且数据卷中的更改是实时生效的（不需要重启容器之类的，哪怕容器没有启动），数据卷的生命周期长（可持续到没有容器使用它为止）\n数据卷被用于容器和宿主机之间的互通互联，在宿主机中更新的文件，会实时在容器中生效\ndocker inspect 镜像名或者镜像id # 获取容器/镜像的元数据\n数据卷在该镜像的元数据的Mounts属性中找到\n数据卷默认可读可写（rw），可通过ro来限制容器内部只能读，不能写\n默认情况下\ndocker run -d -p 5000:5000 -v /test/registry/:/tmp/registry:rw – privileged=true registry\n因为rw是默认的，可以省略不写\n限制容器只能读取数据卷，不能写（ro，read only）\ndocker run -d -p 5000:5000 -v /test/registry/:/tmp/registry:ro – privileged=true registry\n数据卷的继承（–volumes-from）\ndocker run -it – privileged=true –volumes-from 容器1 –name 容器2 registry\n容器2继承容器1的数据卷规则（哪怕容器1被删除了或者停止运行了，依然不会影响到容器2的数据卷）\ndocker network\ndocker network可用于容器之间的互联以及通信（端口映射），可通过服务名来直接通信（不受IP变动而影响）\ndocker会默认创建一个叫docker0的虚拟网桥（bridge网络模式）\ndocker0网桥会在内核层连通其他网络网卡和虚拟网卡，实现所有的容器和本地主机的网络连接（同一个物理网络）\ndocker会默认创建三个网络模式，分别为bridge（默认），host，none\n可通过docker network ls命令查看\n创建网络\ndocker network create hallo\n删除网络\ndocker network rm hallo\n查看网络的详细信息\ndocker network inspect bridge\nbridge网络模式：为容器分配和设置IP，并且将容器分配到docker0网桥（如果不指定-network，创建的容器默认在该模式上）（–network bridge，可忽略）\nhost网络模式：容器不会虚拟网卡，而是直接使用宿主机的ip和端口和外界通信（不需要额外进行NAT转换，没有独立的Network namespace，而是和宿主机共用一个Network namespace）（–network host）\nnone网络模式：该模式的容器有自己的独立网络规则（Network namespace），但是没有进行配置，需要手动配置docker容器网络（发挥网络定制功能，没有虚拟网卡，没有IP等等网络信息），在该模式下只有一个127.0.0.1的本地网络回环接口（lo）（–network none）\ncontainer网络模式：该模式下的容器不会配置自己的IP，而是和指定的容器共享IP和端口范围（网络共用，文件和进程隔离）（–network container:指定容器名或者容器ID）\n自定义网络模式（可通过服务名（容器名/主机名）来通信，docker network create hallo）\ndocker-compose容器编排\ndocker-Compose是Docker官方提供的Docker容器集群快速编排工具，用于管理多个docker容器组成的应用，通过docker-compose.yml配置文件来管理多个容器之间的调用关系\n官方文档https://docs.docker.com/compose/\n下载文档：https://docs.docker.com/compose/install/\n下载docker-Compose sudo curl -L “https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)” -o /usr/local/bin/docker-compose\n添加写的权限 sudo chmod +x /usr/local/bin/docker-compose\n测试是否安装完成 docker-compose –version\n构建并且启动容器（执行docker-compose.yml配置文件）（加参数-d为启动服务并且后台运行） docker-compose up\n构建或者重新构建服务 docker-compose build\n删除指定服务的容器 docker-compose rm 容器名\n停止并且删除容器，镜像，网络，卷 docker-compose down\n进入容器 docker-compose exec 服务id\n查看当前docker-compose编排的全部容器 docker-compose top\n查看当前docker-compose编排的容器进程 docker-compose ps\n停止docker-compose服务 docker-compose stop\n启动docker-compose服务 docker-compose start\n重启docker-compose服务 docker-compose restart\n检查配置文件（-q参数表示当配置文件出现问题时才输出信息） docker-compose config\n容器的7种状态：\ncreated（已创建） restarting（重启中） running或up（运行中） removing（迁移中） paused（暂停） exited（停止） dead（死亡）\ndocker-compose.yml配置文件\nversion: \"3.9\"\rservices:\rweb:\rbuild:\rcontext: . dockerfile: Dockerfile_test\rports:\r- \"5000:5000\"\rvolumes:\r- /app/test:/data/app\rlinks:\r- redis\rnetworks:\r- hallo_net\rredis:\rimage: redis\rcommand: redis-server /etc/redis/redis.conf\rnetworks:\rhallo_net:\rversion字段为版本号（具体支持的版本和docker-compose安装的版本有关，具体看实质版本），services字端表示服务容器，services字端下面的服务名的image字段为从指定镜像中启动容器（镜像可本地，可仓库或者镜像ID），ports字段为端口映射，networks字段为指定网络模式，volumes字段为容器数据卷\n外面那个networks字段将会创建hallo_net自定义网络模式，处理基于指定镜像外，还可以基于Dockerfile，build字段下的dockerfile字段就是指定Dockerfile文件所在的路径，context字段为构建的路径，links字段为链接到指定服务中的容器\n一般都是通过Dockerfile自动化构建镜像，然后基于这个镜像使用docker-compose管理容器\nPortainer可视化工具\nPortainer是一个Docker轻量级的可视化工具（Portainer官网，https://www.portainer.io，官网文档：https://docs.portainer.io/v/ce-2.11/start/install/server/docker/linux）\n可直接pull Portainer的镜像来安装\ndocker pull portainer/portainer\ndocker run -d -p 8000:8000 -p 9443:9443 --name portainer \\\r--restart=always \\\r-v /var/run/docker.sock:/var/run/docker.sock \\\r-v portainer_data:/data \\\rportainer/portainer-ce:2.11.1\r启动完毕后，访问1192.168.1.110:9443/，进行设置admin用户和密码\n如果是监控本地的docker，选择local\nCAdvisor+InfluxDB+Granfana(CIG重量级容器监控)\ndocker依赖多种namespace来进行隔离（例如User Namespace，容器用户和宿主用户隔离，process id Namespace，隔离进程id，network Namespace，隔离网络设备，端口号，mount Namespace，隔离挂载等等），依赖于cgroup进行资源管理和控制（例如cpu，内存），namespace和cgroup都由自Linux内核提供\ndocker使用了6种namespace，分别是，mount namespace，uts namespace，ipc namespace，network namespace，pid namespace，user namespace\nmount Namespace：隔离不同进程的挂载数据，保证容器的挂载操作不会影响到宿主的挂载\nsudo unshare –mount –fork /bin/bash # 创建一个mount Namespace，使用/bin/bash进程，在该挂载任何文件，都不会作用于宿主\npid namespace是隔离进程的pid的，也就是说宿主是看不到容器的应用pid，容器也看不到宿主的pid\nsudo unshare –pid –fork –mount-proc /bin/bash\n安全容器：容器运行在虚拟机中，具备虚拟机的安全隔离性，例如kata Container，使用guest kernel（精简了内核，专门提供给容器运行，减低资源的消耗）\n因为docker容器共享宿主内核，存在安全性，所以可使用安全容器来隔离宿主内核，安全容器的内核是完全独立于宿主的内核（虚拟化技术）\ndocker容器资源限制\ndocker run -it –cpus=4 -m=8192 –pids-limit=1000 ubuntu /bin/bash # 启动ubuntu镜像，使用/bin/bash作为终端，资源被设置为4核8g，并且只能创建1000个pid\ndocker stats ubuntu # 查看容器的资源使用情况\ncAdvisor是谷歌开源的容器监控工具，不但可以监控容器的资源使用情况，还可以监控宿主的资源使用情况，可查看容器的历史资源使用情况\ndocker run \\\r--volume=/:/rootfs:ro \\\r--volume=/var/run:/var/run:ro \\\r--volume=/sys:/sys:ro \\\r--volume=/var/lib/docker/:/var/lib/docker:ro \\\r--volume=/dev/disk/:/dev/disk:ro \\\r--publish=8080:8080 \\\r--detach=true \\\r--name=cadvisor \\\r--privileged \\\r--device=/dev/kmsg \\\rgcr.io/cadvisor/cadvisor:$VERSION\r访问http://localhost:8080\n容器的资源限制通过/sys/fs/cgroup/memory/docker下的，目录名为容器id，其中memory.limit_in_bytes是该容器的内存限制文件，memory.usage_in_bytes是该容器的内存使用情况，proc/容器的pid/net/dev是该容器的网络使用情况，cpuset.cpus是cpu限制使用核数，cpu.cfs_period_us是一个cpu核心的带宽（单位微秒，容器的cpu总带宽=cpu核心数*单个cpu核心的带宽），cpu.cfs_quota_us是可使用cpu带宽（单位微秒，-1为不限制）\n容器监控工具实质上是通过读取和记录宿主的文件来显示容器资源情况的，所以启动容器监控工具，要映射数据卷/sys:到容器中\nkubernetes简称k8s，用来自动化容器的部署，监控，容器负载均衡等等\nmaster是容器集群的控制系统，可以用来监控容器的状态，调度负载均衡\nnode是k8s的工作节点，可以接收master的指令，根据指令来创建和销毁Pod等等\nPod是容器的容器，可以包含多个容器，是k8s中最小的可部署单元，pod内部的网络是互通的，每一个pod都有自己的虚拟ip\nk8s将弃用dockershim（dockershim是k8s内置的一个组件，该组件可让k8s能够通过CRI（Container Runtime Interface）来操作docker）\n安装docker\n配置docker\n添加docker官方GPGkey\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\nsudo apt-key fingerprint 0EBFCD88\n安装依赖\nsudo apt install apt-transport-https ca-certificates curl software-properties-common\n设置docker仓库\nsudo add-apt-repository “deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable”\n重新加载源\nsudo apt update\n如果报错，可以手动在/etc/apt/source.list添加\ndeb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable\nsudo apt dist-upgrade（智能处理包依赖，会自己安装新软件或者删除原有软件包来完成升级）\n安装docker\nsudo apt install docker-ce docker-ce-cli containerd.io\n","wordCount":"891","inLanguage":"en","datePublished":"2021-06-16T09:34:00Z","dateModified":"2021-06-16T09:34:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://99999.fun/posts/18/"},"publisher":{"@type":"Organization","name":"知政的个人博客","logo":{"@type":"ImageObject","url":"https://99999.fun/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://99999.fun/ accesskey=h title="知政的个人博客 (Alt + H)"><img src=https://99999.fun/favicon.ico alt aria-label=logo height=35>知政的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://99999.fun/ title=首页><span>首页</span></a></li><li><a href=https://99999.fun/categories/ title=分类><span>分类</span></a></li><li><a href=https://99999.fun/archives/ title=归档><span>归档</span></a></li><li><a href=https://99999.fun/tags/ title=标签><span>标签</span></a></li><li><a href=https://99999.fun/links/ title=链接><span>链接</span></a></li><li><a href=https://99999.fun/about/ title=关于><span>关于</span></a></li><li><a href=https://99999.fun/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://99999.fun/>Home</a>&nbsp;»&nbsp;<a href=https://99999.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Docker容器的简单使用</h1><div class=post-meta><span title='2021-06-16 09:34:00 +0000 UTC'>2021-06-16</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://99999.fun//posts/Docker%e5%ae%b9%e5%99%a8%e7%9a%84%e7%ae%80%e5%8d%95%e4%bd%bf%e7%94%a8.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>docker是一个应用容器，可以将应用以及该应用的依赖打包到一个可以移植的容器中，应用在这个容器中运行</p><p>可以进行转移，修改，版本管理等操作，不用担心应用转移到别的服务器会出现依赖问题</p><p>将容器文件转移到别的服务器上，不会影响到容器，一次配置，可以在多个服务器上使用相同的环境</p><p>在以前，根本不可能实现或者保障一个服务器是运行多个应用，直到虚拟机的出现，虚拟机可以让空闲的服务器部署新的应用，但是虚拟机依赖于操作系统，操作系统又会占用CPU和内存，以及存储，而且虚拟机的移植性差启动缓慢，直到容器的出现</p><p>运行在相同的宿主机的容器是共享一个操作系统的，而且容器具备启动快，移植性强的特点（不用担心本地运行好好的，到生产环境就出一堆问题）</p><p>docker的多数项目和工具是使用golang编写的</p><p>Docker容器技术高度依赖于Linux内核，不管是在windwos或者Mac OS上都不是真正的容器化（只有在Linux系统上才能实现无虚拟化的真正容器化），都是在虚拟化Linux之后，在Linux虚拟机的基础上实现的</p><p>Docker三大件：镜像，容器，仓库</p><p>镜像被用来创建容器（而且镜像文件是复用，只可读的）</p><p>容器是镜像文件的实例，容器与容器之间是隔离的，容器可被启动，查看，暂停，退出，重启，删除</p><p>仓库是集中存储镜像文件的地方，Docker官方仓库：https://hub.docker.com/</p><p>Docker官网文档：https://docs.docker.com/</p><p>Docker是基于C/S架构（Client-Server）的系统，Docker的守护进程（Docker Daemon）运行在服务端上，客户端通过Docker Client和守护进程建立通信，守护进程可以接收客户端发送的指令并且可以管理服务端的容器</p><p>Docker Engine（引擎）会执行客户端发送的指令，来执行Docker内部的工作，每一项工作以Job的形式存在（一个job表示一个工作任务）</p><p>如果job（工作任务）需要镜像时，会从Docker Registry中下载获取镜像（如果本地存在则从本地获取，如果没有再从远程仓库获取）</p><p>当Docker容器需要创建网络环境时，通过Network driver创建并且配置Docker容器网络环境（通过网桥来暴露对外的端口和ip）</p><p>如果需要限制Docker容器运行资源或者执行用户指令时，通过Exec driver完成</p><p>网络的配置以及Exec driver的实现都是通过Libcontainer来实现的，Libcontainer是用来管理容器的包，该包基于go语言开发的，像创建容器，删除容器等等都可通过Libcontainer完成</p><p>安装docker（环境为ubuntu20.04）</p><p>如果之前安装过docker，需要先卸载</p><p>sudo apt remove docker docker-engine docker.io containerd runc</p><p>docker官方推荐使用docker的存储库来安装或者升级，而不是通过脚本或者通过下载deb软件的方式来安装</p><p>安装依赖</p><p>sudo apt install ca-certificates curl gnupg lsb-release</p><p>配置docker官方的GPG密钥</p><p>curl -fsSL <a href=https://download.docker.com/linux/ubuntu/gpg>https://download.docker.com/linux/ubuntu/gpg</a> | sudo gpg &ndash;dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</p><p>配置稳定Docker CE源</p><p>sudo add-apt-repository<br>&ldquo;deb [arch=amd64] <a href=https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian>https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian</a><br>$(lsb_release -cs)<br>stable&rdquo;</p><p>安装docker引擎</p><p>sudo apt install docker-ce docker-ce-cli containerd.io</p><p>或者直接使用docker官方提供的sh脚本</p><p>curl -s <a href=https://get.docker.com>https://get.docker.com</a> | sh （不推荐使用）</p><p>如果需要安装指定版本的docker，可指定docker-ce和docker-ce-cli的版本</p><p>查看源仓库中可安装的docker的版本</p><p>apt-cache madison docker-ce</p><p>启动docker服务</p><p>service docker start</p><p>关闭docker服务</p><p>service docker stop</p><p>重启docker服务</p><p>service docker restart</p><p>检查是否安装成功（创建一个测试容器，并且执行该容器，该容器会返回信息并且退出）</p><p>sudo docker run hello-world</p><p>或者docker version</p><p>查看所有镜像</p><p>docker image ls或者docker images</p><p>查看所有容器</p><p>docker ps</p><p>docker ps -a # 输出所有容器（包括未运行的）</p><p>docker ps -q # 只输出容器id</p><p>docker ps -a -q # 输出所有容器id</p><p>docker ps -n 5 # 输出最近创建的5个容器</p><p>docker ps -l # 显示最近创建的容器</p><p>REPOSITORY：镜像名称，TAG：镜像的标签（一般为该镜像的版本号），IMAGE ID：镜像id，CREATED：镜像创建时间，SIZE：镜像大小</p><p>镜像id实质上为该镜像的sha256</p><p>注意：如果不指定版本，将默认使用latest版本的镜像</p><p>docker system df # 查看Docker的磁盘使用情况</p><p>docker stop 容器id（或者容器名都可以） -f # 关闭指定容器，-f为强制删除</p><p>docker stop $(docker ps -a -q) # 关闭所有容器</p><p>删除指定容器</p><p>docker image rm 容器名称 # 例如 docker image rm centos</p><p>docker rmi 容器id # 删除指定镜像</p><p>docker rmi $(docker images -a -q) # 删除所有镜像</p><p>查看所有正在运行的容器</p><p>docker container ls或者docker ps</p><p>查看所有的容器（包括已经停止运行的）</p><p>docker container ls &ndash;all</p><p>运行指定容器</p><p>docker container run 镜像名</p><p>或者</p><p>docker run 镜像名</p><p>启动容器</p><p>docker start 容器ID或者容器名</p><p>重启容器</p><p>docker restart 容器ID或者容器名</p><p>停止容器</p><p>docker stop 容器ID或者容器名</p><p>强制停止运行容器</p><p>docker kill 容器ID或者容器名</p><p>删除已经停止运行的容器</p><p>docker rm 容器ID</p><p>注意：rm是删除容器，rmi是删除镜像</p><p>docker exec -it 容器ID bash # 在容器中打开新终端，并且启动新的进程，在这个情况下使用exit退出不会导致容器的暂停，而attach会导致容器的暂停，推荐使用exec</p><p>docker attach 容器ID # 直接进入容器启动命令的终端，不启动新的进程</p><p>docker run -it ubuntu /bin/bash # i表示以交互模式运行容器，t为给容器创建一个伪终端（搭配使用就是交互式容器）</p><p>docker run &ndash;name=&ldquo;容器的新名称&rdquo; 镜像名 # 为容器指定新名称，如果不指定，容器名称默认为镜像名</p><p>docker run -d 镜像名 # 后台运行容器并且返回容器id（以守护进程的方式后台运行容器）</p><p>docker run -p 80:8080 镜像名 # 运行并且映射指定容器的80端口到物理机的8080端口</p><p>docker run -P 镜像名 # 随机端口映射，不常用</p><p>获取容器（从镜像源（docker hub）中下载到本地，docker提供大量已经配置好的容器，可以直接下载使用，修改）</p><p>docker image pull 镜像名 # 拉取某个镜像</p><p>docker search 镜像名 # 搜索查找某个镜像</p><p>NAME：容器仓库名称，DESCRIPTION：容器描述，STARS：类似github的star，关注，喜欢
OFFICIAL：是否为官方，AUTOMATED：是否为自动构建</p><p>docker cp 容器id:容器内部的路径 目标主机的路径 # 将容器的文件备份（拷贝）到主机中</p><p>导出导入容器（备份容器）</p><p>docker export 容器id > 文件x.tar # 导出容器</p><p>car 文件x.tar | docker import - 镜像用户/镜像名:镜像版本号 # 导入容器</p><p>修改容器源</p><p>国内容器源</p><p><a href=http://hub-mirror.c.163.com>http://hub-mirror.c.163.com</a> # 网易云</p><p><a href=https://docker.mirrors.ustc.edu.cn>https://docker.mirrors.ustc.edu.cn</a> # 中国科技大学</p><p><a href=https://mirror.ccs.tencentyun.com>https://mirror.ccs.tencentyun.com</a> # 腾讯云</p><p>docker run hello-world &ndash;registry-mirror=https://mirror.ccs.tencentyun.com 容器名 # 只对当前指令起作用</p><p>找到/etc/default/docker 插入</p><p>DOCKER_OPTS="&ndash;registry-mirror=https://mirror.ccs.tencentyun.com"</p><p>或者</p><p>找到/etc/docker/daemon.json，插入</p><p>{&ldquo;registry-mirrors&rdquo;: [&ldquo;https://mirror.ccs.tencentyun.com&rdquo;]} # 可以插入多个源</p><p>然后重启服务</p><p>如果dockerhub满足不了，可以在hub已存在的容器中进行修改（安装，卸载&mldr;）</p><p>或者使用Dockerfile，从零开始构建容器</p><p>mkdir hallo && cd hallo # 新建一个文件夹，并且进入这个文件夹</p><p>nano Dockerfile # 新建个文件，并且修改它</p><p>FROM ubuntu:18.04
RUN apt -y update && apt install -y nginx && apt install -y mariadb-server && apt install -y php*</p><p>FROM：基础镜像,操作都是基于这个基础镜像，RUM：执行指定指令（shell）</p><p>其他参数，MAINTAINER：容器创建者，CMD：当容器启动时执行命令，只能有一条CMD命令，多条执行最后一条，容器run命令会覆盖cmd命令</p><p>ENTRYPOINT：当容器启动时执行命令，不可覆盖</p><p>USER：指定哪个用户来启动容器</p><p>EXPOSE：容器内部开启端口，一般用于容器端口映射到主机端口上</p><p>ENV：环境变量</p><p>ADD：复制或者下载到容器，请确保本地或者docker仓库中有需要add的文件，例如：</p><p>ADD 文件路径（或者url） 目标容器的绝对路径</p><p>VOLUME：切换目录用，类似cd</p><p>打包容器</p><p>docker build -t 容器名 .</p><p>这个“.”表示为当前路径</p><p>如果正在运行docker，想退出可以使用ctrl+D，例如</p><p>在centos中体验Ubuntu系统</p><p>例如docker container run -it ubuntu bash</p><p>如果想退出docker，可以在docker（run进去的容器）中输入exit</p><p>如果想docker中的容器不停止， 快捷键 ctrl+p+q</p><p>推送本地容器到docker仓库中</p><p>首先需要一个docker仓库账号，例如https://hub.docker.com/或者https://cr.console.aliyun.com/cn-hangzhou/new # 阿里容器镜像服务，</p><p>docker login -u 账号 -p 密码 # 登录DockerHub账号</p><p>docker push hallo_word:yes</p><p>docker pull会默认推送带有latest标签的容器到本地，所以推荐把容器标签修改为latest，或者直接指定要推送哪个容器，精确到标签</p><p>docker tag hallo_word:yes hallo_word:latest</p><p>推送到第三方仓库（例如：阿里容器镜像服务）</p><p>docker pull registry.cn-hangzhou.aliyuncs.com/xxx/xxx:latest # 推送容器到本地</p><p>docker login &ndash;<a href="mailto:username=xxx@qq.com">username=xxx@qq.com</a> registry.cn-hangzhou.aliyuncs.com # 登录的用户名为阿里云账号全名，密码为开通服务时设置的密码，如果是私有仓库，那么需要推送容器到本地之前执行，推送容器到本地之后再执行一次</p><p>docker tag 容器id registry.cn-hangzhou.aliyuncs.com/xxx/xxx:latest # 推送到阿里容器仓库</p><p>端口映射（实质上并不是docker容器技术实现的，是利用了iptables）</p><p>docker配置文件hostconfig.json</p><p>docker run -d -p 8000:80 ubuntu // 将容器的8000端口映射到宿主机上的80端口</p><hr><p>docker为啥比虚拟机性能好</p><p>docker不需要硬件资源的虚拟化，docker的容器的软件是可以直接使用物理机的硬件资源的（更好的利用硬件资源），而且docker是直接调用的宿主机的内核，不需要重新加载操作系统的OS内核（减少不必要的浪费）</p><hr><p>虚悬镜像（dangling image）：指的是仓库名，标签都是的镜像，一般出现在删除镜像出错时</p><p>查找虚悬镜像</p><p>docker image ls -f dangling=true</p><p>删除虚悬镜像</p><p>docker image prune #删除所有dangling image</p><hr><p>镜像是一种独立，可执行，轻量级的软件包，包含某个软件需要的所有内容，这个镜像包含应用程序，应用的配置依赖，这个镜像实质上就是一个可交付的运行环境</p><p>镜像分层系统实现依赖于UnionFS</p><p>UnionFS（联合文件系统）：是一种分层，轻量级的高性能文件系统，支持对文件系统的修改作为一次提交来一层一层的叠加，并且将不同的目录挂载到同一个虚拟文件系统下</p><p>镜像可通过分层来基于基础镜像来制造各种应用镜像</p><p>Docker镜像加载原理：通过UnionFS来一层一层组成，bootfs（boot file system）加载和引导内核，当boot加载完毕，内存使用权从bootfs转交到内核，系统卸载bootfs</p><p>rootfs（root file system）就是操作系统，包含Linux系统中标准的/bin，/etc等目录</p><p>Docker镜像为啥这么小的原因就是镜像只包含bootfs和rootfs，复用宿主机的内核</p><p>镜像分层的好处：可复用，方便共享（复制迁移）资源，镜像的每一层都可以被共享，可复用</p><p>镜像层是只读，容器层是可写的，当一个容器被启动，一个可写层被加载到镜像的顶部时，那么这一层被叫为容器层，容器层之下的都被叫为镜像层</p><p>commit命令提交副本来创建新镜像</p><p>docker commit -m=&ldquo;注释&rdquo; -a=&ldquo;作者&rdquo; 容器id 用户/镜像名:镜像版本号</p><hr><p>搭建私有仓库</p><p>docker私有仓库（Docker Registry）</p><p>Docker Registry是docker提供的镜像，专门用来构建docker私有仓库</p><p>docker pull registry # 拉取Registry镜像</p><p>docker run -d -p 5000:5000 -v /test/registry/:/tmp/registry &ndash; privileged=true registry</p><p>默认情况下，仓库被创建在容器的/var/lib/registry目录下（当然也可以通过容器卷来映射）</p><p>docker tag ubuntu 192.168.1.110:5000/ubuntu # 修改tag为符合私有仓库的规范</p><p>这个私有仓库默认不支持http推送，需要修改/etc/docker/daemon.json</p><p>&ldquo;insecure-registries&rdquo;: [&ldquo;192.168.1.110:5000&rdquo;]</p><p>如果不生效，请重启docker服务</p><p>推送镜像到私有仓库</p><p>docker push 192.168.1.110:5000/ubuntu</p><p>查看私有仓库存储的镜像</p><p>curl -XGET http://192.168.1.110:5000/v2/_catalog</p><p>获取私有仓库镜像到本地</p><p>docker pull 192.168.1.110:5000/ubuntu</p><hr><p>容器数据卷</p><p>-v参数为启动自定义容器数据卷</p><p>比如说docker run -d -p 5000:5000 -v /test/registry/:/tmp/registry &ndash; privileged=true registry</p><p>/test/registry/为宿主机路径，/tmp/registry为容器内部路径，&ndash; privileged=true为开启privileged，（开启privileged后，容器内部的root才拥有真正的root权限，否则容器的root只是普通用户权限）</p><p>容器数据卷用于数据的持久化（独立于容器的生命周期），可绕过联合文件系统来达到持续存在或者共享数据的目的，docker不会在删除容器时，删除容器挂载的数据卷，数据卷指定容器内部路径，任何在该路径存储的数据，都会被映射到宿主机指定的那个目录下</p><p>在数据卷中的任何更改都不会认为是镜像的更新，而且数据卷中的更改是实时生效的（不需要重启容器之类的，哪怕容器没有启动），数据卷的生命周期长（可持续到没有容器使用它为止）</p><p>数据卷被用于容器和宿主机之间的互通互联，在宿主机中更新的文件，会实时在容器中生效</p><p>docker inspect 镜像名或者镜像id # 获取容器/镜像的元数据</p><p>数据卷在该镜像的元数据的Mounts属性中找到</p><p>数据卷默认可读可写（rw），可通过ro来限制容器内部只能读，不能写</p><p>默认情况下</p><p>docker run -d -p 5000:5000 -v /test/registry/:/tmp/registry:rw &ndash; privileged=true registry</p><p>因为rw是默认的，可以省略不写</p><p>限制容器只能读取数据卷，不能写（ro，read only）</p><p>docker run -d -p 5000:5000 -v /test/registry/:/tmp/registry:ro &ndash; privileged=true registry</p><p>数据卷的继承（&ndash;volumes-from）</p><p>docker run -it &ndash; privileged=true &ndash;volumes-from 容器1 &ndash;name 容器2 registry</p><p>容器2继承容器1的数据卷规则（哪怕容器1被删除了或者停止运行了，依然不会影响到容器2的数据卷）</p><hr><p>docker network</p><p>docker network可用于容器之间的互联以及通信（端口映射），可通过服务名来直接通信（不受IP变动而影响）</p><p>docker会默认创建一个叫docker0的虚拟网桥（bridge网络模式）</p><p>docker0网桥会在内核层连通其他网络网卡和虚拟网卡，实现所有的容器和本地主机的网络连接（同一个物理网络）</p><p>docker会默认创建三个网络模式，分别为bridge（默认），host，none</p><p>可通过docker network ls命令查看</p><p>创建网络</p><p>docker network create hallo</p><p>删除网络</p><p>docker network rm hallo</p><p>查看网络的详细信息</p><p>docker network inspect bridge</p><p>bridge网络模式：为容器分配和设置IP，并且将容器分配到docker0网桥（如果不指定-network，创建的容器默认在该模式上）（&ndash;network bridge，可忽略）</p><p>host网络模式：容器不会虚拟网卡，而是直接使用宿主机的ip和端口和外界通信（不需要额外进行NAT转换，没有独立的Network namespace，而是和宿主机共用一个Network namespace）（&ndash;network host）</p><p>none网络模式：该模式的容器有自己的独立网络规则（Network namespace），但是没有进行配置，需要手动配置docker容器网络（发挥网络定制功能，没有虚拟网卡，没有IP等等网络信息），在该模式下只有一个127.0.0.1的本地网络回环接口（lo）（&ndash;network none）</p><p>container网络模式：该模式下的容器不会配置自己的IP，而是和指定的容器共享IP和端口范围（网络共用，文件和进程隔离）（&ndash;network container:指定容器名或者容器ID）</p><p>自定义网络模式（可通过服务名（容器名/主机名）来通信，docker network create hallo）</p><hr><p>docker-compose容器编排</p><p>docker-Compose是Docker官方提供的Docker容器集群快速编排工具，用于管理多个docker容器组成的应用，通过docker-compose.yml配置文件来管理多个容器之间的调用关系</p><p>官方文档https://docs.docker.com/compose/</p><p>下载文档：https://docs.docker.com/compose/install/</p><p>下载docker-Compose
sudo curl -L &ldquo;<a href=https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname>https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname</a> -s)-$(uname -m)&rdquo; -o /usr/local/bin/docker-compose</p><p>添加写的权限
sudo chmod +x /usr/local/bin/docker-compose</p><p>测试是否安装完成
docker-compose &ndash;version</p><p>构建并且启动容器（执行docker-compose.yml配置文件）（加参数-d为启动服务并且后台运行）
docker-compose up</p><p>构建或者重新构建服务
docker-compose build</p><p>删除指定服务的容器
docker-compose rm 容器名</p><p>停止并且删除容器，镜像，网络，卷
docker-compose down</p><p>进入容器
docker-compose exec 服务id</p><p>查看当前docker-compose编排的全部容器
docker-compose top</p><p>查看当前docker-compose编排的容器进程
docker-compose ps</p><p>停止docker-compose服务
docker-compose stop</p><p>启动docker-compose服务
docker-compose start</p><p>重启docker-compose服务
docker-compose restart</p><p>检查配置文件（-q参数表示当配置文件出现问题时才输出信息）
docker-compose config</p><p>容器的7种状态：</p><p>created（已创建）
restarting（重启中）
running或up（运行中）
removing（迁移中）
paused（暂停）
exited（停止）
dead（死亡）</p><p>docker-compose.yml配置文件</p><pre><code>version: &quot;3.9&quot;
services:
    web:
        build:
            context: .  
            dockerfile: Dockerfile_test
        ports:
            - &quot;5000:5000&quot;
        volumes:
            -  /app/test:/data/app
        links:
            - redis
        networks:
            - hallo_net
    redis:
        image: redis
        command: redis-server /etc/redis/redis.conf
networks:
    hallo_net:
</code></pre><p>version字段为版本号（具体支持的版本和docker-compose安装的版本有关，具体看实质版本），services字端表示服务容器，services字端下面的服务名的image字段为从指定镜像中启动容器（镜像可本地，可仓库或者镜像ID），ports字段为端口映射，networks字段为指定网络模式，volumes字段为容器数据卷</p><p>外面那个networks字段将会创建hallo_net自定义网络模式，处理基于指定镜像外，还可以基于Dockerfile，build字段下的dockerfile字段就是指定Dockerfile文件所在的路径，context字段为构建的路径，links字段为链接到指定服务中的容器</p><p>一般都是通过Dockerfile自动化构建镜像，然后基于这个镜像使用docker-compose管理容器</p><hr><p>Portainer可视化工具</p><p>Portainer是一个Docker轻量级的可视化工具（Portainer官网，https://www.portainer.io，官网文档：https://docs.portainer.io/v/ce-2.11/start/install/server/docker/linux）</p><p>可直接pull Portainer的镜像来安装</p><p>docker pull portainer/portainer</p><pre><code>docker run -d -p 8000:8000 -p 9443:9443 --name portainer \
    --restart=always \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v portainer_data:/data \
    portainer/portainer-ce:2.11.1
</code></pre><p>启动完毕后，访问1192.168.1.110:9443/，进行设置admin用户和密码</p><p>如果是监控本地的docker，选择local</p><hr><p>CAdvisor+InfluxDB+Granfana(CIG重量级容器监控)</p><hr><p>docker依赖多种namespace来进行隔离（例如User Namespace，容器用户和宿主用户隔离，process id Namespace，隔离进程id，network Namespace，隔离网络设备，端口号，mount Namespace，隔离挂载等等），依赖于cgroup进行资源管理和控制（例如cpu，内存），namespace和cgroup都由自Linux内核提供</p><p>docker使用了6种namespace，分别是，mount namespace，uts namespace，ipc namespace，network namespace，pid namespace，user namespace</p><p>mount Namespace：隔离不同进程的挂载数据，保证容器的挂载操作不会影响到宿主的挂载</p><p>sudo unshare &ndash;mount &ndash;fork /bin/bash # 创建一个mount Namespace，使用/bin/bash进程，在该挂载任何文件，都不会作用于宿主</p><p>pid namespace是隔离进程的pid的，也就是说宿主是看不到容器的应用pid，容器也看不到宿主的pid</p><p>sudo unshare &ndash;pid &ndash;fork &ndash;mount-proc /bin/bash</p><p>安全容器：容器运行在虚拟机中，具备虚拟机的安全隔离性，例如kata Container，使用guest kernel（精简了内核，专门提供给容器运行，减低资源的消耗）</p><p>因为docker容器共享宿主内核，存在安全性，所以可使用安全容器来隔离宿主内核，安全容器的内核是完全独立于宿主的内核（虚拟化技术）</p><p>docker容器资源限制</p><p>docker run -it &ndash;cpus=4 -m=8192 &ndash;pids-limit=1000 ubuntu /bin/bash # 启动ubuntu镜像，使用/bin/bash作为终端，资源被设置为4核8g，并且只能创建1000个pid</p><p>docker stats ubuntu # 查看容器的资源使用情况</p><p>cAdvisor是谷歌开源的容器监控工具，不但可以监控容器的资源使用情况，还可以监控宿主的资源使用情况，可查看容器的历史资源使用情况</p><pre><code>docker run \
--volume=/:/rootfs:ro \
--volume=/var/run:/var/run:ro \
--volume=/sys:/sys:ro \
--volume=/var/lib/docker/:/var/lib/docker:ro \
--volume=/dev/disk/:/dev/disk:ro \
--publish=8080:8080 \
--detach=true \
--name=cadvisor \
--privileged \
--device=/dev/kmsg \
gcr.io/cadvisor/cadvisor:$VERSION
</code></pre><p>访问http://localhost:8080</p><p>容器的资源限制通过/sys/fs/cgroup/memory/docker下的，目录名为容器id，其中memory.limit_in_bytes是该容器的内存限制文件，memory.usage_in_bytes是该容器的内存使用情况，proc/容器的pid/net/dev是该容器的网络使用情况，cpuset.cpus是cpu限制使用核数，cpu.cfs_period_us是一个cpu核心的带宽（单位微秒，容器的cpu总带宽=cpu核心数*单个cpu核心的带宽），cpu.cfs_quota_us是可使用cpu带宽（单位微秒，-1为不限制）</p><p>容器监控工具实质上是通过读取和记录宿主的文件来显示容器资源情况的，所以启动容器监控工具，要映射数据卷/sys:到容器中</p><hr><p>kubernetes简称k8s，用来自动化容器的部署，监控，容器负载均衡等等</p><p>master是容器集群的控制系统，可以用来监控容器的状态，调度负载均衡</p><p>node是k8s的工作节点，可以接收master的指令，根据指令来创建和销毁Pod等等</p><p>Pod是容器的容器，可以包含多个容器，是k8s中最小的可部署单元，pod内部的网络是互通的，每一个pod都有自己的虚拟ip</p><p>k8s将弃用dockershim（dockershim是k8s内置的一个组件，该组件可让k8s能够通过CRI（Container Runtime Interface）来操作docker）</p><hr><p>安装docker</p><p>配置docker</p><p>添加docker官方GPGkey</p><p>curl -fsSL <a href=https://download.docker.com/linux/ubuntu/gpg>https://download.docker.com/linux/ubuntu/gpg</a> | sudo apt-key add -</p><p>sudo apt-key fingerprint 0EBFCD88</p><p>安装依赖</p><p>sudo apt install apt-transport-https ca-certificates curl software-properties-common</p><p>设置docker仓库</p><p>sudo add-apt-repository &ldquo;deb [arch=amd64] <a href=https://download.docker.com/linux/ubuntu>https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable&rdquo;</p><p>重新加载源</p><p>sudo apt update</p><p>如果报错，可以手动在/etc/apt/source.list添加</p><p>deb [arch=amd64] <a href=https://download.docker.com/linux/ubuntu>https://download.docker.com/linux/ubuntu</a> bionic stable</p><p>sudo apt dist-upgrade（智能处理包依赖，会自己安装新软件或者删除原有软件包来完成升级）</p><p>安装docker</p><p>sudo apt install docker-ce docker-ce-cli containerd.io</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://99999.fun/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://99999.fun/posts/19/><span class=title>« Prev</span><br><span>JAVA基础学习笔记</span>
</a><a class=next href=https://99999.fun/posts/17/><span class=title>Next »</span><br><span>XML学习笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://99999.fun/>知政的个人博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>